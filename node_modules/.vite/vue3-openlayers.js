import {
  EMPTY_OBJ,
  NO,
  NOOP,
  PatchFlagNames,
  camelize,
  capitalize,
  extend,
  generateCodeFrame,
  hyphenate,
  init_runtime_dom_esm_bundler,
  init_shared_esm_bundler,
  isArray,
  isHTMLTag,
  isObject,
  isOn,
  isReservedProp,
  isSVGTag,
  isString,
  isSymbol,
  isVoidTag,
  makeMap,
  parseStringStyle,
  runtime_dom_esm_bundler_exports,
  shared_esm_bundler_exports,
  slotFlagsText,
  toHandlerKey
} from "./chunk-ZTXAFTBG.js";
import {
  __commonJS,
  __esm,
  __export
} from "./chunk-3DB52H5I.js";

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : code;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, isVNode = false) {
  return {
    type: 20,
    index,
    value,
    isVNode,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
function getInnerRange(loc, offset, length) {
  const source = loc.source.slice(offset, offset + length);
  const newLoc = {
    source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };
  if (length != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
  }
  return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly)
        continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some((p) => p.type === 7 && p.name === "bind" && (!p.arg || p.arg.type !== 4 || !p.arg.isStatic));
}
function isText(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      first.properties.unshift(prop);
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    let alreadyExists = false;
    if (prop.key.type === 4) {
      const propKeyName = prop.key.content;
      alreadyExists = props.properties.some((p) => p.key.type === 4 && p.key.content === propKeyName);
    }
    if (!alreadyExists) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
      return false;
    default:
      if (true)
        ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function getCompatValue(key, context) {
  const config = context.options ? context.options.compatConfig : context.compatConfig;
  const value = config && config[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc)
    err.loc = loc;
  context.onWarn(err);
}
function baseParse(content, options = {}) {
  const context = createParserContext(content, options);
  const start = getCursor(context);
  return createRoot(parseChildren(context, 0, []), getSelection(context, start));
}
function createParserContext(content, rawOptions) {
  const options = extend({}, defaultParserOptions);
  let key;
  for (key in rawOptions) {
    options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
  }
  return {
    options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}
function parseChildren(context, mode, ancestors) {
  const parent = last(ancestors);
  const ns = parent ? parent.ns : 0;
  const nodes = [];
  while (!isEnd(context, mode, ancestors)) {
    const s = context.source;
    let node = void 0;
    if (mode === 0 || mode === 1) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        node = parseInterpolation(context, mode);
      } else if (mode === 0 && s[0] === "<") {
        if (s.length === 1) {
          emitError(context, 5, 1);
        } else if (s[1] === "!") {
          if (startsWith(s, "<!--")) {
            node = parseComment(context);
          } else if (startsWith(s, "<!DOCTYPE")) {
            node = parseBogusComment(context);
          } else if (startsWith(s, "<![CDATA[")) {
            if (ns !== 0) {
              node = parseCDATA(context, ancestors);
            } else {
              emitError(context, 1);
              node = parseBogusComment(context);
            }
          } else {
            emitError(context, 11);
            node = parseBogusComment(context);
          }
        } else if (s[1] === "/") {
          if (s.length === 2) {
            emitError(context, 5, 2);
          } else if (s[2] === ">") {
            emitError(context, 14, 2);
            advanceBy(context, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            emitError(context, 23);
            parseTag(context, 1, parent);
            continue;
          } else {
            emitError(context, 12, 2);
            node = parseBogusComment(context);
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors);
          if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) && node && node.tag === "template" && !node.props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
            warnDeprecation("COMPILER_NATIVE_TEMPLATE", context, node.loc);
            node = node.children;
          }
        } else if (s[1] === "?") {
          emitError(context, 21, 1);
          node = parseBogusComment(context);
        } else {
          emitError(context, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context, mode);
    }
    if (isArray(node)) {
      for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context.options.whitespace !== "preserve";
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!context.inPre && node.type === 2) {
        if (!/[^\t\r\n\f ]/.test(node.content)) {
          const prev = nodes[i - 1];
          const next = nodes[i + 1];
          if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
        }
      } else if (node.type === 3 && !context.options.comments) {
        removedWhitespace = true;
        nodes[i] = null;
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev = last(nodes);
    if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
      prev.content += node.content;
      prev.loc.end = node.loc.end;
      prev.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  const nodes = parseChildren(context, 3, ancestors);
  if (context.source.length === 0) {
    emitError(context, 6);
  } else {
    advanceBy(context, 3);
  }
  return nodes;
}
function parseComment(context) {
  const start = getCursor(context);
  let content;
  const match = /--(\!)?>/.exec(context.source);
  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7);
  } else {
    if (match.index <= 3) {
      emitError(context, 0);
    }
    if (match[1]) {
      emitError(context, 10);
    }
    content = context.source.slice(4, match.index);
    const s = context.source.slice(0, match.index);
    let prevIndex = 1, nestedIndex = 0;
    while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s.length) {
        emitError(context, 16);
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseBogusComment(context) {
  const start = getCursor(context);
  const contentStart = context.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context.source.indexOf(">");
  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context, start)
  };
}
function parseElement(context, ancestors) {
  const wasInPre = context.inPre;
  const wasInVPre = context.inVPre;
  const parent = last(ancestors);
  const element = parseTag(context, 0, parent);
  const isPreBoundary = context.inPre && !wasInPre;
  const isVPreBoundary = context.inVPre && !wasInVPre;
  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context.options.getTextMode(element, parent);
  const children = parseChildren(context, mode, ancestors);
  ancestors.pop();
  {
    const inlineTemplateProp = element.props.find((p) => p.type === 6 && p.name === "inline-template");
    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context, inlineTemplateProp.loc)) {
      const loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2,
        content: loc.source,
        loc
      };
    }
  }
  element.children = children;
  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1, parent);
  } else {
    emitError(context, 24, 0, element.loc.start);
    if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first = children[0];
      if (first && startsWith(first.loc.source, "<!--")) {
        emitError(context, 8);
      }
    }
  }
  element.loc = getSelection(context, element.loc.start);
  if (isPreBoundary) {
    context.inPre = false;
  }
  if (isVPreBoundary) {
    context.inVPre = false;
  }
  return element;
}
function parseTag(context, type, parent) {
  const start = getCursor(context);
  const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  const tag = match[1];
  const ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context);
  const cursor = getCursor(context);
  const currentSource = context.source;
  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  }
  let props = parseAttributes(context, type);
  if (type === 0 && !context.inVPre && props.some((p) => p.type === 7 && p.name === "pre")) {
    context.inVPre = true;
    extend(context, cursor);
    context.source = currentSource;
    props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context.source.length === 0) {
    emitError(context, 9);
  } else {
    isSelfClosing = startsWith(context.source, "/>");
    if (type === 1 && isSelfClosing) {
      emitError(context, 4);
    }
    advanceBy(context, isSelfClosing ? 2 : 1);
  }
  if (type === 1) {
    return;
  }
  if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context)) {
    let hasIf = false;
    let hasFor = false;
    for (let i = 0; i < props.length; i++) {
      const p = props[i];
      if (p.type === 7) {
        if (p.name === "if") {
          hasIf = true;
        } else if (p.name === "for") {
          hasFor = true;
        }
      }
      if (hasIf && hasFor) {
        warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context, getSelection(context, start));
        break;
      }
    }
  }
  let tagType = 0;
  if (!context.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
        tagType = 3;
      }
    } else if (isComponent(tag, props, context)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns,
    tag,
    tagType,
    props,
    isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: void 0
  };
}
function isComponent(tag, props, context) {
  const options = context.options;
  if (options.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
          return true;
        }
      }
    } else {
      if (p.name === "is") {
        return true;
      } else if (p.name === "bind" && isStaticArgOf(p.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
        return true;
      }
    }
  }
}
function parseAttributes(context, type) {
  const props = [];
  const attributeNames = new Set();
  while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
    if (startsWith(context.source, "/")) {
      emitError(context, 22);
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }
    if (type === 1) {
      emitError(context, 3);
    }
    const attr = parseAttribute(context, attributeNames);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type === 0) {
      props.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15);
    }
    advanceSpaces(context);
  }
  return props;
}
function parseAttribute(context, nameSet) {
  const start = getCursor(context);
  const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  const name = match[0];
  if (nameSet.has(name)) {
    emitError(context, 2);
  }
  nameSet.add(name);
  if (name[0] === "=") {
    emitError(context, 19);
  }
  {
    const pattern = /["'<]/g;
    let m;
    while (m = pattern.exec(name)) {
      emitError(context, 17, m.index);
    }
  }
  advanceBy(context, name.length);
  let value = void 0;
  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);
    if (!value) {
      emitError(context, 13);
    }
  }
  const loc = getSelection(context, start);
  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
    const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
    let isPropShorthand = startsWith(name, ".");
    let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
    let arg;
    if (match2[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name.lastIndexOf(match2[2]);
      const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
      let content = match2[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(context, 27);
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match2[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
    if (isPropShorthand)
      modifiers.push("prop");
    if (dirName === "bind" && arg) {
      if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)) {
        dirName = "model";
        modifiers.splice(modifiers.indexOf("sync"), 1);
      }
      if (modifiers.includes("prop")) {
        checkCompatEnabled("COMPILER_V_BIND_PROP", context, loc);
      }
    }
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        constType: 0,
        loc: value.loc
      },
      arg,
      modifiers,
      loc
    };
  }
  if (!context.inVPre && startsWith(name, "v-")) {
    emitError(context, 26);
  }
  return {
    type: 6,
    name,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc
    },
    loc
  };
}
function parseAttributeValue(context) {
  const start = getCursor(context);
  let content;
  const quote = context.source[0];
  const isQuoted = quote === `"` || quote === `'`;
  if (isQuoted) {
    advanceBy(context, 1);
    const endIndex = context.source.indexOf(quote);
    if (endIndex === -1) {
      content = parseTextData(context, context.source.length, 4);
    } else {
      content = parseTextData(context, endIndex, 4);
      advanceBy(context, 1);
    }
  } else {
    const match = /^[^\t\r\n\f >]+/.exec(context.source);
    if (!match) {
      return void 0;
    }
    const unexpectedChars = /["'<=`]/g;
    let m;
    while (m = unexpectedChars.exec(match[0])) {
      emitError(context, 18, m.index);
    }
    content = parseTextData(context, match[0].length, 4);
  }
  return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
  const [open2, close] = context.options.delimiters;
  const closeIndex = context.source.indexOf(close, open2.length);
  if (closeIndex === -1) {
    emitError(context, 25);
    return void 0;
  }
  const start = getCursor(context);
  advanceBy(context, open2.length);
  const innerStart = getCursor(context);
  const innerEnd = getCursor(context);
  const rawContentLength = closeIndex - open2.length;
  const rawContent = context.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}
function parseText(context, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
  let endIndex = context.source.length;
  for (let i = 0; i < endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1);
    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }
  const start = getCursor(context);
  const content = parseTextData(context, endIndex, mode);
  return {
    type: 2,
    content,
    loc: getSelection(context, start)
  };
}
function parseTextData(context, length, mode) {
  const rawText = context.source.slice(0, length);
  advanceBy(context, length);
  if (mode === 2 || mode === 3 || !rawText.includes("&")) {
    return rawText;
  } else {
    return context.options.decodeEntities(rawText, mode === 4);
  }
}
function getCursor(context) {
  const { column, line, offset } = context;
  return { column, line, offset };
}
function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}
function last(xs) {
  return xs[xs.length - 1];
}
function startsWith(source, searchString) {
  return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
  const { source } = context;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
  const match = /^[\t\r\n\f ]+/.exec(context.source);
  if (match) {
    advanceBy(context, match[0].length);
  }
}
function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }
  context.options.onError(createCompilerError(code, {
    start: loc,
    end: loc,
    source: ""
  }));
}
function isEnd(context, mode, ancestors) {
  const s = context.source;
  switch (mode) {
    case 0:
      if (startsWith(s, "</")) {
        for (let i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2: {
      const parent = last(ancestors);
      if (parent && startsWithEndTagOpen(s, parent.tag)) {
        return true;
      }
      break;
    }
    case 3:
      if (startsWith(s, "]]>")) {
        return true;
      }
      break;
  }
  return !s;
}
function startsWithEndTagOpen(source, tag) {
  return startsWith(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
}
function hoistStatic(root, context) {
  walk(root, context, isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12 && getConstantType(child.content, context) >= 2) {
      child.codegenNode = context.hoist(child.codegenNode);
      hoistedCount++;
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(child.branches[i2], context, child.branches[i2].children.length === 1);
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
    node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      if (true)
        ;
      return 0;
  }
}
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    root,
    helpers: new Map(),
    components: new Set(),
    directives: new Set(),
    hoists: [],
    imports: [],
    constantCache: new Map(),
    temps: 0,
    cached: 0,
    identifiers: Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode);
    }
  };
  {
    context.filters = new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = [...context.helpers.keys()];
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        makeBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = PatchFlagNames[64];
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
      patchFlagText += `, ${PatchFlagNames[2048]}`;
    }
    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, void 0, false);
  } else
    ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child))
      continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n));
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated)
    options.onContextCreated(context);
  const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
  const hasHelpers = ast.helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(`const { ${ast.helpers.map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`).join(", ")} } = _Vue`);
      push(`
`);
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
  const VueBinding = runtimeGlobalName;
  const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
  if (ast.helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline, helper, scopeId, mode } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = ${``}`);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText$1(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText$1(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(node);
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(node);
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push(`[${node.content}]`, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, node);
  genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(true);
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare)
        continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id)
        continue;
      onIdent(stmt.id);
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element)
          extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(createCompilerError(44, node.loc, void 0, message));
  }
}
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(28, dir.loc));
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(createCompilerError(30, node.loc));
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(createCompilerError(29, branch.userKey.loc));
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(createCompilerError(30, node.loc));
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: node.tagType === 3 && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`)
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), [
      true ? '"v-if"' : '""',
      "true"
    ]));
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, false, false, branch.loc);
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      makeBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(31, dir.loc));
    return;
  }
  const parseResult = parseForExpression(dir.exp, context);
  if (!parseResult) {
    context.onError(createCompilerError(32, dir.loc));
    return;
  }
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
function parseForExpression(input, context) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0
  };
  if (true) {
    validateBrowserExpression(result.source, context);
  }
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
      if (true) {
        validateBrowserExpression(result.key, context, true);
      }
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
        if (true) {
          validateBrowserExpression(result.index, context, true);
        }
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
    if (true) {
      validateBrowserExpression(result.value, context, true);
    }
  }
  return result;
}
function createAliasExpression(range, content, offset) {
  return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = new Set();
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(createCompilerError(37, slotDir.loc));
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
    let vIf;
    let vElse;
    let vFor;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
      } else {
        context.onError(createCompilerError(30, vElse.loc));
      }
    } else if (vFor = findDir(slotElement, "for")) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
      if (parseResult) {
        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
          parseResult.source,
          createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
        ]));
      } else {
        context.onError(createCompilerError(32, vFor.loc));
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(38, dirLoc));
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false))), loc);
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn) {
  return createObjectExpression([
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ]);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp
    ]);
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  const isComponent2 = node.tagType === 1;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (!isComponent2 && isEventHandler && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        if (context.scopes.vFor > 0) {
          properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
        }
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
    } else {
      const { name, arg, exp, loc } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(createCompilerError(40, loc));
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
        properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            properties = [];
          }
          if (isVBind) {
            {
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context, loc);
                }
              }
              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            mergeArgs.push({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: [exp]
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 34 : 35, loc));
        }
        continue;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        properties.push(...props2);
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
    }
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
          }
          if (styleProp && !isStaticExp(styleProp.value) && (hasStyleBinding || styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
          }
        } else {
          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
          createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
            propsExpression
          ])
        ]);
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize2(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp)
          slotName = p.exp;
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize2(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(node, context, nonNameProps);
    slotProps = props;
    if (directives.length) {
      context.onError(createCompilerError(36, directives[0].loc));
    }
  }
  return {
    slotName,
    slotProps
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ")
            break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation("COMPILER_FILTER", context, node.loc);
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(template, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(46));
    } else if (isModuleMode) {
      onError(createCompilerError(47));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(48));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(49));
  }
  const ast = isString(template) ? baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(ast, extend({}, options, {
    prefixIdentifiers,
    nodeTransforms: [
      ...nodeTransforms,
      ...options.nodeTransforms || []
    ],
    directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {})
  }));
  return generate(ast, extend({}, options, {
    prefixIdentifiers
  }));
}
var errorMessages, FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, locStub, isStaticExp, isBuiltInType, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, propsHelperSet, deprecationData, decodeRE, decodeMap, defaultParserOptions, isSpecialTemplateDirective, allowHoistedHelperSet, PURE_ANNOTATION, isFunctionType, isStaticProperty, isStaticPropertyKey, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformFor, forAliasRE, forIteratorRE, stripParensRE, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, cacheStringFunction, camelizeRE, camelize2, transformSlotOutlet, fnExpRE, transformOn, transformBind, injectPrefix, transformText, seen, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen$1, transformMemo, noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    errorMessages = {
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `Error parsing JavaScript expression: `,
      [45]: `<KeepAlive> expects exactly one child component.`,
      [46]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [47]: `ES module mode is not supported in this build of compiler.`,
      [48]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [49]: `"scopeId" option is only supported in module mode.`,
      [50]: ``
    };
    FRAGMENT = Symbol(true ? `Fragment` : ``);
    TELEPORT = Symbol(true ? `Teleport` : ``);
    SUSPENSE = Symbol(true ? `Suspense` : ``);
    KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
    OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
    CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
    CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
    CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
    CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
    RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
    RESOLVE_DYNAMIC_COMPONENT = Symbol(true ? `resolveDynamicComponent` : ``);
    RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
    RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
    WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
    RENDER_LIST = Symbol(true ? `renderList` : ``);
    RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
    MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
    NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
    NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
    GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
    TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    CAMELIZE = Symbol(true ? `camelize` : ``);
    CAPITALIZE = Symbol(true ? `capitalize` : ``);
    TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
    SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
    PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    WITH_CTX = Symbol(true ? `withCtx` : ``);
    UNREF = Symbol(true ? `unref` : ``);
    IS_REF = Symbol(true ? `isRef` : ``);
    WITH_MEMO = Symbol(true ? `withMemo` : ``);
    IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    locStub = {
      source: "",
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
    };
    isStaticExp = (p) => p.type === 4 && p.isStatic;
    isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
    nonIdentifierRE = /^\d|[^\$\w]/;
    isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    isMemberExpressionBrowser = (path) => {
      path = path.trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3.vuejs.org/guide/migration/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3.vuejs.org/guide/migration/v-model.html`
      },
      ["COMPILER_V_BIND_PROP"]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3.vuejs.org/guide/migration/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3.vuejs.org/guide/migration/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3.vuejs.org/guide/migration/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3.vuejs.org/guide/migration/inline-template-attribute.html`
      },
      ["COMPILER_FILTER"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3.vuejs.org/guide/migration/filters.html`
      }
    };
    decodeRE = /&(gt|lt|amp|apos|quot);/g;
    decodeMap = {
      gt: ">",
      lt: "<",
      amp: "&",
      apos: "'",
      quot: '"'
    };
    defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      getTextMode: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true
    };
    isSpecialTemplateDirective = makeMap(`if,else,else-if,for,slot`);
    allowHoistedHelperSet = new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    PURE_ANNOTATION = `/*#__PURE__*/`;
    isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
    stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(node.content, context);
      } else if (node.type === 1) {
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(exp, context, dir.name === "slot");
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
          const sibling = siblings[i];
          if (sibling && sibling.type === 9) {
            key += sibling.branches.length;
          }
        }
        return () => {
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
          } else {
            const parentCondition = getParentCondition(ifNode.codegenNode);
            parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
          }
        };
      });
    });
    transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
      const { helper, removeHelper } = context;
      return processFor(node, dir, context, (forNode) => {
        const renderExp = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, "memo");
        const keyProp = findProp(node, `key`);
        const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
        const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``), void 0, void 0, true, !isStableFragment, false, node.loc);
        return () => {
          let childBlock;
          const { children } = forNode;
          if (isTemplate) {
            node.children.some((c) => {
              if (c.type === 1) {
                const key = findProp(c, "key");
                if (key) {
                  context.onError(createCompilerError(33, key.loc));
                  return true;
                }
              }
            });
          }
          const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
          const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
          if (slotOutlet) {
            childBlock = slotOutlet.codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
          } else if (needFragmentWrapper) {
            childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``), void 0, void 0, true, void 0, false);
          } else {
            childBlock = children[0].codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
            if (childBlock.isBlock !== !isStableFragment) {
              if (childBlock.isBlock) {
                removeHelper(OPEN_BLOCK);
                removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            childBlock.isBlock = !isStableFragment;
            if (childBlock.isBlock) {
              helper(OPEN_BLOCK);
              helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
            } else {
              helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
            }
          }
          if (memo) {
            const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ]));
            loop.body = createBlockStatement([
              createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
              createCompoundExpression([
                `if (_cached`,
                ...keyExp ? [` && _cached.key === `, keyExp] : [],
                ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
              ]),
              createCompoundExpression([`const _item = `, childBlock]),
              createSimpleExpression(`_item.memo = _memo`),
              createSimpleExpression(`return _item`)
            ]);
            renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
          } else {
            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
          }
        };
      });
    });
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          vSlot.exp;
          context.scopes.vSlot++;
          return () => {
            context.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.parseResult = parseForExpression(vFor.exp, context);
        if (result) {
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
    directiveImportMap = new WeakMap();
    transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
        if (props.length > 0) {
          const propsBuildResult = buildProps(node, context);
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context.onError(createCompilerError(45, {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }));
            }
          }
          const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (patchFlag !== 0) {
          if (true) {
            if (patchFlag < 0) {
              vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
            } else {
              const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
              vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
            }
          } else {
            vnodePatchFlag = String(patchFlag);
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
      };
    };
    true ? Object.freeze({}) : {};
    true ? Object.freeze([]) : [];
    cacheStringFunction = (fn) => {
      const cache = Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    camelizeRE = /-(\w)/g;
    camelize2 = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
      }
    };
    fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          eventName = createSimpleExpression(toHandlerKey(camelize(rawName)), true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(exp, context, false, hasMultipleStatements);
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => p.key.isHandlerKey = true);
      return ret;
    };
    transformBind = (dir, _node, context) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      if (!exp || exp.type === 4 && !exp.content.trim()) {
        context.onError(createCompilerError(34, loc));
        return {
          props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
        };
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = {
                      type: 8,
                      loc: child.loc,
                      children: [child]
                    };
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p) => p.type === 7 && !context.directiveTransforms[p.name]) && !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``));
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
              };
            }
          }
        };
      }
    };
    seen = new WeakSet();
    transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen.has(node) || context.inVOnce) {
          return;
        }
        seen.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(cur.codegenNode, true);
          }
        };
      }
    };
    transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(createCompilerError(41, dir.loc));
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      context.bindingMetadata[rawExp];
      const maybeRef = false;
      if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
        context.onError(createCompilerError(42, exp.loc));
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        createObjectProperty(propName, dir.exp),
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTER", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      }
      if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    seen$1 = new WeakSet();
    transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen$1.has(node)) {
          return;
        }
        seen$1.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              makeBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached++)
            ]);
          }
        };
      }
    };
    noopDirectiveTransform = () => ({ props: [] });
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMNodeTransforms: () => DOMNodeTransforms,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getInnerRange: () => getInnerRange,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isBuiltInType: () => isBuiltInType,
  isCoreComponent: () => isCoreComponent,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText,
  isVSlot: () => isVSlot,
  locStub: () => locStub,
  makeBlock: () => makeBlock,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  traverseNode: () => traverseNode,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation
});
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code, loc) {
  return createCompilerError(code, loc, true ? DOMErrorMessages : void 0);
}
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter((c) => c.type !== 3 && !(c.type === 2 && !c.content.trim()));
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
function compile(template, options = {}) {
  return baseCompile(template, extend({}, parserOptions, options, {
    nodeTransforms: [
      ignoreSideEffectTags,
      ...DOMNodeTransforms,
      ...options.nodeTransforms || []
    ],
    directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
    transformHoist: null
  }));
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}
var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, isRawTextContainer, parserOptions, transformStyle, parseInlineCSS, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, warnTransitionChildren, ignoreSideEffectTags, DOMNodeTransforms, DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
    V_MODEL_CHECKBOX = Symbol(true ? `vModelCheckbox` : ``);
    V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
    V_MODEL_SELECT = Symbol(true ? `vModelSelect` : ``);
    V_MODEL_DYNAMIC = Symbol(true ? `vModelDynamic` : ``);
    V_ON_WITH_MODIFIERS = Symbol(true ? `vOnModifiersGuard` : ``);
    V_ON_WITH_KEYS = Symbol(true ? `vOnKeysGuard` : ``);
    V_SHOW = Symbol(true ? `vShow` : ``);
    TRANSITION = Symbol(true ? `Transition` : ``);
    TRANSITION_GROUP = Symbol(true ? `TransitionGroup` : ``);
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    isRawTextContainer = makeMap("style,iframe,script,noscript", true);
    parserOptions = {
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
      isPreTag: (tag) => tag === "pre",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (isBuiltInType(tag, `Transition`)) {
          return TRANSITION;
        } else if (isBuiltInType(tag, `TransitionGroup`)) {
          return TRANSITION_GROUP;
        }
      },
      getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      },
      getTextMode({ tag, ns }) {
        if (ns === 0) {
          if (tag === "textarea" || tag === "title") {
            return 1;
          }
          if (isRawTextContainer(tag)) {
            return 2;
          }
        }
        return 0;
      }
    };
    transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
    };
    DOMErrorMessages = {
      [50]: `v-html is missing expression.`,
      [51]: `v-html will override element children.`,
      [52]: `v-text is missing expression.`,
      [53]: `v-text will override element children.`,
      [54]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [55]: `v-model argument is not supported on plain elements.`,
      [56]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [57]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [58]: `v-show is missing expression.`,
      [59]: `<Transition> expects exactly one child element or component.`,
      [60]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(50, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(51, loc));
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression("", true))
        ]
      };
    };
    transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(52, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(53, loc));
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(createSimpleExpression(`textContent`, true), exp ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression("", true))
        ]
      };
    };
    transformModel2 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(createDOMCompilerError(55, dir.arg.loc));
      }
      function checkDuplicatedValue() {
        const value = findProp(node, "value");
        if (value) {
          context.onError(createDOMCompilerError(57, value.loc));
        }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(createDOMCompilerError(56, dir.loc));
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(createDOMCompilerError(54, dir.loc));
      }
      baseResult.props = baseResult.props.filter((p) => !(p.key.type === 4 && p.key.content === "modelValue"));
      return baseResult;
    };
    isEventOptionModifier = makeMap(`passive,once,capture`);
    isNonKeyModifier = makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
    maybeKeyModifier = makeMap("left,right");
    isKeyboardEvent = makeMap(`onkeyup,onkeydown,onkeypress`, true);
    resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === "native" && checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key)) {
              if (isKeyboardEvent(key.content)) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    transformOn2 = (dir, node, context) => {
      return transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length)
          return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && (!isStaticExp(key) || isKeyboardEvent(key.content))) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key, handlerExp)]
        };
      });
    };
    transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(58, loc));
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    warnTransitionChildren = (node, context) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (node.children.length && hasMultipleChildren(node)) {
              context.onError(createDOMCompilerError(59, {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }));
            }
          };
        }
      }
    };
    ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(createDOMCompilerError(60, node.loc));
        context.removeNode();
      }
    };
    DOMNodeTransforms = [
      transformStyle,
      ...true ? [warnTransitionChildren] : []
    ];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      on: transformOn2,
      show: transformShow
    };
  }
});

// node_modules/vue/dist/vue.cjs.js
var require_vue_cjs = __commonJS({
  "node_modules/vue/dist/vue.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom = (init_compiler_dom_esm_bundler(), compiler_dom_esm_bundler_exports);
    var runtimeDom = (init_runtime_dom_esm_bundler(), runtime_dom_esm_bundler_exports);
    var shared = (init_shared_esm_bundler(), shared_esm_bundler_exports);
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          n[k] = e[k];
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = _interopNamespace(runtimeDom);
    var compileCache = Object.create(null);
    function compileToFunction(template, options) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          runtimeDom.warn(`invalid template option: `, template);
          return shared.NOOP;
        }
      }
      const key = template;
      const cached = compileCache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
          runtimeDom.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
      }
      const { code } = compilerDom.compile(template, shared.extend({
        hoistStatic: true,
        onError,
        onWarn: (e) => onError(e, true)
      }, options));
      function onError(err, asWarning = false) {
        const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);
        runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
      const render = new Function("Vue", code)(runtimeDom__namespace);
      render._rc = true;
      return compileCache[key] = render;
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    Object.keys(runtimeDom).forEach(function(k) {
      if (k !== "default")
        exports[k] = runtimeDom[k];
    });
    exports.compile = compileToFunction;
  }
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_cjs();
    }
  }
});

// node_modules/vue3-openlayers/dist/vue3-openlayers.common.js
var require_vue3_openlayers_common = __commonJS({
  "node_modules/vue3-openlayers/dist/vue3-openlayers.common.js"(exports, module) {
    module.exports = function(modules) {
      function webpackJsonpCallback(data) {
        var chunkIds = data[0];
        var moreModules = data[1];
        var moduleId, chunkId, i2 = 0, resolves = [];
        for (; i2 < chunkIds.length; i2++) {
          chunkId = chunkIds[i2];
          if (Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
            resolves.push(installedChunks[chunkId][0]);
          }
          installedChunks[chunkId] = 0;
        }
        for (moduleId in moreModules) {
          if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
            modules[moduleId] = moreModules[moduleId];
          }
        }
        if (parentJsonpFunction)
          parentJsonpFunction(data);
        while (resolves.length) {
          resolves.shift()();
        }
      }
      ;
      var installedModules = {};
      var installedChunks = {
        0: 0
      };
      function jsonpScriptSrc(chunkId) {
        return __webpack_require__.p + "vue3-openlayers.common." + ({}[chunkId] || chunkId) + ".js";
      }
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.e = function requireEnsure(chunkId) {
        var promises = [];
        var installedChunkData = installedChunks[chunkId];
        if (installedChunkData !== 0) {
          if (installedChunkData) {
            promises.push(installedChunkData[2]);
          } else {
            var promise = new Promise(function(resolve, reject) {
              installedChunkData = installedChunks[chunkId] = [resolve, reject];
            });
            promises.push(installedChunkData[2] = promise);
            var script = document.createElement("script");
            var onScriptComplete;
            script.charset = "utf-8";
            script.timeout = 120;
            if (__webpack_require__.nc) {
              script.setAttribute("nonce", __webpack_require__.nc);
            }
            script.src = jsonpScriptSrc(chunkId);
            var error = new Error();
            onScriptComplete = function(event) {
              script.onerror = script.onload = null;
              clearTimeout(timeout);
              var chunk = installedChunks[chunkId];
              if (chunk !== 0) {
                if (chunk) {
                  var errorType = event && (event.type === "load" ? "missing" : event.type);
                  var realSrc = event && event.target && event.target.src;
                  error.message = "Loading chunk " + chunkId + " failed.\n(" + errorType + ": " + realSrc + ")";
                  error.name = "ChunkLoadError";
                  error.type = errorType;
                  error.request = realSrc;
                  chunk[1](error);
                }
                installedChunks[chunkId] = void 0;
              }
            };
            var timeout = setTimeout(function() {
              onScriptComplete({ type: "timeout", target: script });
            }, 12e4);
            script.onerror = script.onload = onScriptComplete;
            document.head.appendChild(script);
          }
        }
        return Promise.all(promises);
      };
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1)
          value = __webpack_require__(value);
        if (mode & 8)
          return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
          return value;
        var ns = Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string")
          for (var key in value)
            __webpack_require__.d(ns, key, function(key2) {
              return value[key2];
            }.bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      __webpack_require__.oe = function(err) {
        console.error(err);
        throw err;
      };
      var jsonpArray = (typeof self !== "undefined" ? self : this)["webpackJsonpvue3_openlayers"] = (typeof self !== "undefined" ? self : this)["webpackJsonpvue3_openlayers"] || [];
      var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
      jsonpArray.push = webpackJsonpCallback;
      jsonpArray = jsonpArray.slice();
      for (var i = 0; i < jsonpArray.length; i++)
        webpackJsonpCallback(jsonpArray[i]);
      var parentJsonpFunction = oldJsonpFunction;
      return __webpack_require__(__webpack_require__.s = "fb15");
    }({
      "00b4": function(module2, exports2, __webpack_require__) {
        "use strict";
        __webpack_require__("ac1f");
        var $ = __webpack_require__("23e7");
        var global = __webpack_require__("da84");
        var call = __webpack_require__("c65b");
        var uncurryThis = __webpack_require__("e330");
        var isCallable = __webpack_require__("1626");
        var isObject2 = __webpack_require__("861d");
        var DELEGATES_TO_EXEC = function() {
          var execCalled = false;
          var re = /[ac]/;
          re.exec = function() {
            execCalled = true;
            return /./.exec.apply(this, arguments);
          };
          return re.test("abc") === true && execCalled;
        }();
        var Error2 = global.Error;
        var un$Test = uncurryThis(/./.test);
        $({ target: "RegExp", proto: true, forced: !DELEGATES_TO_EXEC }, {
          test: function(str) {
            var exec = this.exec;
            if (!isCallable(exec))
              return un$Test(this, str);
            var result = call(exec, this, str);
            if (result !== null && !isObject2(result)) {
              throw new Error2("RegExp exec method returned something other than an Object or null");
            }
            return !!result;
          }
        });
      },
      "00ee": function(module2, exports2, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var test = {};
        test[TO_STRING_TAG] = "z";
        module2.exports = String(test) === "[object z]";
      },
      "01d4": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_exports__["a"] = {
          CHANGE: "change",
          ERROR: "error",
          BLUR: "blur",
          CLEAR: "clear",
          CONTEXTMENU: "contextmenu",
          CLICK: "click",
          DBLCLICK: "dblclick",
          DRAGENTER: "dragenter",
          DRAGOVER: "dragover",
          DROP: "drop",
          FOCUS: "focus",
          KEYDOWN: "keydown",
          KEYPRESS: "keypress",
          LOAD: "load",
          RESIZE: "resize",
          TOUCHMOVE: "touchmove",
          WHEEL: "wheel"
        };
      },
      "0366": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var aCallable = __webpack_require__("59ed");
        var NATIVE_BIND = __webpack_require__("40d5");
        var bind = uncurryThis(uncurryThis.bind);
        module2.exports = function(fn, that) {
          aCallable(fn);
          return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
            return fn.apply(that, arguments);
          };
        };
      },
      "04d1": function(module2, exports2, __webpack_require__) {
        var userAgent = __webpack_require__("342f");
        var firefox = userAgent.match(/firefox\/(\d+)/i);
        module2.exports = !!firefox && +firefox[1];
      },
      "0538": function(module2, exports2, __webpack_require__) {
        "use strict";
        var global = __webpack_require__("da84");
        var uncurryThis = __webpack_require__("e330");
        var aCallable = __webpack_require__("59ed");
        var isObject2 = __webpack_require__("861d");
        var hasOwn = __webpack_require__("1a2d");
        var arraySlice = __webpack_require__("f36a");
        var NATIVE_BIND = __webpack_require__("40d5");
        var Function2 = global.Function;
        var concat = uncurryThis([].concat);
        var join = uncurryThis([].join);
        var factories = {};
        var construct = function(C, argsLength, args) {
          if (!hasOwn(factories, argsLength)) {
            for (var list = [], i = 0; i < argsLength; i++)
              list[i] = "a[" + i + "]";
            factories[argsLength] = Function2("C,a", "return new C(" + join(list, ",") + ")");
          }
          return factories[argsLength](C, args);
        };
        module2.exports = NATIVE_BIND ? Function2.bind : function bind(that) {
          var F = aCallable(this);
          var Prototype = F.prototype;
          var partArgs = arraySlice(arguments, 1);
          var boundFunction = function bound() {
            var args = concat(partArgs, arraySlice(arguments));
            return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
          };
          if (isObject2(Prototype))
            boundFunction.prototype = Prototype;
          return boundFunction;
        };
      },
      "057f": function(module2, exports2, __webpack_require__) {
        var classof = __webpack_require__("c6b6");
        var toIndexedObject = __webpack_require__("fc6a");
        var $getOwnPropertyNames = __webpack_require__("241c").f;
        var arraySlice = __webpack_require__("4dae");
        var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        var getWindowNames = function(it) {
          try {
            return $getOwnPropertyNames(it);
          } catch (error) {
            return arraySlice(windowNames);
          }
        };
        module2.exports.f = function getOwnPropertyNames(it) {
          return windowNames && classof(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
        };
      },
      "06cf": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var call = __webpack_require__("c65b");
        var propertyIsEnumerableModule = __webpack_require__("d1e7");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        var toIndexedObject = __webpack_require__("fc6a");
        var toPropertyKey = __webpack_require__("a04b");
        var hasOwn = __webpack_require__("1a2d");
        var IE8_DOM_DEFINE = __webpack_require__("0cfb");
        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
          O = toIndexedObject(O);
          P = toPropertyKey(P);
          if (IE8_DOM_DEFINE)
            try {
              return $getOwnPropertyDescriptor(O, P);
            } catch (error) {
            }
          if (hasOwn(O, P))
            return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
        };
      },
      "07ac": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var $values = __webpack_require__("6f53").values;
        $({ target: "Object", stat: true }, {
          values: function values(O) {
            return $values(O);
          }
        });
      },
      "07fa": function(module2, exports2, __webpack_require__) {
        var toLength = __webpack_require__("50c4");
        module2.exports = function(obj) {
          return toLength(obj.length);
        };
      },
      "0999": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", function() {
          return createCanvasContext2D;
        });
        __webpack_require__.d(__webpack_exports__, "c", function() {
          return outerWidth;
        });
        __webpack_require__.d(__webpack_exports__, "b", function() {
          return outerHeight;
        });
        __webpack_require__.d(__webpack_exports__, "g", function() {
          return replaceNode;
        });
        __webpack_require__.d(__webpack_exports__, "e", function() {
          return removeNode;
        });
        __webpack_require__.d(__webpack_exports__, "d", function() {
          return removeChildren;
        });
        __webpack_require__.d(__webpack_exports__, "f", function() {
          return replaceChildren;
        });
        var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("617d");
        function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {
          var canvas;
          if (opt_canvasPool && opt_canvasPool.length) {
            canvas = opt_canvasPool.shift();
          } else if (_has_js__WEBPACK_IMPORTED_MODULE_0__["g"]) {
            canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);
          } else {
            canvas = document.createElement("canvas");
          }
          if (opt_width) {
            canvas.width = opt_width;
          }
          if (opt_height) {
            canvas.height = opt_height;
          }
          return canvas.getContext("2d", opt_Context2DSettings);
        }
        function outerWidth(element) {
          var width = element.offsetWidth;
          var style = getComputedStyle(element);
          width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
          return width;
        }
        function outerHeight(element) {
          var height = element.offsetHeight;
          var style = getComputedStyle(element);
          height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
          return height;
        }
        function replaceNode(newNode, oldNode) {
          var parent = oldNode.parentNode;
          if (parent) {
            parent.replaceChild(newNode, oldNode);
          }
        }
        function removeNode(node) {
          return node && node.parentNode ? node.parentNode.removeChild(node) : null;
        }
        function removeChildren(node) {
          while (node.lastChild) {
            node.removeChild(node.lastChild);
          }
        }
        function replaceChildren(node, children) {
          var oldChildren = node.childNodes;
          for (var i = 0; true; ++i) {
            var oldChild = oldChildren[i];
            var newChild = children[i];
            if (!oldChild && !newChild) {
              break;
            }
            if (oldChild === newChild) {
              continue;
            }
            if (!oldChild) {
              node.appendChild(newChild);
              continue;
            }
            if (!newChild) {
              node.removeChild(oldChild);
              --i;
              continue;
            }
            node.insertBefore(newChild, oldChild);
          }
        }
      },
      "0b42": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isArray2 = __webpack_require__("e8b5");
        var isConstructor = __webpack_require__("68ee");
        var isObject2 = __webpack_require__("861d");
        var wellKnownSymbol = __webpack_require__("b622");
        var SPECIES = wellKnownSymbol("species");
        var Array2 = global.Array;
        module2.exports = function(originalArray) {
          var C;
          if (isArray2(originalArray)) {
            C = originalArray.constructor;
            if (isConstructor(C) && (C === Array2 || isArray2(C.prototype)))
              C = void 0;
            else if (isObject2(C)) {
              C = C[SPECIES];
              if (C === null)
                C = void 0;
            }
          }
          return C === void 0 ? Array2 : C;
        };
      },
      "0cb2": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var toObject = __webpack_require__("7b0b");
        var floor = Math.floor;
        var charAt = uncurryThis("".charAt);
        var replace = uncurryThis("".replace);
        var stringSlice = uncurryThis("".slice);
        var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
        module2.exports = function(matched, str, position, captures, namedCaptures, replacement) {
          var tailPos = position + matched.length;
          var m = captures.length;
          var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
          if (namedCaptures !== void 0) {
            namedCaptures = toObject(namedCaptures);
            symbols = SUBSTITUTION_SYMBOLS;
          }
          return replace(replacement, symbols, function(match, ch) {
            var capture;
            switch (charAt(ch, 0)) {
              case "$":
                return "$";
              case "&":
                return matched;
              case "`":
                return stringSlice(str, 0, position);
              case "'":
                return stringSlice(str, tailPos);
              case "<":
                capture = namedCaptures[stringSlice(ch, 1, -1)];
                break;
              default:
                var n = +ch;
                if (n === 0)
                  return match;
                if (n > m) {
                  var f = floor(n / 10);
                  if (f === 0)
                    return match;
                  if (f <= m)
                    return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
                  return match;
                }
                capture = captures[n - 1];
            }
            return capture === void 0 ? "" : capture;
          });
        };
      },
      "0cfb": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var fails = __webpack_require__("d039");
        var createElement = __webpack_require__("cc12");
        module2.exports = !DESCRIPTORS && !fails(function() {
          return Object.defineProperty(createElement("div"), "a", {
            get: function() {
              return 7;
            }
          }).a != 7;
        });
      },
      "0d51": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var String2 = global.String;
        module2.exports = function(argument) {
          try {
            return String2(argument);
          } catch (error) {
            return "Object";
          }
        };
      },
      "0ec0": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("da5c");
        var _Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("cef7");
        var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("57cb");
        var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("38f3");
        var __extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Target = function(_super) {
          __extends(Target2, _super);
          function Target2(opt_target) {
            var _this = _super.call(this) || this;
            _this.eventTarget_ = opt_target;
            _this.pendingRemovals_ = null;
            _this.dispatching_ = null;
            _this.listeners_ = null;
            return _this;
          }
          Target2.prototype.addEventListener = function(type, listener) {
            if (!type || !listener) {
              return;
            }
            var listeners = this.listeners_ || (this.listeners_ = {});
            var listenersForType = listeners[type] || (listeners[type] = []);
            if (listenersForType.indexOf(listener) === -1) {
              listenersForType.push(listener);
            }
          };
          Target2.prototype.dispatchEvent = function(event) {
            var evt = typeof event === "string" ? new _Event_js__WEBPACK_IMPORTED_MODULE_1__["a"](event) : event;
            var type = evt.type;
            if (!evt.target) {
              evt.target = this.eventTarget_ || this;
            }
            var listeners = this.listeners_ && this.listeners_[type];
            var propagate;
            if (listeners) {
              var dispatching = this.dispatching_ || (this.dispatching_ = {});
              var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
              if (!(type in dispatching)) {
                dispatching[type] = 0;
                pendingRemovals[type] = 0;
              }
              ++dispatching[type];
              for (var i = 0, ii = listeners.length; i < ii; ++i) {
                if ("handleEvent" in listeners[i]) {
                  propagate = listeners[i].handleEvent(evt);
                } else {
                  propagate = listeners[i].call(this, evt);
                }
                if (propagate === false || evt.propagationStopped) {
                  propagate = false;
                  break;
                }
              }
              --dispatching[type];
              if (dispatching[type] === 0) {
                var pr = pendingRemovals[type];
                delete pendingRemovals[type];
                while (pr--) {
                  this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__["c"]);
                }
                delete dispatching[type];
              }
              return propagate;
            }
          };
          Target2.prototype.disposeInternal = function() {
            this.listeners_ && Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["b"])(this.listeners_);
          };
          Target2.prototype.getListeners = function(type) {
            return this.listeners_ && this.listeners_[type] || void 0;
          };
          Target2.prototype.hasListener = function(opt_type) {
            if (!this.listeners_) {
              return false;
            }
            return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
          };
          Target2.prototype.removeEventListener = function(type, listener) {
            var listeners = this.listeners_ && this.listeners_[type];
            if (listeners) {
              var index = listeners.indexOf(listener);
              if (index !== -1) {
                if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                  listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__["c"];
                  ++this.pendingRemovals_[type];
                } else {
                  listeners.splice(index, 1);
                  if (listeners.length === 0) {
                    delete this.listeners_[type];
                  }
                }
              }
            }
          };
          return Target2;
        }(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__["a"]);
        __webpack_exports__["a"] = Target;
      },
      "107c": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var global = __webpack_require__("da84");
        var $RegExp = global.RegExp;
        module2.exports = fails(function() {
          var re = $RegExp("(?<a>b)", "g");
          return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
        });
      },
      "1300": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", function() {
          return abstract;
        });
        __webpack_require__.d(__webpack_exports__, "c", function() {
          return getUid;
        });
        __webpack_require__.d(__webpack_exports__, "a", function() {
          return VERSION;
        });
        function abstract() {
          return function() {
            throw new Error("Unimplemented abstract method.");
          }();
        }
        var uidCounter_ = 0;
        function getUid(obj) {
          return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
        }
        var VERSION = "6.12.0";
      },
      "14c3": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var call = __webpack_require__("c65b");
        var anObject = __webpack_require__("825a");
        var isCallable = __webpack_require__("1626");
        var classof = __webpack_require__("c6b6");
        var regexpExec = __webpack_require__("9263");
        var TypeError2 = global.TypeError;
        module2.exports = function(R, S) {
          var exec = R.exec;
          if (isCallable(exec)) {
            var result = call(exec, R, S);
            if (result !== null)
              anObject(result);
            return result;
          }
          if (classof(R) === "RegExp")
            return call(regexpExec, R, S);
          throw TypeError2("RegExp#exec called on incompatible receiver");
        };
      },
      "159b": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var DOMIterables = __webpack_require__("fdbc");
        var DOMTokenListPrototype = __webpack_require__("785a");
        var forEach = __webpack_require__("17c2");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var handlePrototype = function(CollectionPrototype) {
          if (CollectionPrototype && CollectionPrototype.forEach !== forEach)
            try {
              createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
            } catch (error) {
              CollectionPrototype.forEach = forEach;
            }
        };
        for (var COLLECTION_NAME in DOMIterables) {
          if (DOMIterables[COLLECTION_NAME]) {
            handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype);
          }
        }
        handlePrototype(DOMTokenListPrototype);
      },
      "1626": function(module2, exports2) {
        module2.exports = function(argument) {
          return typeof argument == "function";
        };
      },
      "17c2": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $forEach = __webpack_require__("b727").forEach;
        var arrayMethodIsStrict = __webpack_require__("a640");
        var STRICT_METHOD = arrayMethodIsStrict("forEach");
        module2.exports = !STRICT_METHOD ? function forEach(callbackfn) {
          return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        } : [].forEach;
      },
      "1a2d": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var toObject = __webpack_require__("7b0b");
        var hasOwnProperty = uncurryThis({}.hasOwnProperty);
        module2.exports = Object.hasOwn || function hasOwn(it, key) {
          return hasOwnProperty(toObject(it), key);
        };
      },
      "1be4": function(module2, exports2, __webpack_require__) {
        var getBuiltIn = __webpack_require__("d066");
        module2.exports = getBuiltIn("document", "documentElement");
      },
      "1c7e": function(module2, exports2, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var ITERATOR = wellKnownSymbol("iterator");
        var SAFE_CLOSING = false;
        try {
          var called = 0;
          var iteratorWithReturn = {
            next: function() {
              return { done: !!called++ };
            },
            "return": function() {
              SAFE_CLOSING = true;
            }
          };
          iteratorWithReturn[ITERATOR] = function() {
            return this;
          };
          Array.from(iteratorWithReturn, function() {
            throw 2;
          });
        } catch (error) {
        }
        module2.exports = function(exec, SKIP_CLOSING) {
          if (!SKIP_CLOSING && !SAFE_CLOSING)
            return false;
          var ITERATION_SUPPORT = false;
          try {
            var object = {};
            object[ITERATOR] = function() {
              return {
                next: function() {
                  return { done: ITERATION_SUPPORT = true };
                }
              };
            };
            exec(object);
          } catch (error) {
          }
          return ITERATION_SUPPORT;
        };
      },
      "1d80": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var TypeError2 = global.TypeError;
        module2.exports = function(it) {
          if (it == void 0)
            throw TypeError2("Can't call method on " + it);
          return it;
        };
      },
      "1dde": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var wellKnownSymbol = __webpack_require__("b622");
        var V8_VERSION = __webpack_require__("2d00");
        var SPECIES = wellKnownSymbol("species");
        module2.exports = function(METHOD_NAME) {
          return V8_VERSION >= 51 || !fails(function() {
            var array = [];
            var constructor = array.constructor = {};
            constructor[SPECIES] = function() {
              return { foo: 1 };
            };
            return array[METHOD_NAME](Boolean).foo !== 1;
          });
        };
      },
      "1e8d": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", function() {
          return listen;
        });
        __webpack_require__.d(__webpack_exports__, "b", function() {
          return listenOnce;
        });
        __webpack_require__.d(__webpack_exports__, "c", function() {
          return unlistenByKey;
        });
        var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("38f3");
        function listen(target, type, listener, opt_this, opt_once) {
          if (opt_this && opt_this !== target) {
            listener = listener.bind(opt_this);
          }
          if (opt_once) {
            var originalListener_1 = listener;
            listener = function() {
              target.removeEventListener(type, listener);
              originalListener_1.apply(this, arguments);
            };
          }
          var eventsKey = {
            target,
            type,
            listener
          };
          target.addEventListener(type, listener);
          return eventsKey;
        }
        function listenOnce(target, type, listener, opt_this) {
          return listen(target, type, listener, opt_this, true);
        }
        function unlistenByKey(key) {
          if (key && key.target) {
            key.target.removeEventListener(key.type, key.listener);
            Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["b"])(key);
          }
        }
      },
      "1fb5": function(module2, exports2, __webpack_require__) {
        "use strict";
        exports2.byteLength = byteLength;
        exports2.toByteArray = toByteArray;
        exports2.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
          var len2 = b64.length;
          if (len2 % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          var validLen = b64.indexOf("=");
          if (validLen === -1)
            validLen = len2;
          var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
          return [validLen, placeHoldersLen];
        }
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
          var curByte = 0;
          var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
          var i2;
          for (i2 = 0; i2 < len2; i2 += 4) {
            tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
            arr[curByte++] = tmp >> 16 & 255;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 2) {
            tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 1) {
            tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i2 = start; i2 < end; i2 += 3) {
            tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          var tmp;
          var len2 = uint8.length;
          var extraBytes = len2 % 3;
          var parts = [];
          var maxChunkLength = 16383;
          for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
            parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
          }
          if (extraBytes === 1) {
            tmp = uint8[len2 - 1];
            parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
          } else if (extraBytes === 2) {
            tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
            parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
          }
          return parts.join("");
        }
      },
      "21a6": function(module2, exports2, __webpack_require__) {
        (function(global) {
          var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          (function(a, b) {
            if (true)
              !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = b, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            else {
            }
          })(this, function() {
            "use strict";
            function b(a2, b2) {
              return typeof b2 == "undefined" ? b2 = { autoBom: false } : typeof b2 != "object" && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
            }
            function c(a2, b2, c2) {
              var d2 = new XMLHttpRequest();
              d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
                g(d2.response, b2, c2);
              }, d2.onerror = function() {
                console.error("could not download file");
              }, d2.send();
            }
            function d(a2) {
              var b2 = new XMLHttpRequest();
              b2.open("HEAD", a2, false);
              try {
                b2.send();
              } catch (a3) {
              }
              return 200 <= b2.status && 299 >= b2.status;
            }
            function e(a2) {
              try {
                a2.dispatchEvent(new MouseEvent("click"));
              } catch (c2) {
                var b2 = document.createEvent("MouseEvents");
                b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
              }
            }
            var f = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || (typeof window != "object" || window !== f ? function() {
            } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
              var i = f.URL || f.webkitURL, j = document.createElement("a");
              g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", typeof b2 == "string" ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
                i.revokeObjectURL(j.href);
              }, 4e4), setTimeout(function() {
                e(j);
              }, 0));
            } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
              if (g2 = g2 || f2.name || "download", typeof f2 != "string")
                navigator.msSaveOrOpenBlob(b(f2, h), g2);
              else if (d(f2))
                c(f2, g2, h);
              else {
                var i = document.createElement("a");
                i.href = f2, i.target = "_blank", setTimeout(function() {
                  e(i);
                });
              }
            } : function(b2, d2, e2, g2) {
              if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), typeof b2 == "string")
                return c(b2, d2, e2);
              var h = b2.type === "application/octet-stream", i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
              if ((j || h && i || a) && typeof FileReader != "undefined") {
                var k = new FileReader();
                k.onloadend = function() {
                  var a2 = k.result;
                  a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
                }, k.readAsDataURL(b2);
              } else {
                var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
                g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
                  l.revokeObjectURL(m);
                }, 4e4);
              }
            });
            f.saveAs = g.saveAs = g, module2.exports = g;
          });
        }).call(this, __webpack_require__("c8ba"));
      },
      "23cb": function(module2, exports2, __webpack_require__) {
        var toIntegerOrInfinity = __webpack_require__("5926");
        var max = Math.max;
        var min = Math.min;
        module2.exports = function(index, length) {
          var integer = toIntegerOrInfinity(index);
          return integer < 0 ? max(integer + length, 0) : min(integer, length);
        };
      },
      "23e7": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
        var createNonEnumerableProperty = __webpack_require__("9112");
        var redefine = __webpack_require__("6eeb");
        var setGlobal = __webpack_require__("ce4e");
        var copyConstructorProperties = __webpack_require__("e893");
        var isForced = __webpack_require__("94ca");
        module2.exports = function(options, source) {
          var TARGET = options.target;
          var GLOBAL = options.global;
          var STATIC = options.stat;
          var FORCED, target, key, targetProperty, sourceProperty, descriptor;
          if (GLOBAL) {
            target = global;
          } else if (STATIC) {
            target = global[TARGET] || setGlobal(TARGET, {});
          } else {
            target = (global[TARGET] || {}).prototype;
          }
          if (target)
            for (key in source) {
              sourceProperty = source[key];
              if (options.noTargetGet) {
                descriptor = getOwnPropertyDescriptor(target, key);
                targetProperty = descriptor && descriptor.value;
              } else
                targetProperty = target[key];
              FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
              if (!FORCED && targetProperty !== void 0) {
                if (typeof sourceProperty == typeof targetProperty)
                  continue;
                copyConstructorProperties(sourceProperty, targetProperty);
              }
              if (options.sham || targetProperty && targetProperty.sham) {
                createNonEnumerableProperty(sourceProperty, "sham", true);
              }
              redefine(target, key, sourceProperty, options);
            }
        };
      },
      "241c": function(module2, exports2, __webpack_require__) {
        var internalObjectKeys = __webpack_require__("ca84");
        var enumBugKeys = __webpack_require__("7839");
        var hiddenKeys = enumBugKeys.concat("length", "prototype");
        exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return internalObjectKeys(O, hiddenKeys);
        };
      },
      "2532": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var uncurryThis = __webpack_require__("e330");
        var notARegExp = __webpack_require__("5a34");
        var requireObjectCoercible = __webpack_require__("1d80");
        var toString = __webpack_require__("577e");
        var correctIsRegExpLogic = __webpack_require__("ab13");
        var stringIndexOf = uncurryThis("".indexOf);
        $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
          includes: function includes(searchString) {
            return !!~stringIndexOf(toString(requireObjectCoercible(this)), toString(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "25a5": function(module2, exports2, __webpack_require__) {
        !function(t, i) {
          true ? module2.exports = i() : void 0;
        }(this, function() {
          "use strict";
          function t(t2, r2, e2, a2, h2) {
            !function t3(n2, r3, e3, a3, h3) {
              for (; a3 > e3; ) {
                if (a3 - e3 > 600) {
                  var o2 = a3 - e3 + 1, s2 = r3 - e3 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e3, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                  t3(n2, r3, m2, c2, h3);
                }
                var p2 = n2[r3], d2 = e3, x = a3;
                for (i(n2, e3, r3), h3(n2[a3], p2) > 0 && i(n2, e3, a3); d2 < x; ) {
                  for (i(n2, d2, x), d2++, x--; h3(n2[d2], p2) < 0; )
                    d2++;
                  for (; h3(n2[x], p2) > 0; )
                    x--;
                }
                h3(n2[e3], p2) === 0 ? i(n2, e3, x) : i(n2, ++x, a3), x <= r3 && (e3 = x + 1), r3 <= x && (a3 = x - 1);
              }
            }(t2, r2, e2 || 0, a2 || t2.length - 1, h2 || n);
          }
          function i(t2, i2, n2) {
            var r2 = t2[i2];
            t2[i2] = t2[n2], t2[n2] = r2;
          }
          function n(t2, i2) {
            return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
          }
          var r = function(t2) {
            t2 === void 0 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
          };
          function e(t2, i2, n2) {
            if (!n2)
              return i2.indexOf(t2);
            for (var r2 = 0; r2 < i2.length; r2++)
              if (n2(t2, i2[r2]))
                return r2;
            return -1;
          }
          function a(t2, i2) {
            h(t2, 0, t2.children.length, i2, t2);
          }
          function h(t2, i2, n2, r2, e2) {
            e2 || (e2 = p(null)), e2.minX = 1 / 0, e2.minY = 1 / 0, e2.maxX = -1 / 0, e2.maxY = -1 / 0;
            for (var a2 = i2; a2 < n2; a2++) {
              var h2 = t2.children[a2];
              o(e2, t2.leaf ? r2(h2) : h2);
            }
            return e2;
          }
          function o(t2, i2) {
            return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
          }
          function s(t2, i2) {
            return t2.minX - i2.minX;
          }
          function l(t2, i2) {
            return t2.minY - i2.minY;
          }
          function f(t2) {
            return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
          }
          function u(t2) {
            return t2.maxX - t2.minX + (t2.maxY - t2.minY);
          }
          function m(t2, i2) {
            return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
          }
          function c(t2, i2) {
            return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
          }
          function p(t2) {
            return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          }
          function d(i2, n2, r2, e2, a2) {
            for (var h2 = [n2, r2]; h2.length; )
              if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e2)) {
                var o2 = n2 + Math.ceil((r2 - n2) / e2 / 2) * e2;
                t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
              }
          }
          return r.prototype.all = function() {
            return this._all(this.data, []);
          }, r.prototype.search = function(t2) {
            var i2 = this.data, n2 = [];
            if (!c(t2, i2))
              return n2;
            for (var r2 = this.toBBox, e2 = []; i2; ) {
              for (var a2 = 0; a2 < i2.children.length; a2++) {
                var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
                c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e2.push(h2));
              }
              i2 = e2.pop();
            }
            return n2;
          }, r.prototype.collides = function(t2) {
            var i2 = this.data;
            if (!c(t2, i2))
              return false;
            for (var n2 = []; i2; ) {
              for (var r2 = 0; r2 < i2.children.length; r2++) {
                var e2 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e2) : e2;
                if (c(t2, a2)) {
                  if (i2.leaf || m(t2, a2))
                    return true;
                  n2.push(e2);
                }
              }
              i2 = n2.pop();
            }
            return false;
          }, r.prototype.load = function(t2) {
            if (!t2 || !t2.length)
              return this;
            if (t2.length < this._minEntries) {
              for (var i2 = 0; i2 < t2.length; i2++)
                this.insert(t2[i2]);
              return this;
            }
            var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
            if (this.data.children.length)
              if (this.data.height === n2.height)
                this._splitRoot(this.data, n2);
              else {
                if (this.data.height < n2.height) {
                  var r2 = this.data;
                  this.data = n2, n2 = r2;
                }
                this._insert(n2, this.data.height - n2.height - 1, true);
              }
            else
              this.data = n2;
            return this;
          }, r.prototype.insert = function(t2) {
            return t2 && this._insert(t2, this.data.height - 1), this;
          }, r.prototype.clear = function() {
            return this.data = p([]), this;
          }, r.prototype.remove = function(t2, i2) {
            if (!t2)
              return this;
            for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
              if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
                var f2 = e(t2, h2.children, i2);
                if (f2 !== -1)
                  return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
              }
              a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
            }
            return this;
          }, r.prototype.toBBox = function(t2) {
            return t2;
          }, r.prototype.compareMinX = function(t2, i2) {
            return t2.minX - i2.minX;
          }, r.prototype.compareMinY = function(t2, i2) {
            return t2.minY - i2.minY;
          }, r.prototype.toJSON = function() {
            return this.data;
          }, r.prototype.fromJSON = function(t2) {
            return this.data = t2, this;
          }, r.prototype._all = function(t2, i2) {
            for (var n2 = []; t2; )
              t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
            return i2;
          }, r.prototype._build = function(t2, i2, n2, r2) {
            var e2, h2 = n2 - i2 + 1, o2 = this._maxEntries;
            if (h2 <= o2)
              return a(e2 = p(t2.slice(i2, n2 + 1)), this.toBBox), e2;
            r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e2 = p([])).leaf = false, e2.height = r2;
            var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
            d(t2, i2, n2, l2, this.compareMinX);
            for (var f2 = i2; f2 <= n2; f2 += l2) {
              var u2 = Math.min(f2 + l2 - 1, n2);
              d(t2, f2, u2, s2, this.compareMinY);
              for (var m2 = f2; m2 <= u2; m2 += s2) {
                var c2 = Math.min(m2 + s2 - 1, u2);
                e2.children.push(this._build(t2, m2, c2, r2 - 1));
              }
            }
            return a(e2, this.toBBox), e2;
          }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
            for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
              for (var e2 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
                var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
                u2 < a2 ? (a2 = u2, e2 = l2 < e2 ? l2 : e2, h2 = s2) : u2 === a2 && l2 < e2 && (e2 = l2, h2 = s2);
              }
              i2 = h2 || i2.children[0];
            }
            var m2, c2;
            return i2;
          }, r.prototype._insert = function(t2, i2, n2) {
            var r2 = n2 ? t2 : this.toBBox(t2), e2 = [], a2 = this._chooseSubtree(r2, this.data, i2, e2);
            for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e2[i2].children.length > this._maxEntries; )
              this._split(e2, i2), i2--;
            this._adjustParentBBoxes(r2, e2, i2);
          }, r.prototype._split = function(t2, i2) {
            var n2 = t2[i2], r2 = n2.children.length, e2 = this._minEntries;
            this._chooseSplitAxis(n2, e2, r2);
            var h2 = this._chooseSplitIndex(n2, e2, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
            o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
          }, r.prototype._splitRoot = function(t2, i2) {
            this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
          }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
            for (var r2, e2, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
              var d2 = h(t2, 0, p2, this.toBBox), x = h(t2, p2, n2, this.toBBox), v = (e2 = d2, a2 = x, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e2.minX, a2.minX), s2 = Math.max(e2.minY, a2.minY), l2 = Math.min(e2.maxX, a2.maxX), u2 = Math.min(e2.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x);
              v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
            }
            return r2 || n2 - i2;
          }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
            var r2 = t2.leaf ? this.compareMinX : s, e2 = t2.leaf ? this.compareMinY : l;
            this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e2) && t2.children.sort(r2);
          }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
            t2.children.sort(r2);
            for (var e2 = this.toBBox, a2 = h(t2, 0, i2, e2), s2 = h(t2, n2 - i2, n2, e2), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
              var m2 = t2.children[f2];
              o(a2, t2.leaf ? e2(m2) : m2), l2 += u(a2);
            }
            for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
              var p2 = t2.children[c2];
              o(s2, t2.leaf ? e2(p2) : p2), l2 += u(s2);
            }
            return l2;
          }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
            for (var r2 = n2; r2 >= 0; r2--)
              o(i2[r2], t2);
          }, r.prototype._condense = function(t2) {
            for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
              t2[i2].children.length === 0 ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
          }, r;
        });
      },
      "2a62": function(module2, exports2, __webpack_require__) {
        var call = __webpack_require__("c65b");
        var anObject = __webpack_require__("825a");
        var getMethod = __webpack_require__("dc4a");
        module2.exports = function(iterator, kind, value) {
          var innerResult, innerError;
          anObject(iterator);
          try {
            innerResult = getMethod(iterator, "return");
            if (!innerResult) {
              if (kind === "throw")
                throw value;
              return value;
            }
            innerResult = call(innerResult, iterator);
          } catch (error) {
            innerError = true;
            innerResult = error;
          }
          if (kind === "throw")
            throw value;
          if (innerError)
            throw innerResult;
          anObject(innerResult);
          return value;
        };
      },
      "2ba4": function(module2, exports2, __webpack_require__) {
        var NATIVE_BIND = __webpack_require__("40d5");
        var FunctionPrototype = Function.prototype;
        var apply = FunctionPrototype.apply;
        var call = FunctionPrototype.call;
        module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
          return call.apply(apply, arguments);
        });
      },
      "2d00": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var userAgent = __webpack_require__("342f");
        var process2 = global.process;
        var Deno = global.Deno;
        var versions = process2 && process2.versions || Deno && Deno.version;
        var v8 = versions && versions.v8;
        var match, version;
        if (v8) {
          match = v8.split(".");
          version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
        }
        if (!version && userAgent) {
          match = userAgent.match(/Edge\/(\d+)/);
          if (!match || match[1] >= 74) {
            match = userAgent.match(/Chrome\/(\d+)/);
            if (match)
              version = +match[1];
          }
        }
        module2.exports = version;
      },
      "3410": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var fails = __webpack_require__("d039");
        var toObject = __webpack_require__("7b0b");
        var nativeGetPrototypeOf = __webpack_require__("e163");
        var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeGetPrototypeOf(1);
        });
        $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
          getPrototypeOf: function getPrototypeOf(it) {
            return nativeGetPrototypeOf(toObject(it));
          }
        });
      },
      "342f": function(module2, exports2, __webpack_require__) {
        var getBuiltIn = __webpack_require__("d066");
        module2.exports = getBuiltIn("navigator", "userAgent") || "";
      },
      "35a1": function(module2, exports2, __webpack_require__) {
        var classof = __webpack_require__("f5df");
        var getMethod = __webpack_require__("dc4a");
        var Iterators = __webpack_require__("3f8c");
        var wellKnownSymbol = __webpack_require__("b622");
        var ITERATOR = wellKnownSymbol("iterator");
        module2.exports = function(it) {
          if (it != void 0)
            return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
        };
      },
      "35a7": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", function() {
          return unByKey;
        });
        var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0ec0");
        var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("01d4");
        var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("1e8d");
        var __extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Observable = function(_super) {
          __extends(Observable2, _super);
          function Observable2() {
            var _this = _super.call(this) || this;
            _this.on = _this.onInternal;
            _this.once = _this.onceInternal;
            _this.un = _this.unInternal;
            _this.revision_ = 0;
            return _this;
          }
          Observable2.prototype.changed = function() {
            ++this.revision_;
            this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["a"].CHANGE);
          };
          Observable2.prototype.getRevision = function() {
            return this.revision_;
          };
          Observable2.prototype.onInternal = function(type, listener) {
            if (Array.isArray(type)) {
              var len = type.length;
              var keys = new Array(len);
              for (var i = 0; i < len; ++i) {
                keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["a"])(this, type[i], listener);
              }
              return keys;
            } else {
              return Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["a"])(this, type, listener);
            }
          };
          Observable2.prototype.onceInternal = function(type, listener) {
            var key;
            if (Array.isArray(type)) {
              var len = type.length;
              key = new Array(len);
              for (var i = 0; i < len; ++i) {
                key[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["b"])(this, type[i], listener);
              }
            } else {
              key = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["b"])(this, type, listener);
            }
            listener.ol_key = key;
            return key;
          };
          Observable2.prototype.unInternal = function(type, listener) {
            var key = listener.ol_key;
            if (key) {
              unByKey(key);
            } else if (Array.isArray(type)) {
              for (var i = 0, ii = type.length; i < ii; ++i) {
                this.removeEventListener(type[i], listener);
              }
            } else {
              this.removeEventListener(type, listener);
            }
          };
          return Observable2;
        }(_events_Target_js__WEBPACK_IMPORTED_MODULE_0__["a"]);
        Observable.prototype.on;
        Observable.prototype.once;
        Observable.prototype.un;
        function unByKey(key) {
          if (Array.isArray(key)) {
            for (var i = 0, ii = key.length; i < ii; ++i) {
              Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["c"])(key[i]);
            }
          } else {
            Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["c"])(key);
          }
        }
        __webpack_exports__["a"] = Observable;
      },
      "37e8": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__("aed9");
        var definePropertyModule = __webpack_require__("9bf2");
        var anObject = __webpack_require__("825a");
        var toIndexedObject = __webpack_require__("fc6a");
        var objectKeys = __webpack_require__("df75");
        exports2.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var props = toIndexedObject(Properties);
          var keys = objectKeys(Properties);
          var length = keys.length;
          var index = 0;
          var key;
          while (length > index)
            definePropertyModule.f(O, key = keys[index++], props[key]);
          return O;
        };
      },
      "38f3": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", function() {
          return assign;
        });
        __webpack_require__.d(__webpack_exports__, "b", function() {
          return clear;
        });
        __webpack_require__.d(__webpack_exports__, "c", function() {
          return getValues;
        });
        __webpack_require__.d(__webpack_exports__, "d", function() {
          return isEmpty;
        });
        var assign = typeof Object.assign === "function" ? Object.assign : function(target, var_sources) {
          if (target === void 0 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var i = 1, ii = arguments.length; i < ii; ++i) {
            var source = arguments[i];
            if (source !== void 0 && source !== null) {
              for (var key in source) {
                if (source.hasOwnProperty(key)) {
                  output[key] = source[key];
                }
              }
            }
          }
          return output;
        };
        function clear(object) {
          for (var property in object) {
            delete object[property];
          }
        }
        var getValues = typeof Object.values === "function" ? Object.values : function(object) {
          var values = [];
          for (var property in object) {
            values.push(object[property]);
          }
          return values;
        };
        function isEmpty(object) {
          var property;
          for (property in object) {
            return false;
          }
          return !property;
        }
      },
      "3900": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e269");
        var _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("592d");
        var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("57cb");
        var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("1e8d");
        var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0999");
        var __extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Control = function(_super) {
          __extends(Control2, _super);
          function Control2(options) {
            var _this = _super.call(this) || this;
            var element = options.element;
            if (element && !options.target && !element.style.pointerEvents) {
              element.style.pointerEvents = "auto";
            }
            _this.element = element ? element : null;
            _this.target_ = null;
            _this.map_ = null;
            _this.listenerKeys = [];
            if (options.render) {
              _this.render = options.render;
            }
            if (options.target) {
              _this.setTarget(options.target);
            }
            return _this;
          }
          Control2.prototype.disposeInternal = function() {
            Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__["e"])(this.element);
            _super.prototype.disposeInternal.call(this);
          };
          Control2.prototype.getMap = function() {
            return this.map_;
          };
          Control2.prototype.setMap = function(map) {
            if (this.map_) {
              Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__["e"])(this.element);
            }
            for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
              Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["c"])(this.listenerKeys[i]);
            }
            this.listenerKeys.length = 0;
            this.map_ = map;
            if (this.map_) {
              var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
              target.appendChild(this.element);
              if (this.render !== _functions_js__WEBPACK_IMPORTED_MODULE_2__["c"]) {
                this.listenerKeys.push(Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["a"])(map, _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__["a"].POSTRENDER, this.render, this));
              }
              map.render();
            }
          };
          Control2.prototype.render = function(mapEvent) {
          };
          Control2.prototype.setTarget = function(target) {
            this.target_ = typeof target === "string" ? document.getElementById(target) : target;
          };
          return Control2;
        }(_Object_js__WEBPACK_IMPORTED_MODULE_0__["a"]);
        __webpack_exports__["default"] = Control;
      },
      "3a9b": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        module2.exports = uncurryThis({}.isPrototypeOf);
      },
      "3bbe": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isCallable = __webpack_require__("1626");
        var String2 = global.String;
        var TypeError2 = global.TypeError;
        module2.exports = function(argument) {
          if (typeof argument == "object" || isCallable(argument))
            return argument;
          throw TypeError2("Can't set " + String2(argument) + " as a prototype");
        };
      },
      "3ca3": function(module2, exports2, __webpack_require__) {
        "use strict";
        var charAt = __webpack_require__("6547").charAt;
        var toString = __webpack_require__("577e");
        var InternalStateModule = __webpack_require__("69f3");
        var defineIterator = __webpack_require__("7dd0");
        var STRING_ITERATOR = "String Iterator";
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
        defineIterator(String, "String", function(iterated) {
          setInternalState(this, {
            type: STRING_ITERATOR,
            string: toString(iterated),
            index: 0
          });
        }, function next() {
          var state = getInternalState(this);
          var string = state.string;
          var index = state.index;
          var point;
          if (index >= string.length)
            return { value: void 0, done: true };
          point = charAt(string, index);
          state.index += point.length;
          return { value: point, done: false };
        });
      },
      "3f8c": function(module2, exports2) {
        module2.exports = {};
      },
      "408a": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        module2.exports = uncurryThis(1 .valueOf);
      },
      "40d5": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        module2.exports = !fails(function() {
          var test = function() {
          }.bind();
          return typeof test != "function" || test.hasOwnProperty("prototype");
        });
      },
      "428f": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        module2.exports = global;
      },
      "44ad": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var uncurryThis = __webpack_require__("e330");
        var fails = __webpack_require__("d039");
        var classof = __webpack_require__("c6b6");
        var Object2 = global.Object;
        var split = uncurryThis("".split);
        module2.exports = fails(function() {
          return !Object2("z").propertyIsEnumerable(0);
        }) ? function(it) {
          return classof(it) == "String" ? split(it, "") : Object2(it);
        } : Object2;
      },
      "44d2": function(module2, exports2, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var create = __webpack_require__("7c73");
        var definePropertyModule = __webpack_require__("9bf2");
        var UNSCOPABLES = wellKnownSymbol("unscopables");
        var ArrayPrototype = Array.prototype;
        if (ArrayPrototype[UNSCOPABLES] == void 0) {
          definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
            configurable: true,
            value: create(null)
          });
        }
        module2.exports = function(key) {
          ArrayPrototype[UNSCOPABLES][key] = true;
        };
      },
      "44e7": function(module2, exports2, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        var classof = __webpack_require__("c6b6");
        var wellKnownSymbol = __webpack_require__("b622");
        var MATCH = wellKnownSymbol("match");
        module2.exports = function(it) {
          var isRegExp;
          return isObject2(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
        };
      },
      "485a": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var call = __webpack_require__("c65b");
        var isCallable = __webpack_require__("1626");
        var isObject2 = __webpack_require__("861d");
        var TypeError2 = global.TypeError;
        module2.exports = function(input, pref) {
          var fn, val;
          if (pref === "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input)))
            return val;
          if (isCallable(fn = input.valueOf) && !isObject2(val = call(fn, input)))
            return val;
          if (pref !== "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input)))
            return val;
          throw TypeError2("Can't convert object to primitive value");
        };
      },
      "4930": function(module2, exports2, __webpack_require__) {
        var V8_VERSION = __webpack_require__("2d00");
        var fails = __webpack_require__("d039");
        module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
          var symbol = Symbol();
          return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
        });
      },
      "4ae1": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var getBuiltIn = __webpack_require__("d066");
        var apply = __webpack_require__("2ba4");
        var bind = __webpack_require__("0538");
        var aConstructor = __webpack_require__("5087");
        var anObject = __webpack_require__("825a");
        var isObject2 = __webpack_require__("861d");
        var create = __webpack_require__("7c73");
        var fails = __webpack_require__("d039");
        var nativeConstruct = getBuiltIn("Reflect", "construct");
        var ObjectPrototype = Object.prototype;
        var push = [].push;
        var NEW_TARGET_BUG = fails(function() {
          function F() {
          }
          return !(nativeConstruct(function() {
          }, [], F) instanceof F);
        });
        var ARGS_BUG = !fails(function() {
          nativeConstruct(function() {
          });
        });
        var FORCED = NEW_TARGET_BUG || ARGS_BUG;
        $({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
          construct: function construct(Target, args) {
            aConstructor(Target);
            anObject(args);
            var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
            if (ARGS_BUG && !NEW_TARGET_BUG)
              return nativeConstruct(Target, args, newTarget);
            if (Target == newTarget) {
              switch (args.length) {
                case 0:
                  return new Target();
                case 1:
                  return new Target(args[0]);
                case 2:
                  return new Target(args[0], args[1]);
                case 3:
                  return new Target(args[0], args[1], args[2]);
                case 4:
                  return new Target(args[0], args[1], args[2], args[3]);
              }
              var $args = [null];
              apply(push, $args, args);
              return new (apply(bind, Target, $args))();
            }
            var proto = newTarget.prototype;
            var instance = create(isObject2(proto) ? proto : ObjectPrototype);
            var result = apply(Target, instance, args);
            return isObject2(result) ? result : instance;
          }
        });
      },
      "4d64": function(module2, exports2, __webpack_require__) {
        var toIndexedObject = __webpack_require__("fc6a");
        var toAbsoluteIndex = __webpack_require__("23cb");
        var lengthOfArrayLike = __webpack_require__("07fa");
        var createMethod = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var O = toIndexedObject($this);
            var length = lengthOfArrayLike(O);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            if (IS_INCLUDES && el != el)
              while (length > index) {
                value = O[index++];
                if (value != value)
                  return true;
              }
            else
              for (; length > index; index++) {
                if ((IS_INCLUDES || index in O) && O[index] === el)
                  return IS_INCLUDES || index || 0;
              }
            return !IS_INCLUDES && -1;
          };
        };
        module2.exports = {
          includes: createMethod(true),
          indexOf: createMethod(false)
        };
      },
      "4dae": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var toAbsoluteIndex = __webpack_require__("23cb");
        var lengthOfArrayLike = __webpack_require__("07fa");
        var createProperty = __webpack_require__("8418");
        var Array2 = global.Array;
        var max = Math.max;
        module2.exports = function(O, start, end) {
          var length = lengthOfArrayLike(O);
          var k = toAbsoluteIndex(start, length);
          var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
          var result = Array2(max(fin - k, 0));
          for (var n = 0; k < fin; k++, n++)
            createProperty(result, n, O[k]);
          result.length = n;
          return result;
        };
      },
      "4de4": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $filter = __webpack_require__("b727").filter;
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
          filter: function filter(callbackfn) {
            return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "4df4": function(module2, exports2, __webpack_require__) {
        "use strict";
        var global = __webpack_require__("da84");
        var bind = __webpack_require__("0366");
        var call = __webpack_require__("c65b");
        var toObject = __webpack_require__("7b0b");
        var callWithSafeIterationClosing = __webpack_require__("9bdd");
        var isArrayIteratorMethod = __webpack_require__("e95a");
        var isConstructor = __webpack_require__("68ee");
        var lengthOfArrayLike = __webpack_require__("07fa");
        var createProperty = __webpack_require__("8418");
        var getIterator = __webpack_require__("9a1f");
        var getIteratorMethod = __webpack_require__("35a1");
        var Array2 = global.Array;
        module2.exports = function from(arrayLike) {
          var O = toObject(arrayLike);
          var IS_CONSTRUCTOR = isConstructor(this);
          var argumentsLength = arguments.length;
          var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
          var mapping = mapfn !== void 0;
          if (mapping)
            mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
          var iteratorMethod = getIteratorMethod(O);
          var index = 0;
          var length, result, step, iterator, next, value;
          if (iteratorMethod && !(this == Array2 && isArrayIteratorMethod(iteratorMethod))) {
            iterator = getIterator(O, iteratorMethod);
            next = iterator.next;
            result = IS_CONSTRUCTOR ? new this() : [];
            for (; !(step = call(next, iterator)).done; index++) {
              value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
              createProperty(result, index, value);
            }
          } else {
            length = lengthOfArrayLike(O);
            result = IS_CONSTRUCTOR ? new this(length) : Array2(length);
            for (; length > index; index++) {
              value = mapping ? mapfn(O[index], index) : O[index];
              createProperty(result, index, value);
            }
          }
          result.length = index;
          return result;
        };
      },
      "4e82": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var uncurryThis = __webpack_require__("e330");
        var aCallable = __webpack_require__("59ed");
        var toObject = __webpack_require__("7b0b");
        var lengthOfArrayLike = __webpack_require__("07fa");
        var toString = __webpack_require__("577e");
        var fails = __webpack_require__("d039");
        var internalSort = __webpack_require__("addb");
        var arrayMethodIsStrict = __webpack_require__("a640");
        var FF = __webpack_require__("04d1");
        var IE_OR_EDGE = __webpack_require__("d998");
        var V8 = __webpack_require__("2d00");
        var WEBKIT = __webpack_require__("512c");
        var test = [];
        var un$Sort = uncurryThis(test.sort);
        var push = uncurryThis(test.push);
        var FAILS_ON_UNDEFINED = fails(function() {
          test.sort(void 0);
        });
        var FAILS_ON_NULL = fails(function() {
          test.sort(null);
        });
        var STRICT_METHOD = arrayMethodIsStrict("sort");
        var STABLE_SORT = !fails(function() {
          if (V8)
            return V8 < 70;
          if (FF && FF > 3)
            return;
          if (IE_OR_EDGE)
            return true;
          if (WEBKIT)
            return WEBKIT < 603;
          var result = "";
          var code, chr, value, index;
          for (code = 65; code < 76; code++) {
            chr = String.fromCharCode(code);
            switch (code) {
              case 66:
              case 69:
              case 70:
              case 72:
                value = 3;
                break;
              case 68:
              case 71:
                value = 4;
                break;
              default:
                value = 2;
            }
            for (index = 0; index < 47; index++) {
              test.push({ k: chr + index, v: value });
            }
          }
          test.sort(function(a, b) {
            return b.v - a.v;
          });
          for (index = 0; index < test.length; index++) {
            chr = test[index].k.charAt(0);
            if (result.charAt(result.length - 1) !== chr)
              result += chr;
          }
          return result !== "DGBEFHACIJK";
        });
        var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
        var getSortCompare = function(comparefn) {
          return function(x, y) {
            if (y === void 0)
              return -1;
            if (x === void 0)
              return 1;
            if (comparefn !== void 0)
              return +comparefn(x, y) || 0;
            return toString(x) > toString(y) ? 1 : -1;
          };
        };
        $({ target: "Array", proto: true, forced: FORCED }, {
          sort: function sort(comparefn) {
            if (comparefn !== void 0)
              aCallable(comparefn);
            var array = toObject(this);
            if (STABLE_SORT)
              return comparefn === void 0 ? un$Sort(array) : un$Sort(array, comparefn);
            var items = [];
            var arrayLength = lengthOfArrayLike(array);
            var itemsLength, index;
            for (index = 0; index < arrayLength; index++) {
              if (index in array)
                push(items, array[index]);
            }
            internalSort(items, getSortCompare(comparefn));
            itemsLength = items.length;
            index = 0;
            while (index < itemsLength)
              array[index] = items[index++];
            while (index < arrayLength)
              delete array[index++];
            return array;
          }
        });
      },
      "5087": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isConstructor = __webpack_require__("68ee");
        var tryToString = __webpack_require__("0d51");
        var TypeError2 = global.TypeError;
        module2.exports = function(argument) {
          if (isConstructor(argument))
            return argument;
          throw TypeError2(tryToString(argument) + " is not a constructor");
        };
      },
      "50c4": function(module2, exports2, __webpack_require__) {
        var toIntegerOrInfinity = __webpack_require__("5926");
        var min = Math.min;
        module2.exports = function(argument) {
          return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
        };
      },
      "512c": function(module2, exports2, __webpack_require__) {
        var userAgent = __webpack_require__("342f");
        var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
        module2.exports = !!webkit && +webkit[1];
      },
      "5319": function(module2, exports2, __webpack_require__) {
        "use strict";
        var apply = __webpack_require__("2ba4");
        var call = __webpack_require__("c65b");
        var uncurryThis = __webpack_require__("e330");
        var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
        var fails = __webpack_require__("d039");
        var anObject = __webpack_require__("825a");
        var isCallable = __webpack_require__("1626");
        var toIntegerOrInfinity = __webpack_require__("5926");
        var toLength = __webpack_require__("50c4");
        var toString = __webpack_require__("577e");
        var requireObjectCoercible = __webpack_require__("1d80");
        var advanceStringIndex = __webpack_require__("8aa5");
        var getMethod = __webpack_require__("dc4a");
        var getSubstitution = __webpack_require__("0cb2");
        var regExpExec = __webpack_require__("14c3");
        var wellKnownSymbol = __webpack_require__("b622");
        var REPLACE = wellKnownSymbol("replace");
        var max = Math.max;
        var min = Math.min;
        var concat = uncurryThis([].concat);
        var push = uncurryThis([].push);
        var stringIndexOf = uncurryThis("".indexOf);
        var stringSlice = uncurryThis("".slice);
        var maybeToString = function(it) {
          return it === void 0 ? it : String(it);
        };
        var REPLACE_KEEPS_$0 = function() {
          return "a".replace(/./, "$0") === "$0";
        }();
        var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
          if (/./[REPLACE]) {
            return /./[REPLACE]("a", "$0") === "";
          }
          return false;
        }();
        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
          var re = /./;
          re.exec = function() {
            var result = [];
            result.groups = { a: "7" };
            return result;
          };
          return "".replace(re, "$<a>") !== "7";
        });
        fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
          var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
          return [
            function replace(searchValue, replaceValue) {
              var O = requireObjectCoercible(this);
              var replacer = searchValue == void 0 ? void 0 : getMethod(searchValue, REPLACE);
              return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
            },
            function(string, replaceValue) {
              var rx = anObject(this);
              var S = toString(string);
              if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
                var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
                if (res.done)
                  return res.value;
              }
              var functionalReplace = isCallable(replaceValue);
              if (!functionalReplace)
                replaceValue = toString(replaceValue);
              var global = rx.global;
              if (global) {
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
              }
              var results = [];
              while (true) {
                var result = regExpExec(rx, S);
                if (result === null)
                  break;
                push(results, result);
                if (!global)
                  break;
                var matchStr = toString(result[0]);
                if (matchStr === "")
                  rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
              }
              var accumulatedResult = "";
              var nextSourcePosition = 0;
              for (var i = 0; i < results.length; i++) {
                result = results[i];
                var matched = toString(result[0]);
                var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
                var captures = [];
                for (var j = 1; j < result.length; j++)
                  push(captures, maybeToString(result[j]));
                var namedCaptures = result.groups;
                if (functionalReplace) {
                  var replacerArgs = concat([matched], captures, position, S);
                  if (namedCaptures !== void 0)
                    push(replacerArgs, namedCaptures);
                  var replacement = toString(apply(replaceValue, void 0, replacerArgs));
                } else {
                  replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                }
                if (position >= nextSourcePosition) {
                  accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
                  nextSourcePosition = position + matched.length;
                }
              }
              return accumulatedResult + stringSlice(S, nextSourcePosition);
            }
          ];
        }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
      },
      "5692": function(module2, exports2, __webpack_require__) {
        var IS_PURE = __webpack_require__("c430");
        var store = __webpack_require__("c6cd");
        (module2.exports = function(key, value) {
          return store[key] || (store[key] = value !== void 0 ? value : {});
        })("versions", []).push({
          version: "3.20.3",
          mode: IS_PURE ? "pure" : "global",
          copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
          license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE",
          source: "https://github.com/zloirock/core-js"
        });
      },
      "56ef": function(module2, exports2, __webpack_require__) {
        var getBuiltIn = __webpack_require__("d066");
        var uncurryThis = __webpack_require__("e330");
        var getOwnPropertyNamesModule = __webpack_require__("241c");
        var getOwnPropertySymbolsModule = __webpack_require__("7418");
        var anObject = __webpack_require__("825a");
        var concat = uncurryThis([].concat);
        module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
          var keys = getOwnPropertyNamesModule.f(anObject(it));
          var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
        };
      },
      "577e": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var classof = __webpack_require__("f5df");
        var String2 = global.String;
        module2.exports = function(argument) {
          if (classof(argument) === "Symbol")
            throw TypeError("Cannot convert a Symbol value to a string");
          return String2(argument);
        };
      },
      "57cb": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", function() {
          return TRUE;
        });
        __webpack_require__.d(__webpack_exports__, "a", function() {
          return FALSE;
        });
        __webpack_require__.d(__webpack_exports__, "c", function() {
          return VOID;
        });
        __webpack_require__.d(__webpack_exports__, "d", function() {
          return memoizeOne;
        });
        var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9f5e");
        function TRUE() {
          return true;
        }
        function FALSE() {
          return false;
        }
        function VOID() {
        }
        function memoizeOne(fn) {
          var called = false;
          var lastResult;
          var lastArgs;
          var lastThis;
          return function() {
            var nextArgs = Array.prototype.slice.call(arguments);
            if (!called || this !== lastThis || !Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["b"])(nextArgs, lastArgs)) {
              called = true;
              lastThis = this;
              lastArgs = nextArgs;
              lastResult = fn.apply(this, arguments);
            }
            return lastResult;
          };
        }
        function toPromise(getter) {
          function promiseGetter() {
            var value;
            try {
              value = getter();
            } catch (err) {
              return Promise.reject(err);
            }
            if (value instanceof Promise) {
              return value;
            }
            return Promise.resolve(value);
          }
          return promiseGetter();
        }
      },
      "5899": function(module2, exports2) {
        module2.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
      },
      "58a8": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var requireObjectCoercible = __webpack_require__("1d80");
        var toString = __webpack_require__("577e");
        var whitespaces = __webpack_require__("5899");
        var replace = uncurryThis("".replace);
        var whitespace = "[" + whitespaces + "]";
        var ltrim = RegExp("^" + whitespace + whitespace + "*");
        var rtrim = RegExp(whitespace + whitespace + "*$");
        var createMethod = function(TYPE) {
          return function($this) {
            var string = toString(requireObjectCoercible($this));
            if (TYPE & 1)
              string = replace(string, ltrim, "");
            if (TYPE & 2)
              string = replace(string, rtrim, "");
            return string;
          };
        };
        module2.exports = {
          start: createMethod(1),
          end: createMethod(2),
          trim: createMethod(3)
        };
      },
      "5926": function(module2, exports2) {
        var ceil = Math.ceil;
        var floor = Math.floor;
        module2.exports = function(argument) {
          var number = +argument;
          return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
        };
      },
      "592d": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_exports__["a"] = {
          POSTRENDER: "postrender",
          MOVESTART: "movestart",
          MOVEEND: "moveend"
        };
      },
      "59ed": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isCallable = __webpack_require__("1626");
        var tryToString = __webpack_require__("0d51");
        var TypeError2 = global.TypeError;
        module2.exports = function(argument) {
          if (isCallable(argument))
            return argument;
          throw TypeError2(tryToString(argument) + " is not a function");
        };
      },
      "5a34": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isRegExp = __webpack_require__("44e7");
        var TypeError2 = global.TypeError;
        module2.exports = function(it) {
          if (isRegExp(it)) {
            throw TypeError2("The method doesn't accept regular expressions");
          }
          return it;
        };
      },
      "5bc0": function(module2, exports2, __webpack_require__) {
      },
      "5c6c": function(module2, exports2) {
        module2.exports = function(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value
          };
        };
      },
      "5e77": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var hasOwn = __webpack_require__("1a2d");
        var FunctionPrototype = Function.prototype;
        var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
        var EXISTS = hasOwn(FunctionPrototype, "name");
        var PROPER = EXISTS && function something() {
        }.name === "something";
        var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
        module2.exports = {
          EXISTS,
          PROPER,
          CONFIGURABLE
        };
      },
      "617d": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", function() {
          return FIREFOX;
        });
        __webpack_require__.d(__webpack_exports__, "f", function() {
          return WEBKIT;
        });
        __webpack_require__.d(__webpack_exports__, "d", function() {
          return MAC;
        });
        __webpack_require__.d(__webpack_exports__, "a", function() {
          return DEVICE_PIXEL_RATIO;
        });
        __webpack_require__.d(__webpack_exports__, "g", function() {
          return WORKER_OFFSCREEN_CANVAS;
        });
        __webpack_require__.d(__webpack_exports__, "c", function() {
          return IMAGE_DECODE;
        });
        __webpack_require__.d(__webpack_exports__, "e", function() {
          return PASSIVE_EVENT_LISTENERS;
        });
        var ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
        var FIREFOX = ua.indexOf("firefox") !== -1;
        var SAFARI = ua.indexOf("safari") !== -1 && ua.indexOf("chrom") == -1;
        var WEBKIT = ua.indexOf("webkit") !== -1 && ua.indexOf("edge") == -1;
        var MAC = ua.indexOf("macintosh") !== -1;
        var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
        var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
        var IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
        var PASSIVE_EVENT_LISTENERS = function() {
          var passive = false;
          try {
            var options = Object.defineProperty({}, "passive", {
              get: function() {
                passive = true;
              }
            });
            window.addEventListener("_", null, options);
            window.removeEventListener("_", null, options);
          } catch (error) {
          }
          return passive;
        }();
      },
      "6547": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var toIntegerOrInfinity = __webpack_require__("5926");
        var toString = __webpack_require__("577e");
        var requireObjectCoercible = __webpack_require__("1d80");
        var charAt = uncurryThis("".charAt);
        var charCodeAt = uncurryThis("".charCodeAt);
        var stringSlice = uncurryThis("".slice);
        var createMethod = function(CONVERT_TO_STRING) {
          return function($this, pos) {
            var S = toString(requireObjectCoercible($this));
            var position = toIntegerOrInfinity(pos);
            var size = S.length;
            var first, second;
            if (position < 0 || position >= size)
              return CONVERT_TO_STRING ? "" : void 0;
            first = charCodeAt(S, position);
            return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
          };
        };
        module2.exports = {
          codeAt: createMethod(false),
          charAt: createMethod(true)
        };
      },
      "658f": function(module2, exports2, __webpack_require__) {
        !function(t, e) {
          true ? module2.exports = e(__webpack_require__("3900")) : void 0;
        }(this, function(t) {
          "use strict";
          function e(t2) {
            return t2 && typeof t2 == "object" && "default" in t2 ? t2 : { default: t2 };
          }
          var n = e(t), i = "ol-ctx-menu", o = { namespace: i, container: i + "-container", separator: i + "-separator", submenu: i + "-submenu", hidden: i + "-hidden", icon: i + "-icon", zoomIn: i + "-zoom-in", zoomOut: i + "-zoom-out", unselectable: "ol-unselectable" }, s = o, a = "beforeopen", r = "open", l = "close", c = "contextmenu", h = { width: 150, scrollAt: 4, eventType: c, defaultItems: true }, p = [{ text: "Zoom In", classname: o.zoomIn + " " + o.icon, callback: function(t2, e2) {
            var n2 = e2.getView();
            n2.animate({ zoom: +n2.getZoom() + 1, duration: 700, center: t2.coordinate });
          } }, { text: "Zoom Out", classname: o.zoomOut + " " + o.icon, callback: function(t2, e2) {
            var n2 = e2.getView();
            n2.animate({ zoom: +n2.getZoom() - 1, duration: 700, center: t2.coordinate });
          } }];
          function u(t2, e2) {
            if (e2 === void 0 && (e2 = "Assertion failed"), !t2) {
              if (typeof Error != "undefined")
                throw new Error(e2);
              throw e2;
            }
          }
          function d(t2) {
            return /^\d+$/.test(t2);
          }
          function m(t2, e2) {
            return t2.classList ? t2.classList.contains(e2) : g(e2).test(t2.className);
          }
          function f(t2, e2, n2) {
            e2 === void 0 && (e2 = window.document);
            var i2 = Array.prototype.slice, o2 = [];
            if (/^(#?[\w-]+|\.[\w-.]+)$/.test(t2))
              switch (t2[0]) {
                case "#":
                  o2 = [y(t2.substr(1))];
                  break;
                case ".":
                  o2 = i2.call(e2.getElementsByClassName(t2.substr(1).replace(/\./g, " ")));
                  break;
                default:
                  o2 = i2.call(e2.getElementsByTagName(t2));
              }
            else
              o2 = i2.call(e2.querySelectorAll(t2));
            return n2 ? o2 : o2[0];
          }
          function y(t2) {
            return t2 = t2[0] === "#" ? t2.substr(1, t2.length) : t2, document.getElementById(t2);
          }
          function v(t2) {
            var e2 = document.createDocumentFragment(), n2 = document.createElement("div");
            for (n2.innerHTML = t2; n2.firstChild; )
              e2.appendChild(n2.firstChild);
            return e2;
          }
          function g(t2) {
            return new RegExp("(^|\\s+) " + t2 + " (\\s+|$)");
          }
          function b(t2, e2, n2) {
            t2.classList ? t2.classList.add(e2) : t2.className = (t2.className + " " + e2).trim(), n2 && d(n2) && window.setTimeout(function() {
              return C(t2, e2);
            }, n2);
          }
          function C(t2, e2, n2) {
            t2.classList ? t2.classList.remove(e2) : t2.className = t2.className.replace(g(e2), " ").trim(), n2 && d(n2) && window.setTimeout(function() {
              return b(t2, e2);
            }, n2);
          }
          var E = function(t2) {
            return this.Base = t2, this.map = void 0, this.viewport = void 0, this.coordinateClicked = void 0, this.pixelClicked = void 0, this.lineHeight = 0, this.items = {}, this.opened = false, this.submenu = { left: t2.options.width - 15 + "px", lastLeft: "" }, this.eventHandler = this.handleEvent.bind(this), this.eventMapMoveHandler = this.handleMapMoveEvent.bind(this), this;
          };
          E.prototype.init = function(t2) {
            this.map = t2, this.viewport = t2.getViewport(), this.setListeners(), this.Base.Html.createMenu(), this.lineHeight = this.getItemsLength() > 0 ? this.Base.container.offsetHeight / this.getItemsLength() : this.Base.Html.cloneAndGetLineHeight();
          }, E.prototype.getItemsLength = function() {
            var t2 = this, e2 = 0;
            return Object.keys(this.items).forEach(function(n2) {
              t2.items[n2].submenu || t2.items[n2].separator || e2++;
            }), e2;
          }, E.prototype.getPixelClicked = function() {
            return this.pixelClicked;
          }, E.prototype.getCoordinateClicked = function() {
            return this.coordinateClicked;
          }, E.prototype.positionContainer = function(t2) {
            var e2 = this, n2 = this.Base.container, i2 = this.map.getSize(), o2 = i2[1] - t2[1], a2 = i2[0] - t2[0], r2 = n2.offsetWidth, l2 = Math.round(this.lineHeight * this.getItemsLength()), c2 = f("li." + s.submenu + ">div", n2, true);
            a2 >= r2 ? (n2.style.right = "auto", n2.style.left = t2[0] + 5 + "px") : (n2.style.left = "auto", n2.style.right = "15px"), o2 >= l2 ? (n2.style.bottom = "auto", n2.style.top = t2[1] - 10 + "px") : (n2.style.top = "auto", n2.style.bottom = 0), function t3(e3, n3, i3) {
              if (Array.isArray(e3))
                e3.forEach(function(e4) {
                  return t3(e4, n3, i3);
                });
              else
                for (var o3 = Array.isArray(n3) ? n3 : n3.split(/\s+/), s2 = o3.length; s2--; )
                  m(e3, o3[s2]) && C(e3, o3[s2], i3);
            }(n2, s.hidden), c2.length && (this.submenu.lastLeft = a2 < 2 * r2 ? "-" + r2 + "px" : this.submenu.left, c2.forEach(function(t3) {
              var n3, i3, s2, a3 = { w: window.innerWidth || document.documentElement.clientWidth, h: window.innerHeight || document.documentElement.clientHeight }, r3 = (i3 = (n3 = t3).getBoundingClientRect(), s2 = document.documentElement, { left: i3.left + window.pageXOffset - s2.clientLeft, top: i3.top + window.pageYOffset - s2.clientTop, width: n3.offsetWidth, height: n3.offsetHeight }), l3 = r3.height, c3 = o2 - l3;
              c3 < 0 && (c3 = l3 - (a3.h - r3.top), t3.style.top = "-" + c3 + "px"), t3.style.left = e2.submenu.lastLeft;
            }));
          }, E.prototype.openMenu = function(t2, e2) {
            this.Base.dispatchEvent({ type: r, pixel: t2, coordinate: e2 }), this.opened = true, this.positionContainer(t2);
          }, E.prototype.closeMenu = function() {
            this.opened = false, function t2(e2, n2, i2) {
              if (Array.isArray(e2))
                e2.forEach(function(e3) {
                  return t2(e3, n2);
                });
              else
                for (var o2 = Array.isArray(n2) ? n2 : n2.split(/\s+/), s2 = o2.length; s2--; )
                  m(e2, o2[s2]) || b(e2, o2[s2], i2);
            }(this.Base.container, s.hidden), this.Base.dispatchEvent({ type: l });
          }, E.prototype.setListeners = function() {
            this.viewport.addEventListener(this.Base.options.eventType, this.eventHandler, false), this.map.on("movestart", this.eventMapMoveHandler);
          }, E.prototype.removeListeners = function() {
            this.viewport.removeEventListener(this.Base.options.eventType, this.eventHandler, false), this.map.un("movestart", this.eventMapMoveHandler);
          }, E.prototype.handleEvent = function(t2) {
            var e2 = this;
            this.coordinateClicked = this.map.getEventCoordinate(t2), this.pixelClicked = this.map.getEventPixel(t2), this.Base.dispatchEvent({ type: a, pixel: this.pixelClicked, coordinate: this.coordinateClicked }), this.Base.disabled || (this.Base.options.eventType === c && (t2.stopPropagation(), t2.preventDefault()), this.openMenu(this.pixelClicked, this.coordinateClicked), t2.target.addEventListener("pointerdown", { handleEvent: function(n2) {
              e2.opened && (e2.closeMenu(), n2.stopPropagation(), t2.target.removeEventListener(n2.type, this, false));
            } }, false));
          }, E.prototype.handleMapMoveEvent = function(t2) {
            this.closeMenu();
          }, E.prototype.setItemListener = function(t2, e2) {
            var n2, i2 = this;
            t2 && typeof this.items[e2].callback == "function" && (n2 = this.items[e2].callback, t2.addEventListener("click", function(t3) {
              t3.preventDefault();
              var o2 = { coordinate: i2.getCoordinateClicked(), data: i2.items[e2].data || null };
              i2.closeMenu(), n2(o2, i2.map);
            }, false));
          };
          var w = function(t2) {
            return this.Base = t2, this.Base.container = this.container = this.createContainer(true), this;
          };
          return w.prototype.createContainer = function(t2) {
            var e2 = document.createElement("div"), n2 = document.createElement("ul"), i2 = [s.container, s.unselectable];
            return t2 && i2.push(s.hidden), e2.className = i2.join(" "), e2.style.width = parseInt(this.Base.options.width, 10) + "px", e2.appendChild(n2), e2;
          }, w.prototype.createMenu = function() {
            var t2 = [];
            if ("items" in this.Base.options ? t2 = this.Base.options.defaultItems ? this.Base.options.items.concat(p) : this.Base.options.items : this.Base.options.defaultItems && (t2 = p), t2.length === 0)
              return false;
            t2.forEach(this.addMenuEntry, this);
          }, w.prototype.addMenuEntry = function(t2) {
            var e2, n2 = this;
            if (t2.items && Array.isArray(t2.items)) {
              t2.classname = t2.classname || "", e2 = s.submenu, ~t2.classname.indexOf(e2) || (t2.classname = t2.classname.length ? " " + s.submenu : s.submenu);
              var i2 = this.generateHtmlAndPublish(this.container, t2), o2 = this.createContainer();
              o2.style.left = this.Base.Internal.submenu.lastLeft || this.Base.Internal.submenu.left, i2.appendChild(o2), t2.items.forEach(function(t3) {
                n2.generateHtmlAndPublish(o2, t3, true);
              });
            } else
              this.generateHtmlAndPublish(this.container, t2);
          }, w.prototype.generateHtmlAndPublish = function(t2, e2, n2) {
            var i2, o2, a2 = "_" + Math.random().toString(36).substr(2, 9), r2 = false;
            return typeof e2 == "string" && e2.trim() === "-" ? (i2 = v('<li id="' + a2 + '" class="' + s.separator + '"><hr></li>'), o2 = [].slice.call(i2.childNodes, 0)[0], t2.firstChild.appendChild(i2), r2 = true) : (e2.classname = e2.classname || "", i2 = v("<span>" + e2.text + "</span>"), o2 = document.createElement("li"), e2.icon && (e2.classname === "" ? e2.classname = s.icon : e2.classname.indexOf(s.icon) === -1 && (e2.classname += " " + s.icon), o2.setAttribute("style", "background-image:url(" + e2.icon + ")")), o2.id = a2, o2.className = e2.classname, o2.appendChild(i2), t2.firstChild.appendChild(o2)), this.Base.Internal.items[a2] = { id: a2, submenu: n2 || 0, separator: r2, callback: e2.callback, data: e2.data || null }, this.Base.Internal.setItemListener(o2, a2), o2;
          }, w.prototype.removeMenuEntry = function(t2) {
            var e2 = f("#" + t2, this.container.firstChild);
            e2 && this.container.firstChild.removeChild(e2), delete this.Base.Internal.items[t2];
          }, w.prototype.cloneAndGetLineHeight = function() {
            var t2 = this.container.cloneNode(), e2 = v("<span>Foo</span>"), n2 = v("<span>Foo</span>"), i2 = document.createElement("li"), o2 = document.createElement("li");
            i2.appendChild(e2), o2.appendChild(n2), t2.appendChild(i2), t2.appendChild(o2), this.container.parentNode.appendChild(t2);
            var s2 = t2.offsetHeight / 2;
            return this.container.parentNode.removeChild(t2), s2;
          }, function(t2) {
            function e2(e3) {
              e3 === void 0 && (e3 = {}), u(typeof e3 == "object", "@param `opt_options` should be object type!"), this.options = function(t3, e4) {
                var n2 = {};
                for (var i2 in t3)
                  n2[i2] = t3[i2];
                for (var o2 in e4)
                  n2[o2] = e4[o2];
                return n2;
              }(h, e3), this.disabled = false, this.Internal = new E(this), this.Html = new w(this), t2.call(this, { element: this.container });
            }
            return t2 && (e2.__proto__ = t2), e2.prototype = Object.create(t2 && t2.prototype), e2.prototype.constructor = e2, e2.prototype.clear = function() {
              Object.keys(this.Internal.items).forEach(this.Html.removeMenuEntry, this.Html);
            }, e2.prototype.close = function() {
              this.Internal.closeMenu();
            }, e2.prototype.enable = function() {
              this.disabled = false;
            }, e2.prototype.disable = function() {
              this.disabled = true;
            }, e2.prototype.getDefaultItems = function() {
              return p;
            }, e2.prototype.countItems = function() {
              return Object.keys(this.Internal.items).length;
            }, e2.prototype.extend = function(t3) {
              u(Array.isArray(t3), "@param `arr` should be an Array."), t3.forEach(this.push, this);
            }, e2.prototype.isOpen = function() {
              return this.Internal.opened;
            }, e2.prototype.updatePosition = function(t3) {
              u(Array.isArray(t3), "@param `pixel` should be an Array."), this.isOpen() && this.Internal.positionContainer(t3);
            }, e2.prototype.pop = function() {
              var t3 = Object.keys(this.Internal.items);
              this.Html.removeMenuEntry(t3[t3.length - 1]);
            }, e2.prototype.push = function(t3) {
              u(t3 != null, "@param `item` must be informed."), this.Html.addMenuEntry(t3);
            }, e2.prototype.shift = function() {
              this.Html.removeMenuEntry(Object.keys(this.Internal.items)[0]);
            }, e2.prototype.setMap = function(e3) {
              t2.prototype.setMap.call(this, e3), e3 ? this.Internal.init(e3, this) : this.Internal.removeListeners();
            }, e2;
          }(n.default);
        });
      },
      "65f0": function(module2, exports2, __webpack_require__) {
        var arraySpeciesConstructor = __webpack_require__("0b42");
        module2.exports = function(originalArray, length) {
          return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
        };
      },
      "68ee": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var fails = __webpack_require__("d039");
        var isCallable = __webpack_require__("1626");
        var classof = __webpack_require__("f5df");
        var getBuiltIn = __webpack_require__("d066");
        var inspectSource = __webpack_require__("8925");
        var noop = function() {
        };
        var empty = [];
        var construct = getBuiltIn("Reflect", "construct");
        var constructorRegExp = /^\s*(?:class|function)\b/;
        var exec = uncurryThis(constructorRegExp.exec);
        var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
        var isConstructorModern = function isConstructor(argument) {
          if (!isCallable(argument))
            return false;
          try {
            construct(noop, empty, argument);
            return true;
          } catch (error) {
            return false;
          }
        };
        var isConstructorLegacy = function isConstructor(argument) {
          if (!isCallable(argument))
            return false;
          switch (classof(argument)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
          } catch (error) {
            return true;
          }
        };
        isConstructorLegacy.sham = true;
        module2.exports = !construct || fails(function() {
          var called;
          return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
            called = true;
          }) || called;
        }) ? isConstructorLegacy : isConstructorModern;
      },
      "69f3": function(module2, exports2, __webpack_require__) {
        var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
        var global = __webpack_require__("da84");
        var uncurryThis = __webpack_require__("e330");
        var isObject2 = __webpack_require__("861d");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var hasOwn = __webpack_require__("1a2d");
        var shared = __webpack_require__("c6cd");
        var sharedKey = __webpack_require__("f772");
        var hiddenKeys = __webpack_require__("d012");
        var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
        var TypeError2 = global.TypeError;
        var WeakMap2 = global.WeakMap;
        var set, get, has;
        var enforce = function(it) {
          return has(it) ? get(it) : set(it, {});
        };
        var getterFor = function(TYPE) {
          return function(it) {
            var state;
            if (!isObject2(it) || (state = get(it)).type !== TYPE) {
              throw TypeError2("Incompatible receiver, " + TYPE + " required");
            }
            return state;
          };
        };
        if (NATIVE_WEAK_MAP || shared.state) {
          var store = shared.state || (shared.state = new WeakMap2());
          var wmget = uncurryThis(store.get);
          var wmhas = uncurryThis(store.has);
          var wmset = uncurryThis(store.set);
          set = function(it, metadata) {
            if (wmhas(store, it))
              throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it;
            wmset(store, it, metadata);
            return metadata;
          };
          get = function(it) {
            return wmget(store, it) || {};
          };
          has = function(it) {
            return wmhas(store, it);
          };
        } else {
          var STATE = sharedKey("state");
          hiddenKeys[STATE] = true;
          set = function(it, metadata) {
            if (hasOwn(it, STATE))
              throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
            metadata.facade = it;
            createNonEnumerableProperty(it, STATE, metadata);
            return metadata;
          };
          get = function(it) {
            return hasOwn(it, STATE) ? it[STATE] : {};
          };
          has = function(it) {
            return hasOwn(it, STATE);
          };
        }
        module2.exports = {
          set,
          get,
          has,
          enforce,
          getterFor
        };
      },
      "6b0d": function(module2, exports2, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.default = (sfc, props) => {
          const target = sfc.__vccOpts || sfc;
          for (const [key, val] of props) {
            target[key] = val;
          }
          return target;
        };
      },
      "6eeb": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isCallable = __webpack_require__("1626");
        var hasOwn = __webpack_require__("1a2d");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var setGlobal = __webpack_require__("ce4e");
        var inspectSource = __webpack_require__("8925");
        var InternalStateModule = __webpack_require__("69f3");
        var CONFIGURABLE_FUNCTION_NAME = __webpack_require__("5e77").CONFIGURABLE;
        var getInternalState = InternalStateModule.get;
        var enforceInternalState = InternalStateModule.enforce;
        var TEMPLATE = String(String).split("String");
        (module2.exports = function(O, key, value, options) {
          var unsafe = options ? !!options.unsafe : false;
          var simple = options ? !!options.enumerable : false;
          var noTargetGet = options ? !!options.noTargetGet : false;
          var name = options && options.name !== void 0 ? options.name : key;
          var state;
          if (isCallable(value)) {
            if (String(name).slice(0, 7) === "Symbol(") {
              name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
            }
            if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
              createNonEnumerableProperty(value, "name", name);
            }
            state = enforceInternalState(value);
            if (!state.source) {
              state.source = TEMPLATE.join(typeof name == "string" ? name : "");
            }
          }
          if (O === global) {
            if (simple)
              O[key] = value;
            else
              setGlobal(key, value);
            return;
          } else if (!unsafe) {
            delete O[key];
          } else if (!noTargetGet && O[key]) {
            simple = true;
          }
          if (simple)
            O[key] = value;
          else
            createNonEnumerableProperty(O, key, value);
        })(Function.prototype, "toString", function toString() {
          return isCallable(this) && getInternalState(this).source || inspectSource(this);
        });
      },
      "6f53": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var uncurryThis = __webpack_require__("e330");
        var objectKeys = __webpack_require__("df75");
        var toIndexedObject = __webpack_require__("fc6a");
        var $propertyIsEnumerable = __webpack_require__("d1e7").f;
        var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
        var push = uncurryThis([].push);
        var createMethod = function(TO_ENTRIES) {
          return function(it) {
            var O = toIndexedObject(it);
            var keys = objectKeys(O);
            var length = keys.length;
            var i = 0;
            var result = [];
            var key;
            while (length > i) {
              key = keys[i++];
              if (!DESCRIPTORS || propertyIsEnumerable(O, key)) {
                push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
              }
            }
            return result;
          };
        };
        module2.exports = {
          entries: createMethod(true),
          values: createMethod(false)
        };
      },
      "7037": function(module2, exports2, __webpack_require__) {
        __webpack_require__("a4d3");
        __webpack_require__("e01a");
        __webpack_require__("d3b7");
        __webpack_require__("d28b");
        __webpack_require__("e260");
        __webpack_require__("3ca3");
        __webpack_require__("ddb0");
        function _typeof(obj) {
          "@babel/helpers - typeof";
          return module2.exports = _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
            return typeof obj2;
          } : function(obj2) {
            return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof(obj);
        }
        module2.exports = _typeof, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      },
      "7156": function(module2, exports2, __webpack_require__) {
        var isCallable = __webpack_require__("1626");
        var isObject2 = __webpack_require__("861d");
        var setPrototypeOf = __webpack_require__("d2bb");
        module2.exports = function($this, dummy, Wrapper) {
          var NewTarget, NewTargetPrototype;
          if (setPrototypeOf && isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)
            setPrototypeOf($this, NewTargetPrototype);
          return $this;
        };
      },
      "72ba": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", function() {
          return zlibSync;
        });
        __webpack_require__.d(__webpack_exports__, "a", function() {
          return unzlibSync;
        });
        var ch2 = {};
        var wk = function(c, id, msg, transfer, cb) {
          var u = ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: "text/javascript" })));
          var w = new Worker(u);
          w.onerror = function(e) {
            return cb(e.error, null);
          };
          w.onmessage = function(e) {
            return cb(null, e.data);
          };
          w.postMessage(msg, transfer);
          return w;
        };
        var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
        var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
        var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
        var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        var freb = function(eb, start) {
          var b = new u16(31);
          for (var i2 = 0; i2 < 31; ++i2) {
            b[i2] = start += 1 << eb[i2 - 1];
          }
          var r = new u32(b[30]);
          for (var i2 = 1; i2 < 30; ++i2) {
            for (var j = b[i2]; j < b[i2 + 1]; ++j) {
              r[j] = j - b[i2] << 5 | i2;
            }
          }
          return [b, r];
        };
        var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
        fl[28] = 258, revfl[258] = 28;
        var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
        var rev = new u16(32768);
        for (var i = 0; i < 32768; ++i) {
          var x = (i & 43690) >>> 1 | (i & 21845) << 1;
          x = (x & 52428) >>> 2 | (x & 13107) << 2;
          x = (x & 61680) >>> 4 | (x & 3855) << 4;
          rev[i] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1;
        }
        var hMap = function(cd, mb, r) {
          var s = cd.length;
          var i2 = 0;
          var l = new u16(mb);
          for (; i2 < s; ++i2)
            ++l[cd[i2] - 1];
          var le = new u16(mb);
          for (i2 = 0; i2 < mb; ++i2) {
            le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
          }
          var co;
          if (r) {
            co = new u16(1 << mb);
            var rvb = 15 - mb;
            for (i2 = 0; i2 < s; ++i2) {
              if (cd[i2]) {
                var sv = i2 << 4 | cd[i2];
                var r_1 = mb - cd[i2];
                var v = le[cd[i2] - 1]++ << r_1;
                for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
                  co[rev[v] >>> rvb] = sv;
                }
              }
            }
          } else {
            co = new u16(s);
            for (i2 = 0; i2 < s; ++i2)
              co[i2] = rev[le[cd[i2] - 1]++] >>> 15 - cd[i2];
          }
          return co;
        };
        var flt = new u8(288);
        for (var i = 0; i < 144; ++i)
          flt[i] = 8;
        for (var i = 144; i < 256; ++i)
          flt[i] = 9;
        for (var i = 256; i < 280; ++i)
          flt[i] = 7;
        for (var i = 280; i < 288; ++i)
          flt[i] = 8;
        var fdt = new u8(32);
        for (var i = 0; i < 32; ++i)
          fdt[i] = 5;
        var flm = hMap(flt, 9, 0), flrm = hMap(flt, 9, 1);
        var fdm = hMap(fdt, 5, 0), fdrm = hMap(fdt, 5, 1);
        var max = function(a) {
          var m = a[0];
          for (var i2 = 1; i2 < a.length; ++i2) {
            if (a[i2] > m)
              m = a[i2];
          }
          return m;
        };
        var bits = function(d, p, m) {
          var o = p / 8 >> 0;
          return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;
        };
        var bits16 = function(d, p) {
          var o = p / 8 >> 0;
          return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);
        };
        var shft = function(p) {
          return (p / 8 >> 0) + (p & 7 && 1);
        };
        var slc = function(v, s, e) {
          if (s == null || s < 0)
            s = 0;
          if (e == null || e > v.length)
            e = v.length;
          var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
          n.set(v.subarray(s, e));
          return n;
        };
        var inflt = function(dat, buf, st) {
          var sl = dat.length;
          var noBuf = !buf || st;
          var noSt = !st || st.i;
          if (!st)
            st = {};
          if (!buf)
            buf = new u8(sl * 3);
          var cbuf = function(l2) {
            var bl = buf.length;
            if (l2 > bl) {
              var nbuf = new u8(Math.max(bl * 2, l2));
              nbuf.set(buf);
              buf = nbuf;
            }
          };
          var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
          var tbts = sl * 8;
          do {
            if (!lm) {
              st.f = final = bits(dat, pos, 1);
              var type = bits(dat, pos + 1, 3);
              pos += 3;
              if (!type) {
                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
                if (t > sl) {
                  if (noSt)
                    throw "unexpected EOF";
                  break;
                }
                if (noBuf)
                  cbuf(bt + l);
                buf.set(dat.subarray(s, t), bt);
                st.b = bt += l, st.p = pos = t * 8;
                continue;
              } else if (type == 1)
                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
              else if (type == 2) {
                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                var tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14;
                var ldt = new u8(tl);
                var clt = new u8(19);
                for (var i2 = 0; i2 < hcLen; ++i2) {
                  clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
                }
                pos += hcLen * 3;
                var clb = max(clt), clbmsk = (1 << clb) - 1;
                if (!noSt && pos + tl * (clb + 7) > tbts)
                  break;
                var clm = hMap(clt, clb, 1);
                for (var i2 = 0; i2 < tl; ) {
                  var r = clm[bits(dat, pos, clbmsk)];
                  pos += r & 15;
                  var s = r >>> 4;
                  if (s < 16) {
                    ldt[i2++] = s;
                  } else {
                    var c = 0, n = 0;
                    if (s == 16)
                      n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
                    else if (s == 17)
                      n = 3 + bits(dat, pos, 7), pos += 3;
                    else if (s == 18)
                      n = 11 + bits(dat, pos, 127), pos += 7;
                    while (n--)
                      ldt[i2++] = c;
                  }
                }
                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                lbt = max(lt);
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
              } else
                throw "invalid block type";
              if (pos > tbts)
                throw "unexpected EOF";
            }
            if (noBuf)
              cbuf(bt + 131072);
            var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
            var mxa = lbt + dbt + 18;
            while (noSt || pos + mxa < tbts) {
              var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
              pos += c & 15;
              if (pos > tbts)
                throw "unexpected EOF";
              if (!c)
                throw "invalid length/literal";
              if (sym < 256)
                buf[bt++] = sym;
              else if (sym == 256) {
                lm = null;
                break;
              } else {
                var add = sym - 254;
                if (sym > 264) {
                  var i2 = sym - 257, b = fleb[i2];
                  add = bits(dat, pos, (1 << b) - 1) + fl[i2];
                  pos += b;
                }
                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                if (!d)
                  throw "invalid distance";
                pos += d & 15;
                var dt = fd[dsym];
                if (dsym > 3) {
                  var b = fdeb[dsym];
                  dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
                }
                if (pos > tbts)
                  throw "unexpected EOF";
                if (noBuf)
                  cbuf(bt + 131072);
                var end = bt + add;
                for (; bt < end; bt += 4) {
                  buf[bt] = buf[bt - dt];
                  buf[bt + 1] = buf[bt + 1 - dt];
                  buf[bt + 2] = buf[bt + 2 - dt];
                  buf[bt + 3] = buf[bt + 3 - dt];
                }
                bt = end;
              }
            }
            st.l = lm, st.p = pos, st.b = bt;
            if (lm)
              final = 1, st.m = lbt, st.d = dm, st.n = dbt;
          } while (!final);
          return bt == buf.length ? buf : slc(buf, 0, bt);
        };
        var wbits = function(d, p, v) {
          v <<= p & 7;
          var o = p / 8 >> 0;
          d[o] |= v;
          d[o + 1] |= v >>> 8;
        };
        var wbits16 = function(d, p, v) {
          v <<= p & 7;
          var o = p / 8 >> 0;
          d[o] |= v;
          d[o + 1] |= v >>> 8;
          d[o + 2] |= v >>> 16;
        };
        var hTree = function(d, mb) {
          var t = [];
          for (var i2 = 0; i2 < d.length; ++i2) {
            if (d[i2])
              t.push({ s: i2, f: d[i2] });
          }
          var s = t.length;
          var t2 = t.slice();
          if (!s)
            return [new u8(0), 0];
          if (s == 1) {
            var v = new u8(t[0].s + 1);
            v[t[0].s] = 1;
            return [v, 1];
          }
          t.sort(function(a, b) {
            return a.f - b.f;
          });
          t.push({ s: -1, f: 25001 });
          var l = t[0], r = t[1], i0 = 0, i1 = 1, i22 = 2;
          t[0] = { s: -1, f: l.f + r.f, l, r };
          while (i1 != s - 1) {
            l = t[t[i0].f < t[i22].f ? i0++ : i22++];
            r = t[i0 != i1 && t[i0].f < t[i22].f ? i0++ : i22++];
            t[i1++] = { s: -1, f: l.f + r.f, l, r };
          }
          var maxSym = t2[0].s;
          for (var i2 = 1; i2 < s; ++i2) {
            if (t2[i2].s > maxSym)
              maxSym = t2[i2].s;
          }
          var tr = new u16(maxSym + 1);
          var mbt = ln(t[i1 - 1], tr, 0);
          if (mbt > mb) {
            var i2 = 0, dt = 0;
            var lft = mbt - mb, cst = 1 << lft;
            t2.sort(function(a, b) {
              return tr[b.s] - tr[a.s] || a.f - b.f;
            });
            for (; i2 < s; ++i2) {
              var i2_1 = t2[i2].s;
              if (tr[i2_1] > mb) {
                dt += cst - (1 << mbt - tr[i2_1]);
                tr[i2_1] = mb;
              } else
                break;
            }
            dt >>>= lft;
            while (dt > 0) {
              var i2_2 = t2[i2].s;
              if (tr[i2_2] < mb)
                dt -= 1 << mb - tr[i2_2]++ - 1;
              else
                ++i2;
            }
            for (; i2 >= 0 && dt; --i2) {
              var i2_3 = t2[i2].s;
              if (tr[i2_3] == mb) {
                --tr[i2_3];
                ++dt;
              }
            }
            mbt = mb;
          }
          return [new u8(tr), mbt];
        };
        var ln = function(n, l, d) {
          return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
        };
        var lc = function(c) {
          var s = c.length;
          while (s && !c[--s])
            ;
          var cl = new u16(++s);
          var cli = 0, cln = c[0], cls = 1;
          var w = function(v) {
            cl[cli++] = v;
          };
          for (var i2 = 1; i2 <= s; ++i2) {
            if (c[i2] == cln && i2 != s)
              ++cls;
            else {
              if (!cln && cls > 2) {
                for (; cls > 138; cls -= 138)
                  w(32754);
                if (cls > 2) {
                  w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
                  cls = 0;
                }
              } else if (cls > 3) {
                w(cln), --cls;
                for (; cls > 6; cls -= 6)
                  w(8304);
                if (cls > 2)
                  w(cls - 3 << 5 | 8208), cls = 0;
              }
              while (cls--)
                w(cln);
              cls = 1;
              cln = c[i2];
            }
          }
          return [cl.subarray(0, cli), s];
        };
        var clen = function(cf, cl) {
          var l = 0;
          for (var i2 = 0; i2 < cl.length; ++i2)
            l += cf[i2] * cl[i2];
          return l;
        };
        var wfblk = function(out, pos, dat) {
          var s = dat.length;
          var o = shft(pos + 2);
          out[o] = s & 255;
          out[o + 1] = s >>> 8;
          out[o + 2] = out[o] ^ 255;
          out[o + 3] = out[o + 1] ^ 255;
          for (var i2 = 0; i2 < s; ++i2)
            out[o + i2 + 4] = dat[i2];
          return (o + 4 + s) * 8;
        };
        var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
          wbits(out, p++, final);
          ++lf[256];
          var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
          var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
          var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
          var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
          var lcfreq = new u16(19);
          for (var i2 = 0; i2 < lclt.length; ++i2)
            lcfreq[lclt[i2] & 31]++;
          for (var i2 = 0; i2 < lcdt.length; ++i2)
            lcfreq[lcdt[i2] & 31]++;
          var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
          var nlcc = 19;
          for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
            ;
          var flen = bl + 5 << 3;
          var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
          var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
          if (flen <= ftlen && flen <= dtlen)
            return wfblk(out, p, dat.subarray(bs, bs + bl));
          var lm, ll, dm, dl;
          wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
          if (dtlen < ftlen) {
            lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
            var llm = hMap(lct, mlcb, 0);
            wbits(out, p, nlc - 257);
            wbits(out, p + 5, ndc - 1);
            wbits(out, p + 10, nlcc - 4);
            p += 14;
            for (var i2 = 0; i2 < nlcc; ++i2)
              wbits(out, p + 3 * i2, lct[clim[i2]]);
            p += 3 * nlcc;
            var lcts = [lclt, lcdt];
            for (var it = 0; it < 2; ++it) {
              var clct = lcts[it];
              for (var i2 = 0; i2 < clct.length; ++i2) {
                var len = clct[i2] & 31;
                wbits(out, p, llm[len]), p += lct[len];
                if (len > 15)
                  wbits(out, p, clct[i2] >>> 5 & 127), p += clct[i2] >>> 12;
              }
            }
          } else {
            lm = flm, ll = flt, dm = fdm, dl = fdt;
          }
          for (var i2 = 0; i2 < li; ++i2) {
            if (syms[i2] > 255) {
              var len = syms[i2] >>> 18 & 31;
              wbits16(out, p, lm[len + 257]), p += ll[len + 257];
              if (len > 7)
                wbits(out, p, syms[i2] >>> 23 & 31), p += fleb[len];
              var dst = syms[i2] & 31;
              wbits16(out, p, dm[dst]), p += dl[dst];
              if (dst > 3)
                wbits16(out, p, syms[i2] >>> 5 & 8191), p += fdeb[dst];
            } else {
              wbits16(out, p, lm[syms[i2]]), p += ll[syms[i2]];
            }
          }
          wbits16(out, p, lm[256]);
          return p + ll[256];
        };
        var deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
        var et = new u8(0);
        var dflt = function(dat, lvl, plvl, pre, post, lst) {
          var s = dat.length;
          var o = new u8(pre + s + 5 * (1 + Math.floor(s / 7e3)) + post);
          var w = o.subarray(pre, o.length - post);
          var pos = 0;
          if (!lvl || s < 8) {
            for (var i2 = 0; i2 <= s; i2 += 65535) {
              var e = i2 + 65535;
              if (e < s) {
                pos = wfblk(w, pos, dat.subarray(i2, e));
              } else {
                w[i2] = lst;
                pos = wfblk(w, pos, dat.subarray(i2, s));
              }
            }
          } else {
            var opt = deo[lvl - 1];
            var n = opt >>> 13, c = opt & 8191;
            var msk_1 = (1 << plvl) - 1;
            var prev = new u16(32768), head = new u16(msk_1 + 1);
            var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
            var hsh = function(i3) {
              return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
            };
            var syms = new u32(25e3);
            var lf = new u16(288), df = new u16(32);
            var lc_1 = 0, eb = 0, i2 = 0, li = 0, wi = 0, bs = 0;
            for (; i2 < s; ++i2) {
              var hv = hsh(i2);
              var imod = i2 & 32767;
              var pimod = head[hv];
              prev[imod] = pimod;
              head[hv] = imod;
              if (wi <= i2) {
                var rem = s - i2;
                if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
                  pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
                  li = lc_1 = eb = 0, bs = i2;
                  for (var j = 0; j < 286; ++j)
                    lf[j] = 0;
                  for (var j = 0; j < 30; ++j)
                    df[j] = 0;
                }
                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
                if (rem > 2 && hv == hsh(i2 - dif)) {
                  var maxn = Math.min(n, rem) - 1;
                  var maxd = Math.min(32767, i2);
                  var ml = Math.min(258, rem);
                  while (dif <= maxd && --ch_1 && imod != pimod) {
                    if (dat[i2 + l] == dat[i2 + l - dif]) {
                      var nl = 0;
                      for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                        ;
                      if (nl > l) {
                        l = nl, d = dif;
                        if (nl > maxn)
                          break;
                        var mmd = Math.min(dif, nl - 2);
                        var md = 0;
                        for (var j = 0; j < mmd; ++j) {
                          var ti = i2 - dif + j + 32768 & 32767;
                          var pti = prev[ti];
                          var cd = ti - pti + 32768 & 32767;
                          if (cd > md)
                            md = cd, pimod = ti;
                        }
                      }
                    }
                    imod = pimod, pimod = prev[imod];
                    dif += imod - pimod + 32768 & 32767;
                  }
                }
                if (d) {
                  syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
                  var lin = revfl[l] & 31, din = revfd[d] & 31;
                  eb += fleb[lin] + fdeb[din];
                  ++lf[257 + lin];
                  ++df[din];
                  wi = i2 + l;
                  ++lc_1;
                } else {
                  syms[li++] = dat[i2];
                  ++lf[dat[i2]];
                }
              }
            }
            pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
            if (!lst)
              pos = wfblk(w, pos, et);
          }
          return slc(o, 0, pre + shft(pos) + post);
        };
        var crct = function() {
          var t = new u32(256);
          for (var i2 = 0; i2 < 256; ++i2) {
            var c = i2, k = 9;
            while (--k)
              c = (c & 1 && 3988292384) ^ c >>> 1;
            t[i2] = c;
          }
          return t;
        }();
        var crc = function() {
          var c = 4294967295;
          return {
            p: function(d) {
              var cr = c;
              for (var i2 = 0; i2 < d.length; ++i2)
                cr = crct[cr & 255 ^ d[i2]] ^ cr >>> 8;
              c = cr;
            },
            d: function() {
              return c ^ 4294967295;
            }
          };
        };
        var adler = function() {
          var a = 1, b = 0;
          return {
            p: function(d) {
              var n = a, m = b;
              var l = d.length;
              for (var i2 = 0; i2 != l; ) {
                var e = Math.min(i2 + 5552, l);
                for (; i2 < e; ++i2)
                  n += d[i2], m += n;
                n %= 65521, m %= 65521;
              }
              a = n, b = m;
            },
            d: function() {
              return (a >>> 8 << 16 | (b & 255) << 8 | b >>> 8) + ((a & 255) << 23) * 2;
            }
          };
        };
        ;
        var dopt = function(dat, opt, pre, post, st) {
          return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);
        };
        var mrg = function(a, b) {
          var o = {};
          for (var k in a)
            o[k] = a[k];
          for (var k in b)
            o[k] = b[k];
          return o;
        };
        var wcln = function(fn, fnStr, td) {
          var dt = fn();
          var st = fn.toString();
          var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/ /g, "").split(",");
          for (var i2 = 0; i2 < dt.length; ++i2) {
            var v = dt[i2], k = ks[i2];
            if (typeof v == "function") {
              fnStr += ";" + k + "=";
              var st_1 = v.toString();
              if (v.prototype) {
                if (st_1.indexOf("[native code]") != -1) {
                  var spInd = st_1.indexOf(" ", 8) + 1;
                  fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
                } else {
                  fnStr += st_1;
                  for (var t in v.prototype)
                    fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
                }
              } else
                fnStr += st_1;
            } else
              td[k] = v;
          }
          return [fnStr, td];
        };
        var ch = [];
        var cbfs = function(v) {
          var tl = [];
          for (var k in v) {
            if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)
              tl.push((v[k] = new v[k].constructor(v[k])).buffer);
          }
          return tl;
        };
        var wrkr = function(fns, init, id, cb) {
          var _a2;
          if (!ch[id]) {
            var fnStr = "", td_1 = {}, m = fns.length - 1;
            for (var i2 = 0; i2 < m; ++i2)
              _a2 = wcln(fns[i2], fnStr, td_1), fnStr = _a2[0], td_1 = _a2[1];
            ch[id] = wcln(fns[m], fnStr, td_1);
          }
          var td = mrg({}, ch[id][1]);
          return wk(ch[id][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td, cbfs(td), cb);
        };
        var bInflt = function() {
          return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8];
        };
        var bDflt = function() {
          return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
        };
        var gze = function() {
          return [gzh, gzhl, wbytes, crc, crct];
        };
        var guze = function() {
          return [gzs, gzl];
        };
        var zle = function() {
          return [zlh, wbytes, adler];
        };
        var zule = function() {
          return [zlv];
        };
        var pbf = function(msg) {
          return postMessage(msg, [msg.buffer]);
        };
        var gu8 = function(o) {
          return o && o.size && new u8(o.size);
        };
        var cbify = function(dat, opts, fns, init, id, cb) {
          var w = wrkr(fns, init, id, function(err, dat2) {
            w.terminate();
            cb(err, dat2);
          });
          if (!opts.consume)
            dat = new u8(dat);
          w.postMessage([dat, opts], [dat.buffer]);
          return function() {
            w.terminate();
          };
        };
        var astrm = function(strm) {
          strm.ondata = function(dat, final) {
            return postMessage([dat, final], [dat.buffer]);
          };
          return function(ev) {
            return strm.push(ev.data[0], ev.data[1]);
          };
        };
        var astrmify = function(fns, strm, opts, init, id) {
          var t;
          var w = wrkr(fns, init, id, function(err, dat) {
            if (err)
              w.terminate(), strm.ondata.call(strm, err);
            else {
              if (dat[1])
                w.terminate();
              strm.ondata.call(strm, err, dat[0], dat[1]);
            }
          });
          w.postMessage(opts);
          strm.push = function(d, f) {
            if (t)
              throw "stream finished";
            if (!strm.ondata)
              throw "no stream handler";
            w.postMessage([d, t = f], [d.buffer]);
          };
          strm.terminate = function() {
            w.terminate();
          };
        };
        var b2 = function(d, b) {
          return d[b] | d[b + 1] << 8;
        };
        var b4 = function(d, b) {
          return (d[b] | d[b + 1] << 8 | d[b + 2] << 16) + (d[b + 3] << 23) * 2;
        };
        var wbytes = function(d, b, v) {
          for (; v; ++b)
            d[b] = v, v >>>= 8;
        };
        var gzh = function(c, o) {
          var fn = o.filename;
          c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
          if (o.mtime != 0)
            wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
          if (fn) {
            c[3] = 8;
            for (var i2 = 0; i2 <= fn.length; ++i2)
              c[i2 + 10] = fn.charCodeAt(i2);
          }
        };
        var gzs = function(d) {
          if (d[0] != 31 || d[1] != 139 || d[2] != 8)
            throw "invalid gzip data";
          var flg = d[3];
          var st = 10;
          if (flg & 4)
            st += d[10] | (d[11] << 8) + 2;
          for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
            ;
          return st + (flg & 2);
        };
        var gzl = function(d) {
          var l = d.length;
          return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) + 2 * (d[l - 1] << 23);
        };
        var gzhl = function(o) {
          return 10 + (o.filename && o.filename.length + 1 || 0);
        };
        var zlh = function(c, o) {
          var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
          c[0] = 120, c[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
        };
        var zlv = function(d) {
          if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
            throw "invalid zlib data";
          if (d[1] & 32)
            throw "invalid zlib data: preset dictionaries not supported";
        };
        function AsyncCmpStrm(opts, cb) {
          if (!cb && typeof opts == "function")
            cb = opts, opts = {};
          this.ondata = cb;
          return opts;
        }
        var Deflate = function() {
          function Deflate2(opts, cb) {
            if (!cb && typeof opts == "function")
              cb = opts, opts = {};
            this.ondata = cb;
            this.o = opts || {};
          }
          Deflate2.prototype.p = function(c, f) {
            this.ondata(dopt(c, this.o, 0, 0, !f), f);
          };
          Deflate2.prototype.push = function(chunk, final) {
            if (this.d)
              throw "stream finished";
            if (!this.ondata)
              throw "no stream handler";
            this.d = final;
            this.p(chunk, final || false);
          };
          return Deflate2;
        }();
        var AsyncDeflate = function() {
          function AsyncDeflate2(opts, cb) {
            astrmify([
              bDflt,
              function() {
                return [astrm, Deflate];
              }
            ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
              var strm = new Deflate(ev.data);
              onmessage = astrm(strm);
            }, 6);
          }
          return AsyncDeflate2;
        }();
        function deflate(data, opts, cb) {
          if (!cb)
            cb = opts, opts = {};
          if (typeof cb != "function")
            throw "no callback";
          return cbify(data, opts, [
            bDflt
          ], function(ev) {
            return pbf(deflateSync(ev.data[0], ev.data[1]));
          }, 0, cb);
        }
        function deflateSync(data, opts) {
          if (opts === void 0) {
            opts = {};
          }
          return dopt(data, opts, 0, 0);
        }
        var Inflate = function() {
          function Inflate2(cb) {
            this.s = {};
            this.p = new u8(0);
            this.ondata = cb;
          }
          Inflate2.prototype.e = function(c) {
            if (this.d)
              throw "stream finished";
            if (!this.ondata)
              throw "no stream handler";
            var l = this.p.length;
            var n = new u8(l + c.length);
            n.set(this.p), n.set(c, l), this.p = n;
          };
          Inflate2.prototype.c = function(final) {
            this.d = this.s.i = final || false;
            var bts = this.s.b;
            var dt = inflt(this.p, this.o, this.s);
            this.ondata(slc(dt, bts, this.s.b), this.d);
            this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
            this.p = slc(this.p, this.s.p / 8 >> 0), this.s.p &= 7;
          };
          Inflate2.prototype.push = function(chunk, final) {
            this.e(chunk), this.c(final);
          };
          return Inflate2;
        }();
        var AsyncInflate = function() {
          function AsyncInflate2(cb) {
            this.ondata = cb;
            astrmify([
              bInflt,
              function() {
                return [astrm, Inflate];
              }
            ], this, 0, function() {
              var strm = new Inflate();
              onmessage = astrm(strm);
            }, 7);
          }
          return AsyncInflate2;
        }();
        function inflate(data, opts, cb) {
          if (!cb)
            cb = opts, opts = {};
          if (typeof cb != "function")
            throw "no callback";
          return cbify(data, opts, [
            bInflt
          ], function(ev) {
            return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));
          }, 1, cb);
        }
        function inflateSync(data, out) {
          return inflt(data, out);
        }
        var Gzip = function() {
          function Gzip2(opts, cb) {
            this.c = crc();
            this.l = 0;
            this.v = 1;
            Deflate.call(this, opts, cb);
          }
          Gzip2.prototype.push = function(chunk, final) {
            Deflate.prototype.push.call(this, chunk, final);
          };
          Gzip2.prototype.p = function(c, f) {
            this.c.p(c);
            this.l += c.length;
            var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);
            if (this.v)
              gzh(raw, this.o), this.v = 0;
            if (f)
              wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
            this.ondata(raw, f);
          };
          return Gzip2;
        }();
        var AsyncGzip = function() {
          function AsyncGzip2(opts, cb) {
            astrmify([
              bDflt,
              gze,
              function() {
                return [astrm, Deflate, Gzip];
              }
            ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
              var strm = new Gzip(ev.data);
              onmessage = astrm(strm);
            }, 8);
          }
          return AsyncGzip2;
        }();
        function gzip(data, opts, cb) {
          if (!cb)
            cb = opts, opts = {};
          if (typeof cb != "function")
            throw "no callback";
          return cbify(data, opts, [
            bDflt,
            gze,
            function() {
              return [gzipSync];
            }
          ], function(ev) {
            return pbf(gzipSync(ev.data[0], ev.data[1]));
          }, 2, cb);
        }
        function gzipSync(data, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var c = crc(), l = data.length;
          c.p(data);
          var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
          return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
        }
        var Gunzip = function() {
          function Gunzip2(cb) {
            this.v = 1;
            Inflate.call(this, cb);
          }
          Gunzip2.prototype.push = function(chunk, final) {
            Inflate.prototype.e.call(this, chunk);
            if (this.v) {
              var s = gzs(this.p);
              if (s >= this.p.length && !final)
                return;
              this.p = this.p.subarray(s), this.v = 0;
            }
            if (final) {
              if (this.p.length < 8)
                throw "invalid gzip stream";
              this.p = this.p.subarray(0, -8);
            }
            Inflate.prototype.c.call(this, final);
          };
          return Gunzip2;
        }();
        var AsyncGunzip = function() {
          function AsyncGunzip2(cb) {
            this.ondata = cb;
            astrmify([
              bInflt,
              guze,
              function() {
                return [astrm, Inflate, Gunzip];
              }
            ], this, 0, function() {
              var strm = new Gunzip();
              onmessage = astrm(strm);
            }, 9);
          }
          return AsyncGunzip2;
        }();
        function gunzip(data, opts, cb) {
          if (!cb)
            cb = opts, opts = {};
          if (typeof cb != "function")
            throw "no callback";
          return cbify(data, opts, [
            bInflt,
            guze,
            function() {
              return [gunzipSync];
            }
          ], function(ev) {
            return pbf(gunzipSync(ev.data[0]));
          }, 3, cb);
        }
        function gunzipSync(data, out) {
          return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));
        }
        var Zlib = function() {
          function Zlib2(opts, cb) {
            this.c = adler();
            this.v = 1;
            Deflate.call(this, opts, cb);
          }
          Zlib2.prototype.push = function(chunk, final) {
            Deflate.prototype.push.call(this, chunk, final);
          };
          Zlib2.prototype.p = function(c, f) {
            this.c.p(c);
            var raw = dopt(c, this.o, this.v && 2, f && 4, !f);
            if (this.v)
              zlh(raw, this.o), this.v = 0;
            if (f)
              wbytes(raw, raw.length - 4, this.c.d());
            this.ondata(raw, f);
          };
          return Zlib2;
        }();
        var AsyncZlib = function() {
          function AsyncZlib2(opts, cb) {
            astrmify([
              bDflt,
              zle,
              function() {
                return [astrm, Deflate, Zlib];
              }
            ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
              var strm = new Zlib(ev.data);
              onmessage = astrm(strm);
            }, 10);
          }
          return AsyncZlib2;
        }();
        function zlib(data, opts, cb) {
          if (!cb)
            cb = opts, opts = {};
          if (typeof cb != "function")
            throw "no callback";
          return cbify(data, opts, [
            bDflt,
            zle,
            function() {
              return [zlibSync];
            }
          ], function(ev) {
            return pbf(zlibSync(ev.data[0], ev.data[1]));
          }, 4, cb);
        }
        function zlibSync(data, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var a = adler();
          a.p(data);
          var d = dopt(data, opts, 2, 4);
          return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
        }
        var Unzlib = function() {
          function Unzlib2(cb) {
            this.v = 1;
            Inflate.call(this, cb);
          }
          Unzlib2.prototype.push = function(chunk, final) {
            Inflate.prototype.e.call(this, chunk);
            if (this.v) {
              if (this.p.length < 2 && !final)
                return;
              this.p = this.p.subarray(2), this.v = 0;
            }
            if (final) {
              if (this.p.length < 4)
                throw "invalid zlib stream";
              this.p = this.p.subarray(0, -4);
            }
            Inflate.prototype.c.call(this, final);
          };
          return Unzlib2;
        }();
        var AsyncUnzlib = function() {
          function AsyncUnzlib2(cb) {
            this.ondata = cb;
            astrmify([
              bInflt,
              zule,
              function() {
                return [astrm, Inflate, Unzlib];
              }
            ], this, 0, function() {
              var strm = new Unzlib();
              onmessage = astrm(strm);
            }, 11);
          }
          return AsyncUnzlib2;
        }();
        function unzlib(data, opts, cb) {
          if (!cb)
            cb = opts, opts = {};
          if (typeof cb != "function")
            throw "no callback";
          return cbify(data, opts, [
            bInflt,
            zule,
            function() {
              return [unzlibSync];
            }
          ], function(ev) {
            return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));
          }, 5, cb);
        }
        function unzlibSync(data, out) {
          return inflt((zlv(data), data.subarray(2, -4)), out);
        }
        var Decompress = function() {
          function Decompress2(cb) {
            this.G = Gunzip;
            this.I = Inflate;
            this.Z = Unzlib;
            this.ondata = cb;
          }
          Decompress2.prototype.push = function(chunk, final) {
            if (!this.ondata)
              throw "no stream handler";
            if (!this.s) {
              if (this.p && this.p.length) {
                var n = new u8(this.p.length + chunk.length);
                n.set(this.p), n.set(chunk, this.p.length);
              } else
                this.p = chunk;
              if (this.p.length > 2) {
                var _this_1 = this;
                var cb = function() {
                  _this_1.ondata.apply(_this_1, arguments);
                };
                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);
                this.s.push(this.p, final);
                this.p = null;
              }
            } else
              this.s.push(chunk, final);
          };
          return Decompress2;
        }();
        var AsyncDecompress = function() {
          function AsyncDecompress2(cb) {
            this.G = AsyncGunzip;
            this.I = AsyncInflate;
            this.Z = AsyncUnzlib;
            this.ondata = cb;
          }
          AsyncDecompress2.prototype.push = function(chunk, final) {
            Decompress.prototype.push.call(this, chunk, final);
          };
          return AsyncDecompress2;
        }();
        function decompress(data, opts, cb) {
          if (!cb)
            cb = opts, opts = {};
          if (typeof cb != "function")
            throw "no callback";
          return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);
        }
        function decompressSync(data, out) {
          return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);
        }
        var fltn = function(d, p, t, o) {
          for (var k in d) {
            var val = d[k], n = p + k;
            if (val instanceof u8)
              t[n] = [val, o];
            else if (Array.isArray(val))
              t[n] = [val[0], mrg(o, val[1])];
            else
              fltn(val, n + "/", t, o);
          }
        };
        function strToU8(str, latin1) {
          var l = str.length;
          if (!latin1 && typeof TextEncoder != "undefined")
            return new TextEncoder().encode(str);
          var ar = new u8(str.length + (str.length >>> 1));
          var ai = 0;
          var w = function(v) {
            ar[ai++] = v;
          };
          for (var i2 = 0; i2 < l; ++i2) {
            if (ai + 5 > ar.length) {
              var n = new u8(ai + 8 + (l - i2 << 1));
              n.set(ar);
              ar = n;
            }
            var c = str.charCodeAt(i2);
            if (c < 128 || latin1)
              w(c);
            else if (c < 2048)
              w(192 | c >>> 6), w(128 | c & 63);
            else if (c > 55295 && c < 57344)
              c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i2) & 1023, w(240 | c >>> 18), w(128 | c >>> 12 & 63), w(128 | c >>> 6 & 63), w(128 | c & 63);
            else
              w(224 | c >>> 12), w(128 | c >>> 6 & 63), w(128 | c & 63);
          }
          return slc(ar, 0, ai);
        }
        function strFromU8(dat, latin1) {
          var r = "";
          if (!latin1 && typeof TextDecoder != "undefined")
            return new TextDecoder().decode(dat);
          for (var i2 = 0; i2 < dat.length; ) {
            var c = dat[i2++];
            if (c < 128 || latin1)
              r += String.fromCharCode(c);
            else if (c < 224)
              r += String.fromCharCode((c & 31) << 6 | dat[i2++] & 63);
            else if (c < 240)
              r += String.fromCharCode((c & 15) << 12 | (dat[i2++] & 63) << 6 | dat[i2++] & 63);
            else
              c = ((c & 15) << 18 | (dat[i2++] & 63) << 12 | (dat[i2++] & 63) << 6 | dat[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
          }
          return r;
        }
        ;
        var slzh = function(d, b) {
          return b + 30 + b2(d, b + 26) + b2(d, b + 28);
        };
        var zh = function(d, b, z) {
          var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl;
          var _a2 = z ? z64e(d, es) : [b4(d, b + 20), b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
          return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
        };
        var z64e = function(d, b) {
          for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
            ;
          return [b4(d, b + 12), b4(d, b + 4), b4(d, b + 20)];
        };
        var wzh = function(d, b, c, cmp, su, fn, u, o, ce, t) {
          var fl2 = fn.length, l = cmp.length;
          wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
          if (ce != null)
            d[b] = 20, b += 2;
          d[b] = 20, b += 2;
          d[b++] = t == 8 && (o.level == 1 ? 6 : o.level < 6 ? 4 : o.level == 9 ? 2 : 0), d[b++] = u && 8;
          d[b] = t, b += 2;
          var dt = new Date(o.mtime || Date.now()), y = dt.getFullYear() - 1980;
          if (y < 0 || y > 119)
            throw "date not in range 1980-2099";
          wbytes(d, b, (y << 24) * 2 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1);
          b += 4;
          wbytes(d, b, c);
          wbytes(d, b + 4, l);
          wbytes(d, b + 8, su);
          wbytes(d, b + 12, fl2), b += 16;
          if (ce != null)
            wbytes(d, b += 10, ce), b += 4;
          d.set(fn, b);
          b += fl2;
          if (ce == null)
            d.set(cmp, b);
        };
        var wzf = function(o, b, c, d, e) {
          wbytes(o, b, 101010256);
          wbytes(o, b + 8, c);
          wbytes(o, b + 10, c);
          wbytes(o, b + 12, d);
          wbytes(o, b + 16, e);
        };
        function zip(data, opts, cb) {
          if (!cb)
            cb = opts, opts = {};
          if (typeof cb != "function")
            throw "no callback";
          var r = {};
          fltn(data, "", r, opts);
          var k = Object.keys(r);
          var lft = k.length, o = 0, tot = 0;
          var slft = lft, files = new Array(lft);
          var term = [];
          var tAll = function() {
            for (var i3 = 0; i3 < term.length; ++i3)
              term[i3]();
          };
          var cbf = function() {
            var out = new u8(tot + 22), oe = o, cdl = tot - o;
            tot = 0;
            for (var i3 = 0; i3 < slft; ++i3) {
              var f = files[i3];
              try {
                wzh(out, tot, f.c, f.d, f.m, f.n, f.u, f.p, null, f.t);
                wzh(out, o, f.c, f.d, f.m, f.n, f.u, f.p, tot, f.t), o += 46 + f.n.length, tot += 30 + f.n.length + f.d.length;
              } catch (e) {
                return cb(e, null);
              }
            }
            wzf(out, o, files.length, cdl, oe);
            cb(null, out);
          };
          if (!lft)
            cbf();
          var _loop_1 = function(i3) {
            var fn = k[i3];
            var _a2 = r[fn], file = _a2[0], p = _a2[1];
            var c = crc(), m = file.length;
            c.p(file);
            var n = strToU8(fn), s = n.length;
            var t = p.level == 0 ? 0 : 8;
            var cbl = function(e, d) {
              if (e) {
                tAll();
                cb(e, null);
              } else {
                var l = d.length;
                files[i3] = {
                  t,
                  d,
                  m,
                  c: c.d(),
                  u: fn.length != l,
                  n,
                  p
                };
                o += 30 + s + l;
                tot += 76 + 2 * s + l;
                if (!--lft)
                  cbf();
              }
            };
            if (n.length > 65535)
              cbl("filename too long", null);
            if (!t)
              cbl(null, file);
            else if (m < 16e4) {
              try {
                cbl(null, deflateSync(file, p));
              } catch (e) {
                cbl(e, null);
              }
            } else
              term.push(deflate(file, p, cbl));
          };
          for (var i2 = 0; i2 < slft; ++i2) {
            _loop_1(i2);
          }
          return tAll;
        }
        function zipSync(data, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var r = {};
          var files = [];
          fltn(data, "", r, opts);
          var o = 0;
          var tot = 0;
          for (var fn in r) {
            var _a2 = r[fn], file = _a2[0], p = _a2[1];
            var t = p.level == 0 ? 0 : 8;
            var n = strToU8(fn), s = n.length;
            if (n.length > 65535)
              throw "filename too long";
            var d = t ? deflateSync(file, p) : file, l = d.length;
            var c = crc();
            c.p(file);
            files.push({
              t,
              d,
              m: file.length,
              c: c.d(),
              u: fn.length != s,
              n,
              o,
              p
            });
            o += 30 + s + l;
            tot += 76 + 2 * s + l;
          }
          var out = new u8(tot + 22), oe = o, cdl = tot - o;
          for (var i2 = 0; i2 < files.length; ++i2) {
            var f = files[i2];
            wzh(out, f.o, f.c, f.d, f.m, f.n, f.u, f.p, null, f.t);
            wzh(out, o, f.c, f.d, f.m, f.n, f.u, f.p, f.o, f.t), o += 46 + f.n.length;
          }
          wzf(out, o, files.length, cdl, oe);
          return out;
        }
        function unzip(data, cb) {
          if (typeof cb != "function")
            throw "no callback";
          var term = [];
          var tAll = function() {
            for (var i3 = 0; i3 < term.length; ++i3)
              term[i3]();
          };
          var files = {};
          var e = data.length - 22;
          for (; b4(data, e) != 101010256; --e) {
            if (!e || data.length - e > 65558) {
              cb("invalid zip file", null);
              return;
            }
          }
          ;
          var lft = b2(data, e + 8);
          if (!lft)
            cb(null, {});
          var c = lft;
          var o = b4(data, e + 16);
          var z = o == 4294967295;
          if (z) {
            e = b4(data, e - 12);
            if (b4(data, e) != 101075792)
              throw "invalid zip file";
            c = lft = b4(data, e + 32);
            o = b4(data, e + 48);
          }
          var _loop_2 = function(i3) {
            var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
            o = no;
            var cbl = function(e2, d) {
              if (e2) {
                tAll();
                cb(e2, null);
              } else {
                files[fn] = d;
                if (!--lft)
                  cb(null, files);
              }
            };
            if (!c_1)
              cbl(null, slc(data, b, b + sc));
            else if (c_1 == 8) {
              var infl = data.subarray(b, b + sc);
              if (sc < 32e4) {
                try {
                  cbl(null, inflateSync(infl, new u8(su)));
                } catch (e2) {
                  cbl(e2, null);
                }
              } else
                term.push(inflate(infl, { size: su }, cbl));
            } else
              cbl("unknown compression type " + c_1, null);
          };
          for (var i2 = 0; i2 < c; ++i2) {
            _loop_2(i2);
          }
          return tAll;
        }
        function unzipSync(data) {
          var files = {};
          var e = data.length - 22;
          for (; b4(data, e) != 101010256; --e) {
            if (!e || data.length - e > 65558)
              throw "invalid zip file";
          }
          ;
          var c = b2(data, e + 8);
          if (!c)
            return {};
          var o = b4(data, e + 16);
          var z = o == 4294967295;
          if (z) {
            e = b4(data, e - 12);
            if (b4(data, e) != 101075792)
              throw "invalid zip file";
            c = b4(data, e + 32);
            o = b4(data, e + 48);
          }
          for (var i2 = 0; i2 < c; ++i2) {
            var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
            o = no;
            if (!c_2)
              files[fn] = slc(data, b, b + sc);
            else if (c_2 == 8)
              files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));
            else
              throw "unknown compression type " + c_2;
          }
          return files;
        }
      },
      "7418": function(module2, exports2) {
        exports2.f = Object.getOwnPropertySymbols;
      },
      "746f": function(module2, exports2, __webpack_require__) {
        var path = __webpack_require__("428f");
        var hasOwn = __webpack_require__("1a2d");
        var wrappedWellKnownSymbolModule = __webpack_require__("e538");
        var defineProperty = __webpack_require__("9bf2").f;
        module2.exports = function(NAME) {
          var Symbol2 = path.Symbol || (path.Symbol = {});
          if (!hasOwn(Symbol2, NAME))
            defineProperty(Symbol2, NAME, {
              value: wrappedWellKnownSymbolModule.f(NAME)
            });
        };
      },
      "7839": function(module2, exports2) {
        module2.exports = [
          "constructor",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "toLocaleString",
          "toString",
          "valueOf"
        ];
      },
      "785a": function(module2, exports2, __webpack_require__) {
        var documentCreateElement = __webpack_require__("cc12");
        var classList = documentCreateElement("span").classList;
        var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
        module2.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
      },
      "7915": function(module2, exports2, __webpack_require__) {
        "use strict";
        module2.exports = Pbf;
        var ieee754 = __webpack_require__("9152");
        function Pbf(buf) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
          this.pos = 0;
          this.type = 0;
          this.length = this.buf.length;
        }
        Pbf.Varint = 0;
        Pbf.Fixed64 = 1;
        Pbf.Bytes = 2;
        Pbf.Fixed32 = 5;
        var SHIFT_LEFT_32 = (1 << 16) * (1 << 16), SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
        var TEXT_DECODER_MIN_LENGTH = 12;
        var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
        Pbf.prototype = {
          destroy: function() {
            this.buf = null;
          },
          readFields: function(readField, result, end) {
            end = end || this.length;
            while (this.pos < end) {
              var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
              this.type = val & 7;
              readField(tag, result, this);
              if (this.pos === startPos)
                this.skip(val);
            }
            return result;
          },
          readMessage: function(readField, result) {
            return this.readFields(readField, result, this.readVarint() + this.pos);
          },
          readFixed32: function() {
            var val = readUInt32(this.buf, this.pos);
            this.pos += 4;
            return val;
          },
          readSFixed32: function() {
            var val = readInt32(this.buf, this.pos);
            this.pos += 4;
            return val;
          },
          readFixed64: function() {
            var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
            this.pos += 8;
            return val;
          },
          readSFixed64: function() {
            var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
            this.pos += 8;
            return val;
          },
          readFloat: function() {
            var val = ieee754.read(this.buf, this.pos, true, 23, 4);
            this.pos += 4;
            return val;
          },
          readDouble: function() {
            var val = ieee754.read(this.buf, this.pos, true, 52, 8);
            this.pos += 8;
            return val;
          },
          readVarint: function(isSigned) {
            var buf = this.buf, val, b;
            b = buf[this.pos++];
            val = b & 127;
            if (b < 128)
              return val;
            b = buf[this.pos++];
            val |= (b & 127) << 7;
            if (b < 128)
              return val;
            b = buf[this.pos++];
            val |= (b & 127) << 14;
            if (b < 128)
              return val;
            b = buf[this.pos++];
            val |= (b & 127) << 21;
            if (b < 128)
              return val;
            b = buf[this.pos];
            val |= (b & 15) << 28;
            return readVarintRemainder(val, isSigned, this);
          },
          readVarint64: function() {
            return this.readVarint(true);
          },
          readSVarint: function() {
            var num = this.readVarint();
            return num % 2 === 1 ? (num + 1) / -2 : num / 2;
          },
          readBoolean: function() {
            return Boolean(this.readVarint());
          },
          readString: function() {
            var end = this.readVarint() + this.pos;
            var pos = this.pos;
            this.pos = end;
            if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
              return readUtf8TextDecoder(this.buf, pos, end);
            }
            return readUtf8(this.buf, pos, end);
          },
          readBytes: function() {
            var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
            this.pos = end;
            return buffer;
          },
          readPackedVarint: function(arr, isSigned) {
            if (this.type !== Pbf.Bytes)
              return arr.push(this.readVarint(isSigned));
            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end)
              arr.push(this.readVarint(isSigned));
            return arr;
          },
          readPackedSVarint: function(arr) {
            if (this.type !== Pbf.Bytes)
              return arr.push(this.readSVarint());
            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end)
              arr.push(this.readSVarint());
            return arr;
          },
          readPackedBoolean: function(arr) {
            if (this.type !== Pbf.Bytes)
              return arr.push(this.readBoolean());
            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end)
              arr.push(this.readBoolean());
            return arr;
          },
          readPackedFloat: function(arr) {
            if (this.type !== Pbf.Bytes)
              return arr.push(this.readFloat());
            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end)
              arr.push(this.readFloat());
            return arr;
          },
          readPackedDouble: function(arr) {
            if (this.type !== Pbf.Bytes)
              return arr.push(this.readDouble());
            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end)
              arr.push(this.readDouble());
            return arr;
          },
          readPackedFixed32: function(arr) {
            if (this.type !== Pbf.Bytes)
              return arr.push(this.readFixed32());
            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end)
              arr.push(this.readFixed32());
            return arr;
          },
          readPackedSFixed32: function(arr) {
            if (this.type !== Pbf.Bytes)
              return arr.push(this.readSFixed32());
            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end)
              arr.push(this.readSFixed32());
            return arr;
          },
          readPackedFixed64: function(arr) {
            if (this.type !== Pbf.Bytes)
              return arr.push(this.readFixed64());
            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end)
              arr.push(this.readFixed64());
            return arr;
          },
          readPackedSFixed64: function(arr) {
            if (this.type !== Pbf.Bytes)
              return arr.push(this.readSFixed64());
            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end)
              arr.push(this.readSFixed64());
            return arr;
          },
          skip: function(val) {
            var type = val & 7;
            if (type === Pbf.Varint)
              while (this.buf[this.pos++] > 127) {
              }
            else if (type === Pbf.Bytes)
              this.pos = this.readVarint() + this.pos;
            else if (type === Pbf.Fixed32)
              this.pos += 4;
            else if (type === Pbf.Fixed64)
              this.pos += 8;
            else
              throw new Error("Unimplemented type: " + type);
          },
          writeTag: function(tag, type) {
            this.writeVarint(tag << 3 | type);
          },
          realloc: function(min) {
            var length = this.length || 16;
            while (length < this.pos + min)
              length *= 2;
            if (length !== this.length) {
              var buf = new Uint8Array(length);
              buf.set(this.buf);
              this.buf = buf;
              this.length = length;
            }
          },
          finish: function() {
            this.length = this.pos;
            this.pos = 0;
            return this.buf.subarray(0, this.length);
          },
          writeFixed32: function(val) {
            this.realloc(4);
            writeInt32(this.buf, val, this.pos);
            this.pos += 4;
          },
          writeSFixed32: function(val) {
            this.realloc(4);
            writeInt32(this.buf, val, this.pos);
            this.pos += 4;
          },
          writeFixed64: function(val) {
            this.realloc(8);
            writeInt32(this.buf, val & -1, this.pos);
            writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
            this.pos += 8;
          },
          writeSFixed64: function(val) {
            this.realloc(8);
            writeInt32(this.buf, val & -1, this.pos);
            writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
            this.pos += 8;
          },
          writeVarint: function(val) {
            val = +val || 0;
            if (val > 268435455 || val < 0) {
              writeBigVarint(val, this);
              return;
            }
            this.realloc(4);
            this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
            if (val <= 127)
              return;
            this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
            if (val <= 127)
              return;
            this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
            if (val <= 127)
              return;
            this.buf[this.pos++] = val >>> 7 & 127;
          },
          writeSVarint: function(val) {
            this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
          },
          writeBoolean: function(val) {
            this.writeVarint(Boolean(val));
          },
          writeString: function(str) {
            str = String(str);
            this.realloc(str.length * 4);
            this.pos++;
            var startPos = this.pos;
            this.pos = writeUtf8(this.buf, str, this.pos);
            var len = this.pos - startPos;
            if (len >= 128)
              makeRoomForExtraLength(startPos, len, this);
            this.pos = startPos - 1;
            this.writeVarint(len);
            this.pos += len;
          },
          writeFloat: function(val) {
            this.realloc(4);
            ieee754.write(this.buf, val, this.pos, true, 23, 4);
            this.pos += 4;
          },
          writeDouble: function(val) {
            this.realloc(8);
            ieee754.write(this.buf, val, this.pos, true, 52, 8);
            this.pos += 8;
          },
          writeBytes: function(buffer) {
            var len = buffer.length;
            this.writeVarint(len);
            this.realloc(len);
            for (var i = 0; i < len; i++)
              this.buf[this.pos++] = buffer[i];
          },
          writeRawMessage: function(fn, obj) {
            this.pos++;
            var startPos = this.pos;
            fn(obj, this);
            var len = this.pos - startPos;
            if (len >= 128)
              makeRoomForExtraLength(startPos, len, this);
            this.pos = startPos - 1;
            this.writeVarint(len);
            this.pos += len;
          },
          writeMessage: function(tag, fn, obj) {
            this.writeTag(tag, Pbf.Bytes);
            this.writeRawMessage(fn, obj);
          },
          writePackedVarint: function(tag, arr) {
            if (arr.length)
              this.writeMessage(tag, writePackedVarint, arr);
          },
          writePackedSVarint: function(tag, arr) {
            if (arr.length)
              this.writeMessage(tag, writePackedSVarint, arr);
          },
          writePackedBoolean: function(tag, arr) {
            if (arr.length)
              this.writeMessage(tag, writePackedBoolean, arr);
          },
          writePackedFloat: function(tag, arr) {
            if (arr.length)
              this.writeMessage(tag, writePackedFloat, arr);
          },
          writePackedDouble: function(tag, arr) {
            if (arr.length)
              this.writeMessage(tag, writePackedDouble, arr);
          },
          writePackedFixed32: function(tag, arr) {
            if (arr.length)
              this.writeMessage(tag, writePackedFixed32, arr);
          },
          writePackedSFixed32: function(tag, arr) {
            if (arr.length)
              this.writeMessage(tag, writePackedSFixed32, arr);
          },
          writePackedFixed64: function(tag, arr) {
            if (arr.length)
              this.writeMessage(tag, writePackedFixed64, arr);
          },
          writePackedSFixed64: function(tag, arr) {
            if (arr.length)
              this.writeMessage(tag, writePackedSFixed64, arr);
          },
          writeBytesField: function(tag, buffer) {
            this.writeTag(tag, Pbf.Bytes);
            this.writeBytes(buffer);
          },
          writeFixed32Field: function(tag, val) {
            this.writeTag(tag, Pbf.Fixed32);
            this.writeFixed32(val);
          },
          writeSFixed32Field: function(tag, val) {
            this.writeTag(tag, Pbf.Fixed32);
            this.writeSFixed32(val);
          },
          writeFixed64Field: function(tag, val) {
            this.writeTag(tag, Pbf.Fixed64);
            this.writeFixed64(val);
          },
          writeSFixed64Field: function(tag, val) {
            this.writeTag(tag, Pbf.Fixed64);
            this.writeSFixed64(val);
          },
          writeVarintField: function(tag, val) {
            this.writeTag(tag, Pbf.Varint);
            this.writeVarint(val);
          },
          writeSVarintField: function(tag, val) {
            this.writeTag(tag, Pbf.Varint);
            this.writeSVarint(val);
          },
          writeStringField: function(tag, str) {
            this.writeTag(tag, Pbf.Bytes);
            this.writeString(str);
          },
          writeFloatField: function(tag, val) {
            this.writeTag(tag, Pbf.Fixed32);
            this.writeFloat(val);
          },
          writeDoubleField: function(tag, val) {
            this.writeTag(tag, Pbf.Fixed64);
            this.writeDouble(val);
          },
          writeBooleanField: function(tag, val) {
            this.writeVarintField(tag, Boolean(val));
          }
        };
        function readVarintRemainder(l, s, p) {
          var buf = p.buf, h, b;
          b = buf[p.pos++];
          h = (b & 112) >> 4;
          if (b < 128)
            return toNum(l, h, s);
          b = buf[p.pos++];
          h |= (b & 127) << 3;
          if (b < 128)
            return toNum(l, h, s);
          b = buf[p.pos++];
          h |= (b & 127) << 10;
          if (b < 128)
            return toNum(l, h, s);
          b = buf[p.pos++];
          h |= (b & 127) << 17;
          if (b < 128)
            return toNum(l, h, s);
          b = buf[p.pos++];
          h |= (b & 127) << 24;
          if (b < 128)
            return toNum(l, h, s);
          b = buf[p.pos++];
          h |= (b & 1) << 31;
          if (b < 128)
            return toNum(l, h, s);
          throw new Error("Expected varint not more than 10 bytes");
        }
        function readPackedEnd(pbf) {
          return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
        }
        function toNum(low, high, isSigned) {
          if (isSigned) {
            return high * 4294967296 + (low >>> 0);
          }
          return (high >>> 0) * 4294967296 + (low >>> 0);
        }
        function writeBigVarint(val, pbf) {
          var low, high;
          if (val >= 0) {
            low = val % 4294967296 | 0;
            high = val / 4294967296 | 0;
          } else {
            low = ~(-val % 4294967296);
            high = ~(-val / 4294967296);
            if (low ^ 4294967295) {
              low = low + 1 | 0;
            } else {
              low = 0;
              high = high + 1 | 0;
            }
          }
          if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
            throw new Error("Given varint doesn't fit into 10 bytes");
          }
          pbf.realloc(10);
          writeBigVarintLow(low, high, pbf);
          writeBigVarintHigh(high, pbf);
        }
        function writeBigVarintLow(low, high, pbf) {
          pbf.buf[pbf.pos++] = low & 127 | 128;
          low >>>= 7;
          pbf.buf[pbf.pos++] = low & 127 | 128;
          low >>>= 7;
          pbf.buf[pbf.pos++] = low & 127 | 128;
          low >>>= 7;
          pbf.buf[pbf.pos++] = low & 127 | 128;
          low >>>= 7;
          pbf.buf[pbf.pos] = low & 127;
        }
        function writeBigVarintHigh(high, pbf) {
          var lsb = (high & 7) << 4;
          pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
          if (!high)
            return;
          pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
          if (!high)
            return;
          pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
          if (!high)
            return;
          pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
          if (!high)
            return;
          pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
          if (!high)
            return;
          pbf.buf[pbf.pos++] = high & 127;
        }
        function makeRoomForExtraLength(startPos, len, pbf) {
          var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
          pbf.realloc(extraLen);
          for (var i = pbf.pos - 1; i >= startPos; i--)
            pbf.buf[i + extraLen] = pbf.buf[i];
        }
        function writePackedVarint(arr, pbf) {
          for (var i = 0; i < arr.length; i++)
            pbf.writeVarint(arr[i]);
        }
        function writePackedSVarint(arr, pbf) {
          for (var i = 0; i < arr.length; i++)
            pbf.writeSVarint(arr[i]);
        }
        function writePackedFloat(arr, pbf) {
          for (var i = 0; i < arr.length; i++)
            pbf.writeFloat(arr[i]);
        }
        function writePackedDouble(arr, pbf) {
          for (var i = 0; i < arr.length; i++)
            pbf.writeDouble(arr[i]);
        }
        function writePackedBoolean(arr, pbf) {
          for (var i = 0; i < arr.length; i++)
            pbf.writeBoolean(arr[i]);
        }
        function writePackedFixed32(arr, pbf) {
          for (var i = 0; i < arr.length; i++)
            pbf.writeFixed32(arr[i]);
        }
        function writePackedSFixed32(arr, pbf) {
          for (var i = 0; i < arr.length; i++)
            pbf.writeSFixed32(arr[i]);
        }
        function writePackedFixed64(arr, pbf) {
          for (var i = 0; i < arr.length; i++)
            pbf.writeFixed64(arr[i]);
        }
        function writePackedSFixed64(arr, pbf) {
          for (var i = 0; i < arr.length; i++)
            pbf.writeSFixed64(arr[i]);
        }
        function readUInt32(buf, pos) {
          return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
        }
        function writeInt32(buf, val, pos) {
          buf[pos] = val;
          buf[pos + 1] = val >>> 8;
          buf[pos + 2] = val >>> 16;
          buf[pos + 3] = val >>> 24;
        }
        function readInt32(buf, pos) {
          return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
        }
        function readUtf8(buf, pos, end) {
          var str = "";
          var i = pos;
          while (i < end) {
            var b0 = buf[i];
            var c = null;
            var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
            if (i + bytesPerSequence > end)
              break;
            var b1, b2, b3;
            if (bytesPerSequence === 1) {
              if (b0 < 128) {
                c = b0;
              }
            } else if (bytesPerSequence === 2) {
              b1 = buf[i + 1];
              if ((b1 & 192) === 128) {
                c = (b0 & 31) << 6 | b1 & 63;
                if (c <= 127) {
                  c = null;
                }
              }
            } else if (bytesPerSequence === 3) {
              b1 = buf[i + 1];
              b2 = buf[i + 2];
              if ((b1 & 192) === 128 && (b2 & 192) === 128) {
                c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
                if (c <= 2047 || c >= 55296 && c <= 57343) {
                  c = null;
                }
              }
            } else if (bytesPerSequence === 4) {
              b1 = buf[i + 1];
              b2 = buf[i + 2];
              b3 = buf[i + 3];
              if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
                c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
                if (c <= 65535 || c >= 1114112) {
                  c = null;
                }
              }
            }
            if (c === null) {
              c = 65533;
              bytesPerSequence = 1;
            } else if (c > 65535) {
              c -= 65536;
              str += String.fromCharCode(c >>> 10 & 1023 | 55296);
              c = 56320 | c & 1023;
            }
            str += String.fromCharCode(c);
            i += bytesPerSequence;
          }
          return str;
        }
        function readUtf8TextDecoder(buf, pos, end) {
          return utf8TextDecoder.decode(buf.subarray(pos, end));
        }
        function writeUtf8(buf, str, pos) {
          for (var i = 0, c, lead; i < str.length; i++) {
            c = str.charCodeAt(i);
            if (c > 55295 && c < 57344) {
              if (lead) {
                if (c < 56320) {
                  buf[pos++] = 239;
                  buf[pos++] = 191;
                  buf[pos++] = 189;
                  lead = c;
                  continue;
                } else {
                  c = lead - 55296 << 10 | c - 56320 | 65536;
                  lead = null;
                }
              } else {
                if (c > 56319 || i + 1 === str.length) {
                  buf[pos++] = 239;
                  buf[pos++] = 191;
                  buf[pos++] = 189;
                } else {
                  lead = c;
                }
                continue;
              }
            } else if (lead) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = null;
            }
            if (c < 128) {
              buf[pos++] = c;
            } else {
              if (c < 2048) {
                buf[pos++] = c >> 6 | 192;
              } else {
                if (c < 65536) {
                  buf[pos++] = c >> 12 | 224;
                } else {
                  buf[pos++] = c >> 18 | 240;
                  buf[pos++] = c >> 12 & 63 | 128;
                }
                buf[pos++] = c >> 6 & 63 | 128;
              }
              buf[pos++] = c & 63 | 128;
            }
          }
          return pos;
        }
      },
      "7b0b": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var requireObjectCoercible = __webpack_require__("1d80");
        var Object2 = global.Object;
        module2.exports = function(argument) {
          return Object2(requireObjectCoercible(argument));
        };
      },
      "7b4f": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_exports__["a"] = {
          PROPERTYCHANGE: "propertychange"
        };
      },
      "7c73": function(module2, exports2, __webpack_require__) {
        var anObject = __webpack_require__("825a");
        var definePropertiesModule = __webpack_require__("37e8");
        var enumBugKeys = __webpack_require__("7839");
        var hiddenKeys = __webpack_require__("d012");
        var html = __webpack_require__("1be4");
        var documentCreateElement = __webpack_require__("cc12");
        var sharedKey = __webpack_require__("f772");
        var GT = ">";
        var LT = "<";
        var PROTOTYPE = "prototype";
        var SCRIPT = "script";
        var IE_PROTO = sharedKey("IE_PROTO");
        var EmptyConstructor = function() {
        };
        var scriptTag = function(content) {
          return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
        };
        var NullProtoObjectViaActiveX = function(activeXDocument2) {
          activeXDocument2.write(scriptTag(""));
          activeXDocument2.close();
          var temp = activeXDocument2.parentWindow.Object;
          activeXDocument2 = null;
          return temp;
        };
        var NullProtoObjectViaIFrame = function() {
          var iframe = documentCreateElement("iframe");
          var JS = "java" + SCRIPT + ":";
          var iframeDocument;
          iframe.style.display = "none";
          html.appendChild(iframe);
          iframe.src = String(JS);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(scriptTag("document.F=Object"));
          iframeDocument.close();
          return iframeDocument.F;
        };
        var activeXDocument;
        var NullProtoObject = function() {
          try {
            activeXDocument = new ActiveXObject("htmlfile");
          } catch (error) {
          }
          NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
          var length = enumBugKeys.length;
          while (length--)
            delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
          return NullProtoObject();
        };
        hiddenKeys[IE_PROTO] = true;
        module2.exports = Object.create || function create(O, Properties) {
          var result;
          if (O !== null) {
            EmptyConstructor[PROTOTYPE] = anObject(O);
            result = new EmptyConstructor();
            EmptyConstructor[PROTOTYPE] = null;
            result[IE_PROTO] = O;
          } else
            result = NullProtoObject();
          return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
        };
      },
      "7d05": function(module2, exports2, __webpack_require__) {
      },
      "7dd0": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var call = __webpack_require__("c65b");
        var IS_PURE = __webpack_require__("c430");
        var FunctionName = __webpack_require__("5e77");
        var isCallable = __webpack_require__("1626");
        var createIteratorConstructor = __webpack_require__("9ed3");
        var getPrototypeOf = __webpack_require__("e163");
        var setPrototypeOf = __webpack_require__("d2bb");
        var setToStringTag = __webpack_require__("d44e");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var redefine = __webpack_require__("6eeb");
        var wellKnownSymbol = __webpack_require__("b622");
        var Iterators = __webpack_require__("3f8c");
        var IteratorsCore = __webpack_require__("ae93");
        var PROPER_FUNCTION_NAME = FunctionName.PROPER;
        var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
        var IteratorPrototype = IteratorsCore.IteratorPrototype;
        var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
        var ITERATOR = wellKnownSymbol("iterator");
        var KEYS = "keys";
        var VALUES = "values";
        var ENTRIES = "entries";
        var returnThis = function() {
          return this;
        };
        module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
          createIteratorConstructor(IteratorConstructor, NAME, next);
          var getIterationMethod = function(KIND) {
            if (KIND === DEFAULT && defaultIterator)
              return defaultIterator;
            if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
              return IterablePrototype[KIND];
            switch (KIND) {
              case KEYS:
                return function keys() {
                  return new IteratorConstructor(this, KIND);
                };
              case VALUES:
                return function values() {
                  return new IteratorConstructor(this, KIND);
                };
              case ENTRIES:
                return function entries() {
                  return new IteratorConstructor(this, KIND);
                };
            }
            return function() {
              return new IteratorConstructor(this);
            };
          };
          var TO_STRING_TAG = NAME + " Iterator";
          var INCORRECT_VALUES_NAME = false;
          var IterablePrototype = Iterable.prototype;
          var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
          var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
          var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
          var CurrentIteratorPrototype, methods, KEY;
          if (anyNativeIterator) {
            CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
            if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
              if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf) {
                  setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                  redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
                }
              }
              setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
              if (IS_PURE)
                Iterators[TO_STRING_TAG] = returnThis;
            }
          }
          if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
            if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
              createNonEnumerableProperty(IterablePrototype, "name", VALUES);
            } else {
              INCORRECT_VALUES_NAME = true;
              defaultIterator = function values() {
                return call(nativeIterator, this);
              };
            }
          }
          if (DEFAULT) {
            methods = {
              values: getIterationMethod(VALUES),
              keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
              entries: getIterationMethod(ENTRIES)
            };
            if (FORCED)
              for (KEY in methods) {
                if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                  redefine(IterablePrototype, KEY, methods[KEY]);
                }
              }
            else
              $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
          }
          if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
            redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
          }
          Iterators[NAME] = defaultIterator;
          return methods;
        };
      },
      "7f9a": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isCallable = __webpack_require__("1626");
        var inspectSource = __webpack_require__("8925");
        var WeakMap2 = global.WeakMap;
        module2.exports = isCallable(WeakMap2) && /native code/.test(inspectSource(WeakMap2));
      },
      "7fd1": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        (function(Buffer) {
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return create;
          });
          function create() {
            var source = 'var e="function"==typeof Object.assign?Object.assign:function(e,n){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var t=Object(e),r=1,o=arguments.length;r<o;++r){var i=arguments[r];if(null!=i)for(var f in i)i.hasOwnProperty(f)&&(t[f]=i[f])}return t},n="GENERATE_BUFFERS",t=[],r={vertexPosition:0,indexPosition:0};function o(e,n,t,r,o){e[n+0]=t,e[n+1]=r,e[n+2]=o}function i(e,n,i,f,s,u){var a=3+s,l=e[n+0],v=e[n+1],c=t;c.length=s;for(var g=0;g<c.length;g++)c[g]=e[n+2+g];var b=u?u.vertexPosition:0,h=u?u.indexPosition:0,d=b/a;return o(i,b,l,v,0),c.length&&i.set(c,b+3),o(i,b+=a,l,v,1),c.length&&i.set(c,b+3),o(i,b+=a,l,v,2),c.length&&i.set(c,b+3),o(i,b+=a,l,v,3),c.length&&i.set(c,b+3),b+=a,f[h++]=d,f[h++]=d+1,f[h++]=d+3,f[h++]=d+1,f[h++]=d+2,f[h++]=d+3,r.vertexPosition=b,r.indexPosition=h,r}var f=self;f.onmessage=function(t){var r=t.data;if(r.type===n){for(var o=r.customAttributesCount,s=2+o,u=new Float32Array(r.renderInstructions),a=u.length/s,l=4*a*(o+3),v=new Uint32Array(6*a),c=new Float32Array(l),g=null,b=0;b<u.length;b+=s)g=i(u,b,c,v,o,g);var h=e({vertexBuffer:c.buffer,indexBuffer:v.buffer,renderInstructions:u.buffer},r);f.postMessage(h,[c.buffer,v.buffer,u.buffer])}};';
            return new Worker(typeof Blob === "undefined" ? "data:application/javascript;base64," + Buffer.from(source, "binary").toString("base64") : URL.createObjectURL(new Blob([source], { type: "application/javascript" })));
          }
        }).call(this, __webpack_require__("b639").Buffer);
      },
      "825a": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isObject2 = __webpack_require__("861d");
        var String2 = global.String;
        var TypeError2 = global.TypeError;
        module2.exports = function(argument) {
          if (isObject2(argument))
            return argument;
          throw TypeError2(String2(argument) + " is not an object");
        };
      },
      "83ab": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        module2.exports = !fails(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      },
      "8418": function(module2, exports2, __webpack_require__) {
        "use strict";
        var toPropertyKey = __webpack_require__("a04b");
        var definePropertyModule = __webpack_require__("9bf2");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        module2.exports = function(object, key, value) {
          var propertyKey = toPropertyKey(key);
          if (propertyKey in object)
            definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
          else
            object[propertyKey] = value;
        };
      },
      "861d": function(module2, exports2, __webpack_require__) {
        var isCallable = __webpack_require__("1626");
        module2.exports = function(it) {
          return typeof it == "object" ? it !== null : isCallable(it);
        };
      },
      "872d": function(module2, exports2, __webpack_require__) {
      },
      "8875": function(module2, exports2, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        (function(root, factory) {
          if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
          }
        })(typeof self !== "undefined" ? self : this, function() {
          function getCurrentScript() {
            var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
            if (!descriptor && "currentScript" in document && document.currentScript) {
              return document.currentScript;
            }
            if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
              return document.currentScript;
            }
            try {
              throw new Error();
            } catch (err) {
              var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
              if (scriptLocation === currentLocation) {
                pageSource = document.documentElement.outerHTML;
                inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
                inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
              }
              for (var i = 0; i < scripts.length; i++) {
                if (scripts[i].readyState === "interactive") {
                  return scripts[i];
                }
                if (scripts[i].src === scriptLocation) {
                  return scripts[i];
                }
                if (scriptLocation === currentLocation && scripts[i].innerHTML && scripts[i].innerHTML.trim() === inlineScriptSource) {
                  return scripts[i];
                }
              }
              return null;
            }
          }
          ;
          return getCurrentScript;
        });
      },
      "8925": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var isCallable = __webpack_require__("1626");
        var store = __webpack_require__("c6cd");
        var functionToString = uncurryThis(Function.toString);
        if (!isCallable(store.inspectSource)) {
          store.inspectSource = function(it) {
            return functionToString(it);
          };
        }
        module2.exports = store.inspectSource;
      },
      "8aa5": function(module2, exports2, __webpack_require__) {
        "use strict";
        var charAt = __webpack_require__("6547").charAt;
        module2.exports = function(S, index, unicode) {
          return index + (unicode ? charAt(S, index).length : 1);
        };
      },
      "8baf": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        (function(global) {
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return E;
          });
          var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7037");
          var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
          var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("72ba");
          var n = function() {
            return typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this;
          }();
          function i() {
            n.console && typeof n.console.log == "function" && n.console.log.apply(n.console, arguments);
          }
          var a = { log: i, warn: function(t) {
            n.console && (typeof n.console.warn == "function" ? n.console.warn.apply(n.console, arguments) : i.call(null, arguments));
          }, error: function(t) {
            n.console && (typeof n.console.error == "function" ? n.console.error.apply(n.console, arguments) : i(t));
          } };
          function o(t, e, r) {
            var n2 = new XMLHttpRequest();
            n2.open("GET", t), n2.responseType = "blob", n2.onload = function() {
              l(n2.response, e, r);
            }, n2.onerror = function() {
              a.error("could not download file");
            }, n2.send();
          }
          function s(t) {
            var e = new XMLHttpRequest();
            e.open("HEAD", t, false);
            try {
              e.send();
            } catch (t2) {
            }
            return e.status >= 200 && e.status <= 299;
          }
          function c(t) {
            try {
              t.dispatchEvent(new MouseEvent("click"));
            } catch (r) {
              var e = document.createEvent("MouseEvents");
              e.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t.dispatchEvent(e);
            }
          }
          var u, h, l = n.saveAs || ((typeof window == "undefined" ? "undefined" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(window)) !== "object" || window !== n ? function() {
          } : typeof HTMLAnchorElement != "undefined" && "download" in HTMLAnchorElement.prototype ? function(t, e, r) {
            var i2 = n.URL || n.webkitURL, a2 = document.createElement("a");
            e = e || t.name || "download", a2.download = e, a2.rel = "noopener", typeof t == "string" ? (a2.href = t, a2.origin !== location.origin ? s(a2.href) ? o(t, e, r) : c(a2, a2.target = "_blank") : c(a2)) : (a2.href = i2.createObjectURL(t), setTimeout(function() {
              i2.revokeObjectURL(a2.href);
            }, 4e4), setTimeout(function() {
              c(a2);
            }, 0));
          } : "msSaveOrOpenBlob" in navigator ? function(e, r, n2) {
            if (r = r || e.name || "download", typeof e == "string")
              if (s(e))
                o(e, r, n2);
              else {
                var i2 = document.createElement("a");
                i2.href = e, i2.target = "_blank", setTimeout(function() {
                  c(i2);
                });
              }
            else
              navigator.msSaveOrOpenBlob(function(e2, r2) {
                return r2 === void 0 ? r2 = { autoBom: false } : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(r2) !== "object" && (a.warn("Deprecated: Expected third argument to be a object"), r2 = { autoBom: !r2 }), r2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e2.type) ? new Blob([String.fromCharCode(65279), e2], { type: e2.type }) : e2;
              }(e, n2), r);
          } : function(e, r, i2, a2) {
            if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), typeof e == "string")
              return o(e, r, i2);
            var s2 = e.type === "application/octet-stream", c2 = /constructor/i.test(n.HTMLElement) || n.safari, u2 = /CriOS\/[\d]+/.test(navigator.userAgent);
            if ((u2 || s2 && c2) && (typeof FileReader == "undefined" ? "undefined" : _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(FileReader)) === "object") {
              var h2 = new FileReader();
              h2.onloadend = function() {
                var t = h2.result;
                t = u2 ? t : t.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t : location = t, a2 = null;
              }, h2.readAsDataURL(e);
            } else {
              var l2 = n.URL || n.webkitURL, f2 = l2.createObjectURL(e);
              a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
                l2.revokeObjectURL(f2);
              }, 4e4);
            }
          });
          function f(t) {
            var e;
            t = t || "", this.ok = false, t.charAt(0) == "#" && (t = t.substr(1, 6));
            t = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t = (t = t.replace(/ /g, "")).toLowerCase()] || t;
            for (var r = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t2) {
              return [parseInt(t2[1]), parseInt(t2[2]), parseInt(t2[3])];
            } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t2) {
              return [parseInt(t2[1], 16), parseInt(t2[2], 16), parseInt(t2[3], 16)];
            } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t2) {
              return [parseInt(t2[1] + t2[1], 16), parseInt(t2[2] + t2[2], 16), parseInt(t2[3] + t2[3], 16)];
            } }], n2 = 0; n2 < r.length; n2++) {
              var i2 = r[n2].re, a2 = r[n2].process, o2 = i2.exec(t);
              o2 && (e = a2(o2), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = true);
            }
            this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
              return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
            }, this.toHex = function() {
              var t2 = this.r.toString(16), e2 = this.g.toString(16), r2 = this.b.toString(16);
              return t2.length == 1 && (t2 = "0" + t2), e2.length == 1 && (e2 = "0" + e2), r2.length == 1 && (r2 = "0" + r2), "#" + t2 + e2 + r2;
            };
          }
          function d(t, e) {
            var r = t[0], n2 = t[1], i2 = t[2], a2 = t[3];
            r = g(r, n2, i2, a2, e[0], 7, -680876936), a2 = g(a2, r, n2, i2, e[1], 12, -389564586), i2 = g(i2, a2, r, n2, e[2], 17, 606105819), n2 = g(n2, i2, a2, r, e[3], 22, -1044525330), r = g(r, n2, i2, a2, e[4], 7, -176418897), a2 = g(a2, r, n2, i2, e[5], 12, 1200080426), i2 = g(i2, a2, r, n2, e[6], 17, -1473231341), n2 = g(n2, i2, a2, r, e[7], 22, -45705983), r = g(r, n2, i2, a2, e[8], 7, 1770035416), a2 = g(a2, r, n2, i2, e[9], 12, -1958414417), i2 = g(i2, a2, r, n2, e[10], 17, -42063), n2 = g(n2, i2, a2, r, e[11], 22, -1990404162), r = g(r, n2, i2, a2, e[12], 7, 1804603682), a2 = g(a2, r, n2, i2, e[13], 12, -40341101), i2 = g(i2, a2, r, n2, e[14], 17, -1502002290), r = m(r, n2 = g(n2, i2, a2, r, e[15], 22, 1236535329), i2, a2, e[1], 5, -165796510), a2 = m(a2, r, n2, i2, e[6], 9, -1069501632), i2 = m(i2, a2, r, n2, e[11], 14, 643717713), n2 = m(n2, i2, a2, r, e[0], 20, -373897302), r = m(r, n2, i2, a2, e[5], 5, -701558691), a2 = m(a2, r, n2, i2, e[10], 9, 38016083), i2 = m(i2, a2, r, n2, e[15], 14, -660478335), n2 = m(n2, i2, a2, r, e[4], 20, -405537848), r = m(r, n2, i2, a2, e[9], 5, 568446438), a2 = m(a2, r, n2, i2, e[14], 9, -1019803690), i2 = m(i2, a2, r, n2, e[3], 14, -187363961), n2 = m(n2, i2, a2, r, e[8], 20, 1163531501), r = m(r, n2, i2, a2, e[13], 5, -1444681467), a2 = m(a2, r, n2, i2, e[2], 9, -51403784), i2 = m(i2, a2, r, n2, e[7], 14, 1735328473), r = v(r, n2 = m(n2, i2, a2, r, e[12], 20, -1926607734), i2, a2, e[5], 4, -378558), a2 = v(a2, r, n2, i2, e[8], 11, -2022574463), i2 = v(i2, a2, r, n2, e[11], 16, 1839030562), n2 = v(n2, i2, a2, r, e[14], 23, -35309556), r = v(r, n2, i2, a2, e[1], 4, -1530992060), a2 = v(a2, r, n2, i2, e[4], 11, 1272893353), i2 = v(i2, a2, r, n2, e[7], 16, -155497632), n2 = v(n2, i2, a2, r, e[10], 23, -1094730640), r = v(r, n2, i2, a2, e[13], 4, 681279174), a2 = v(a2, r, n2, i2, e[0], 11, -358537222), i2 = v(i2, a2, r, n2, e[3], 16, -722521979), n2 = v(n2, i2, a2, r, e[6], 23, 76029189), r = v(r, n2, i2, a2, e[9], 4, -640364487), a2 = v(a2, r, n2, i2, e[12], 11, -421815835), i2 = v(i2, a2, r, n2, e[15], 16, 530742520), r = b(r, n2 = v(n2, i2, a2, r, e[2], 23, -995338651), i2, a2, e[0], 6, -198630844), a2 = b(a2, r, n2, i2, e[7], 10, 1126891415), i2 = b(i2, a2, r, n2, e[14], 15, -1416354905), n2 = b(n2, i2, a2, r, e[5], 21, -57434055), r = b(r, n2, i2, a2, e[12], 6, 1700485571), a2 = b(a2, r, n2, i2, e[3], 10, -1894986606), i2 = b(i2, a2, r, n2, e[10], 15, -1051523), n2 = b(n2, i2, a2, r, e[1], 21, -2054922799), r = b(r, n2, i2, a2, e[8], 6, 1873313359), a2 = b(a2, r, n2, i2, e[15], 10, -30611744), i2 = b(i2, a2, r, n2, e[6], 15, -1560198380), n2 = b(n2, i2, a2, r, e[13], 21, 1309151649), r = b(r, n2, i2, a2, e[4], 6, -145523070), a2 = b(a2, r, n2, i2, e[11], 10, -1120210379), i2 = b(i2, a2, r, n2, e[2], 15, 718787259), n2 = b(n2, i2, a2, r, e[9], 21, -343485551), t[0] = _(r, t[0]), t[1] = _(n2, t[1]), t[2] = _(i2, t[2]), t[3] = _(a2, t[3]);
          }
          function p(t, e, r, n2, i2, a2) {
            return e = _(_(e, t), _(n2, a2)), _(e << i2 | e >>> 32 - i2, r);
          }
          function g(t, e, r, n2, i2, a2, o2) {
            return p(e & r | ~e & n2, t, e, i2, a2, o2);
          }
          function m(t, e, r, n2, i2, a2, o2) {
            return p(e & n2 | r & ~n2, t, e, i2, a2, o2);
          }
          function v(t, e, r, n2, i2, a2, o2) {
            return p(e ^ r ^ n2, t, e, i2, a2, o2);
          }
          function b(t, e, r, n2, i2, a2, o2) {
            return p(r ^ (e | ~n2), t, e, i2, a2, o2);
          }
          function y(t) {
            var e, r = t.length, n2 = [1732584193, -271733879, -1732584194, 271733878];
            for (e = 64; e <= t.length; e += 64)
              d(n2, w(t.substring(e - 64, e)));
            t = t.substring(e - 64);
            var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            for (e = 0; e < t.length; e++)
              i2[e >> 2] |= t.charCodeAt(e) << (e % 4 << 3);
            if (i2[e >> 2] |= 128 << (e % 4 << 3), e > 55)
              for (d(n2, i2), e = 0; e < 16; e++)
                i2[e] = 0;
            return i2[14] = 8 * r, d(n2, i2), n2;
          }
          function w(t) {
            var e, r = [];
            for (e = 0; e < 64; e += 4)
              r[e >> 2] = t.charCodeAt(e) + (t.charCodeAt(e + 1) << 8) + (t.charCodeAt(e + 2) << 16) + (t.charCodeAt(e + 3) << 24);
            return r;
          }
          u = n.atob.bind(n), h = n.btoa.bind(n);
          var N = "0123456789abcdef".split("");
          function L(t) {
            for (var e = "", r = 0; r < 4; r++)
              e += N[t >> 8 * r + 4 & 15] + N[t >> 8 * r & 15];
            return e;
          }
          function A(t) {
            return String.fromCharCode((255 & t) >> 0, (65280 & t) >> 8, (16711680 & t) >> 16, (4278190080 & t) >> 24);
          }
          function x(t) {
            return y(t).map(A).join("");
          }
          var S = function(t) {
            for (var e = 0; e < t.length; e++)
              t[e] = L(t[e]);
            return t.join("");
          }(y("hello")) != "5d41402abc4b2a76b9719d911017c592";
          function _(t, e) {
            if (S) {
              var r = (65535 & t) + (65535 & e);
              return (t >> 16) + (e >> 16) + (r >> 16) << 16 | 65535 & r;
            }
            return t + e & 4294967295;
          }
          function P(t, e) {
            var r, n2, i2, a2;
            if (t !== r) {
              for (var o2 = (i2 = t, a2 = 1 + (256 / t.length >> 0), new Array(a2 + 1).join(i2)), s2 = [], c2 = 0; c2 < 256; c2++)
                s2[c2] = c2;
              var u2 = 0;
              for (c2 = 0; c2 < 256; c2++) {
                var h2 = s2[c2];
                u2 = (u2 + h2 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u2], s2[u2] = h2;
              }
              r = t, n2 = s2;
            } else
              s2 = n2;
            var l2 = e.length, f2 = 0, d2 = 0, p2 = "";
            for (c2 = 0; c2 < l2; c2++)
              d2 = (d2 + (h2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = h2, o2 = s2[(s2[f2] + s2[d2]) % 256], p2 += String.fromCharCode(e.charCodeAt(c2) ^ o2);
            return p2;
          }
          var k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
          function I(t, e, r, n2) {
            this.v = 1, this.r = 2;
            var i2 = 192;
            t.forEach(function(t2) {
              if (k.perm !== void 0)
                throw new Error("Invalid permission: " + t2);
              i2 += k[t2];
            }), this.padding = "(\xBFN^Nu\x8AAd\0NV\xFF\xFA\b..\0\xB6\xD0h>\x80/\f\xA9\xFEdSiz";
            var a2 = (e + this.padding).substr(0, 32), o2 = (r + this.padding).substr(0, 32);
            this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = x(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
          }
          function F(t) {
            if (/[^\u0000-\u00ff]/.test(t))
              throw new Error("Invalid PDF Name Object: " + t + ", Only accept ASCII characters.");
            for (var e = "", r = t.length, n2 = 0; n2 < r; n2++) {
              var i2 = t.charCodeAt(n2);
              if (i2 < 33 || i2 === 35 || i2 === 37 || i2 === 40 || i2 === 41 || i2 === 47 || i2 === 60 || i2 === 62 || i2 === 91 || i2 === 93 || i2 === 123 || i2 === 125 || i2 > 126)
                e += "#" + ("0" + i2.toString(16)).slice(-2);
              else
                e += t[n2];
            }
            return e;
          }
          function C(e) {
            if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e) !== "object")
              throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
            var r = {};
            this.subscribe = function(t, e2, n2) {
              if (n2 = n2 || false, typeof t != "string" || typeof e2 != "function" || typeof n2 != "boolean")
                throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
              r.hasOwnProperty(t) || (r[t] = {});
              var i2 = Math.random().toString(35);
              return r[t][i2] = [e2, !!n2], i2;
            }, this.unsubscribe = function(t) {
              for (var e2 in r)
                if (r[e2][t])
                  return delete r[e2][t], Object.keys(r[e2]).length === 0 && delete r[e2], true;
              return false;
            }, this.publish = function(t) {
              if (r.hasOwnProperty(t)) {
                var i2 = Array.prototype.slice.call(arguments, 1), o2 = [];
                for (var s2 in r[t]) {
                  var c2 = r[t][s2];
                  try {
                    c2[0].apply(e, i2);
                  } catch (t2) {
                    n.console && a.error("jsPDF PubSub Error", t2.message, t2);
                  }
                  c2[1] && o2.push(s2);
                }
                o2.length && o2.forEach(this.unsubscribe);
              }
            }, this.getTopics = function() {
              return r;
            };
          }
          function j(t) {
            if (!(this instanceof j))
              return new j(t);
            var e = "opacity,stroke-opacity".split(",");
            for (var r in t)
              t.hasOwnProperty(r) && e.indexOf(r) >= 0 && (this[r] = t[r]);
            this.id = "", this.objectNumber = -1;
          }
          function O(t, e) {
            this.gState = t, this.matrix = e, this.id = "", this.objectNumber = -1;
          }
          function B(t, e, r, n2, i2) {
            if (!(this instanceof B))
              return new B(t, e, r, n2, i2);
            this.type = t === "axial" ? 2 : 3, this.coords = e, this.colors = r, O.call(this, n2, i2);
          }
          function M(t, e, r, n2, i2) {
            if (!(this instanceof M))
              return new M(t, e, r, n2, i2);
            this.boundingBox = t, this.xStep = e, this.yStep = r, this.stream = "", this.cloneIndex = 0, O.call(this, n2, i2);
          }
          function E(e) {
            var r, i2 = typeof arguments[0] == "string" ? arguments[0] : "p", o2 = arguments[1], s2 = arguments[2], c2 = arguments[3], u2 = [], d2 = 1, p2 = 16, g2 = "S", m2 = null;
            _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e = e || {}) === "object" && (i2 = e.orientation, o2 = e.unit || o2, s2 = e.format || s2, c2 = e.compress || e.compressPdf || c2, (m2 = e.encryption || null) !== null && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), d2 = typeof e.userUnit == "number" ? Math.abs(e.userUnit) : 1, e.precision !== void 0 && (r = e.precision), e.floatPrecision !== void 0 && (p2 = e.floatPrecision), g2 = e.defaultPathOperation || "S"), u2 = e.filters || (c2 === true ? ["FlateEncode"] : u2), o2 = o2 || "mm", i2 = ("" + (i2 || "P")).toLowerCase();
            var v2 = e.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };
            y2.__private__.PubSub = C;
            var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
              return w2;
            };
            y2.__private__.setPdfVersion = function(t) {
              w2 = t;
            };
            var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
            y2.__private__.getPageFormats = function() {
              return L2;
            };
            var A2 = y2.__private__.getPageFormat = function(t) {
              return L2[t];
            };
            s2 = s2 || "a4";
            var x2 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x2.COMPAT;
            function _2() {
              this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + " cm"), this.setFontSize(this.getFontSize() / _t2), g2 = "n", S2 = x2.ADVANCED;
            }
            function P2() {
              this.restoreGraphicsState(), g2 = "S", S2 = x2.COMPAT;
            }
            var k2 = y2.__private__.combineFontStyleAndFontWeight = function(t, e2) {
              if (t == "bold" && e2 == "normal" || t == "bold" && e2 == 400 || t == "normal" && e2 == "italic" || t == "bold" && e2 == "italic")
                throw new Error("Invalid Combination of fontweight and fontstyle");
              return e2 && (t = e2 == 400 || e2 === "normal" ? t === "italic" ? "italic" : "normal" : e2 != 700 && e2 !== "bold" || t !== "normal" ? (e2 == 700 ? "bold" : e2) + "" + t : "bold"), t;
            };
            y2.advancedAPI = function(t) {
              var e2 = S2 === x2.COMPAT;
              return e2 && _2.call(this), typeof t != "function" || (t(this), e2 && P2.call(this)), this;
            }, y2.compatAPI = function(t) {
              var e2 = S2 === x2.ADVANCED;
              return e2 && P2.call(this), typeof t != "function" || (t(this), e2 && _2.call(this)), this;
            }, y2.isAdvancedAPI = function() {
              return S2 === x2.ADVANCED;
            };
            var O2, q2 = function(t) {
              if (S2 !== x2.ADVANCED)
                throw new Error(t + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
            }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t, e2) {
              var n2 = r || e2;
              if (isNaN(t) || isNaN(n2))
                throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
              return t.toFixed(n2).replace(/0+$/, "");
            };
            O2 = y2.hpf = y2.__private__.hpf = typeof p2 == "number" ? function(t) {
              if (isNaN(t))
                throw new Error("Invalid argument passed to jsPDF.hpf");
              return D2(t, p2);
            } : p2 === "smart" ? function(t) {
              if (isNaN(t))
                throw new Error("Invalid argument passed to jsPDF.hpf");
              return D2(t, t > -1 && t < 1 ? 16 : 5);
            } : function(t) {
              if (isNaN(t))
                throw new Error("Invalid argument passed to jsPDF.hpf");
              return D2(t, 16);
            };
            var R2 = y2.f2 = y2.__private__.f2 = function(t) {
              if (isNaN(t))
                throw new Error("Invalid argument passed to jsPDF.f2");
              return D2(t, 2);
            }, T2 = y2.__private__.f3 = function(t) {
              if (isNaN(t))
                throw new Error("Invalid argument passed to jsPDF.f3");
              return D2(t, 3);
            }, z2 = y2.scale = y2.__private__.scale = function(t) {
              if (isNaN(t))
                throw new Error("Invalid argument passed to jsPDF.scale");
              return S2 === x2.COMPAT ? t * _t2 : S2 === x2.ADVANCED ? t : void 0;
            }, U2 = function(t) {
              return S2 === x2.COMPAT ? Rr() - t : S2 === x2.ADVANCED ? t : void 0;
            }, H2 = function(t) {
              return z2(U2(t));
            };
            y2.__private__.setPrecision = y2.setPrecision = function(t) {
              typeof parseInt(t, 10) == "number" && (r = parseInt(t, 10));
            };
            var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
              return V2;
            }, Y2 = y2.__private__.setFileId = function(t) {
              return V2 = t !== void 0 && /^[a-fA-F0-9]{32}$/.test(t) ? t.toUpperCase() : V2.split("").map(function() {
                return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
              }).join(""), m2 !== null && (Ye = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
            };
            y2.setFileId = function(t) {
              return Y2(t), this;
            }, y2.getFileId = function() {
              return G2();
            };
            var J2 = y2.__private__.convertDateToPDFDate = function(t) {
              var e2 = t.getTimezoneOffset(), r2 = e2 < 0 ? "+" : "-", n2 = Math.floor(Math.abs(e2 / 60)), i3 = Math.abs(e2 % 60), a2 = [r2, Q2(n2), "'", Q2(i3), "'"].join("");
              return ["D:", t.getFullYear(), Q2(t.getMonth() + 1), Q2(t.getDate()), Q2(t.getHours()), Q2(t.getMinutes()), Q2(t.getSeconds()), a2].join("");
            }, X2 = y2.__private__.convertPDFDateToDate = function(t) {
              var e2 = parseInt(t.substr(2, 4), 10), r2 = parseInt(t.substr(6, 2), 10) - 1, n2 = parseInt(t.substr(8, 2), 10), i3 = parseInt(t.substr(10, 2), 10), a2 = parseInt(t.substr(12, 2), 10), o3 = parseInt(t.substr(14, 2), 10);
              return new Date(e2, r2, n2, i3, a2, o3, 0);
            }, K2 = y2.__private__.setCreationDate = function(t) {
              var e2;
              if (t === void 0 && (t = new Date()), t instanceof Date)
                e2 = J2(t);
              else {
                if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t))
                  throw new Error("Invalid argument passed to jsPDF.setCreationDate");
                e2 = t;
              }
              return W2 = e2;
            }, Z2 = y2.__private__.getCreationDate = function(t) {
              var e2 = W2;
              return t === "jsDate" && (e2 = X2(W2)), e2;
            };
            y2.setCreationDate = function(t) {
              return K2(t), this;
            }, y2.getCreationDate = function(t) {
              return Z2(t);
            };
            var $2, Q2 = y2.__private__.padd2 = function(t) {
              return ("0" + parseInt(t)).slice(-2);
            }, tt2 = y2.__private__.padd2Hex = function(t) {
              return ("00" + (t = t.toString())).substr(t.length);
            }, et2 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {
              et2 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
            };
            y2.__private__.setCustomOutputDestination = function(t) {
              st2 = true, ct2 = t;
            };
            var ht2 = function(t) {
              st2 || (ct2 = t);
            };
            y2.__private__.resetCustomOutputDestination = function() {
              st2 = false, ct2 = nt2;
            };
            var lt2 = y2.__private__.out = function(t) {
              return t = t.toString(), it2 += t.length + 1, ct2.push(t), ct2;
            }, ft2 = y2.__private__.write = function(t) {
              return lt2(arguments.length === 1 ? t.toString() : Array.prototype.join.call(arguments, " "));
            }, dt2 = y2.__private__.getArrayBuffer = function(t) {
              for (var e2 = t.length, r2 = new ArrayBuffer(e2), n2 = new Uint8Array(r2); e2--; )
                n2[e2] = t.charCodeAt(e2);
              return r2;
            }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
            y2.__private__.getStandardFonts = function() {
              return pt2;
            };
            var gt2 = e.fontSize || 16;
            y2.__private__.setFontSize = y2.setFontSize = function(t) {
              return gt2 = S2 === x2.ADVANCED ? t / _t2 : t, this;
            };
            var mt2, vt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
              return S2 === x2.COMPAT ? gt2 : gt2 * _t2;
            }, bt2 = e.R2L || false;
            y2.__private__.setR2L = y2.setR2L = function(t) {
              return bt2 = t, this;
            }, y2.__private__.getR2L = y2.getR2L = function() {
              return bt2;
            };
            var yt2, wt2 = y2.__private__.setZoomMode = function(t) {
              var e2 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
              if (/^\d*\.?\d*%$/.test(t))
                mt2 = t;
              else if (isNaN(t)) {
                if (e2.indexOf(t) === -1)
                  throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t + '" is not recognized.');
                mt2 = t;
              } else
                mt2 = parseInt(t, 10);
            };
            y2.__private__.getZoomMode = function() {
              return mt2;
            };
            var Nt2, Lt2 = y2.__private__.setPageMode = function(t) {
              if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t) == -1)
                throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t + '" is not recognized.');
              yt2 = t;
            };
            y2.__private__.getPageMode = function() {
              return yt2;
            };
            var At2 = y2.__private__.setLayoutMode = function(t) {
              if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t) == -1)
                throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t + '" is not recognized.');
              Nt2 = t;
            };
            y2.__private__.getLayoutMode = function() {
              return Nt2;
            }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t, e2, r2) {
              return wt2(t), At2(e2), Lt2(r2), this;
            };
            var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
            y2.__private__.getDocumentProperty = function(t) {
              if (Object.keys(xt2).indexOf(t) === -1)
                throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
              return xt2[t];
            }, y2.__private__.getDocumentProperties = function() {
              return xt2;
            }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t) {
              for (var e2 in xt2)
                xt2.hasOwnProperty(e2) && t[e2] && (xt2[e2] = t[e2]);
              return this;
            }, y2.__private__.setDocumentProperty = function(t, e2) {
              if (Object.keys(xt2).indexOf(t) === -1)
                throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
              return xt2[t] = e2;
            };
            var St2, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y2), zt2 = e.hotfixes || [], Ut2 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t(e2, r2, n2, i3, a2, o3) {
              if (!(this instanceof t))
                return new t(e2, r2, n2, i3, a2, o3);
              isNaN(e2) && (e2 = 1), isNaN(r2) && (r2 = 0), isNaN(n2) && (n2 = 0), isNaN(i3) && (i3 = 1), isNaN(a2) && (a2 = 0), isNaN(o3) && (o3 = 0), this._matrix = [e2, r2, n2, i3, a2, o3];
            };
            Object.defineProperty(Vt2.prototype, "sx", { get: function() {
              return this._matrix[0];
            }, set: function(t) {
              this._matrix[0] = t;
            } }), Object.defineProperty(Vt2.prototype, "shy", { get: function() {
              return this._matrix[1];
            }, set: function(t) {
              this._matrix[1] = t;
            } }), Object.defineProperty(Vt2.prototype, "shx", { get: function() {
              return this._matrix[2];
            }, set: function(t) {
              this._matrix[2] = t;
            } }), Object.defineProperty(Vt2.prototype, "sy", { get: function() {
              return this._matrix[3];
            }, set: function(t) {
              this._matrix[3] = t;
            } }), Object.defineProperty(Vt2.prototype, "tx", { get: function() {
              return this._matrix[4];
            }, set: function(t) {
              this._matrix[4] = t;
            } }), Object.defineProperty(Vt2.prototype, "ty", { get: function() {
              return this._matrix[5];
            }, set: function(t) {
              this._matrix[5] = t;
            } }), Object.defineProperty(Vt2.prototype, "a", { get: function() {
              return this._matrix[0];
            }, set: function(t) {
              this._matrix[0] = t;
            } }), Object.defineProperty(Vt2.prototype, "b", { get: function() {
              return this._matrix[1];
            }, set: function(t) {
              this._matrix[1] = t;
            } }), Object.defineProperty(Vt2.prototype, "c", { get: function() {
              return this._matrix[2];
            }, set: function(t) {
              this._matrix[2] = t;
            } }), Object.defineProperty(Vt2.prototype, "d", { get: function() {
              return this._matrix[3];
            }, set: function(t) {
              this._matrix[3] = t;
            } }), Object.defineProperty(Vt2.prototype, "e", { get: function() {
              return this._matrix[4];
            }, set: function(t) {
              this._matrix[4] = t;
            } }), Object.defineProperty(Vt2.prototype, "f", { get: function() {
              return this._matrix[5];
            }, set: function(t) {
              this._matrix[5] = t;
            } }), Object.defineProperty(Vt2.prototype, "rotation", { get: function() {
              return Math.atan2(this.shx, this.sx);
            } }), Object.defineProperty(Vt2.prototype, "scaleX", { get: function() {
              return this.decompose().scale.sx;
            } }), Object.defineProperty(Vt2.prototype, "scaleY", { get: function() {
              return this.decompose().scale.sy;
            } }), Object.defineProperty(Vt2.prototype, "isIdentity", { get: function() {
              return this.sx === 1 && (this.shy === 0 && (this.shx === 0 && (this.sy === 1 && (this.tx === 0 && this.ty === 0))));
            } }), Vt2.prototype.join = function(t) {
              return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O2).join(t);
            }, Vt2.prototype.multiply = function(t) {
              var e2 = t.sx * this.sx + t.shy * this.shx, r2 = t.sx * this.shy + t.shy * this.sy, n2 = t.shx * this.sx + t.sy * this.shx, i3 = t.shx * this.shy + t.sy * this.sy, a2 = t.tx * this.sx + t.ty * this.shx + this.tx, o3 = t.tx * this.shy + t.ty * this.sy + this.ty;
              return new Vt2(e2, r2, n2, i3, a2, o3);
            }, Vt2.prototype.decompose = function() {
              var t = this.sx, e2 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = Math.sqrt(t * t + e2 * e2), s3 = (t /= o3) * r2 + (e2 /= o3) * n2;
              r2 -= t * s3, n2 -= e2 * s3;
              var c3 = Math.sqrt(r2 * r2 + n2 * n2);
              return s3 /= c3, t * (n2 /= c3) < e2 * (r2 /= c3) && (t = -t, e2 = -e2, s3 = -s3, o3 = -o3), { scale: new Vt2(o3, 0, 0, c3, 0, 0), translate: new Vt2(1, 0, 0, 1, i3, a2), rotate: new Vt2(t, e2, -e2, t, 0, 0), skew: new Vt2(1, 0, s3, 1, 0, 0) };
            }, Vt2.prototype.toString = function(t) {
              return this.join(" ");
            }, Vt2.prototype.inversed = function() {
              var t = this.sx, e2 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = 1 / (t * n2 - e2 * r2), s3 = n2 * o3, c3 = -e2 * o3, u3 = -r2 * o3, h2 = t * o3;
              return new Vt2(s3, c3, u3, h2, -s3 * i3 - u3 * a2, -c3 * i3 - h2 * a2);
            }, Vt2.prototype.applyToPoint = function(t) {
              var e2 = t.x * this.sx + t.y * this.shx + this.tx, r2 = t.x * this.shy + t.y * this.sy + this.ty;
              return new Cr(e2, r2);
            }, Vt2.prototype.applyToRectangle = function(t) {
              var e2 = this.applyToPoint(t), r2 = this.applyToPoint(new Cr(t.x + t.w, t.y + t.h));
              return new jr(e2.x, e2.y, r2.x - e2.x, r2.y - e2.y);
            }, Vt2.prototype.clone = function() {
              var t = this.sx, e2 = this.shy, r2 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty;
              return new Vt2(t, e2, r2, n2, i3, a2);
            }, y2.Matrix = Vt2;
            var Gt2 = y2.matrixMult = function(t, e2) {
              return e2.multiply(t);
            }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
            y2.unitMatrix = y2.identityMatrix = Yt2;
            var Jt2 = function(t, e2) {
              if (!Bt2[t]) {
                var r2 = (e2 instanceof B ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
                e2.id = r2, Bt2[t] = r2, Ot2[r2] = e2, Tt2.publish("addPattern", e2);
              }
            };
            y2.ShadingPattern = B, y2.TilingPattern = M, y2.addShadingPattern = function(t, e2) {
              return q2("addShadingPattern()"), Jt2(t, e2), this;
            }, y2.beginTilingPattern = function(t) {
              q2("beginTilingPattern()"), Br(t.boundingBox[0], t.boundingBox[1], t.boundingBox[2] - t.boundingBox[0], t.boundingBox[3] - t.boundingBox[1], t.matrix);
            }, y2.endTilingPattern = function(t, e2) {
              q2("endTilingPattern()"), e2.stream = ot2[$2].join("\n"), Jt2(t, e2), Tt2.publish("endTilingPattern", e2), Wt2.pop().restore();
            };
            var Xt2 = y2.__private__.newObject = function() {
              var t = Kt2();
              return Zt2(t, true), t;
            }, Kt2 = y2.__private__.newObjectDeferred = function() {
              return et2++, rt2[et2] = function() {
                return it2;
              }, et2;
            }, Zt2 = function(t, e2) {
              return e2 = typeof e2 == "boolean" && e2, rt2[t] = it2, e2 && lt2(t + " 0 obj"), t;
            }, $t2 = y2.__private__.newAdditionalObject = function() {
              var t = { objId: Kt2(), content: "" };
              return at2.push(t), t;
            }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t) {
              var e2 = t.split(" ");
              if (e2.length !== 2 || e2[1] !== "g" && e2[1] !== "G") {
                if (e2.length === 5 && (e2[4] === "k" || e2[4] === "K")) {
                  e2 = [(1 - e2[0]) * (1 - e2[3]), (1 - e2[1]) * (1 - e2[3]), (1 - e2[2]) * (1 - e2[3]), "r"];
                }
              } else {
                var r2 = parseFloat(e2[0]);
                e2 = [r2, r2, r2, "r"];
              }
              for (var n2 = "#", i3 = 0; i3 < 3; i3++)
                n2 += ("0" + Math.floor(255 * parseFloat(e2[i3])).toString(16)).slice(-2);
              return n2;
            }, re2 = y2.__private__.encodeColorString = function(e2) {
              var r2;
              typeof e2 == "string" && (e2 = { ch1: e2 });
              var n2 = e2.ch1, i3 = e2.ch2, a2 = e2.ch3, o3 = e2.ch4, s3 = e2.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
              if (typeof n2 == "string" && n2.charAt(0) !== "#") {
                var c3 = new f(n2);
                if (c3.ok)
                  n2 = c3.toHex();
                else if (!/^\d*\.?\d*$/.test(n2))
                  throw new Error('Invalid color "' + n2 + '" passed to jsPDF.encodeColorString.');
              }
              if (typeof n2 == "string" && /^#[0-9A-Fa-f]{3}$/.test(n2) && (n2 = "#" + n2[1] + n2[1] + n2[2] + n2[2] + n2[3] + n2[3]), typeof n2 == "string" && /^#[0-9A-Fa-f]{6}$/.test(n2)) {
                var u3 = parseInt(n2.substr(1), 16);
                n2 = u3 >> 16 & 255, i3 = u3 >> 8 & 255, a2 = 255 & u3;
              }
              if (i3 === void 0 || o3 === void 0 && n2 === i3 && i3 === a2)
                if (typeof n2 == "string")
                  r2 = n2 + " " + s3[0];
                else
                  switch (e2.precision) {
                    case 2:
                      r2 = R2(n2 / 255) + " " + s3[0];
                      break;
                    case 3:
                    default:
                      r2 = T2(n2 / 255) + " " + s3[0];
                  }
              else if (o3 === void 0 || _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(o3) === "object") {
                if (o3 && !isNaN(o3.a) && o3.a === 0)
                  return r2 = ["1.", "1.", "1.", s3[1]].join(" ");
                if (typeof n2 == "string")
                  r2 = [n2, i3, a2, s3[1]].join(" ");
                else
                  switch (e2.precision) {
                    case 2:
                      r2 = [R2(n2 / 255), R2(i3 / 255), R2(a2 / 255), s3[1]].join(" ");
                      break;
                    default:
                    case 3:
                      r2 = [T2(n2 / 255), T2(i3 / 255), T2(a2 / 255), s3[1]].join(" ");
                  }
              } else if (typeof n2 == "string")
                r2 = [n2, i3, a2, o3, s3[2]].join(" ");
              else
                switch (e2.precision) {
                  case 2:
                    r2 = [R2(n2), R2(i3), R2(a2), R2(o3), s3[2]].join(" ");
                    break;
                  case 3:
                  default:
                    r2 = [T2(n2), T2(i3), T2(a2), T2(o3), s3[2]].join(" ");
                }
              return r2;
            }, ne2 = y2.__private__.getFilters = function() {
              return u2;
            }, ie2 = y2.__private__.putStream = function(t) {
              var e2 = (t = t || {}).data || "", r2 = t.filters || ne2(), n2 = t.alreadyAppliedFilters || [], i3 = t.addLength1 || false, a2 = e2.length, o3 = t.objectId, s3 = function(t2) {
                return t2;
              };
              if (m2 !== null && o3 === void 0)
                throw new Error("ObjectId must be passed to putStream for file encryption");
              m2 !== null && (s3 = Ye.encryptor(o3, 0));
              var c3 = {};
              r2 === true && (r2 = ["FlateEncode"]);
              var u3 = t.additionalKeyValues || [], h2 = (c3 = E.API.processDataByFilters !== void 0 ? E.API.processDataByFilters(e2, r2) : { data: e2, reverseChain: [] }).reverseChain + (Array.isArray(n2) ? n2.join(" ") : n2.toString());
              if (c3.data.length !== 0 && (u3.push({ key: "Length", value: c3.data.length }), i3 === true && u3.push({ key: "Length1", value: a2 })), h2.length != 0)
                if (h2.split("/").length - 1 == 1)
                  u3.push({ key: "Filter", value: h2 });
                else {
                  u3.push({ key: "Filter", value: "[" + h2 + "]" });
                  for (var l2 = 0; l2 < u3.length; l2 += 1)
                    if (u3[l2].key === "DecodeParms") {
                      for (var f2 = [], d3 = 0; d3 < c3.reverseChain.split("/").length - 1; d3 += 1)
                        f2.push("null");
                      f2.push(u3[l2].value), u3[l2].value = "[" + f2.join(" ") + "]";
                    }
                }
              lt2("<<");
              for (var p3 = 0; p3 < u3.length; p3++)
                lt2("/" + u3[p3].key + " " + u3[p3].value);
              lt2(">>"), c3.data.length !== 0 && (lt2("stream"), lt2(s3(c3.data)), lt2("endstream"));
            }, ae2 = y2.__private__.putPage = function(t) {
              var e2 = t.number, r2 = t.data, n2 = t.objId, i3 = t.contentsObjId;
              Zt2(n2, true), lt2("<</Type /Page"), lt2("/Parent " + t.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O2(t.mediaBox.bottomLeftX)) + " " + parseFloat(O2(t.mediaBox.bottomLeftY)) + " " + O2(t.mediaBox.topRightX) + " " + O2(t.mediaBox.topRightY) + "]"), t.cropBox !== null && lt2("/CropBox [" + O2(t.cropBox.bottomLeftX) + " " + O2(t.cropBox.bottomLeftY) + " " + O2(t.cropBox.topRightX) + " " + O2(t.cropBox.topRightY) + "]"), t.bleedBox !== null && lt2("/BleedBox [" + O2(t.bleedBox.bottomLeftX) + " " + O2(t.bleedBox.bottomLeftY) + " " + O2(t.bleedBox.topRightX) + " " + O2(t.bleedBox.topRightY) + "]"), t.trimBox !== null && lt2("/TrimBox [" + O2(t.trimBox.bottomLeftX) + " " + O2(t.trimBox.bottomLeftY) + " " + O2(t.trimBox.topRightX) + " " + O2(t.trimBox.topRightY) + "]"), t.artBox !== null && lt2("/ArtBox [" + O2(t.artBox.bottomLeftX) + " " + O2(t.artBox.bottomLeftY) + " " + O2(t.artBox.topRightX) + " " + O2(t.artBox.topRightY) + "]"), typeof t.userUnit == "number" && t.userUnit !== 1 && lt2("/UserUnit " + t.userUnit), Tt2.publish("putPage", { objId: n2, pageContext: Rt2[e2], pageNumber: e2, page: r2 }), lt2("/Contents " + i3 + " 0 R"), lt2(">>"), lt2("endobj");
              var a2 = r2.join("\n");
              return S2 === x2.ADVANCED && (a2 += "\nQ"), Zt2(i3, true), ie2({ data: a2, filters: ne2(), objectId: i3 }), lt2("endobj"), n2;
            }, oe2 = y2.__private__.putPages = function() {
              var t, e2, r2 = [];
              for (t = 1; t <= Dt2; t++)
                Rt2[t].objId = Kt2(), Rt2[t].contentsObjId = Kt2();
              for (t = 1; t <= Dt2; t++)
                r2.push(ae2({ number: t, data: ot2[t], objId: Rt2[t].objId, contentsObjId: Rt2[t].contentsObjId, mediaBox: Rt2[t].mediaBox, cropBox: Rt2[t].cropBox, bleedBox: Rt2[t].bleedBox, trimBox: Rt2[t].trimBox, artBox: Rt2[t].artBox, userUnit: Rt2[t].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
              Zt2(Qt2, true), lt2("<</Type /Pages");
              var n2 = "/Kids [";
              for (e2 = 0; e2 < Dt2; e2++)
                n2 += r2[e2] + " 0 R ";
              lt2(n2 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
            }, se2 = function(t) {
              Tt2.publish("putFont", { font: t, out: lt2, newObject: Xt2, putStream: ie2 }), t.isAlreadyPutted !== true && (t.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F(t.postScriptName)), lt2("/Subtype /Type1"), typeof t.encoding == "string" && lt2("/Encoding /" + t.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
            }, ce2 = function() {
              for (var t in Ft2)
                Ft2.hasOwnProperty(t) && (v2 === false || v2 === true && b2.hasOwnProperty(t)) && se2(Ft2[t]);
            }, ue2 = function(t) {
              t.objectNumber = Xt2();
              var e2 = [];
              e2.push({ key: "Type", value: "/XObject" }), e2.push({ key: "Subtype", value: "/Form" }), e2.push({ key: "BBox", value: "[" + [O2(t.x), O2(t.y), O2(t.x + t.width), O2(t.y + t.height)].join(" ") + "]" }), e2.push({ key: "Matrix", value: "[" + t.matrix.toString() + "]" });
              var r2 = t.pages[1].join("\n");
              ie2({ data: r2, additionalKeyValues: e2, objectId: t.objectNumber }), lt2("endobj");
            }, he2 = function() {
              for (var t in Ut2)
                Ut2.hasOwnProperty(t) && ue2(Ut2[t]);
            }, le2 = function(t, e2) {
              var r2, n2 = [], i3 = 1 / (e2 - 1);
              for (r2 = 0; r2 < 1; r2 += i3)
                n2.push(r2);
              if (n2.push(1), t[0].offset != 0) {
                var a2 = { offset: 0, color: t[0].color };
                t.unshift(a2);
              }
              if (t[t.length - 1].offset != 1) {
                var o3 = { offset: 1, color: t[t.length - 1].color };
                t.push(o3);
              }
              for (var s3 = "", c3 = 0, u3 = 0; u3 < n2.length; u3++) {
                for (r2 = n2[u3]; r2 > t[c3 + 1].offset; )
                  c3++;
                var h2 = t[c3].offset, l2 = (r2 - h2) / (t[c3 + 1].offset - h2), f2 = t[c3].color, d3 = t[c3 + 1].color;
                s3 += tt2(Math.round((1 - l2) * f2[0] + l2 * d3[0]).toString(16)) + tt2(Math.round((1 - l2) * f2[1] + l2 * d3[1]).toString(16)) + tt2(Math.round((1 - l2) * f2[2] + l2 * d3[2]).toString(16));
              }
              return s3.trim();
            }, fe2 = function(t, e2) {
              e2 || (e2 = 21);
              var r2 = Xt2(), n2 = le2(t.colors, e2), i3 = [];
              i3.push({ key: "FunctionType", value: "0" }), i3.push({ key: "Domain", value: "[0.0 1.0]" }), i3.push({ key: "Size", value: "[" + e2 + "]" }), i3.push({ key: "BitsPerSample", value: "8" }), i3.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i3.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: n2, additionalKeyValues: i3, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r2 }), lt2("endobj"), t.objectNumber = Xt2(), lt2("<< /ShadingType " + t.type), lt2("/ColorSpace /DeviceRGB");
              var a2 = "/Coords [" + O2(parseFloat(t.coords[0])) + " " + O2(parseFloat(t.coords[1])) + " ";
              t.type === 2 ? a2 += O2(parseFloat(t.coords[2])) + " " + O2(parseFloat(t.coords[3])) : a2 += O2(parseFloat(t.coords[2])) + " " + O2(parseFloat(t.coords[3])) + " " + O2(parseFloat(t.coords[4])) + " " + O2(parseFloat(t.coords[5])), lt2(a2 += "]"), t.matrix && lt2("/Matrix [" + t.matrix.toString() + "]"), lt2("/Function " + r2 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
            }, de2 = function(t, e2) {
              var r2 = Kt2(), n2 = Xt2();
              e2.push({ resourcesOid: r2, objectOid: n2 }), t.objectNumber = n2;
              var i3 = [];
              i3.push({ key: "Type", value: "/Pattern" }), i3.push({ key: "PatternType", value: "1" }), i3.push({ key: "PaintType", value: "1" }), i3.push({ key: "TilingType", value: "1" }), i3.push({ key: "BBox", value: "[" + t.boundingBox.map(O2).join(" ") + "]" }), i3.push({ key: "XStep", value: O2(t.xStep) }), i3.push({ key: "YStep", value: O2(t.yStep) }), i3.push({ key: "Resources", value: r2 + " 0 R" }), t.matrix && i3.push({ key: "Matrix", value: "[" + t.matrix.toString() + "]" }), ie2({ data: t.stream, additionalKeyValues: i3, objectId: t.objectNumber }), lt2("endobj");
            }, pe2 = function(t) {
              var e2;
              for (e2 in Ot2)
                Ot2.hasOwnProperty(e2) && (Ot2[e2] instanceof B ? fe2(Ot2[e2]) : Ot2[e2] instanceof M && de2(Ot2[e2], t));
            }, ge2 = function(t) {
              for (var e2 in t.objectNumber = Xt2(), lt2("<<"), t)
                switch (e2) {
                  case "opacity":
                    lt2("/ca " + R2(t[e2]));
                    break;
                  case "stroke-opacity":
                    lt2("/CA " + R2(t[e2]));
                }
              lt2(">>"), lt2("endobj");
            }, me2 = function() {
              var t;
              for (t in Mt2)
                Mt2.hasOwnProperty(t) && ge2(Mt2[t]);
            }, ve2 = function() {
              for (var t in lt2("/XObject <<"), Ut2)
                Ut2.hasOwnProperty(t) && Ut2[t].objectNumber >= 0 && lt2("/" + t + " " + Ut2[t].objectNumber + " 0 R");
              Tt2.publish("putXobjectDict"), lt2(">>");
            }, be2 = function() {
              Ye.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye.v), lt2("/R " + Ye.r), lt2("/U <" + Ye.toHexString(Ye.U) + ">"), lt2("/O <" + Ye.toHexString(Ye.O) + ">"), lt2("/P " + Ye.P), lt2(">>"), lt2("endobj");
            }, ye2 = function() {
              for (var t in lt2("/Font <<"), Ft2)
                Ft2.hasOwnProperty(t) && (v2 === false || v2 === true && b2.hasOwnProperty(t)) && lt2("/" + t + " " + Ft2[t].objectNumber + " 0 R");
              lt2(">>");
            }, we2 = function() {
              if (Object.keys(Ot2).length > 0) {
                for (var t in lt2("/Shading <<"), Ot2)
                  Ot2.hasOwnProperty(t) && Ot2[t] instanceof B && Ot2[t].objectNumber >= 0 && lt2("/" + t + " " + Ot2[t].objectNumber + " 0 R");
                Tt2.publish("putShadingPatternDict"), lt2(">>");
              }
            }, Ne2 = function(t) {
              if (Object.keys(Ot2).length > 0) {
                for (var e2 in lt2("/Pattern <<"), Ot2)
                  Ot2.hasOwnProperty(e2) && Ot2[e2] instanceof y2.TilingPattern && Ot2[e2].objectNumber >= 0 && Ot2[e2].objectNumber < t && lt2("/" + e2 + " " + Ot2[e2].objectNumber + " 0 R");
                Tt2.publish("putTilingPatternDict"), lt2(">>");
              }
            }, Le2 = function() {
              if (Object.keys(Mt2).length > 0) {
                var t;
                for (t in lt2("/ExtGState <<"), Mt2)
                  Mt2.hasOwnProperty(t) && Mt2[t].objectNumber >= 0 && lt2("/" + t + " " + Mt2[t].objectNumber + " 0 R");
                Tt2.publish("putGStateDict"), lt2(">>");
              }
            }, Ae = function(t) {
              Zt2(t.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
            }, xe = function() {
              var t = [];
              ce2(), me2(), he2(), pe2(t), Tt2.publish("putResources"), t.forEach(Ae), Ae({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish("postPutResources");
            }, Se = function() {
              Tt2.publish("putAdditionalObjects");
              for (var t = 0; t < at2.length; t++) {
                var e2 = at2[t];
                Zt2(e2.objId, true), lt2(e2.content), lt2("endobj");
              }
              Tt2.publish("postPutAdditionalObjects");
            }, _e = function(t) {
              Ct2[t.fontName] = Ct2[t.fontName] || {}, Ct2[t.fontName][t.fontStyle] = t.id;
            }, Pe = function(t, e2, r2, n2, i3) {
              var a2 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t, fontName: e2, fontStyle: r2, encoding: n2, isStandardFont: i3 || false, metadata: {} };
              return Tt2.publish("addFont", { font: a2, instance: this }), Ft2[a2.id] = a2, _e(a2), a2.id;
            }, ke = function(t) {
              for (var e2 = 0, r2 = pt2.length; e2 < r2; e2++) {
                var n2 = Pe.call(this, t[e2][0], t[e2][1], t[e2][2], pt2[e2][3], true);
                v2 === false && (b2[n2] = true);
                var i3 = t[e2][0].split("-");
                _e({ id: n2, fontName: i3[0], fontStyle: i3[1] || "" });
              }
              Tt2.publish("addFonts", { fonts: Ft2, dictionary: Ct2 });
            }, Ie = function(t) {
              return t.foo = function() {
                try {
                  return t.apply(this, arguments);
                } catch (t2) {
                  var e2 = t2.stack || "";
                  ~e2.indexOf(" at ") && (e2 = e2.split(" at ")[1]);
                  var r2 = "Error in function " + e2.split("\n")[0].split("<")[0] + ": " + t2.message;
                  if (!n.console)
                    throw new Error(r2);
                  n.console.error(r2, t2), n.alert && alert(r2);
                }
              }, t.foo.bar = t, t.foo;
            }, Fe = function(t, e2) {
              var r2, n2, i3, a2, o3, s3, c3, u3, h2;
              if (i3 = (e2 = e2 || {}).sourceEncoding || "Unicode", o3 = e2.outputEncoding, (e2.autoencode || o3) && Ft2[St2].metadata && Ft2[St2].metadata[i3] && Ft2[St2].metadata[i3].encoding && (a2 = Ft2[St2].metadata[i3].encoding, !o3 && Ft2[St2].encoding && (o3 = Ft2[St2].encoding), !o3 && a2.codePages && (o3 = a2.codePages[0]), typeof o3 == "string" && (o3 = a2[o3]), o3)) {
                for (c3 = false, s3 = [], r2 = 0, n2 = t.length; r2 < n2; r2++)
                  (u3 = o3[t.charCodeAt(r2)]) ? s3.push(String.fromCharCode(u3)) : s3.push(t[r2]), s3[r2].charCodeAt(0) >> 8 && (c3 = true);
                t = s3.join("");
              }
              for (r2 = t.length; c3 === void 0 && r2 !== 0; )
                t.charCodeAt(r2 - 1) >> 8 && (c3 = true), r2--;
              if (!c3)
                return t;
              for (s3 = e2.noBOM ? [] : [254, 255], r2 = 0, n2 = t.length; r2 < n2; r2++) {
                if ((h2 = (u3 = t.charCodeAt(r2)) >> 8) >> 8)
                  throw new Error("Character at position " + r2 + " of string '" + t + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
                s3.push(h2), s3.push(u3 - (h2 << 8));
              }
              return String.fromCharCode.apply(void 0, s3);
            }, Ce = y2.__private__.pdfEscape = y2.pdfEscape = function(t, e2) {
              return Fe(t, e2).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
            }, je = y2.__private__.beginPage = function(t) {
              ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t[0]), topRightY: Number(t[1]) } }, Me(Dt2), ht2(ot2[$2]);
            }, Oe = function(t, e2) {
              var r2, n2, o3;
              switch (i2 = e2 || i2, typeof t == "string" && (r2 = A2(t.toLowerCase()), Array.isArray(r2) && (n2 = r2[0], o3 = r2[1])), Array.isArray(t) && (n2 = t[0] * _t2, o3 = t[1] * _t2), isNaN(n2) && (n2 = s2[0], o3 = s2[1]), (n2 > 14400 || o3 > 14400) && (a.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n2 = Math.min(14400, n2), o3 = Math.min(14400, o3)), s2 = [n2, o3], i2.substr(0, 1)) {
                case "l":
                  o3 > n2 && (s2 = [o3, n2]);
                  break;
                case "p":
                  n2 > o3 && (s2 = [o3, n2]);
              }
              je(s2), pr(fr), lt2(Lr), kr !== 0 && lt2(kr + " J"), Ir !== 0 && lt2(Ir + " j"), Tt2.publish("addPage", { pageNumber: Dt2 });
            }, Be = function(t) {
              t > 0 && t <= Dt2 && (ot2.splice(t, 1), Rt2.splice(t, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
            }, Me = function(t) {
              t > 0 && t <= Dt2 && ($2 = t);
            }, Ee = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
              return ot2.length - 1;
            }, qe = function(t, e2, r2) {
              var n2, i3 = void 0;
              return r2 = r2 || {}, t = t !== void 0 ? t : Ft2[St2].fontName, e2 = e2 !== void 0 ? e2 : Ft2[St2].fontStyle, n2 = t.toLowerCase(), Ct2[n2] !== void 0 && Ct2[n2][e2] !== void 0 ? i3 = Ct2[n2][e2] : Ct2[t] !== void 0 && Ct2[t][e2] !== void 0 ? i3 = Ct2[t][e2] : r2.disableWarning === false && a.warn("Unable to look up font label for font '" + t + "', '" + e2 + "'. Refer to getFontList() for available fonts."), i3 || r2.noFallback || (i3 = Ct2.times[e2]) == null && (i3 = Ct2.times.normal), i3;
            }, De = y2.__private__.putInfo = function() {
              var t = Xt2(), e2 = function(t2) {
                return t2;
              };
              for (var r2 in m2 !== null && (e2 = Ye.encryptor(t, 0)), lt2("<<"), lt2("/Producer (" + Ce(e2("jsPDF " + E.version)) + ")"), xt2)
                xt2.hasOwnProperty(r2) && xt2[r2] && lt2("/" + r2.substr(0, 1).toUpperCase() + r2.substr(1) + " (" + Ce(e2(xt2[r2])) + ")");
              lt2("/CreationDate (" + Ce(e2(W2)) + ")"), lt2(">>"), lt2("endobj");
            }, Re = y2.__private__.putCatalog = function(t) {
              var e2 = (t = t || {}).rootDictionaryObjId || Qt2;
              switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e2 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
                case "fullwidth":
                  lt2("/OpenAction [3 0 R /FitH null]");
                  break;
                case "fullheight":
                  lt2("/OpenAction [3 0 R /FitV null]");
                  break;
                case "fullpage":
                  lt2("/OpenAction [3 0 R /Fit]");
                  break;
                case "original":
                  lt2("/OpenAction [3 0 R /XYZ null null 1]");
                  break;
                default:
                  var r2 = "" + mt2;
                  r2.substr(r2.length - 1) === "%" && (mt2 = parseInt(mt2) / 100), typeof mt2 == "number" && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
              }
              switch (Nt2 || (Nt2 = "continuous"), Nt2) {
                case "continuous":
                  lt2("/PageLayout /OneColumn");
                  break;
                case "single":
                  lt2("/PageLayout /SinglePage");
                  break;
                case "two":
                case "twoleft":
                  lt2("/PageLayout /TwoColumnLeft");
                  break;
                case "tworight":
                  lt2("/PageLayout /TwoColumnRight");
              }
              yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
            }, Te = y2.__private__.putTrailer = function() {
              lt2("trailer"), lt2("<<"), lt2("/Size " + (et2 + 1)), lt2("/Root " + et2 + " 0 R"), lt2("/Info " + (et2 - 1) + " 0 R"), m2 !== null && lt2("/Encrypt " + Ye.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
            }, ze = y2.__private__.putHeader = function() {
              lt2("%PDF-" + w2), lt2("%\xBA\xDF\xAC\xE0");
            }, Ue = y2.__private__.putXRef = function() {
              var t = "0000000000";
              lt2("xref"), lt2("0 " + (et2 + 1)), lt2("0000000000 65535 f ");
              for (var e2 = 1; e2 <= et2; e2++) {
                typeof rt2[e2] == "function" ? lt2((t + rt2[e2]()).slice(-10) + " 00000 n ") : rt2[e2] !== void 0 ? lt2((t + rt2[e2]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
              }
            }, He = y2.__private__.buildDocument = function() {
              ut2(), ht2(nt2), Tt2.publish("buildDocument"), ze(), oe2(), Se(), xe(), m2 !== null && be2(), De(), Re();
              var t = it2;
              return Ue(), Te(), lt2("startxref"), lt2("" + t), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
            }, We = y2.__private__.getBlob = function(t) {
              return new Blob([dt2(t)], { type: "application/pdf" });
            }, Ve = y2.output = y2.__private__.output = Ie(function(t, e2) {
              switch (typeof (e2 = e2 || {}) == "string" ? e2 = { filename: e2 } : e2.filename = e2.filename || "generated.pdf", t) {
                case void 0:
                  return He();
                case "save":
                  y2.save(e2.filename);
                  break;
                case "arraybuffer":
                  return dt2(He());
                case "blob":
                  return We(He());
                case "bloburi":
                case "bloburl":
                  if (n.URL !== void 0 && typeof n.URL.createObjectURL == "function")
                    return n.URL && n.URL.createObjectURL(We(He())) || void 0;
                  a.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
                  break;
                case "datauristring":
                case "dataurlstring":
                  var r2 = "", i3 = He();
                  try {
                    r2 = h(i3);
                  } catch (t2) {
                    r2 = h(unescape(encodeURIComponent(i3)));
                  }
                  return "data:application/pdf;filename=" + e2.filename + ";base64," + r2;
                case "pdfobjectnewwindow":
                  if (Object.prototype.toString.call(n) === "[object Window]") {
                    var o3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + (e2.pdfObjectUrl || "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js") + '"><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e2) + ");<\/script></body></html>", s3 = n.open();
                    return s3 !== null && s3.document.write(o3), s3;
                  }
                  throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
                case "pdfjsnewwindow":
                  if (Object.prototype.toString.call(n) === "[object Window]") {
                    var c3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e2.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e2.filename + '" width="500px" height="400px" /></body></html>', u3 = n.open();
                    if (u3 !== null) {
                      u3.document.write(c3);
                      var l2 = this;
                      u3.document.documentElement.querySelector("#pdfViewer").onload = function() {
                        u3.document.title = e2.filename, u3.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(l2.output("bloburl"));
                      };
                    }
                    return u3;
                  }
                  throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
                case "dataurlnewwindow":
                  if (Object.prototype.toString.call(n) !== "[object Window]")
                    throw new Error("The option dataurlnewwindow just works in a browser-environment.");
                  var f2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e2) + '"></iframe></body></html>', d3 = n.open();
                  if (d3 !== null && (d3.document.write(f2), d3.document.title = e2.filename), d3 || typeof safari == "undefined")
                    return d3;
                  break;
                case "datauri":
                case "dataurl":
                  return n.document.location.href = this.output("datauristring", e2);
                default:
                  return null;
              }
            }), Ge = function(t) {
              return Array.isArray(zt2) === true && zt2.indexOf(t) > -1;
            };
            switch (o2) {
              case "pt":
                _t2 = 1;
                break;
              case "mm":
                _t2 = 72 / 25.4;
                break;
              case "cm":
                _t2 = 72 / 2.54;
                break;
              case "in":
                _t2 = 72;
                break;
              case "px":
                _t2 = Ge("px_scaling") == 1 ? 0.75 : 96 / 72;
                break;
              case "pc":
              case "em":
                _t2 = 12;
                break;
              case "ex":
                _t2 = 6;
                break;
              default:
                if (typeof o2 != "number")
                  throw new Error("Invalid unit: " + o2);
                _t2 = o2;
            }
            var Ye = null;
            K2(), Y2();
            var Je = function(t) {
              return m2 !== null ? Ye.encryptor(t, 0) : function(t2) {
                return t2;
              };
            }, Xe = y2.__private__.getPageInfo = y2.getPageInfo = function(t) {
              if (isNaN(t) || t % 1 != 0)
                throw new Error("Invalid argument passed to jsPDF.getPageInfo");
              return { objId: Rt2[t].objId, pageNumber: t, pageContext: Rt2[t] };
            }, Ke = y2.__private__.getPageInfoByObjId = function(t) {
              if (isNaN(t) || t % 1 != 0)
                throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
              for (var e2 in Rt2)
                if (Rt2[e2].objId === t)
                  break;
              return Xe(e2);
            }, Ze = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
              return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
            };
            y2.addPage = function() {
              return Oe.apply(this, arguments), this;
            }, y2.setPage = function() {
              return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;
            }, y2.insertPage = function(t) {
              return this.addPage(), this.movePage($2, t), this;
            }, y2.movePage = function(t, e2) {
              var r2, n2;
              if (t > e2) {
                r2 = ot2[t], n2 = Rt2[t];
                for (var i3 = t; i3 > e2; i3--)
                  ot2[i3] = ot2[i3 - 1], Rt2[i3] = Rt2[i3 - 1];
                ot2[e2] = r2, Rt2[e2] = n2, this.setPage(e2);
              } else if (t < e2) {
                r2 = ot2[t], n2 = Rt2[t];
                for (var a2 = t; a2 < e2; a2++)
                  ot2[a2] = ot2[a2 + 1], Rt2[a2] = Rt2[a2 + 1];
                ot2[e2] = r2, Rt2[e2] = n2, this.setPage(e2);
              }
              return this;
            }, y2.deletePage = function() {
              return Be.apply(this, arguments), this;
            }, y2.__private__.text = y2.text = function(e2, r2, n2, i3, a2) {
              var o3, s3, c3, u3, h2, l2, f2, d3, p3, g3 = (i3 = i3 || {}).scope || this;
              if (typeof e2 == "number" && typeof r2 == "number" && (typeof n2 == "string" || Array.isArray(n2))) {
                var m3 = n2;
                n2 = r2, r2 = e2, e2 = m3;
              }
              if (arguments[3] instanceof Vt2 == false ? (c3 = arguments[4], u3 = arguments[5], _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(f2 = arguments[3]) === "object" && f2 !== null || (typeof c3 == "string" && (u3 = c3, c3 = null), typeof f2 == "string" && (u3 = f2, f2 = null), typeof f2 == "number" && (c3 = f2, f2 = null), i3 = { flags: f2, angle: c3, align: u3 })) : (q2("The transform parameter of text() with a Matrix value"), p3 = a2), isNaN(r2) || isNaN(n2) || e2 == null)
                throw new Error("Invalid arguments passed to jsPDF.text");
              if (e2.length === 0)
                return g3;
              var v3 = "", y3 = false, w3 = typeof i3.lineHeightFactor == "number" ? i3.lineHeightFactor : lr, N3 = g3.internal.scaleFactor;
              function L3(t) {
                return t = t.split("	").join(Array(i3.TabLen || 9).join(" ")), Ce(t, f2);
              }
              function A3(t) {
                for (var e3, r3 = t.concat(), n3 = [], i4 = r3.length; i4--; )
                  typeof (e3 = r3.shift()) == "string" ? n3.push(e3) : Array.isArray(t) && (e3.length === 1 || e3[1] === void 0 && e3[2] === void 0) ? n3.push(e3[0]) : n3.push([e3[0], e3[1], e3[2]]);
                return n3;
              }
              function _3(t, e3) {
                var r3;
                if (typeof t == "string")
                  r3 = e3(t)[0];
                else if (Array.isArray(t)) {
                  for (var n3, i4, a3 = t.concat(), o4 = [], s4 = a3.length; s4--; )
                    typeof (n3 = a3.shift()) == "string" ? o4.push(e3(n3)[0]) : Array.isArray(n3) && typeof n3[0] == "string" && (i4 = e3(n3[0], n3[1], n3[2]), o4.push([i4[0], i4[1], i4[2]]));
                  r3 = o4;
                }
                return r3;
              }
              var P3 = false, k3 = true;
              if (typeof e2 == "string")
                P3 = true;
              else if (Array.isArray(e2)) {
                var I2 = e2.concat();
                s3 = [];
                for (var F2, C2 = I2.length; C2--; )
                  (typeof (F2 = I2.shift()) != "string" || Array.isArray(F2) && typeof F2[0] != "string") && (k3 = false);
                P3 = k3;
              }
              if (P3 === false)
                throw new Error('Type of text must be string or Array. "' + e2 + '" is not recognized.');
              typeof e2 == "string" && (e2 = e2.match(/[\r?\n]/) ? e2.split(/\r\n|\r|\n/g) : [e2]);
              var j2 = gt2 / g3.internal.scaleFactor, B2 = j2 * (w3 - 1);
              switch (i3.baseline) {
                case "bottom":
                  n2 -= B2;
                  break;
                case "top":
                  n2 += j2 - B2;
                  break;
                case "hanging":
                  n2 += j2 - 2 * B2;
                  break;
                case "middle":
                  n2 += j2 / 2 - B2;
              }
              if ((l2 = i3.maxWidth || 0) > 0 && (typeof e2 == "string" ? e2 = g3.splitTextToSize(e2, l2) : Object.prototype.toString.call(e2) === "[object Array]" && (e2 = e2.reduce(function(t, e3) {
                return t.concat(g3.splitTextToSize(e3, l2));
              }, []))), o3 = { text: e2, x: r2, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("preProcessText", o3), e2 = o3.text, c3 = (i3 = o3.options).angle, p3 instanceof Vt2 == false && c3 && typeof c3 == "number") {
                c3 *= Math.PI / 180, i3.rotationDirection === 0 && (c3 = -c3), S2 === x2.ADVANCED && (c3 = -c3);
                var M2 = Math.cos(c3), E2 = Math.sin(c3);
                p3 = new Vt2(M2, E2, -E2, M2, 0, 0);
              } else
                c3 && c3 instanceof Vt2 && (p3 = c3);
              S2 !== x2.ADVANCED || p3 || (p3 = Yt2), (h2 = i3.charSpace || _r) !== void 0 && (v3 += O2(z2(h2)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), (d3 = i3.horizontalScale) !== void 0 && (v3 += O2(100 * d3) + " Tz\n");
              i3.lang;
              var D3 = -1, R3 = i3.renderingMode !== void 0 ? i3.renderingMode : i3.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
              switch (R3) {
                case 0:
                case false:
                case "fill":
                  D3 = 0;
                  break;
                case 1:
                case true:
                case "stroke":
                  D3 = 1;
                  break;
                case 2:
                case "fillThenStroke":
                  D3 = 2;
                  break;
                case 3:
                case "invisible":
                  D3 = 3;
                  break;
                case 4:
                case "fillAndAddForClipping":
                  D3 = 4;
                  break;
                case 5:
                case "strokeAndAddPathForClipping":
                  D3 = 5;
                  break;
                case 6:
                case "fillThenStrokeAndAddToPathForClipping":
                  D3 = 6;
                  break;
                case 7:
                case "addToPathForClipping":
                  D3 = 7;
              }
              var U3 = T3.usedRenderingMode !== void 0 ? T3.usedRenderingMode : -1;
              D3 !== -1 ? v3 += D3 + " Tr\n" : U3 !== -1 && (v3 += "0 Tr\n"), D3 !== -1 && (T3.usedRenderingMode = D3), u3 = i3.align || "left";
              var H3, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[St2];
              h2 = i3.charSpace || _r, l2 = i3.maxWidth || 0, f2 = Object.assign({ autoencode: true, noBOM: true }, i3.flags);
              var Y3 = [];
              if (Object.prototype.toString.call(e2) === "[object Array]") {
                var J3;
                s3 = A3(e2), u3 !== "left" && (H3 = s3.map(function(t) {
                  return g3.getStringUnitWidth(t, { font: G3, charSpace: h2, fontSize: gt2, doKerning: false }) * gt2 / N3;
                }));
                var X3, K3 = 0;
                if (u3 === "right") {
                  r2 -= H3[0], e2 = [], C2 = s3.length;
                  for (var Z3 = 0; Z3 < C2; Z3++)
                    Z3 === 0 ? (X3 = br(r2), J3 = yr(n2)) : (X3 = z2(K3 - H3[Z3]), J3 = -W3), e2.push([s3[Z3], X3, J3]), K3 = H3[Z3];
                } else if (u3 === "center") {
                  r2 -= H3[0] / 2, e2 = [], C2 = s3.length;
                  for (var $3 = 0; $3 < C2; $3++)
                    $3 === 0 ? (X3 = br(r2), J3 = yr(n2)) : (X3 = z2((K3 - H3[$3]) / 2), J3 = -W3), e2.push([s3[$3], X3, J3]), K3 = H3[$3];
                } else if (u3 === "left") {
                  e2 = [], C2 = s3.length;
                  for (var Q3 = 0; Q3 < C2; Q3++)
                    e2.push(s3[Q3]);
                } else {
                  if (u3 !== "justify")
                    throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
                  e2 = [], C2 = s3.length, l2 = l2 !== 0 ? l2 : V3;
                  for (var tt3 = 0; tt3 < C2; tt3++)
                    J3 = tt3 === 0 ? yr(n2) : -W3, X3 = tt3 === 0 ? br(r2) : 0, tt3 < C2 - 1 ? Y3.push(O2(z2((l2 - H3[tt3]) / (s3[tt3].split(" ").length - 1)))) : Y3.push(0), e2.push([s3[tt3], X3, J3]);
                }
              }
              var et3 = typeof i3.R2L == "boolean" ? i3.R2L : bt2;
              et3 === true && (e2 = _3(e2, function(t, e3, r3) {
                return [t.split("").reverse().join(""), e3, r3];
              })), o3 = { text: e2, x: r2, y: n2, options: i3, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("postProcessText", o3), e2 = o3.text, y3 = o3.mutex.isHex || false;
              var rt3 = Ft2[St2].encoding;
              rt3 !== "WinAnsiEncoding" && rt3 !== "StandardEncoding" || (e2 = _3(e2, function(t, e3, r3) {
                return [L3(t), e3, r3];
              })), s3 = A3(e2), e2 = [];
              for (var nt3, it3, at3, ot3 = 0, st3 = 1, ct3 = Array.isArray(s3[0]) ? st3 : ot3, ut3 = "", ht3 = function(t, e3, r3) {
                var n3 = "";
                return r3 instanceof Vt2 ? (r3 = typeof i3.angle == "number" ? Gt2(r3, new Vt2(1, 0, 0, 1, t, e3)) : Gt2(new Vt2(1, 0, 0, 1, t, e3), r3), S2 === x2.ADVANCED && (r3 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r3)), n3 = r3.join(" ") + " Tm\n") : n3 = O2(t) + " " + O2(e3) + " Td\n", n3;
              }, ft3 = 0; ft3 < s3.length; ft3++) {
                switch (ut3 = "", ct3) {
                  case st3:
                    at3 = (y3 ? "<" : "(") + s3[ft3][0] + (y3 ? ">" : ")"), nt3 = parseFloat(s3[ft3][1]), it3 = parseFloat(s3[ft3][2]);
                    break;
                  case ot3:
                    at3 = (y3 ? "<" : "(") + s3[ft3] + (y3 ? ">" : ")"), nt3 = br(r2), it3 = yr(n2);
                }
                Y3 !== void 0 && Y3[ft3] !== void 0 && (ut3 = Y3[ft3] + " Tw\n"), ft3 === 0 ? e2.push(ut3 + ht3(nt3, it3, p3) + at3) : ct3 === ot3 ? e2.push(ut3 + at3) : ct3 === st3 && e2.push(ut3 + ht3(nt3, it3, p3) + at3);
              }
              e2 = ct3 === ot3 ? e2.join(" Tj\nT* ") : e2.join(" Tj\n"), e2 += " Tj\n";
              var dt3 = "BT\n/";
              return dt3 += St2 + " " + gt2 + " Tf\n", dt3 += O2(gt2 * w3) + " TL\n", dt3 += xr + "\n", dt3 += v3, dt3 += e2, lt2(dt3 += "ET"), b2[St2] = true, g3;
            };
            var $e = y2.__private__.clip = y2.clip = function(t) {
              return lt2(t === "evenodd" ? "W*" : "W"), this;
            };
            y2.clipEvenOdd = function() {
              return $e("evenodd");
            }, y2.__private__.discardPath = y2.discardPath = function() {
              return lt2("n"), this;
            };
            var Qe = y2.__private__.isValidStyle = function(t) {
              var e2 = false;
              return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t) !== -1 && (e2 = true), e2;
            };
            y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t) {
              return Qe(t) && (g2 = t), this;
            };
            var tr = y2.__private__.getStyle = y2.getStyle = function(t) {
              var e2 = g2;
              switch (t) {
                case "D":
                case "S":
                  e2 = "S";
                  break;
                case "F":
                  e2 = "f";
                  break;
                case "FD":
                case "DF":
                  e2 = "B";
                  break;
                case "f":
                case "f*":
                case "B":
                case "B*":
                  e2 = t;
              }
              return e2;
            }, er = y2.close = function() {
              return lt2("h"), this;
            };
            y2.stroke = function() {
              return lt2("S"), this;
            }, y2.fill = function(t) {
              return rr("f", t), this;
            }, y2.fillEvenOdd = function(t) {
              return rr("f*", t), this;
            }, y2.fillStroke = function(t) {
              return rr("B", t), this;
            }, y2.fillStrokeEvenOdd = function(t) {
              return rr("B*", t), this;
            };
            var rr = function(e2, r2) {
              _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(r2) === "object" ? ar(r2, e2) : lt2(e2);
            }, nr = function(t) {
              t === null || S2 === x2.ADVANCED && t === void 0 || (t = tr(t), lt2(t));
            };
            function ir(t, e2, r2, n2, i3) {
              var a2 = new M(e2 || this.boundingBox, r2 || this.xStep, n2 || this.yStep, this.gState, i3 || this.matrix);
              a2.stream = this.stream;
              var o3 = t + "$$" + this.cloneIndex++ + "$$";
              return Jt2(o3, a2), a2;
            }
            var ar = function(t, e2) {
              var r2 = Bt2[t.key], n2 = Ot2[r2];
              if (n2 instanceof B)
                lt2("q"), lt2(or(e2)), n2.gState && y2.setGState(n2.gState), lt2(t.matrix.toString() + " cm"), lt2("/" + r2 + " sh"), lt2("Q");
              else if (n2 instanceof M) {
                var i3 = new Vt2(1, 0, 0, -1, 0, Rr());
                t.matrix && (i3 = i3.multiply(t.matrix || Yt2), r2 = ir.call(n2, t.key, t.boundingBox, t.xStep, t.yStep, i3).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r2 + " scn"), n2.gState && y2.setGState(n2.gState), lt2(e2), lt2("Q");
              }
            }, or = function(t) {
              switch (t) {
                case "f":
                case "F":
                  return "W n";
                case "f*":
                  return "W* n";
                case "B":
                  return "W S";
                case "B*":
                  return "W* S";
                case "S":
                  return "W S";
                case "n":
                  return "W n";
              }
            }, sr = y2.moveTo = function(t, e2) {
              return lt2(O2(z2(t)) + " " + O2(H2(e2)) + " m"), this;
            }, cr = y2.lineTo = function(t, e2) {
              return lt2(O2(z2(t)) + " " + O2(H2(e2)) + " l"), this;
            }, ur = y2.curveTo = function(t, e2, r2, n2, i3, a2) {
              return lt2([O2(z2(t)), O2(H2(e2)), O2(z2(r2)), O2(H2(n2)), O2(z2(i3)), O2(H2(a2)), "c"].join(" ")), this;
            };
            y2.__private__.line = y2.line = function(t, e2, r2, n2, i3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n2) || !Qe(i3))
                throw new Error("Invalid arguments passed to jsPDF.line");
              return S2 === x2.COMPAT ? this.lines([[r2 - t, n2 - e2]], t, e2, [1, 1], i3 || "S") : this.lines([[r2 - t, n2 - e2]], t, e2, [1, 1]).stroke();
            }, y2.__private__.lines = y2.lines = function(t, e2, r2, n2, i3, a2) {
              var o3, s3, c3, u3, h2, l2, f2, d3, p3, g3, m3, v3;
              if (typeof t == "number" && (v3 = r2, r2 = e2, e2 = t, t = v3), n2 = n2 || [1, 1], a2 = a2 || false, isNaN(e2) || isNaN(r2) || !Array.isArray(t) || !Array.isArray(n2) || !Qe(i3) || typeof a2 != "boolean")
                throw new Error("Invalid arguments passed to jsPDF.lines");
              for (sr(e2, r2), o3 = n2[0], s3 = n2[1], u3 = t.length, g3 = e2, m3 = r2, c3 = 0; c3 < u3; c3++)
                (h2 = t[c3]).length === 2 ? (g3 = h2[0] * o3 + g3, m3 = h2[1] * s3 + m3, cr(g3, m3)) : (l2 = h2[0] * o3 + g3, f2 = h2[1] * s3 + m3, d3 = h2[2] * o3 + g3, p3 = h2[3] * s3 + m3, g3 = h2[4] * o3 + g3, m3 = h2[5] * s3 + m3, ur(l2, f2, d3, p3, g3, m3));
              return a2 && er(), nr(i3), this;
            }, y2.path = function(t) {
              for (var e2 = 0; e2 < t.length; e2++) {
                var r2 = t[e2], n2 = r2.c;
                switch (r2.op) {
                  case "m":
                    sr(n2[0], n2[1]);
                    break;
                  case "l":
                    cr(n2[0], n2[1]);
                    break;
                  case "c":
                    ur.apply(this, n2);
                    break;
                  case "h":
                    er();
                }
              }
              return this;
            }, y2.__private__.rect = y2.rect = function(t, e2, r2, n2, i3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n2) || !Qe(i3))
                throw new Error("Invalid arguments passed to jsPDF.rect");
              return S2 === x2.COMPAT && (n2 = -n2), lt2([O2(z2(t)), O2(H2(e2)), O2(z2(r2)), O2(z2(n2)), "re"].join(" ")), nr(i3), this;
            }, y2.__private__.triangle = y2.triangle = function(t, e2, r2, n2, i3, a2, o3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3))
                throw new Error("Invalid arguments passed to jsPDF.triangle");
              return this.lines([[r2 - t, n2 - e2], [i3 - r2, a2 - n2], [t - i3, e2 - a2]], t, e2, [1, 1], o3, true), this;
            }, y2.__private__.roundedRect = y2.roundedRect = function(t, e2, r2, n2, i3, a2, o3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe(o3))
                throw new Error("Invalid arguments passed to jsPDF.roundedRect");
              var s3 = 4 / 3 * (Math.SQRT2 - 1);
              return i3 = Math.min(i3, 0.5 * r2), a2 = Math.min(a2, 0.5 * n2), this.lines([[r2 - 2 * i3, 0], [i3 * s3, 0, i3, a2 - a2 * s3, i3, a2], [0, n2 - 2 * a2], [0, a2 * s3, -i3 * s3, a2, -i3, a2], [2 * i3 - r2, 0], [-i3 * s3, 0, -i3, -a2 * s3, -i3, -a2], [0, 2 * a2 - n2], [0, -a2 * s3, i3 * s3, -a2, i3, -a2]], t + i3, e2, [1, 1], o3, true), this;
            }, y2.__private__.ellipse = y2.ellipse = function(t, e2, r2, n2, i3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n2) || !Qe(i3))
                throw new Error("Invalid arguments passed to jsPDF.ellipse");
              var a2 = 4 / 3 * (Math.SQRT2 - 1) * r2, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;
              return sr(t + r2, e2), ur(t + r2, e2 - o3, t + a2, e2 - n2, t, e2 - n2), ur(t - a2, e2 - n2, t - r2, e2 - o3, t - r2, e2), ur(t - r2, e2 + o3, t - a2, e2 + n2, t, e2 + n2), ur(t + a2, e2 + n2, t + r2, e2 + o3, t + r2, e2), nr(i3), this;
            }, y2.__private__.circle = y2.circle = function(t, e2, r2, n2) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || !Qe(n2))
                throw new Error("Invalid arguments passed to jsPDF.circle");
              return this.ellipse(t, e2, r2, r2, n2);
            }, y2.setFont = function(t, e2, r2) {
              return r2 && (e2 = k2(e2, r2)), St2 = qe(t, e2, { disableWarning: false }), this;
            };
            var hr = y2.__private__.getFont = y2.getFont = function() {
              return Ft2[qe.apply(y2, arguments)];
            };
            y2.__private__.getFontList = y2.getFontList = function() {
              var t, e2, r2 = {};
              for (t in Ct2)
                if (Ct2.hasOwnProperty(t))
                  for (e2 in r2[t] = [], Ct2[t])
                    Ct2[t].hasOwnProperty(e2) && r2[t].push(e2);
              return r2;
            }, y2.addFont = function(t, e2, r2, n2, i3) {
              var a2 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
              return arguments[3] && a2.indexOf(arguments[3]) !== -1 ? i3 = arguments[3] : arguments[3] && a2.indexOf(arguments[3]) == -1 && (r2 = k2(r2, n2)), i3 = i3 || "Identity-H", Pe.call(this, t, e2, r2, i3);
            };
            var lr, fr = e.lineWidth || 0.200025, dr = y2.__private__.getLineWidth = y2.getLineWidth = function() {
              return fr;
            }, pr = y2.__private__.setLineWidth = y2.setLineWidth = function(t) {
              return fr = t, lt2(O2(z2(t)) + " w"), this;
            };
            y2.__private__.setLineDash = E.API.setLineDash = E.API.setLineDashPattern = function(t, e2) {
              if (t = t || [], e2 = e2 || 0, isNaN(e2) || !Array.isArray(t))
                throw new Error("Invalid arguments passed to jsPDF.setLineDash");
              return t = t.map(function(t2) {
                return O2(z2(t2));
              }).join(" "), e2 = O2(z2(e2)), lt2("[" + t + "] " + e2 + " d"), this;
            };
            var gr = y2.__private__.getLineHeight = y2.getLineHeight = function() {
              return gt2 * lr;
            };
            y2.__private__.getLineHeight = y2.getLineHeight = function() {
              return gt2 * lr;
            };
            var mr = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t) {
              return typeof (t = t || 1.15) == "number" && (lr = t), this;
            }, vr = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
              return lr;
            };
            mr(e.lineHeight);
            var br = y2.__private__.getHorizontalCoordinate = function(t) {
              return z2(t);
            }, yr = y2.__private__.getVerticalCoordinate = function(t) {
              return S2 === x2.ADVANCED ? t : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - z2(t);
            }, wr = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t) {
              return O2(br(t));
            }, Nr = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t) {
              return O2(yr(t));
            }, Lr = e.strokeColor || "0 G";
            y2.__private__.getStrokeColor = y2.getDrawColor = function() {
              return ee2(Lr);
            }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t, e2, r2, n2) {
              return Lr = re2({ ch1: t, ch2: e2, ch3: r2, ch4: n2, pdfColorType: "draw", precision: 2 }), lt2(Lr), this;
            };
            var Ar = e.fillColor || "0 g";
            y2.__private__.getFillColor = y2.getFillColor = function() {
              return ee2(Ar);
            }, y2.__private__.setFillColor = y2.setFillColor = function(t, e2, r2, n2) {
              return Ar = re2({ ch1: t, ch2: e2, ch3: r2, ch4: n2, pdfColorType: "fill", precision: 2 }), lt2(Ar), this;
            };
            var xr = e.textColor || "0 g", Sr = y2.__private__.getTextColor = y2.getTextColor = function() {
              return ee2(xr);
            };
            y2.__private__.setTextColor = y2.setTextColor = function(t, e2, r2, n2) {
              return xr = re2({ ch1: t, ch2: e2, ch3: r2, ch4: n2, pdfColorType: "text", precision: 3 }), this;
            };
            var _r = e.charSpace, Pr = y2.__private__.getCharSpace = y2.getCharSpace = function() {
              return parseFloat(_r || 0);
            };
            y2.__private__.setCharSpace = y2.setCharSpace = function(t) {
              if (isNaN(t))
                throw new Error("Invalid argument passed to jsPDF.setCharSpace");
              return _r = t, this;
            };
            var kr = 0;
            y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t) {
              var e2 = y2.CapJoinStyles[t];
              if (e2 === void 0)
                throw new Error("Line cap style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
              return kr = e2, lt2(e2 + " J"), this;
            };
            var Ir = 0;
            y2.__private__.setLineJoin = y2.setLineJoin = function(t) {
              var e2 = y2.CapJoinStyles[t];
              if (e2 === void 0)
                throw new Error("Line join style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
              return Ir = e2, lt2(e2 + " j"), this;
            }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t) {
              if (t = t || 0, isNaN(t))
                throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
              return lt2(O2(z2(t)) + " M"), this;
            }, y2.GState = j, y2.setGState = function(t) {
              (t = typeof t == "string" ? Mt2[Et2[t]] : Fr(null, t)).equals(qt2) || (lt2("/" + t.id + " gs"), qt2 = t);
            };
            var Fr = function(t, e2) {
              if (!t || !Et2[t]) {
                var r2 = false;
                for (var n2 in Mt2)
                  if (Mt2.hasOwnProperty(n2) && Mt2[n2].equals(e2)) {
                    r2 = true;
                    break;
                  }
                if (r2)
                  e2 = Mt2[n2];
                else {
                  var i3 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
                  Mt2[i3] = e2, e2.id = i3;
                }
                return t && (Et2[t] = e2.id), Tt2.publish("addGState", e2), e2;
              }
            };
            y2.addGState = function(t, e2) {
              return Fr(t, e2), this;
            }, y2.saveGraphicsState = function() {
              return lt2("q"), jt2.push({ key: St2, size: gt2, color: xr }), this;
            }, y2.restoreGraphicsState = function() {
              lt2("Q");
              var t = jt2.pop();
              return St2 = t.key, gt2 = t.size, xr = t.color, qt2 = null, this;
            }, y2.setCurrentTransformationMatrix = function(t) {
              return lt2(t.toString() + " cm"), this;
            }, y2.comment = function(t) {
              return lt2("#" + t), this;
            };
            var Cr = function(t, e2) {
              var r2 = t || 0;
              Object.defineProperty(this, "x", { enumerable: true, get: function() {
                return r2;
              }, set: function(t2) {
                isNaN(t2) || (r2 = parseFloat(t2));
              } });
              var n2 = e2 || 0;
              Object.defineProperty(this, "y", { enumerable: true, get: function() {
                return n2;
              }, set: function(t2) {
                isNaN(t2) || (n2 = parseFloat(t2));
              } });
              var i3 = "pt";
              return Object.defineProperty(this, "type", { enumerable: true, get: function() {
                return i3;
              }, set: function(t2) {
                i3 = t2.toString();
              } }), this;
            }, jr = function(t, e2, r2, n2) {
              Cr.call(this, t, e2), this.type = "rect";
              var i3 = r2 || 0;
              Object.defineProperty(this, "w", { enumerable: true, get: function() {
                return i3;
              }, set: function(t2) {
                isNaN(t2) || (i3 = parseFloat(t2));
              } });
              var a2 = n2 || 0;
              return Object.defineProperty(this, "h", { enumerable: true, get: function() {
                return a2;
              }, set: function(t2) {
                isNaN(t2) || (a2 = parseFloat(t2));
              } }), this;
            }, Or = function() {
              this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
            };
            Or.prototype.restore = function() {
              Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
            };
            var Br = function(t, e2, r2, n2, i3) {
              Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t, kt2 = e2, It2 = i3, je([r2, n2]);
            }, Mr = function(t) {
              if (Ht2[t])
                Wt2.pop().restore();
              else {
                var e2 = new Or(), r2 = "Xo" + (Object.keys(Ut2).length + 1).toString(10);
                e2.id = r2, Ht2[t] = r2, Ut2[r2] = e2, Tt2.publish("addFormObject", e2), Wt2.pop().restore();
              }
            };
            for (var Er in y2.beginFormObject = function(t, e2, r2, n2, i3) {
              return Br(t, e2, r2, n2, i3), this;
            }, y2.endFormObject = function(t) {
              return Mr(t), this;
            }, y2.doFormObject = function(t, e2) {
              var r2 = Ut2[Ht2[t]];
              return lt2("q"), lt2(e2.toString() + " cm"), lt2("/" + r2.id + " Do"), lt2("Q"), this;
            }, y2.getFormObject = function(t) {
              var e2 = Ut2[Ht2[t]];
              return { x: e2.x, y: e2.y, width: e2.width, height: e2.height, matrix: e2.matrix };
            }, y2.save = function(t, e2) {
              return t = t || "generated.pdf", (e2 = e2 || {}).returnPromise = e2.returnPromise || false, e2.returnPromise === false ? (l(We(He()), t), typeof l.unload == "function" && n.setTimeout && setTimeout(l.unload, 911), this) : new Promise(function(e3, r2) {
                try {
                  var i3 = l(We(He()), t);
                  typeof l.unload == "function" && n.setTimeout && setTimeout(l.unload, 911), e3(i3);
                } catch (t2) {
                  r2(t2.message);
                }
              });
            }, E.API)
              E.API.hasOwnProperty(Er) && (Er === "events" && E.API.events.length ? function(t, e2) {
                var r2, n2, i3;
                for (i3 = e2.length - 1; i3 !== -1; i3--)
                  r2 = e2[i3][0], n2 = e2[i3][1], t.subscribe.apply(t, [r2].concat(typeof n2 == "function" ? [n2] : n2));
              }(Tt2, E.API.events) : y2[Er] = E.API[Er]);
            var qr = y2.getPageWidth = function(t) {
              return (Rt2[t = t || $2].mediaBox.topRightX - Rt2[t].mediaBox.bottomLeftX) / _t2;
            }, Dr = y2.setPageWidth = function(t, e2) {
              Rt2[t].mediaBox.topRightX = e2 * _t2 + Rt2[t].mediaBox.bottomLeftX;
            }, Rr = y2.getPageHeight = function(t) {
              return (Rt2[t = t || $2].mediaBox.topRightY - Rt2[t].mediaBox.bottomLeftY) / _t2;
            }, Tr = y2.setPageHeight = function(t, e2) {
              Rt2[t].mediaBox.topRightY = e2 * _t2 + Rt2[t].mediaBox.bottomLeftY;
            };
            return y2.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t2, pageSize: { getWidth: function() {
              return qr($2);
            }, setWidth: function(t) {
              Dr($2, t);
            }, getHeight: function() {
              return Rr($2);
            }, setHeight: function(t) {
              Tr($2, t);
            } }, encryptionOptions: m2, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot2, out: lt2, f2: R2, f3: T2, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N2, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge }, Object.defineProperty(y2.internal.pageSize, "width", { get: function() {
              return qr($2);
            }, set: function(t) {
              Dr($2, t);
            }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, "height", { get: function() {
              return Rr($2);
            }, set: function(t) {
              Tr($2, t);
            }, enumerable: true, configurable: true }), ke.call(y2, pt2), St2 = "F1", Oe(s2, i2), Tt2.publish("initialized"), y2;
          }
          I.prototype.lsbFirstWord = function(t) {
            return String.fromCharCode(t >> 0 & 255, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255);
          }, I.prototype.toHexString = function(t) {
            return t.split("").map(function(t2) {
              return ("0" + (255 & t2.charCodeAt(0)).toString(16)).slice(-2);
            }).join("");
          }, I.prototype.hexToBytes = function(t) {
            for (var e = [], r = 0; r < t.length; r += 2)
              e.push(String.fromCharCode(parseInt(t.substr(r, 2), 16)));
            return e.join("");
          }, I.prototype.processOwnerPassword = function(t, e) {
            return P(x(e).substr(0, 5), t);
          }, I.prototype.encryptor = function(t, e) {
            var r = x(this.encryptionKey + String.fromCharCode(255 & t, t >> 8 & 255, t >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
            return function(t2) {
              return P(r, t2);
            };
          }, j.prototype.equals = function(e) {
            var r, n2 = "id,objectNumber,equals";
            if (!e || _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e) !== _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(this))
              return false;
            var i2 = 0;
            for (r in this)
              if (!(n2.indexOf(r) >= 0)) {
                if (this.hasOwnProperty(r) && !e.hasOwnProperty(r))
                  return false;
                if (this[r] !== e[r])
                  return false;
                i2++;
              }
            for (r in e)
              e.hasOwnProperty(r) && n2.indexOf(r) < 0 && i2--;
            return i2 === 0;
          }, E.API = { events: [] }, E.version = "2.5.0";
          var q = E.API, D = 1, R = function(t) {
            return t.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
          }, T = function(t) {
            return t.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
          }, z = function(t) {
            return t.toFixed(2);
          }, U = function(t) {
            return t.toFixed(5);
          };
          q.__acroform__ = {};
          var H = function(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t;
          }, W = function(t) {
            return t * D;
          }, V = function(t) {
            var e = new ut(), r = At.internal.getHeight(t) || 0, n2 = At.internal.getWidth(t) || 0;
            return e.BBox = [0, 0, Number(z(n2)), Number(z(r))], e;
          }, G = q.__acroform__.setBit = function(t, e) {
            if (t = t || 0, e = e || 0, isNaN(t) || isNaN(e))
              throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
            return t |= 1 << e;
          }, Y = q.__acroform__.clearBit = function(t, e) {
            if (t = t || 0, e = e || 0, isNaN(t) || isNaN(e))
              throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
            return t &= ~(1 << e);
          }, J = q.__acroform__.getBit = function(t, e) {
            if (isNaN(t) || isNaN(e))
              throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
            return (t & 1 << e) == 0 ? 0 : 1;
          }, X = q.__acroform__.getBitForPdf = function(t, e) {
            if (isNaN(t) || isNaN(e))
              throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
            return J(t, e - 1);
          }, K = q.__acroform__.setBitForPdf = function(t, e) {
            if (isNaN(t) || isNaN(e))
              throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
            return G(t, e - 1);
          }, Z = q.__acroform__.clearBitForPdf = function(t, e) {
            if (isNaN(t) || isNaN(e))
              throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
            return Y(t, e - 1);
          }, $ = q.__acroform__.calculateCoordinates = function(t, e) {
            var r = e.internal.getHorizontalCoordinate, n2 = e.internal.getVerticalCoordinate, i2 = t[0], a2 = t[1], o2 = t[2], s2 = t[3], c2 = {};
            return c2.lowerLeft_X = r(i2) || 0, c2.lowerLeft_Y = n2(a2 + s2) || 0, c2.upperRight_X = r(i2 + o2) || 0, c2.upperRight_Y = n2(a2) || 0, [Number(z(c2.lowerLeft_X)), Number(z(c2.lowerLeft_Y)), Number(z(c2.upperRight_X)), Number(z(c2.upperRight_Y))];
          }, Q = function(t) {
            if (t.appearanceStreamContent)
              return t.appearanceStreamContent;
            if (t.V || t.DV) {
              var e = [], r = t._V || t.DV, n2 = tt(t, r), i2 = t.scope.internal.getFont(t.fontName, t.fontStyle).id;
              e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(t.scope.__private__.encodeColorString(t.color)), e.push("/" + i2 + " " + z(n2.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(n2.text), e.push("ET"), e.push("Q"), e.push("EMC");
              var a2 = V(t);
              return a2.scope = t.scope, a2.stream = e.join("\n"), a2;
            }
          }, tt = function(t, e) {
            var r = t.fontSize === 0 ? t.maxFontSize : t.fontSize, n2 = { text: "", fontSize: "" }, i2 = (e = (e = e.substr(0, 1) == "(" ? e.substr(1) : e).substr(e.length - 1) == ")" ? e.substr(0, e.length - 1) : e).split(" ");
            i2 = t.multiline ? i2.map(function(t2) {
              return t2.split("\n");
            }) : i2.map(function(t2) {
              return [t2];
            });
            var a2 = r, o2 = At.internal.getHeight(t) || 0;
            o2 = o2 < 0 ? -o2 : o2;
            var s2 = At.internal.getWidth(t) || 0;
            s2 = s2 < 0 ? -s2 : s2;
            var c2 = function(e2, r2, n3) {
              if (e2 + 1 < i2.length) {
                var a3 = r2 + " " + i2[e2 + 1][0];
                return et(a3, t, n3).width <= s2 - 4;
              }
              return false;
            };
            a2++;
            t:
              for (; a2 > 0; ) {
                e = "", a2--;
                var u2, h2, l2 = et("3", t, a2).height, f2 = t.multiline ? o2 - a2 : (o2 - l2) / 2, d2 = f2 += 2, p2 = 0, g2 = 0, m2 = 0;
                if (a2 <= 0) {
                  e = "(...) Tj\n", e += "% Width of Text: " + et(e, t, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
                  break;
                }
                for (var v2 = "", b2 = 0, y2 = 0; y2 < i2.length; y2++)
                  if (i2.hasOwnProperty(y2)) {
                    var w2 = false;
                    if (i2[y2].length !== 1 && m2 !== i2[y2].length - 1) {
                      if ((l2 + 2) * (b2 + 2) + 2 > o2)
                        continue t;
                      v2 += i2[y2][m2], w2 = true, g2 = y2, y2--;
                    } else {
                      v2 = (v2 += i2[y2][m2] + " ").substr(v2.length - 1) == " " ? v2.substr(0, v2.length - 1) : v2;
                      var N2 = parseInt(y2), L2 = c2(N2, v2, a2), A2 = y2 >= i2.length - 1;
                      if (L2 && !A2) {
                        v2 += " ", m2 = 0;
                        continue;
                      }
                      if (L2 || A2) {
                        if (A2)
                          g2 = N2;
                        else if (t.multiline && (l2 + 2) * (b2 + 2) + 2 > o2)
                          continue t;
                      } else {
                        if (!t.multiline)
                          continue t;
                        if ((l2 + 2) * (b2 + 2) + 2 > o2)
                          continue t;
                        g2 = N2;
                      }
                    }
                    for (var x2 = "", S2 = p2; S2 <= g2; S2++) {
                      var _2 = i2[S2];
                      if (t.multiline) {
                        if (S2 === g2) {
                          x2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
                          continue;
                        }
                        if (S2 === p2) {
                          x2 += _2[_2.length - 1] + " ";
                          continue;
                        }
                      }
                      x2 += _2[0] + " ";
                    }
                    switch (x2 = x2.substr(x2.length - 1) == " " ? x2.substr(0, x2.length - 1) : x2, h2 = et(x2, t, a2).width, t.textAlign) {
                      case "right":
                        u2 = s2 - h2 - 2;
                        break;
                      case "center":
                        u2 = (s2 - h2) / 2;
                        break;
                      case "left":
                      default:
                        u2 = 2;
                    }
                    e += z(u2) + " " + z(d2) + " Td\n", e += "(" + R(x2) + ") Tj\n", e += -z(u2) + " 0 Td\n", d2 = -(a2 + 2), h2 = 0, p2 = w2 ? g2 : g2 + 1, b2++, v2 = "";
                  } else
                    ;
                break;
              }
            return n2.text = e, n2.fontSize = a2, n2;
          }, et = function(t, e, r) {
            var n2 = e.scope.internal.getFont(e.fontName, e.fontStyle), i2 = e.scope.getStringUnitWidth(t, { font: n2, fontSize: parseFloat(r), charSpace: 0 }) * parseFloat(r);
            return { height: e.scope.getStringUnitWidth("3", { font: n2, fontSize: parseFloat(r), charSpace: 0 }) * parseFloat(r) * 1.5, width: i2 };
          }, rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false }, nt = function(t, e) {
            var r = { type: "reference", object: t };
            e.internal.getPageInfo(t.page).pageContext.annotations.find(function(t2) {
              return t2.type === r.type && t2.object === r.object;
            }) === void 0 && e.internal.getPageInfo(t.page).pageContext.annotations.push(r);
          }, it = function(e, r) {
            for (var n2 in e)
              if (e.hasOwnProperty(n2)) {
                var i2 = n2, a2 = e[n2];
                r.internal.newObjectDeferredBegin(a2.objId, true), _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(a2) === "object" && typeof a2.putStream == "function" && a2.putStream(), delete e[i2];
              }
          }, at = function(e, r) {
            if (r.scope = e, e.internal !== void 0 && (e.internal.acroformPlugin === void 0 || e.internal.acroformPlugin.isInitialized === false)) {
              if (lt.FieldNum = 0, e.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e.internal.acroformPlugin.acroFormDictionaryRoot)
                throw new Error("Exception while creating AcroformDictionary");
              D = e.internal.scaleFactor, e.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e.internal.acroformPlugin.acroFormDictionaryRoot.scope = e, e.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e.internal.events.subscribe("postPutResources", function() {
                !function(t) {
                  t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = true;
                }(e);
              }), e.internal.events.subscribe("buildDocument", function() {
                !function(t) {
                  t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
                  var e2 = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
                  for (var r2 in e2)
                    if (e2.hasOwnProperty(r2)) {
                      var n2 = e2[r2];
                      n2.objId = void 0, n2.hasAnnotation && nt(n2, t);
                    }
                }(e);
              }), e.internal.events.subscribe("putCatalog", function() {
                !function(t) {
                  if (t.internal.acroformPlugin.acroFormDictionaryRoot === void 0)
                    throw new Error("putCatalogCallback: Root missing.");
                  t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
                }(e);
              }), e.internal.events.subscribe("postPutPages", function(r2) {
                !function(e2, r3) {
                  var n2 = !e2;
                  for (var i2 in e2 || (r3.internal.newObjectDeferredBegin(r3.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r3.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e2 = e2 || r3.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
                    if (e2.hasOwnProperty(i2)) {
                      var a2 = e2[i2], o2 = [], s2 = a2.Rect;
                      if (a2.Rect && (a2.Rect = $(a2.Rect, r3)), r3.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = At.createDefaultAppearanceStream(a2), _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(a2) === "object" && typeof a2.getKeyValueListForStream == "function" && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
                        var c2 = Q(a2);
                        o2.push({ key: "AP", value: "<</N " + c2 + ">>" }), r3.internal.acroformPlugin.xForms.push(c2);
                      }
                      if (a2.appearanceStreamContent) {
                        var u2 = "";
                        for (var h2 in a2.appearanceStreamContent)
                          if (a2.appearanceStreamContent.hasOwnProperty(h2)) {
                            var l2 = a2.appearanceStreamContent[h2];
                            if (u2 += "/" + h2 + " ", u2 += "<<", Object.keys(l2).length >= 1 || Array.isArray(l2)) {
                              for (var i2 in l2)
                                if (l2.hasOwnProperty(i2)) {
                                  var f2 = l2[i2];
                                  typeof f2 == "function" && (f2 = f2.call(r3, a2)), u2 += "/" + i2 + " " + f2 + " ", r3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r3.internal.acroformPlugin.xForms.push(f2);
                                }
                            } else
                              typeof (f2 = l2) == "function" && (f2 = f2.call(r3, a2)), u2 += "/" + i2 + " " + f2, r3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r3.internal.acroformPlugin.xForms.push(f2);
                            u2 += ">>";
                          }
                        o2.push({ key: "AP", value: "<<\n" + u2 + ">>" });
                      }
                      r3.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), r3.internal.out("endobj");
                    }
                  n2 && it(r3.internal.acroformPlugin.xForms, r3);
                }(r2, e);
              }), e.internal.acroformPlugin.isInitialized = true;
            }
          }, ot = q.__acroform__.arrayToPdfArray = function(e, r, n2) {
            var i2 = function(t) {
              return t;
            };
            if (Array.isArray(e)) {
              for (var a2 = "[", o2 = 0; o2 < e.length; o2++)
                switch (o2 !== 0 && (a2 += " "), _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e[o2])) {
                  case "boolean":
                  case "number":
                  case "object":
                    a2 += e[o2].toString();
                    break;
                  case "string":
                    e[o2].substr(0, 1) !== "/" ? (r !== void 0 && n2 && (i2 = n2.internal.getEncryptor(r)), a2 += "(" + R(i2(e[o2].toString())) + ")") : a2 += e[o2].toString();
                }
              return a2 += "]";
            }
            throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
          };
          var st = function(t, e, r) {
            var n2 = function(t2) {
              return t2;
            };
            return e !== void 0 && r && (n2 = r.internal.getEncryptor(e)), (t = t || "").toString(), t = "(" + R(n2(t)) + ")";
          }, ct = function() {
            this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
              if (this._objId === void 0) {
                if (this.scope === void 0)
                  return;
                this._objId = this.scope.internal.newObjectDeferred();
              }
              return this._objId;
            }, set: function(t) {
              this._objId = t;
            } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
          };
          ct.prototype.toString = function() {
            return this.objId + " 0 R";
          }, ct.prototype.putStream = function() {
            var t = this.getKeyValueListForStream();
            this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t, objectId: this.objId }), this.scope.internal.out("endobj");
          }, ct.prototype.getKeyValueListForStream = function() {
            var t = [], e = Object.getOwnPropertyNames(this).filter(function(t2) {
              return t2 != "content" && t2 != "appearanceStreamContent" && t2 != "scope" && t2 != "objId" && t2.substring(0, 1) != "_";
            });
            for (var r in e)
              if (Object.getOwnPropertyDescriptor(this, e[r]).configurable === false) {
                var n2 = e[r], i2 = this[n2];
                i2 && (Array.isArray(i2) ? t.push({ key: n2, value: ot(i2, this.objId, this.scope) }) : i2 instanceof ct ? (i2.scope = this.scope, t.push({ key: n2, value: i2.objId + " 0 R" })) : typeof i2 != "function" && t.push({ key: n2, value: i2 }));
              }
            return t;
          };
          var ut = function() {
            ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
            var t, e = [];
            Object.defineProperty(this, "BBox", { configurable: false, get: function() {
              return e;
            }, set: function(t2) {
              e = t2;
            } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e2) {
              t = e2.trim();
            }, get: function() {
              return t || null;
            } });
          };
          H(ut, ct);
          var ht = function() {
            ct.call(this);
            var t, e = [];
            Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
              return e.length > 0 ? e : void 0;
            } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
              return e;
            } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
              if (t) {
                var e2 = function(t2) {
                  return t2;
                };
                return this.scope && (e2 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e2(t)) + ")";
              }
            }, set: function(e2) {
              t = e2;
            } });
          };
          H(ht, ct);
          var lt = function t() {
            ct.call(this);
            var e = 4;
            Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
              return e;
            }, set: function(t2) {
              if (isNaN(t2))
                throw new Error('Invalid value "' + t2 + '" for attribute F supplied.');
              e = t2;
            } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(e, 3));
            }, set: function(t2) {
              Boolean(t2) === true ? this.F = K(e, 3) : this.F = Z(e, 3);
            } });
            var r = 0;
            Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
              return r;
            }, set: function(t2) {
              if (isNaN(t2))
                throw new Error('Invalid value "' + t2 + '" for attribute Ff supplied.');
              r = t2;
            } });
            var n2 = [];
            Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
              if (n2.length !== 0)
                return n2;
            }, set: function(t2) {
              n2 = t2 !== void 0 ? t2 : [];
            } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
              return !n2 || isNaN(n2[0]) ? 0 : n2[0];
            }, set: function(t2) {
              n2[0] = t2;
            } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
              return !n2 || isNaN(n2[1]) ? 0 : n2[1];
            }, set: function(t2) {
              n2[1] = t2;
            } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
              return !n2 || isNaN(n2[2]) ? 0 : n2[2];
            }, set: function(t2) {
              n2[2] = t2;
            } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
              return !n2 || isNaN(n2[3]) ? 0 : n2[3];
            }, set: function(t2) {
              n2[3] = t2;
            } });
            var i2 = "";
            Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
              return i2;
            }, set: function(t2) {
              switch (t2) {
                case "/Btn":
                case "/Tx":
                case "/Ch":
                case "/Sig":
                  i2 = t2;
                  break;
                default:
                  throw new Error('Invalid value "' + t2 + '" for attribute FT supplied.');
              }
            } });
            var a2 = null;
            Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
              if (!a2 || a2.length < 1) {
                if (this instanceof yt)
                  return;
                a2 = "FieldObject" + t.FieldNum++;
              }
              var e2 = function(t2) {
                return t2;
              };
              return this.scope && (e2 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e2(a2)) + ")";
            }, set: function(t2) {
              a2 = t2.toString();
            } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
              return a2;
            }, set: function(t2) {
              a2 = t2;
            } });
            var o2 = "helvetica";
            Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
              return o2;
            }, set: function(t2) {
              o2 = t2;
            } });
            var s2 = "normal";
            Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
              return s2;
            }, set: function(t2) {
              s2 = t2;
            } });
            var c2 = 0;
            Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
              return c2;
            }, set: function(t2) {
              c2 = t2;
            } });
            var u2 = void 0;
            Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
              return u2 === void 0 ? 50 / D : u2;
            }, set: function(t2) {
              u2 = t2;
            } });
            var h2 = "black";
            Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
              return h2;
            }, set: function(t2) {
              h2 = t2;
            } });
            var l2 = "/F1 0 Tf 0 g";
            Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
              if (!(!l2 || this instanceof yt || this instanceof Nt))
                return st(l2, this.objId, this.scope);
            }, set: function(t2) {
              t2 = t2.toString(), l2 = t2;
            } });
            var f2 = null;
            Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
              if (f2)
                return this instanceof mt == false ? st(f2, this.objId, this.scope) : f2;
            }, set: function(t2) {
              t2 = t2.toString(), f2 = this instanceof mt == false ? t2.substr(0, 1) === "(" ? T(t2.substr(1, t2.length - 2)) : T(t2) : t2;
            } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
              return this instanceof mt == true ? T(f2.substr(1, f2.length - 1)) : f2;
            }, set: function(t2) {
              t2 = t2.toString(), f2 = this instanceof mt == true ? "/" + t2 : t2;
            } });
            var d2 = null;
            Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
              if (d2)
                return d2;
            }, set: function(t2) {
              this.V = t2;
            } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
              if (d2)
                return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;
            }, set: function(t2) {
              t2 = t2.toString(), d2 = this instanceof mt == false ? t2.substr(0, 1) === "(" ? T(t2.substr(1, t2.length - 2)) : T(t2) : t2;
            } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
              return this instanceof mt == true ? T(d2.substr(1, d2.length - 1)) : d2;
            }, set: function(t2) {
              t2 = t2.toString(), d2 = this instanceof mt == true ? "/" + t2 : t2;
            } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
              return this.Rect;
            } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
              return this.hasAnnotation ? "/Annot" : null;
            } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
              return this.hasAnnotation ? "/Widget" : null;
            } });
            var p2, g2 = false;
            Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
              return g2;
            }, set: function(t2) {
              t2 = Boolean(t2), g2 = t2;
            } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
              if (p2)
                return p2;
            }, set: function(t2) {
              p2 = t2;
            } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 1));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 1) : this.Ff = Z(this.Ff, 1);
            } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 2));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 2) : this.Ff = Z(this.Ff, 2);
            } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 3));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 3) : this.Ff = Z(this.Ff, 3);
            } });
            var m2 = null;
            Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
              if (m2 !== null)
                return m2;
            }, set: function(t2) {
              if ([0, 1, 2].indexOf(t2) === -1)
                throw new Error('Invalid value "' + t2 + '" for attribute Q supplied.');
              m2 = t2;
            } }), Object.defineProperty(this, "textAlign", { get: function() {
              var t2;
              switch (m2) {
                case 0:
                default:
                  t2 = "left";
                  break;
                case 1:
                  t2 = "center";
                  break;
                case 2:
                  t2 = "right";
              }
              return t2;
            }, configurable: true, enumerable: true, set: function(t2) {
              switch (t2) {
                case "right":
                case 2:
                  m2 = 2;
                  break;
                case "center":
                case 1:
                  m2 = 1;
                  break;
                case "left":
                case 0:
                default:
                  m2 = 0;
              }
            } });
          };
          H(lt, ct);
          var ft = function() {
            lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
            var t = 0;
            Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
              return t;
            }, set: function(e2) {
              t = e2;
            } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
              return t;
            }, set: function(e2) {
              t = e2;
            } });
            var e = [];
            Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
              return ot(e, this.objId, this.scope);
            }, set: function(t2) {
              var r, n2;
              n2 = [], typeof (r = t2) == "string" && (n2 = function(t3, e2, r2) {
                r2 || (r2 = 1);
                for (var n3, i2 = []; n3 = e2.exec(t3); )
                  i2.push(n3[r2]);
                return i2;
              }(r, /\((.*?)\)/g)), e = n2;
            } }), this.getOptions = function() {
              return e;
            }, this.setOptions = function(t2) {
              e = t2, this.sort && e.sort();
            }, this.addOption = function(t2) {
              t2 = (t2 = t2 || "").toString(), e.push(t2), this.sort && e.sort();
            }, this.removeOption = function(t2, r) {
              for (r = r || false, t2 = (t2 = t2 || "").toString(); e.indexOf(t2) !== -1 && (e.splice(e.indexOf(t2), 1), r !== false); )
                ;
            }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 18));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 18) : this.Ff = Z(this.Ff, 18);
            } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 19));
            }, set: function(t2) {
              this.combo === true && (Boolean(t2) === true ? this.Ff = K(this.Ff, 19) : this.Ff = Z(this.Ff, 19));
            } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 20));
            }, set: function(t2) {
              Boolean(t2) === true ? (this.Ff = K(this.Ff, 20), e.sort()) : this.Ff = Z(this.Ff, 20);
            } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 22));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 22) : this.Ff = Z(this.Ff, 22);
            } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 23));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
            } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 27));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 27) : this.Ff = Z(this.Ff, 27);
            } }), this.hasAppearanceStream = false;
          };
          H(ft, lt);
          var dt = function() {
            ft.call(this), this.fontName = "helvetica", this.combo = false;
          };
          H(dt, ft);
          var pt = function() {
            dt.call(this), this.combo = true;
          };
          H(pt, dt);
          var gt = function() {
            pt.call(this), this.edit = true;
          };
          H(gt, pt);
          var mt = function() {
            lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 15));
            }, set: function(t) {
              Boolean(t) === true ? this.Ff = K(this.Ff, 15) : this.Ff = Z(this.Ff, 15);
            } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 16));
            }, set: function(t) {
              Boolean(t) === true ? this.Ff = K(this.Ff, 16) : this.Ff = Z(this.Ff, 16);
            } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 17));
            }, set: function(t) {
              Boolean(t) === true ? this.Ff = K(this.Ff, 17) : this.Ff = Z(this.Ff, 17);
            } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 26));
            }, set: function(t) {
              Boolean(t) === true ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
            } });
            var e, r = {};
            Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
              var t = function(t2) {
                return t2;
              };
              if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), Object.keys(r).length !== 0) {
                var e2, n2 = [];
                for (e2 in n2.push("<<"), r)
                  n2.push("/" + e2 + " (" + R(t(r[e2])) + ")");
                return n2.push(">>"), n2.join("\n");
              }
            }, set: function(e2) {
              _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e2) === "object" && (r = e2);
            } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
              return r.CA || "";
            }, set: function(t) {
              typeof t == "string" && (r.CA = t);
            } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
              return e;
            }, set: function(t) {
              e = t;
            } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
              return e.substr(1, e.length - 1);
            }, set: function(t) {
              e = "/" + t;
            } });
          };
          H(mt, lt);
          var vt = function() {
            mt.call(this), this.pushButton = true;
          };
          H(vt, mt);
          var bt = function() {
            mt.call(this), this.radio = true, this.pushButton = false;
            var t = [];
            Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
              return t;
            }, set: function(e) {
              t = e !== void 0 ? e : [];
            } });
          };
          H(bt, mt);
          var yt = function() {
            var e, r;
            lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
              return e;
            }, set: function(t) {
              e = t;
            } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
              return r;
            }, set: function(t) {
              r = t;
            } });
            var n2, i2 = {};
            Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
              var t = function(t2) {
                return t2;
              };
              this.scope && (t = this.scope.internal.getEncryptor(this.objId));
              var e2, r2 = [];
              for (e2 in r2.push("<<"), i2)
                r2.push("/" + e2 + " (" + R(t(i2[e2])) + ")");
              return r2.push(">>"), r2.join("\n");
            }, set: function(e2) {
              _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e2) === "object" && (i2 = e2);
            } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
              return i2.CA || "";
            }, set: function(t) {
              typeof t == "string" && (i2.CA = t);
            } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
              return n2;
            }, set: function(t) {
              n2 = t;
            } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
              return n2.substr(1, n2.length - 1);
            }, set: function(t) {
              n2 = "/" + t;
            } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
          };
          H(yt, lt), bt.prototype.setAppearance = function(t) {
            if (!("createAppearanceStream" in t) || !("getCA" in t))
              throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
            for (var e in this.Kids)
              if (this.Kids.hasOwnProperty(e)) {
                var r = this.Kids[e];
                r.appearanceStreamContent = t.createAppearanceStream(r.optionName), r.caption = t.getCA();
              }
          }, bt.prototype.createOption = function(t) {
            var e = new yt();
            return e.Parent = this, e.optionName = t, this.Kids.push(e), xt.call(this.scope, e), e;
          };
          var wt = function() {
            mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
          };
          H(wt, mt);
          var Nt = function() {
            lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 13));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 13) : this.Ff = Z(this.Ff, 13);
            } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 21));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 21) : this.Ff = Z(this.Ff, 21);
            } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 23));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
            } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 24));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 24) : this.Ff = Z(this.Ff, 24);
            } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 25));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 25) : this.Ff = Z(this.Ff, 25);
            } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 26));
            }, set: function(t2) {
              Boolean(t2) === true ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
            } });
            var t = null;
            Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
              return t;
            }, set: function(e) {
              t = e;
            } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
              return t;
            }, set: function(e) {
              Number.isInteger(e) && (t = e);
            } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
              return this.V || this.DV;
            } });
          };
          H(Nt, lt);
          var Lt = function() {
            Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
              return Boolean(X(this.Ff, 14));
            }, set: function(t) {
              Boolean(t) === true ? this.Ff = K(this.Ff, 14) : this.Ff = Z(this.Ff, 14);
            } }), this.password = true;
          };
          H(Lt, Nt);
          var At = { CheckBox: { createAppearanceStream: function() {
            return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
          }, YesPushDown: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = [], n2 = t.scope.internal.getFont(t.fontName, t.fontStyle).id, i2 = t.scope.__private__.encodeColorString(t.color), a2 = tt(t, t.caption);
            return r.push("0.749023 g"), r.push("0 0 " + z(At.internal.getWidth(t)) + " " + z(At.internal.getHeight(t)) + " re"), r.push("f"), r.push("BMC"), r.push("q"), r.push("0 0 1 rg"), r.push("/" + n2 + " " + z(a2.fontSize) + " Tf " + i2), r.push("BT"), r.push(a2.text), r.push("ET"), r.push("Q"), r.push("EMC"), e.stream = r.join("\n"), e;
          }, YesNormal: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = t.scope.internal.getFont(t.fontName, t.fontStyle).id, n2 = t.scope.__private__.encodeColorString(t.color), i2 = [], a2 = At.internal.getHeight(t), o2 = At.internal.getWidth(t), s2 = tt(t, t.caption);
            return i2.push("1 g"), i2.push("0 0 " + z(o2) + " " + z(a2) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + z(o2 - 1) + " " + z(a2 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + r + " " + z(s2.fontSize) + " Tf " + n2), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e.stream = i2.join("\n"), e;
          }, OffPushDown: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = [];
            return r.push("0.749023 g"), r.push("0 0 " + z(At.internal.getWidth(t)) + " " + z(At.internal.getHeight(t)) + " re"), r.push("f"), e.stream = r.join("\n"), e;
          } }, RadioButton: { Circle: { createAppearanceStream: function(t) {
            var e = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
            return e.N[t] = At.RadioButton.Circle.YesNormal, e.D[t] = At.RadioButton.Circle.YesPushDown, e;
          }, getCA: function() {
            return "l";
          }, YesNormal: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = [], n2 = At.internal.getWidth(t) <= At.internal.getHeight(t) ? At.internal.getWidth(t) / 4 : At.internal.getHeight(t) / 4;
            n2 = Number((0.9 * n2).toFixed(5));
            var i2 = At.internal.Bezier_C, a2 = Number((n2 * i2).toFixed(5));
            return r.push("q"), r.push("1 0 0 1 " + U(At.internal.getWidth(t) / 2) + " " + U(At.internal.getHeight(t) / 2) + " cm"), r.push(n2 + " 0 m"), r.push(n2 + " " + a2 + " " + a2 + " " + n2 + " 0 " + n2 + " c"), r.push("-" + a2 + " " + n2 + " -" + n2 + " " + a2 + " -" + n2 + " 0 c"), r.push("-" + n2 + " -" + a2 + " -" + a2 + " -" + n2 + " 0 -" + n2 + " c"), r.push(a2 + " -" + n2 + " " + n2 + " -" + a2 + " " + n2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
          }, YesPushDown: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = [], n2 = At.internal.getWidth(t) <= At.internal.getHeight(t) ? At.internal.getWidth(t) / 4 : At.internal.getHeight(t) / 4;
            n2 = Number((0.9 * n2).toFixed(5));
            var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * At.internal.Bezier_C).toFixed(5));
            return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + U(At.internal.getWidth(t) / 2) + " " + U(At.internal.getHeight(t) / 2) + " cm"), r.push(i2 + " 0 m"), r.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r.push("f"), r.push("Q"), r.push("0 g"), r.push("q"), r.push("1 0 0 1 " + U(At.internal.getWidth(t) / 2) + " " + U(At.internal.getHeight(t) / 2) + " cm"), r.push(n2 + " 0 m"), r.push(n2 + " " + o2 + " " + o2 + " " + n2 + " 0 " + n2 + " c"), r.push("-" + o2 + " " + n2 + " -" + n2 + " " + o2 + " -" + n2 + " 0 c"), r.push("-" + n2 + " -" + o2 + " -" + o2 + " -" + n2 + " 0 -" + n2 + " c"), r.push(o2 + " -" + n2 + " " + n2 + " -" + o2 + " " + n2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
          }, OffPushDown: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = [], n2 = At.internal.getWidth(t) <= At.internal.getHeight(t) ? At.internal.getWidth(t) / 4 : At.internal.getHeight(t) / 4;
            n2 = Number((0.9 * n2).toFixed(5));
            var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5));
            return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + U(At.internal.getWidth(t) / 2) + " " + U(At.internal.getHeight(t) / 2) + " cm"), r.push(i2 + " 0 m"), r.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
          } }, Cross: { createAppearanceStream: function(t) {
            var e = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
            return e.N[t] = At.RadioButton.Cross.YesNormal, e.D[t] = At.RadioButton.Cross.YesPushDown, e;
          }, getCA: function() {
            return "8";
          }, YesNormal: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = [], n2 = At.internal.calculateCross(t);
            return r.push("q"), r.push("1 1 " + z(At.internal.getWidth(t) - 2) + " " + z(At.internal.getHeight(t) - 2) + " re"), r.push("W"), r.push("n"), r.push(z(n2.x1.x) + " " + z(n2.x1.y) + " m"), r.push(z(n2.x2.x) + " " + z(n2.x2.y) + " l"), r.push(z(n2.x4.x) + " " + z(n2.x4.y) + " m"), r.push(z(n2.x3.x) + " " + z(n2.x3.y) + " l"), r.push("s"), r.push("Q"), e.stream = r.join("\n"), e;
          }, YesPushDown: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = At.internal.calculateCross(t), n2 = [];
            return n2.push("0.749023 g"), n2.push("0 0 " + z(At.internal.getWidth(t)) + " " + z(At.internal.getHeight(t)) + " re"), n2.push("f"), n2.push("q"), n2.push("1 1 " + z(At.internal.getWidth(t) - 2) + " " + z(At.internal.getHeight(t) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(z(r.x1.x) + " " + z(r.x1.y) + " m"), n2.push(z(r.x2.x) + " " + z(r.x2.y) + " l"), n2.push(z(r.x4.x) + " " + z(r.x4.y) + " m"), n2.push(z(r.x3.x) + " " + z(r.x3.y) + " l"), n2.push("s"), n2.push("Q"), e.stream = n2.join("\n"), e;
          }, OffPushDown: function(t) {
            var e = V(t);
            e.scope = t.scope;
            var r = [];
            return r.push("0.749023 g"), r.push("0 0 " + z(At.internal.getWidth(t)) + " " + z(At.internal.getHeight(t)) + " re"), r.push("f"), e.stream = r.join("\n"), e;
          } } }, createDefaultAppearanceStream: function(t) {
            var e = t.scope.internal.getFont(t.fontName, t.fontStyle).id, r = t.scope.__private__.encodeColorString(t.color);
            return "/" + e + " " + t.fontSize + " Tf " + r;
          } };
          At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t) {
            var e = At.internal.getWidth(t), r = At.internal.getHeight(t), n2 = Math.min(e, r);
            return { x1: { x: (e - n2) / 2, y: (r - n2) / 2 + n2 }, x2: { x: (e - n2) / 2 + n2, y: (r - n2) / 2 }, x3: { x: (e - n2) / 2, y: (r - n2) / 2 }, x4: { x: (e - n2) / 2 + n2, y: (r - n2) / 2 + n2 } };
          } }, At.internal.getWidth = function(e) {
            var r = 0;
            return _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e) === "object" && (r = W(e.Rect[2])), r;
          }, At.internal.getHeight = function(e) {
            var r = 0;
            return _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e) === "object" && (r = W(e.Rect[3])), r;
          };
          var xt = q.addField = function(t) {
            if (at(this, t), !(t instanceof lt))
              throw new Error("Invalid argument passed to jsPDF.addField.");
            var e;
            return (e = t).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = false, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), t.page = t.scope.internal.getCurrentPageInfo().pageNumber, this;
          };
          q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
          var St = E.AcroForm;
          function _t(t) {
            return t.reduce(function(t2, e, r) {
              return t2[e] = r, t2;
            }, {});
          }
          !function(e) {
            e.__addimage__ = {};
            var r = "UNKNOWN", n2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i2 = e.__addimage__.getImageFileTypeByImageData = function(t, e2) {
              var i3, a3, o3, s3, c3, u2 = r;
              if ((e2 = e2 || r) === "RGBA" || t.data !== void 0 && t.data instanceof Uint8ClampedArray && "height" in t && "width" in t)
                return "RGBA";
              if (x2(t))
                for (c3 in n2)
                  for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
                    for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)
                      if (o3[i3][a3] !== void 0 && o3[i3][a3] !== t[a3]) {
                        s3 = false;
                        break;
                      }
                    if (s3 === true) {
                      u2 = c3;
                      break;
                    }
                  }
              else
                for (c3 in n2)
                  for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
                    for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)
                      if (o3[i3][a3] !== void 0 && o3[i3][a3] !== t.charCodeAt(a3)) {
                        s3 = false;
                        break;
                      }
                    if (s3 === true) {
                      u2 = c3;
                      break;
                    }
                  }
              return u2 === r && e2 !== r && (u2 = e2), u2;
            }, a2 = function t(e2) {
              for (var r2 = this.internal.write, n3 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); i3.indexOf("FlateEncode") !== -1; )
                i3.splice(i3.indexOf("FlateEncode"), 1);
              e2.objectId = this.internal.newObject();
              var a3 = [];
              if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e2.width }), a3.push({ key: "Height", value: e2.height }), e2.colorSpace === b2.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e2.palette.length / 3 - 1) + " " + ("sMask" in e2 && e2.sMask !== void 0 ? e2.objectId + 2 : e2.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e2.colorSpace }), e2.colorSpace === b2.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e2.bitsPerComponent }), "decodeParameters" in e2 && e2.decodeParameters !== void 0 && a3.push({ key: "DecodeParms", value: "<<" + e2.decodeParameters + ">>" }), "transparency" in e2 && Array.isArray(e2.transparency)) {
                for (var o3 = "", s3 = 0, c3 = e2.transparency.length; s3 < c3; s3++)
                  o3 += e2.transparency[s3] + " " + e2.transparency[s3] + " ";
                a3.push({ key: "Mask", value: "[" + o3 + "]" });
              }
              e2.sMask !== void 0 && a3.push({ key: "SMask", value: e2.objectId + 1 + " 0 R" });
              var u2 = e2.filter !== void 0 ? ["/" + e2.filter] : void 0;
              if (n3({ data: e2.data, additionalKeyValues: a3, alreadyAppliedFilters: u2, objectId: e2.objectId }), r2("endobj"), "sMask" in e2 && e2.sMask !== void 0) {
                var h3 = "/Predictor " + e2.predictor + " /Colors 1 /BitsPerComponent " + e2.bitsPerComponent + " /Columns " + e2.width, l3 = { width: e2.width, height: e2.height, colorSpace: "DeviceGray", bitsPerComponent: e2.bitsPerComponent, decodeParameters: h3, data: e2.sMask };
                "filter" in e2 && (l3.filter = e2.filter), t.call(this, l3);
              }
              if (e2.colorSpace === b2.INDEXED) {
                var f3 = this.internal.newObject();
                n3({ data: _2(new Uint8Array(e2.palette)), objectId: f3 }), r2("endobj");
              }
            }, o2 = function() {
              var t = this.internal.collections.addImage_images;
              for (var e2 in t)
                a2.call(this, t[e2]);
            }, s2 = function() {
              var t, e2 = this.internal.collections.addImage_images, r2 = this.internal.write;
              for (var n3 in e2)
                r2("/I" + (t = e2[n3]).index, t.objectId, "0", "R");
            }, c2 = function() {
              this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o2), this.internal.events.subscribe("putXobjectDict", s2));
            }, h2 = function() {
              var t = this.internal.collections.addImage_images;
              return c2.call(this), t;
            }, l2 = function() {
              return Object.keys(this.internal.collections.addImage_images).length;
            }, f2 = function(t) {
              return typeof e["process" + t.toUpperCase()] == "function";
            }, d2 = function(e2) {
              return _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e2) === "object" && e2.nodeType === 1;
            }, p2 = function(t, r2) {
              if (t.nodeName === "IMG" && t.hasAttribute("src")) {
                var n3 = "" + t.getAttribute("src");
                if (n3.indexOf("data:image/") === 0)
                  return u(unescape(n3).split("base64,").pop());
                var i3 = e.loadFile(n3, true);
                if (i3 !== void 0)
                  return i3;
              }
              if (t.nodeName === "CANVAS") {
                if (t.width === 0 || t.height === 0)
                  throw new Error("Given canvas must have data. Canvas width: " + t.width + ", height: " + t.height);
                var a3;
                switch (r2) {
                  case "PNG":
                    a3 = "image/png";
                    break;
                  case "WEBP":
                    a3 = "image/webp";
                    break;
                  case "JPEG":
                  case "JPG":
                  default:
                    a3 = "image/jpeg";
                }
                return u(t.toDataURL(a3, 1).split("base64,").pop());
              }
            }, g2 = function(t) {
              var e2 = this.internal.collections.addImage_images;
              if (e2) {
                for (var r2 in e2)
                  if (t === e2[r2].alias)
                    return e2[r2];
              }
            }, m2 = function(t, e2, r2) {
              return t || e2 || (t = -96, e2 = -96), t < 0 && (t = -1 * r2.width * 72 / t / this.internal.scaleFactor), e2 < 0 && (e2 = -1 * r2.height * 72 / e2 / this.internal.scaleFactor), t === 0 && (t = e2 * r2.width / r2.height), e2 === 0 && (e2 = t * r2.height / r2.width), [t, e2];
            }, v2 = function(t, e2, r2, n3, i3, a3) {
              var o3 = m2.call(this, r2, n3, i3), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u2 = h2.call(this);
              if (r2 = o3[0], n3 = o3[1], u2[i3.index] = i3, a3) {
                a3 *= Math.PI / 180;
                var l3 = Math.cos(a3), f3 = Math.sin(a3), d3 = function(t2) {
                  return t2.toFixed(4);
                }, p3 = [d3(l3), d3(f3), d3(-1 * f3), d3(l3), 0, 0, "cm"];
              }
              this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t), c3(e2 + n3), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(r2), "0", "0", s3(n3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(r2), "0", "0", s3(n3), s3(t), c3(e2 + n3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i3.index + " Do"), this.internal.write("Q");
            }, b2 = e.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
            e.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
            var y2 = e.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e.__addimage__.sHashCode = function(t) {
              var e2, r2, n3 = 0;
              if (typeof t == "string")
                for (r2 = t.length, e2 = 0; e2 < r2; e2++)
                  n3 = (n3 << 5) - n3 + t.charCodeAt(e2), n3 |= 0;
              else if (x2(t))
                for (r2 = t.byteLength / 2, e2 = 0; e2 < r2; e2++)
                  n3 = (n3 << 5) - n3 + t[e2], n3 |= 0;
              return n3;
            }, N2 = e.__addimage__.validateStringAsBase64 = function(t) {
              (t = t || "").toString().trim();
              var e2 = true;
              return t.length === 0 && (e2 = false), t.length % 4 != 0 && (e2 = false), /^[A-Za-z0-9+/]+$/.test(t.substr(0, t.length - 2)) === false && (e2 = false), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t.substr(-2)) === false && (e2 = false), e2;
            }, L2 = e.__addimage__.extractImageFromDataUrl = function(t) {
              var e2 = (t = t || "").split("base64,"), r2 = null;
              if (e2.length === 2) {
                var n3 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e2[0]);
                Array.isArray(n3) && (r2 = { mimeType: n3[1], charset: n3[2], data: e2[1] });
              }
              return r2;
            }, A2 = e.__addimage__.supportsArrayBuffer = function() {
              return typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined";
            };
            e.__addimage__.isArrayBuffer = function(t) {
              return A2() && t instanceof ArrayBuffer;
            };
            var x2 = e.__addimage__.isArrayBufferView = function(t) {
              return A2() && typeof Uint32Array != "undefined" && (t instanceof Int8Array || t instanceof Uint8Array || typeof Uint8ClampedArray != "undefined" && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array);
            }, S2 = e.__addimage__.binaryStringToUint8Array = function(t) {
              for (var e2 = t.length, r2 = new Uint8Array(e2), n3 = 0; n3 < e2; n3++)
                r2[n3] = t.charCodeAt(n3);
              return r2;
            }, _2 = e.__addimage__.arrayBufferToBinaryString = function(t) {
              for (var e2 = "", r2 = x2(t) ? t : new Uint8Array(t), n3 = 0; n3 < r2.length; n3 += 8192)
                e2 += String.fromCharCode.apply(null, r2.subarray(n3, n3 + 8192));
              return e2;
            };
            e.addImage = function() {
              var e2, n3, i3, a3, o3, s3, u2, h3, l3;
              if (typeof arguments[1] == "number" ? (n3 = r, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u2 = arguments[5], h3 = arguments[6], l3 = arguments[7]) : (n3 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u2 = arguments[6], h3 = arguments[7], l3 = arguments[8]), _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e2 = arguments[0]) === "object" && !d2(e2) && "imageData" in e2) {
                var f3 = e2;
                e2 = f3.imageData, n3 = f3.format || n3 || r, i3 = f3.x || i3 || 0, a3 = f3.y || a3 || 0, o3 = f3.w || f3.width || o3, s3 = f3.h || f3.height || s3, u2 = f3.alias || u2, h3 = f3.compression || h3, l3 = f3.rotation || f3.angle || l3;
              }
              var p3 = this.internal.getFilters();
              if (h3 === void 0 && p3.indexOf("FlateEncode") !== -1 && (h3 = "SLOW"), isNaN(i3) || isNaN(a3))
                throw new Error("Invalid coordinates passed to jsPDF.addImage");
              c2.call(this);
              var g3 = P2.call(this, e2, n3, u2, h3);
              return v2.call(this, i3, a3, o3, s3, g3, l3), this;
            };
            var P2 = function(t, n3, a3, o3) {
              var s3, c3, u2;
              if (typeof t == "string" && i2(t) === r) {
                t = unescape(t);
                var h3 = k2(t, false);
                (h3 !== "" || (h3 = e.loadFile(t, true)) !== void 0) && (t = h3);
              }
              if (d2(t) && (t = p2(t, n3)), n3 = i2(t, n3), !f2(n3))
                throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
              if (((u2 = a3) == null || u2.length === 0) && (a3 = function(t2) {
                return typeof t2 == "string" || x2(t2) ? w2(t2) : x2(t2.data) ? w2(t2.data) : null;
              }(t)), (s3 = g2.call(this, a3)) || (A2() && (t instanceof Uint8Array || n3 === "RGBA" || (c3 = t, t = S2(t))), s3 = this["process" + n3.toUpperCase()](t, l2.call(this), a3, function(t2) {
                return t2 && typeof t2 == "string" && (t2 = t2.toUpperCase()), t2 in e.image_compression ? t2 : y2.NONE;
              }(o3), c3)), !s3)
                throw new Error("An unknown error occurred whilst processing the image.");
              return s3;
            }, k2 = e.__addimage__.convertBase64ToBinaryString = function(t, e2) {
              var r2;
              e2 = typeof e2 != "boolean" || e2;
              var n3, i3 = "";
              if (typeof t == "string") {
                n3 = (r2 = L2(t)) !== null ? r2.data : t;
                try {
                  i3 = u(n3);
                } catch (t2) {
                  if (e2)
                    throw N2(n3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t2.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
                }
              }
              return i3;
            };
            e.getImageProperties = function(t) {
              var n3, a3, o3 = "";
              if (d2(t) && (t = p2(t)), typeof t == "string" && i2(t) === r && ((o3 = k2(t, false)) === "" && (o3 = e.loadFile(t) || ""), t = o3), a3 = i2(t), !f2(a3))
                throw new Error("addImage does not support files of type '" + a3 + "', please ensure that a plugin for '" + a3 + "' support is added.");
              if (!A2() || t instanceof Uint8Array || (t = S2(t)), !(n3 = this["process" + a3.toUpperCase()](t)))
                throw new Error("An unknown error occurred whilst processing the image");
              return n3.fileType = a3, n3;
            };
          }(E.API), function(t) {
            var e = function(t2) {
              if (t2 !== void 0 && t2 != "")
                return true;
            };
            E.API.events.push(["addPage", function(t2) {
              this.internal.getPageInfo(t2.pageNumber).pageContext.annotations = [];
            }]), t.events.push(["putPage", function(t2) {
              for (var r, n2, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t2.objId), c2 = t2.pageContext.annotations, u2 = false, h2 = 0; h2 < c2.length && !u2; h2++)
                switch ((r = c2[h2]).type) {
                  case "link":
                    (e(r.options.url) || e(r.options.pageNumber)) && (u2 = true);
                    break;
                  case "reference":
                  case "text":
                  case "freetext":
                    u2 = true;
                }
              if (u2 != 0) {
                this.internal.write("/Annots [");
                for (var l2 = 0; l2 < c2.length; l2++) {
                  r = c2[l2];
                  var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t2.objId);
                  switch (r.type) {
                    case "reference":
                      this.internal.write(" " + r.object.objId + " 0 R ");
                      break;
                    case "text":
                      var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p2.objId), v2 = r.title || "Note";
                      i2 = "<</Type /Annot /Subtype /Text " + (n2 = "/Rect [" + a2(r.bounds.x) + " " + o2(r.bounds.y + r.bounds.h) + " " + a2(r.bounds.x + r.bounds.w) + " " + o2(r.bounds.y) + "] ") + "/Contents (" + f2(m2(r.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f2(m2(v2)) + ") >>", p2.content = i2;
                      var b2 = p2.objId + " 0 R";
                      i2 = "<</Type /Annot /Subtype /Popup " + (n2 = "/Rect [" + a2(r.bounds.x + 30) + " " + o2(r.bounds.y + r.bounds.h) + " " + a2(r.bounds.x + r.bounds.w + 30) + " " + o2(r.bounds.y) + "] ") + " /Parent " + b2, r.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
                      break;
                    case "freetext":
                      n2 = "/Rect [" + a2(r.bounds.x) + " " + o2(r.bounds.y) + " " + a2(r.bounds.x + r.bounds.w) + " " + o2(r.bounds.y + r.bounds.h) + "] ";
                      var y2 = r.color || "#000000";
                      i2 = "<</Type /Annot /Subtype /FreeText " + n2 + "/Contents (" + f2(d2(r.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
                      break;
                    case "link":
                      if (r.options.name) {
                        var w2 = this.annotations._nameMap[r.options.name];
                        r.options.pageNumber = w2.page, r.options.top = w2.y;
                      } else
                        r.options.top || (r.options.top = 0);
                      if (n2 = "/Rect [" + r.finalBounds.x + " " + r.finalBounds.y + " " + r.finalBounds.w + " " + r.finalBounds.h + "] ", i2 = "", r.options.url)
                        i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(r.options.url)) + ") >>";
                      else if (r.options.pageNumber) {
                        switch (i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r.options.pageNumber).objId + " 0 R", r.options.magFactor = r.options.magFactor || "XYZ", r.options.magFactor) {
                          case "Fit":
                            i2 += " /Fit]";
                            break;
                          case "FitH":
                            i2 += " /FitH " + r.options.top + "]";
                            break;
                          case "FitV":
                            r.options.left = r.options.left || 0, i2 += " /FitV " + r.options.left + "]";
                            break;
                          case "XYZ":
                          default:
                            var N2 = o2(r.options.top);
                            r.options.left = r.options.left || 0, r.options.zoom === void 0 && (r.options.zoom = 0), i2 += " /XYZ " + r.options.left + " " + N2 + " " + r.options.zoom + "]";
                        }
                      }
                      i2 != "" && (i2 += " >>", this.internal.write(i2));
                  }
                }
                this.internal.write("]");
              }
            }]), t.createAnnotation = function(t2) {
              var e2 = this.internal.getCurrentPageInfo();
              switch (t2.type) {
                case "link":
                  this.link(t2.bounds.x, t2.bounds.y, t2.bounds.w, t2.bounds.h, t2);
                  break;
                case "text":
                case "freetext":
                  e2.pageContext.annotations.push(t2);
              }
            }, t.link = function(t2, e2, r, n2, i2) {
              var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
              a2.pageContext.annotations.push({ finalBounds: { x: o2(t2), y: s2(e2), w: o2(t2 + r), h: s2(e2 + n2) }, options: i2, type: "link" });
            }, t.textWithLink = function(t2, e2, r, n2) {
              var i2, a2, o2 = this.getTextWidth(t2), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
              if (n2.maxWidth !== void 0) {
                a2 = n2.maxWidth;
                var c2 = this.splitTextToSize(t2, a2).length;
                i2 = Math.ceil(s2 * c2);
              } else
                a2 = o2, i2 = s2;
              return this.text(t2, e2, r, n2), r += 0.2 * s2, n2.align === "center" && (e2 -= o2 / 2), n2.align === "right" && (e2 -= o2), this.link(e2, r - s2, a2, i2, n2), o2;
            }, t.getTextWidth = function(t2) {
              var e2 = this.internal.getFontSize();
              return this.getStringUnitWidth(t2) * e2 / this.internal.scaleFactor;
            };
          }(E.API), function(t) {
            var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];
            t.__arabicParser__ = {};
            var a2 = t.__arabicParser__.isInArabicSubstitutionA = function(t2) {
              return e[t2.charCodeAt(0)] !== void 0;
            }, o2 = t.__arabicParser__.isArabicLetter = function(t2) {
              return typeof t2 == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t2);
            }, s2 = t.__arabicParser__.isArabicEndLetter = function(t2) {
              return o2(t2) && a2(t2) && e[t2.charCodeAt(0)].length <= 2;
            }, c2 = t.__arabicParser__.isArabicAlfLetter = function(t2) {
              return o2(t2) && i2.indexOf(t2.charCodeAt(0)) >= 0;
            };
            t.__arabicParser__.arabicLetterHasIsolatedForm = function(t2) {
              return o2(t2) && a2(t2) && e[t2.charCodeAt(0)].length >= 1;
            };
            var u2 = t.__arabicParser__.arabicLetterHasFinalForm = function(t2) {
              return o2(t2) && a2(t2) && e[t2.charCodeAt(0)].length >= 2;
            };
            t.__arabicParser__.arabicLetterHasInitialForm = function(t2) {
              return o2(t2) && a2(t2) && e[t2.charCodeAt(0)].length >= 3;
            };
            var h2 = t.__arabicParser__.arabicLetterHasMedialForm = function(t2) {
              return o2(t2) && a2(t2) && e[t2.charCodeAt(0)].length == 4;
            }, l2 = t.__arabicParser__.resolveLigatures = function(t2) {
              var e2 = 0, n3 = r, i3 = "", a3 = 0;
              for (e2 = 0; e2 < t2.length; e2 += 1)
                n3[t2.charCodeAt(e2)] !== void 0 ? (a3++, typeof (n3 = n3[t2.charCodeAt(e2)]) == "number" && (i3 += String.fromCharCode(n3), n3 = r, a3 = 0), e2 === t2.length - 1 && (n3 = r, i3 += t2.charAt(e2 - (a3 - 1)), e2 -= a3 - 1, a3 = 0)) : (n3 = r, i3 += t2.charAt(e2 - a3), e2 -= a3, a3 = 0);
              return i3;
            };
            t.__arabicParser__.isArabicDiacritic = function(t2) {
              return t2 !== void 0 && n2[t2.charCodeAt(0)] !== void 0;
            };
            var f2 = t.__arabicParser__.getCorrectForm = function(t2, e2, r2) {
              return o2(t2) ? a2(t2) === false ? -1 : !u2(t2) || !o2(e2) && !o2(r2) || !o2(r2) && s2(e2) || s2(t2) && !o2(e2) || s2(t2) && c2(e2) || s2(t2) && s2(e2) ? 0 : h2(t2) && o2(e2) && !s2(e2) && o2(r2) && u2(r2) ? 3 : s2(t2) || !o2(r2) ? 1 : 2 : -1;
            }, d2 = function(t2) {
              var r2 = 0, n3 = 0, i3 = 0, a3 = "", s3 = "", c3 = "", u3 = (t2 = t2 || "").split("\\s+"), h3 = [];
              for (r2 = 0; r2 < u3.length; r2 += 1) {
                for (h3.push(""), n3 = 0; n3 < u3[r2].length; n3 += 1)
                  a3 = u3[r2][n3], s3 = u3[r2][n3 - 1], c3 = u3[r2][n3 + 1], o2(a3) ? (i3 = f2(a3, s3, c3), h3[r2] += i3 !== -1 ? String.fromCharCode(e[a3.charCodeAt(0)][i3]) : a3) : h3[r2] += a3;
                h3[r2] = l2(h3[r2]);
              }
              return h3.join(" ");
            }, p2 = t.__arabicParser__.processArabic = t.processArabic = function() {
              var t2, e2 = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, r2 = [];
              if (Array.isArray(e2)) {
                var n3 = 0;
                for (r2 = [], n3 = 0; n3 < e2.length; n3 += 1)
                  Array.isArray(e2[n3]) ? r2.push([d2(e2[n3][0]), e2[n3][1], e2[n3][2]]) : r2.push([d2(e2[n3])]);
                t2 = r2;
              } else
                t2 = d2(e2);
              return typeof arguments[0] == "string" ? t2 : (arguments[0].text = t2, arguments[0]);
            };
            t.events.push(["preProcessText", p2]);
          }(E.API), E.API.autoPrint = function(t) {
            var e;
            switch ((t = t || {}).variant = t.variant || "non-conform", t.variant) {
              case "javascript":
                this.addJS("print({});");
                break;
              case "non-conform":
              default:
                this.internal.events.subscribe("postPutResources", function() {
                  e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
                }), this.internal.events.subscribe("putCatalog", function() {
                  this.internal.out("/OpenAction " + e + " 0 R");
                });
            }
            return this;
          }, function(t) {
            var e = function() {
              var t2 = void 0;
              Object.defineProperty(this, "pdf", { get: function() {
                return t2;
              }, set: function(e3) {
                t2 = e3;
              } });
              var e2 = 150;
              Object.defineProperty(this, "width", { get: function() {
                return e2;
              }, set: function(t3) {
                e2 = isNaN(t3) || Number.isInteger(t3) === false || t3 < 0 ? 150 : t3, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e2 + 1);
              } });
              var r = 300;
              Object.defineProperty(this, "height", { get: function() {
                return r;
              }, set: function(t3) {
                r = isNaN(t3) || Number.isInteger(t3) === false || t3 < 0 ? 300 : t3, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
              } });
              var n2 = [];
              Object.defineProperty(this, "childNodes", { get: function() {
                return n2;
              }, set: function(t3) {
                n2 = t3;
              } });
              var i2 = {};
              Object.defineProperty(this, "style", { get: function() {
                return i2;
              }, set: function(t3) {
                i2 = t3;
              } }), Object.defineProperty(this, "parentNode", {});
            };
            e.prototype.getContext = function(t2, e2) {
              var r;
              if ((t2 = t2 || "2d") !== "2d")
                return null;
              for (r in e2)
                this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = e2[r]);
              return this.pdf.context2d._canvas = this, this.pdf.context2d;
            }, e.prototype.toDataURL = function() {
              throw new Error("toDataURL is not implemented.");
            }, t.events.push(["initialized", function() {
              this.canvas = new e(), this.canvas.pdf = this;
            }]);
          }(E.API), function(e) {
            var r = { left: 0, top: 0, bottom: 0, right: 0 }, n2 = false, i2 = function() {
              this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
            }, a2 = function() {
              this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
            }, o2 = function() {
              var t = arguments[0];
              Object.defineProperty(this, "x", { enumerable: true, get: function() {
                return t;
              }, set: function(e3) {
                t = e3;
              } });
              var e2 = arguments[1];
              Object.defineProperty(this, "y", { enumerable: true, get: function() {
                return e2;
              }, set: function(t2) {
                e2 = t2;
              } });
              var r2 = arguments[2];
              Object.defineProperty(this, "width", { enumerable: true, get: function() {
                return r2;
              }, set: function(t2) {
                r2 = t2;
              } });
              var n3 = arguments[3];
              Object.defineProperty(this, "height", { enumerable: true, get: function() {
                return n3;
              }, set: function(t2) {
                n3 = t2;
              } });
              var i3 = arguments[4];
              Object.defineProperty(this, "text", { enumerable: true, get: function() {
                return i3;
              }, set: function(t2) {
                i3 = t2;
              } });
              var a3 = arguments[5];
              Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
                return a3;
              }, set: function(t2) {
                a3 = t2;
              } });
              var o3 = arguments[6];
              return Object.defineProperty(this, "align", { enumerable: true, get: function() {
                return o3;
              }, set: function(t2) {
                o3 = t2;
              } }), this;
            };
            o2.prototype.clone = function() {
              return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
            }, o2.prototype.toArray = function() {
              return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
            }, e.setHeaderFunction = function(t) {
              return i2.call(this), this.internal.__cell__.headerFunction = typeof t == "function" ? t : void 0, this;
            }, e.getTextDimensions = function(t, e2) {
              i2.call(this);
              var r2 = (e2 = e2 || {}).fontSize || this.getFontSize(), n3 = e2.font || this.getFont(), a3 = e2.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c3 = 0, u2 = this;
              if (!Array.isArray(t) && typeof t != "string") {
                if (typeof t != "number")
                  throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
                t = String(t);
              }
              var h2 = e2.maxWidth;
              h2 > 0 ? typeof t == "string" ? t = this.splitTextToSize(t, h2) : Object.prototype.toString.call(t) === "[object Array]" && (t = t.reduce(function(t2, e3) {
                return t2.concat(u2.splitTextToSize(e3, h2));
              }, [])) : t = Array.isArray(t) ? t : [t];
              for (var l2 = 0; l2 < t.length; l2++)
                o3 < (c3 = this.getStringUnitWidth(t[l2], { font: n3 }) * r2) && (o3 = c3);
              return o3 !== 0 && (s3 = t.length), { w: o3 /= a3, h: Math.max((s3 * r2 * this.getLineHeightFactor() - r2 * (this.getLineHeightFactor() - 1)) / a3, 0) };
            }, e.cellAddPage = function() {
              i2.call(this), this.addPage();
              var t = this.internal.__cell__.margins || r;
              return this.internal.__cell__.lastCell = new o2(t.left, t.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
            };
            var s2 = e.cell = function() {
              var t;
              t = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i2.call(this);
              var e2 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || r, c3 = this.internal.__cell__.tableHeaderRow, u2 = this.internal.__cell__.printHeaders;
              return e2.lineNumber !== void 0 && (e2.lineNumber === t.lineNumber ? (t.x = (e2.x || 0) + (e2.width || 0), t.y = e2.y || 0) : e2.y + e2.height + t.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t.y = s3.top, u2 && c3 && (this.printHeaderRow(t.lineNumber, true), t.y += c3[0].height)) : t.y = e2.y + e2.height || t.y), t.text[0] !== void 0 && (this.rect(t.x, t.y, t.width, t.height, n2 === true ? "FD" : void 0), t.align === "right" ? this.text(t.text, t.x + t.width - a3, t.y + a3, { align: "right", baseline: "top" }) : t.align === "center" ? this.text(t.text, t.x + t.width / 2, t.y + a3, { align: "center", baseline: "top", maxWidth: t.width - a3 - a3 }) : this.text(t.text, t.x + a3, t.y + a3, { align: "left", baseline: "top", maxWidth: t.width - a3 - a3 })), this.internal.__cell__.lastCell = t, this;
            };
            e.table = function(e2, n3, u2, h2, l2) {
              if (i2.call(this), !u2)
                throw new Error("No data for PDF table.");
              var f2, d2, p2, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], A2 = (l2 = l2 || {}).autoSize || false, x2 = l2.printHeaders !== false, S2 = l2.css && l2.css["font-size"] !== void 0 ? 16 * l2.css["font-size"] : l2.fontSize || 12, _2 = l2.margins || Object.assign({ width: this.getPageWidth() }, r), P2 = typeof l2.padding == "number" ? l2.padding : 3, k2 = l2.headerBackgroundColor || "#c8c8c8", I2 = l2.headerTextColor || "#000";
              if (a2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), h2 == null)
                v2 = m2 = Object.keys(u2[0]), b2 = m2.map(function() {
                  return "left";
                });
              else if (Array.isArray(h2) && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(h2[0]) === "object")
                for (m2 = h2.map(function(t) {
                  return t.name;
                }), v2 = h2.map(function(t) {
                  return t.prompt || t.name || "";
                }), b2 = h2.map(function(t) {
                  return t.align || "left";
                }), f2 = 0; f2 < h2.length; f2 += 1)
                  w2[h2[f2].name] = h2[f2].width * (19.049976 / 25.4);
              else
                Array.isArray(h2) && typeof h2[0] == "string" && (v2 = m2 = h2, b2 = m2.map(function() {
                  return "left";
                }));
              if (A2 || Array.isArray(h2) && typeof h2[0] == "string")
                for (f2 = 0; f2 < m2.length; f2 += 1) {
                  for (y2[g2 = m2[f2]] = u2.map(function(t) {
                    return t[g2];
                  }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p2 = 0; p2 < d2.length; p2 += 1)
                    N2.push(this.getTextDimensions(d2[p2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
                  w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
                }
              if (x2) {
                var F2 = {};
                for (f2 = 0; f2 < m2.length; f2 += 1)
                  F2[m2[f2]] = {}, F2[m2[f2]].text = v2[f2], F2[m2[f2]].align = b2[f2];
                var C2 = c2.call(this, F2, w2);
                L2 = m2.map(function(t) {
                  return new o2(e2, n3, w2[t], C2, F2[t].text, void 0, F2[t].align);
                }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
              }
              var j2 = h2.reduce(function(t, e3) {
                return t[e3.name] = e3.align, t;
              }, {});
              for (f2 = 0; f2 < u2.length; f2 += 1) {
                "rowStart" in l2 && l2.rowStart instanceof Function && l2.rowStart({ row: f2, data: u2[f2] }, this);
                var O2 = c2.call(this, u2[f2], w2);
                for (p2 = 0; p2 < m2.length; p2 += 1) {
                  var B2 = u2[f2][m2[p2]];
                  "cellStart" in l2 && l2.cellStart instanceof Function && l2.cellStart({ row: f2, col: p2, data: B2 }, this), s2.call(this, new o2(e2, n3, w2[m2[p2]], O2, B2, f2 + 2, j2[m2[p2]]));
                }
              }
              return this.internal.__cell__.table_x = e2, this.internal.__cell__.table_y = n3, this;
            };
            var c2 = function(t, e2) {
              var r2 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
              return Object.keys(t).map(function(n4) {
                var i4 = t[n4];
                return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e2[n4] - r2 - r2);
              }, this).map(function(t2) {
                return this.getLineHeightFactor() * t2.length * n3 / i3 + r2 + r2;
              }, this).reduce(function(t2, e3) {
                return Math.max(t2, e3);
              }, 0);
            };
            e.setTableHeaderRow = function(t) {
              i2.call(this), this.internal.__cell__.tableHeaderRow = t;
            }, e.printHeaderRow = function(t, e2) {
              if (i2.call(this), !this.internal.__cell__.tableHeaderRow)
                throw new Error("Property tableHeaderRow does not exist.");
              var r2;
              if (n2 = true, typeof this.internal.__cell__.headerFunction == "function") {
                var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
                this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
              }
              this.setFont(void 0, "bold");
              for (var c3 = [], u2 = 0; u2 < this.internal.__cell__.tableHeaderRow.length; u2 += 1) {
                r2 = this.internal.__cell__.tableHeaderRow[u2].clone(), e2 && (r2.y = this.internal.__cell__.margins.top || 0, c3.push(r2)), r2.lineNumber = t;
                var h2 = this.getTextColor();
                this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, r2), this.setTextColor(h2);
              }
              c3.length > 0 && this.setTableHeaderRow(c3), this.setFont(void 0, "normal"), n2 = false;
            };
          }(E.API);
          var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], It = _t(kt), Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ct = _t(Ft);
          function jt(t) {
            var e = t.family.replace(/"|'/g, "").toLowerCase(), r = function(t2) {
              return Pt[t2 = t2 || "normal"] ? t2 : "normal";
            }(t.style), n2 = function(t2) {
              if (!t2)
                return 400;
              if (typeof t2 == "number")
                return t2 >= 100 && t2 <= 900 && t2 % 100 == 0 ? t2 : 400;
              if (/^\d00$/.test(t2))
                return parseInt(t2);
              switch (t2) {
                case "bold":
                  return 700;
                case "normal":
                default:
                  return 400;
              }
            }(t.weight), i2 = function(t2) {
              return typeof It[t2 = t2 || "normal"] == "number" ? t2 : "normal";
            }(t.stretch);
            return { family: e, style: r, weight: n2, stretch: i2, src: t.src || [], ref: t.ref || { name: e, style: [i2, r, n2].join(" ") } };
          }
          function Ot(t, e, r, n2) {
            var i2;
            for (i2 = r; i2 >= 0 && i2 < e.length; i2 += n2)
              if (t[e[i2]])
                return t[e[i2]];
            for (i2 = r; i2 >= 0 && i2 < e.length; i2 -= n2)
              if (t[e[i2]])
                return t[e[i2]];
          }
          var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
          function Et(t) {
            return [t.stretch, t.style, t.weight, t.family].join(" ");
          }
          function qt(t, e, r) {
            for (var n2 = (r = r || {}).defaultFontFamily || "times", i2 = Object.assign({}, Bt, r.genericFontFamilies || {}), a2 = null, o2 = null, s2 = 0; s2 < e.length; ++s2)
              if (i2[(a2 = jt(e[s2])).family] && (a2.family = i2[a2.family]), t.hasOwnProperty(a2.family)) {
                o2 = t[a2.family];
                break;
              }
            if (!(o2 = o2 || t[n2]))
              throw new Error("Could not find a font-family for the rule '" + Et(a2) + "' and default family '" + n2 + "'.");
            if (o2 = function(t2, e2) {
              if (e2[t2])
                return e2[t2];
              var r2 = It[t2], n3 = r2 <= It.normal ? -1 : 1, i3 = Ot(e2, kt, r2, n3);
              if (!i3)
                throw new Error("Could not find a matching font-stretch value for " + t2);
              return i3;
            }(a2.stretch, o2), o2 = function(t2, e2) {
              if (e2[t2])
                return e2[t2];
              for (var r2 = Pt[t2], n3 = 0; n3 < r2.length; ++n3)
                if (e2[r2[n3]])
                  return e2[r2[n3]];
              throw new Error("Could not find a matching font-style for " + t2);
            }(a2.style, o2), !(o2 = function(t2, e2) {
              if (e2[t2])
                return e2[t2];
              if (t2 === 400 && e2[500])
                return e2[500];
              if (t2 === 500 && e2[400])
                return e2[400];
              var r2 = Ct[t2], n3 = Ot(e2, Ft, r2, t2 < 400 ? -1 : 1);
              if (!n3)
                throw new Error("Could not find a matching font-weight for value " + t2);
              return n3;
            }(a2.weight, o2)))
              throw new Error("Failed to resolve a font for the rule '" + Et(a2) + "'.");
            return o2;
          }
          function Dt(t) {
            return t.trimLeft();
          }
          function Rt(t, e) {
            for (var r = 0; r < t.length; ) {
              if (t.charAt(r) === e)
                return [t.substring(0, r), t.substring(r + 1)];
              r += 1;
            }
            return null;
          }
          function Tt(t) {
            var e = t.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
            return e === null ? null : [e[0], t.substring(e[0].length)];
          }
          var zt, Ut, Ht, Wt = ["times"];
          !function(e) {
            var r, n2, i2, o2, s2, c2, u2, h2, l2, d2 = function(t) {
              return t = t || {}, this.isStrokeTransparent = t.isStrokeTransparent || false, this.strokeOpacity = t.strokeOpacity || 1, this.strokeStyle = t.strokeStyle || "#000000", this.fillStyle = t.fillStyle || "#000000", this.isFillTransparent = t.isFillTransparent || false, this.fillOpacity = t.fillOpacity || 1, this.font = t.font || "10px sans-serif", this.textBaseline = t.textBaseline || "alphabetic", this.textAlign = t.textAlign || "left", this.lineWidth = t.lineWidth || 1, this.lineJoin = t.lineJoin || "miter", this.lineCap = t.lineCap || "butt", this.path = t.path || [], this.transform = t.transform !== void 0 ? t.transform.clone() : new h2(), this.globalCompositeOperation = t.globalCompositeOperation || "normal", this.globalAlpha = t.globalAlpha || 1, this.clip_path = t.clip_path || [], this.currentPoint = t.currentPoint || new c2(), this.miterLimit = t.miterLimit || 10, this.lastPoint = t.lastPoint || new c2(), this.lineDashOffset = t.lineDashOffset || 0, this.lineDash = t.lineDash || [], this.margin = t.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof t.ignoreClearRect != "boolean" || t.ignoreClearRect, this;
            };
            e.events.push(["initialized", function() {
              this.context2d = new p2(this), r = this.internal.f2, n2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, o2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u2 = this.internal.Rectangle, h2 = this.internal.Matrix, l2 = new d2();
            }]);
            var p2 = function(t) {
              Object.defineProperty(this, "canvas", { get: function() {
                return { parentNode: false, style: false };
              } });
              var e2 = t;
              Object.defineProperty(this, "pdf", { get: function() {
                return e2;
              } });
              var r2 = false;
              Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
                return r2;
              }, set: function(t2) {
                r2 = Boolean(t2);
              } });
              var n3 = false;
              Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
                return n3;
              }, set: function(t2) {
                n3 = Boolean(t2);
              } });
              var i3 = 0;
              Object.defineProperty(this, "posX", { get: function() {
                return i3;
              }, set: function(t2) {
                isNaN(t2) || (i3 = t2);
              } });
              var a2 = 0;
              Object.defineProperty(this, "posY", { get: function() {
                return a2;
              }, set: function(t2) {
                isNaN(t2) || (a2 = t2);
              } }), Object.defineProperty(this, "margin", { get: function() {
                return l2.margin;
              }, set: function(t2) {
                var e3;
                typeof t2 == "number" ? e3 = [t2, t2, t2, t2] : ((e3 = new Array(4))[0] = t2[0], e3[1] = t2.length >= 2 ? t2[1] : e3[0], e3[2] = t2.length >= 3 ? t2[2] : e3[0], e3[3] = t2.length >= 4 ? t2[3] : e3[1]), l2.margin = e3;
              } });
              var o3 = false;
              Object.defineProperty(this, "autoPaging", { get: function() {
                return o3;
              }, set: function(t2) {
                o3 = t2;
              } });
              var s3 = 0;
              Object.defineProperty(this, "lastBreak", { get: function() {
                return s3;
              }, set: function(t2) {
                s3 = t2;
              } });
              var c3 = [];
              Object.defineProperty(this, "pageBreaks", { get: function() {
                return c3;
              }, set: function(t2) {
                c3 = t2;
              } }), Object.defineProperty(this, "ctx", { get: function() {
                return l2;
              }, set: function(t2) {
                t2 instanceof d2 && (l2 = t2);
              } }), Object.defineProperty(this, "path", { get: function() {
                return l2.path;
              }, set: function(t2) {
                l2.path = t2;
              } });
              var u3 = [];
              Object.defineProperty(this, "ctxStack", { get: function() {
                return u3;
              }, set: function(t2) {
                u3 = t2;
              } }), Object.defineProperty(this, "fillStyle", { get: function() {
                return this.ctx.fillStyle;
              }, set: function(t2) {
                var e3;
                e3 = g2(t2), this.ctx.fillStyle = e3.style, this.ctx.isFillTransparent = e3.a === 0, this.ctx.fillOpacity = e3.a, this.pdf.setFillColor(e3.r, e3.g, e3.b, { a: e3.a }), this.pdf.setTextColor(e3.r, e3.g, e3.b, { a: e3.a });
              } }), Object.defineProperty(this, "strokeStyle", { get: function() {
                return this.ctx.strokeStyle;
              }, set: function(t2) {
                var e3 = g2(t2);
                this.ctx.strokeStyle = e3.style, this.ctx.isStrokeTransparent = e3.a === 0, this.ctx.strokeOpacity = e3.a, e3.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (e3.a, this.pdf.setDrawColor(e3.r, e3.g, e3.b));
              } }), Object.defineProperty(this, "lineCap", { get: function() {
                return this.ctx.lineCap;
              }, set: function(t2) {
                ["butt", "round", "square"].indexOf(t2) !== -1 && (this.ctx.lineCap = t2, this.pdf.setLineCap(t2));
              } }), Object.defineProperty(this, "lineWidth", { get: function() {
                return this.ctx.lineWidth;
              }, set: function(t2) {
                isNaN(t2) || (this.ctx.lineWidth = t2, this.pdf.setLineWidth(t2));
              } }), Object.defineProperty(this, "lineJoin", { get: function() {
                return this.ctx.lineJoin;
              }, set: function(t2) {
                ["bevel", "round", "miter"].indexOf(t2) !== -1 && (this.ctx.lineJoin = t2, this.pdf.setLineJoin(t2));
              } }), Object.defineProperty(this, "miterLimit", { get: function() {
                return this.ctx.miterLimit;
              }, set: function(t2) {
                isNaN(t2) || (this.ctx.miterLimit = t2, this.pdf.setMiterLimit(t2));
              } }), Object.defineProperty(this, "textBaseline", { get: function() {
                return this.ctx.textBaseline;
              }, set: function(t2) {
                this.ctx.textBaseline = t2;
              } }), Object.defineProperty(this, "textAlign", { get: function() {
                return this.ctx.textAlign;
              }, set: function(t2) {
                ["right", "end", "center", "left", "start"].indexOf(t2) !== -1 && (this.ctx.textAlign = t2);
              } });
              var h3 = null;
              function f2(t2, e3) {
                if (h3 === null) {
                  var r3 = function(t3) {
                    var e4 = [];
                    return Object.keys(t3).forEach(function(r4) {
                      t3[r4].forEach(function(t4) {
                        var n4 = null;
                        switch (t4) {
                          case "bold":
                            n4 = { family: r4, weight: "bold" };
                            break;
                          case "italic":
                            n4 = { family: r4, style: "italic" };
                            break;
                          case "bolditalic":
                            n4 = { family: r4, weight: "bold", style: "italic" };
                            break;
                          case "":
                          case "normal":
                            n4 = { family: r4 };
                        }
                        n4 !== null && (n4.ref = { name: r4, style: t4 }, e4.push(n4));
                      });
                    }), e4;
                  }(t2.getFontList());
                  h3 = function(t3) {
                    for (var e4 = {}, r4 = 0; r4 < t3.length; ++r4) {
                      var n4 = jt(t3[r4]), i4 = n4.family, a3 = n4.stretch, o4 = n4.style, s4 = n4.weight;
                      e4[i4] = e4[i4] || {}, e4[i4][a3] = e4[i4][a3] || {}, e4[i4][a3][o4] = e4[i4][a3][o4] || {}, e4[i4][a3][o4][s4] = n4;
                    }
                    return e4;
                  }(r3.concat(e3));
                }
                return h3;
              }
              var p3 = null;
              Object.defineProperty(this, "fontFaces", { get: function() {
                return p3;
              }, set: function(t2) {
                h3 = null, p3 = t2;
              } }), Object.defineProperty(this, "font", { get: function() {
                return this.ctx.font;
              }, set: function(t2) {
                var e3;
                if (this.ctx.font = t2, (e3 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t2)) !== null) {
                  var r3 = e3[1], n4 = (e3[2], e3[3]), i4 = e3[4], a3 = (e3[5], e3[6]), o4 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
                  i4 = o4 === "px" ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : o4 === "em" ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
                  var s4 = function(t3) {
                    var e4, r4, n5 = [], i5 = t3.trim();
                    if (i5 === "")
                      return Wt;
                    if (i5 in Mt)
                      return [Mt[i5]];
                    for (; i5 !== ""; ) {
                      switch (r4 = null, e4 = (i5 = Dt(i5)).charAt(0)) {
                        case '"':
                        case "'":
                          r4 = Rt(i5.substring(1), e4);
                          break;
                        default:
                          r4 = Tt(i5);
                      }
                      if (r4 === null)
                        return Wt;
                      if (n5.push(r4[0]), (i5 = Dt(r4[1])) !== "" && i5.charAt(0) !== ",")
                        return Wt;
                      i5 = i5.replace(/^,/, "");
                    }
                    return n5;
                  }(a3);
                  if (this.fontFaces) {
                    var c4 = qt(f2(this.pdf, this.fontFaces), s4.map(function(t3) {
                      return { family: t3, stretch: "normal", weight: n4, style: r3 };
                    }));
                    this.pdf.setFont(c4.ref.name, c4.ref.style);
                  } else {
                    var u4 = "";
                    (n4 === "bold" || parseInt(n4, 10) >= 700 || r3 === "bold") && (u4 = "bold"), r3 === "italic" && (u4 += "italic"), u4.length === 0 && (u4 = "normal");
                    for (var h4 = "", l3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d3 = 0; d3 < s4.length; d3++) {
                      if (this.pdf.internal.getFont(s4[d3], u4, { noFallback: true, disableWarning: true }) !== void 0) {
                        h4 = s4[d3];
                        break;
                      }
                      if (u4 === "bolditalic" && this.pdf.internal.getFont(s4[d3], "bold", { noFallback: true, disableWarning: true }) !== void 0)
                        h4 = s4[d3], u4 = "bold";
                      else if (this.pdf.internal.getFont(s4[d3], "normal", { noFallback: true, disableWarning: true }) !== void 0) {
                        h4 = s4[d3], u4 = "normal";
                        break;
                      }
                    }
                    if (h4 === "") {
                      for (var p4 = 0; p4 < s4.length; p4++)
                        if (l3[s4[p4]]) {
                          h4 = l3[s4[p4]];
                          break;
                        }
                    }
                    h4 = h4 === "" ? "Times" : h4, this.pdf.setFont(h4, u4);
                  }
                }
              } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
                return this.ctx.globalCompositeOperation;
              }, set: function(t2) {
                this.ctx.globalCompositeOperation = t2;
              } }), Object.defineProperty(this, "globalAlpha", { get: function() {
                return this.ctx.globalAlpha;
              }, set: function(t2) {
                this.ctx.globalAlpha = t2;
              } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
                return this.ctx.lineDashOffset;
              }, set: function(t2) {
                this.ctx.lineDashOffset = t2, T2.call(this);
              } }), Object.defineProperty(this, "lineDash", { get: function() {
                return this.ctx.lineDash;
              }, set: function(t2) {
                this.ctx.lineDash = t2, T2.call(this);
              } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
                return this.ctx.ignoreClearRect;
              }, set: function(t2) {
                this.ctx.ignoreClearRect = Boolean(t2);
              } });
            };
            p2.prototype.setLineDash = function(t) {
              this.lineDash = t;
            }, p2.prototype.getLineDash = function() {
              return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
            }, p2.prototype.fill = function() {
              A2.call(this, "fill", false);
            }, p2.prototype.stroke = function() {
              A2.call(this, "stroke", false);
            }, p2.prototype.beginPath = function() {
              this.path = [{ type: "begin" }];
            }, p2.prototype.moveTo = function(t, e2) {
              if (isNaN(t) || isNaN(e2))
                throw a.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
              var r2 = this.ctx.transform.applyToPoint(new c2(t, e2));
              this.path.push({ type: "mt", x: r2.x, y: r2.y }), this.ctx.lastPoint = new c2(t, e2);
            }, p2.prototype.closePath = function() {
              var e2 = new c2(0, 0), r2 = 0;
              for (r2 = this.path.length - 1; r2 !== -1; r2--)
                if (this.path[r2].type === "begin" && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(this.path[r2 + 1]) === "object" && typeof this.path[r2 + 1].x == "number") {
                  e2 = new c2(this.path[r2 + 1].x, this.path[r2 + 1].y);
                  break;
                }
              this.path.push({ type: "close" }), this.ctx.lastPoint = new c2(e2.x, e2.y);
            }, p2.prototype.lineTo = function(t, e2) {
              if (isNaN(t) || isNaN(e2))
                throw a.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
              var r2 = this.ctx.transform.applyToPoint(new c2(t, e2));
              this.path.push({ type: "lt", x: r2.x, y: r2.y }), this.ctx.lastPoint = new c2(r2.x, r2.y);
            }, p2.prototype.clip = function() {
              this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
            }, p2.prototype.quadraticCurveTo = function(t, e2, r2, n3) {
              if (isNaN(r2) || isNaN(n3) || isNaN(t) || isNaN(e2))
                throw a.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
              var i3 = this.ctx.transform.applyToPoint(new c2(r2, n3)), o3 = this.ctx.transform.applyToPoint(new c2(t, e2));
              this.path.push({ type: "qct", x1: o3.x, y1: o3.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new c2(i3.x, i3.y);
            }, p2.prototype.bezierCurveTo = function(t, e2, r2, n3, i3, o3) {
              if (isNaN(i3) || isNaN(o3) || isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n3))
                throw a.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
              var s3 = this.ctx.transform.applyToPoint(new c2(i3, o3)), u3 = this.ctx.transform.applyToPoint(new c2(t, e2)), h3 = this.ctx.transform.applyToPoint(new c2(r2, n3));
              this.path.push({ type: "bct", x1: u3.x, y1: u3.y, x2: h3.x, y2: h3.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new c2(s3.x, s3.y);
            }, p2.prototype.arc = function(t, e2, r2, n3, i3, o3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n3) || isNaN(i3))
                throw a.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
              if (o3 = Boolean(o3), !this.ctx.transform.isIdentity) {
                var s3 = this.ctx.transform.applyToPoint(new c2(t, e2));
                t = s3.x, e2 = s3.y;
                var u3 = this.ctx.transform.applyToPoint(new c2(0, r2)), h3 = this.ctx.transform.applyToPoint(new c2(0, 0));
                r2 = Math.sqrt(Math.pow(u3.x - h3.x, 2) + Math.pow(u3.y - h3.y, 2));
              }
              Math.abs(i3 - n3) >= 2 * Math.PI && (n3 = 0, i3 = 2 * Math.PI), this.path.push({ type: "arc", x: t, y: e2, radius: r2, startAngle: n3, endAngle: i3, counterclockwise: o3 });
            }, p2.prototype.arcTo = function(t, e2, r2, n3, i3) {
              throw new Error("arcTo not implemented.");
            }, p2.prototype.rect = function(t, e2, r2, n3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n3))
                throw a.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
              this.moveTo(t, e2), this.lineTo(t + r2, e2), this.lineTo(t + r2, e2 + n3), this.lineTo(t, e2 + n3), this.lineTo(t, e2), this.lineTo(t + r2, e2), this.lineTo(t, e2);
            }, p2.prototype.fillRect = function(t, e2, r2, n3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n3))
                throw a.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
              if (!m2.call(this)) {
                var i3 = {};
                this.lineCap !== "butt" && (i3.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t, e2, r2, n3), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
              }
            }, p2.prototype.strokeRect = function(t, e2, r2, n3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n3))
                throw a.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
              v2.call(this) || (this.beginPath(), this.rect(t, e2, r2, n3), this.stroke());
            }, p2.prototype.clearRect = function(t, e2, r2, n3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n3))
                throw a.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
              this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t, e2, r2, n3));
            }, p2.prototype.save = function(t) {
              t = typeof t != "boolean" || t;
              for (var e2 = this.pdf.internal.getCurrentPageInfo().pageNumber, r2 = 0; r2 < this.pdf.internal.getNumberOfPages(); r2++)
                this.pdf.setPage(r2 + 1), this.pdf.internal.out("q");
              if (this.pdf.setPage(e2), t) {
                this.ctx.fontSize = this.pdf.internal.getFontSize();
                var n3 = new d2(this.ctx);
                this.ctxStack.push(this.ctx), this.ctx = n3;
              }
            }, p2.prototype.restore = function(t) {
              t = typeof t != "boolean" || t;
              for (var e2 = this.pdf.internal.getCurrentPageInfo().pageNumber, r2 = 0; r2 < this.pdf.internal.getNumberOfPages(); r2++)
                this.pdf.setPage(r2 + 1), this.pdf.internal.out("Q");
              this.pdf.setPage(e2), t && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
            }, p2.prototype.toDataURL = function() {
              throw new Error("toDataUrl not implemented.");
            };
            var g2 = function(t) {
              var e2, r2, n3, i3;
              if (t.isCanvasGradient === true && (t = t.getColor()), !t)
                return { r: 0, g: 0, b: 0, a: 0, style: t };
              if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t))
                e2 = 0, r2 = 0, n3 = 0, i3 = 0;
              else {
                var a2 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t);
                if (a2 !== null)
                  e2 = parseInt(a2[1]), r2 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = 1;
                else if ((a2 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t)) !== null)
                  e2 = parseInt(a2[1]), r2 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = parseFloat(a2[4]);
                else {
                  if (i3 = 1, typeof t == "string" && t.charAt(0) !== "#") {
                    var o3 = new f(t);
                    t = o3.ok ? o3.toHex() : "#000000";
                  }
                  t.length === 4 ? (e2 = t.substring(1, 2), e2 += e2, r2 = t.substring(2, 3), r2 += r2, n3 = t.substring(3, 4), n3 += n3) : (e2 = t.substring(1, 3), r2 = t.substring(3, 5), n3 = t.substring(5, 7)), e2 = parseInt(e2, 16), r2 = parseInt(r2, 16), n3 = parseInt(n3, 16);
                }
              }
              return { r: e2, g: r2, b: n3, a: i3, style: t };
            }, m2 = function() {
              return this.ctx.isFillTransparent || this.globalAlpha == 0;
            }, v2 = function() {
              return Boolean(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
            };
            p2.prototype.fillText = function(t, e2, r2, n3) {
              if (isNaN(e2) || isNaN(r2) || typeof t != "string")
                throw a.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
              if (n3 = isNaN(n3) ? void 0 : n3, !m2.call(this)) {
                var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
                C2.call(this, { text: t, x: e2, y: r2, scale: o3, angle: i3, align: this.textAlign, maxWidth: n3 });
              }
            }, p2.prototype.strokeText = function(t, e2, r2, n3) {
              if (isNaN(e2) || isNaN(r2) || typeof t != "string")
                throw a.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
              if (!v2.call(this)) {
                n3 = isNaN(n3) ? void 0 : n3;
                var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
                C2.call(this, { text: t, x: e2, y: r2, scale: o3, renderingMode: "stroke", angle: i3, align: this.textAlign, maxWidth: n3 });
              }
            }, p2.prototype.measureText = function(t) {
              if (typeof t != "string")
                throw a.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
              var e2 = this.pdf, r2 = this.pdf.internal.scaleFactor, n3 = e2.internal.getFontSize(), i3 = e2.getStringUnitWidth(t) * n3 / e2.internal.scaleFactor, o3 = function(t2) {
                var e3 = (t2 = t2 || {}).width || 0;
                return Object.defineProperty(this, "width", { get: function() {
                  return e3;
                } }), this;
              };
              return new o3({ width: i3 *= Math.round(96 * r2 / 72 * 1e4) / 1e4 });
            }, p2.prototype.scale = function(t, e2) {
              if (isNaN(t) || isNaN(e2))
                throw a.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
              var r2 = new h2(t, 0, 0, e2, 0, 0);
              this.ctx.transform = this.ctx.transform.multiply(r2);
            }, p2.prototype.rotate = function(t) {
              if (isNaN(t))
                throw a.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
              var e2 = new h2(Math.cos(t), Math.sin(t), -Math.sin(t), Math.cos(t), 0, 0);
              this.ctx.transform = this.ctx.transform.multiply(e2);
            }, p2.prototype.translate = function(t, e2) {
              if (isNaN(t) || isNaN(e2))
                throw a.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
              var r2 = new h2(1, 0, 0, 1, t, e2);
              this.ctx.transform = this.ctx.transform.multiply(r2);
            }, p2.prototype.transform = function(t, e2, r2, n3, i3, o3) {
              if (isNaN(t) || isNaN(e2) || isNaN(r2) || isNaN(n3) || isNaN(i3) || isNaN(o3))
                throw a.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
              var s3 = new h2(t, e2, r2, n3, i3, o3);
              this.ctx.transform = this.ctx.transform.multiply(s3);
            }, p2.prototype.setTransform = function(t, e2, r2, n3, i3, a2) {
              t = isNaN(t) ? 1 : t, e2 = isNaN(e2) ? 0 : e2, r2 = isNaN(r2) ? 0 : r2, n3 = isNaN(n3) ? 1 : n3, i3 = isNaN(i3) ? 0 : i3, a2 = isNaN(a2) ? 0 : a2, this.ctx.transform = new h2(t, e2, r2, n3, i3, a2);
            };
            var b2 = function() {
              return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
            };
            p2.prototype.drawImage = function(t, e2, r2, n3, i3, a2, o3, s3, c3) {
              var l3 = this.pdf.getImageProperties(t), f2 = 1, d3 = 1, p3 = 1, g3 = 1;
              n3 !== void 0 && s3 !== void 0 && (p3 = s3 / n3, g3 = c3 / i3, f2 = l3.width / n3 * s3 / n3, d3 = l3.height / i3 * c3 / i3), a2 === void 0 && (a2 = e2, o3 = r2, e2 = 0, r2 = 0), n3 !== void 0 && s3 === void 0 && (s3 = n3, c3 = i3), n3 === void 0 && s3 === void 0 && (s3 = l3.width, c3 = l3.height);
              for (var m3, v3 = this.ctx.transform.decompose(), w3 = q2(v3.rotate.shx), A3 = new h2(), S3 = (A3 = (A3 = (A3 = A3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new u2(a2 - e2 * p3, o3 - r2 * g3, n3 * f2, i3 * d3)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1)
                P3.indexOf(_3[k3]) === -1 && P3.push(_3[k3]);
              if (L2(P3), this.autoPaging)
                for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
                  this.pdf.setPage(C3);
                  var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = C3 === 1 ? this.posY + this.margin[0] : this.margin[0], B3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = C3 === 1 ? 0 : B3 + (C3 - 2) * M3;
                  if (this.ctx.clip_path.length !== 0) {
                    var D3 = this.path;
                    m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
                  }
                  var R3 = JSON.parse(JSON.stringify(S3));
                  R3 = N2([R3], this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset)[0];
                  var T3 = (C3 > I3 || C3 < F3) && b2.call(this);
                  T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();
                }
              else
                this.pdf.addImage(t, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
            };
            var y2 = function(t, e2, r2) {
              var n3 = [];
              e2 = e2 || this.pdf.internal.pageSize.width, r2 = r2 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
              var i3 = this.posY + this.ctx.prevPageLastElemOffset;
              switch (t.type) {
                default:
                case "mt":
                case "lt":
                  n3.push(Math.floor((t.y + i3) / r2) + 1);
                  break;
                case "arc":
                  n3.push(Math.floor((t.y + i3 - t.radius) / r2) + 1), n3.push(Math.floor((t.y + i3 + t.radius) / r2) + 1);
                  break;
                case "qct":
                  var a2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t.x1, t.y1, t.x, t.y);
                  n3.push(Math.floor((a2.y + i3) / r2) + 1), n3.push(Math.floor((a2.y + a2.h + i3) / r2) + 1);
                  break;
                case "bct":
                  var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t.x1, t.y1, t.x2, t.y2, t.x, t.y);
                  n3.push(Math.floor((o3.y + i3) / r2) + 1), n3.push(Math.floor((o3.y + o3.h + i3) / r2) + 1);
                  break;
                case "rect":
                  n3.push(Math.floor((t.y + i3) / r2) + 1), n3.push(Math.floor((t.y + t.h + i3) / r2) + 1);
              }
              for (var s3 = 0; s3 < n3.length; s3 += 1)
                for (; this.pdf.internal.getNumberOfPages() < n3[s3]; )
                  w2.call(this);
              return n3;
            }, w2 = function() {
              var t = this.fillStyle, e2 = this.strokeStyle, r2 = this.font, n3 = this.lineCap, i3 = this.lineWidth, a2 = this.lineJoin;
              this.pdf.addPage(), this.fillStyle = t, this.strokeStyle = e2, this.font = r2, this.lineCap = n3, this.lineWidth = i3, this.lineJoin = a2;
            }, N2 = function(t, e2, r2) {
              for (var n3 = 0; n3 < t.length; n3++)
                switch (t[n3].type) {
                  case "bct":
                    t[n3].x2 += e2, t[n3].y2 += r2;
                  case "qct":
                    t[n3].x1 += e2, t[n3].y1 += r2;
                  case "mt":
                  case "lt":
                  case "arc":
                  default:
                    t[n3].x += e2, t[n3].y += r2;
                }
              return t;
            }, L2 = function(t) {
              return t.sort(function(t2, e2) {
                return t2 - e2;
              });
            }, A2 = function(t, e2) {
              for (var r2, n3, i3 = this.fillStyle, a2 = this.strokeStyle, o3 = this.lineCap, s3 = this.lineWidth, c3 = Math.abs(s3 * this.ctx.transform.scaleX), u3 = this.lineJoin, h3 = JSON.parse(JSON.stringify(this.path)), l3 = JSON.parse(JSON.stringify(this.path)), f2 = [], d3 = 0; d3 < l3.length; d3++)
                if (l3[d3].x !== void 0)
                  for (var p3 = y2.call(this, l3[d3]), g3 = 0; g3 < p3.length; g3 += 1)
                    f2.indexOf(p3[g3]) === -1 && f2.push(p3[g3]);
              for (var m3 = 0; m3 < f2.length; m3++)
                for (; this.pdf.internal.getNumberOfPages() < f2[m3]; )
                  w2.call(this);
              if (L2(f2), this.autoPaging)
                for (var v3 = f2[0], A3 = f2[f2.length - 1], S3 = v3; S3 < A3 + 1; S3++) {
                  this.pdf.setPage(S3), this.fillStyle = i3, this.strokeStyle = a2, this.lineCap = o3, this.lineWidth = c3, this.lineJoin = u3;
                  var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = S3 === 1 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = S3 === 1 ? 0 : k3 + (S3 - 2) * I3;
                  if (this.ctx.clip_path.length !== 0) {
                    var C3 = this.path;
                    r2 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(r2, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t, true), this.path = C3;
                  }
                  if (n3 = JSON.parse(JSON.stringify(h3)), this.path = N2(n3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), e2 === false || S3 === 0) {
                    var j3 = (S3 > v3 || S3 < A3) && b2.call(this);
                    j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, I3, null).clip().discardPath()), x2.call(this, t, e2), j3 && this.pdf.restoreGraphicsState();
                  }
                  this.lineWidth = s3;
                }
              else
                this.lineWidth = c3, x2.call(this, t, e2), this.lineWidth = s3;
              this.path = h3;
            }, x2 = function(t, e2) {
              if ((t !== "stroke" || e2 || !v2.call(this)) && (t === "stroke" || e2 || !m2.call(this))) {
                for (var r2, n3, i3 = [], a2 = this.path, o3 = 0; o3 < a2.length; o3++) {
                  var s3 = a2[o3];
                  switch (s3.type) {
                    case "begin":
                      i3.push({ begin: true });
                      break;
                    case "close":
                      i3.push({ close: true });
                      break;
                    case "mt":
                      i3.push({ start: s3, deltas: [], abs: [] });
                      break;
                    case "lt":
                      var c3 = i3.length;
                      if (a2[o3 - 1] && !isNaN(a2[o3 - 1].x) && (r2 = [s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], c3 > 0)) {
                        for (; c3 >= 0; c3--)
                          if (i3[c3 - 1].close !== true && i3[c3 - 1].begin !== true) {
                            i3[c3 - 1].deltas.push(r2), i3[c3 - 1].abs.push(s3);
                            break;
                          }
                      }
                      break;
                    case "bct":
                      r2 = [s3.x1 - a2[o3 - 1].x, s3.y1 - a2[o3 - 1].y, s3.x2 - a2[o3 - 1].x, s3.y2 - a2[o3 - 1].y, s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r2);
                      break;
                    case "qct":
                      var u3 = a2[o3 - 1].x + 2 / 3 * (s3.x1 - a2[o3 - 1].x), h3 = a2[o3 - 1].y + 2 / 3 * (s3.y1 - a2[o3 - 1].y), l3 = s3.x + 2 / 3 * (s3.x1 - s3.x), f2 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p3 = s3.y;
                      r2 = [u3 - a2[o3 - 1].x, h3 - a2[o3 - 1].y, l3 - a2[o3 - 1].x, f2 - a2[o3 - 1].y, d3 - a2[o3 - 1].x, p3 - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r2);
                      break;
                    case "arc":
                      i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);
                  }
                }
                n3 = e2 ? null : t === "stroke" ? "stroke" : "fill";
                for (var g3 = false, b3 = 0; b3 < i3.length; b3++)
                  if (i3[b3].arc)
                    for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {
                      var N3 = y3[w3];
                      N3.type === "arc" ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e2, !g3) : j2.call(this, N3.x, N3.y), g3 = true;
                    }
                  else if (i3[b3].close === true)
                    this.pdf.internal.out("h"), g3 = false;
                  else if (i3[b3].begin !== true) {
                    var L3 = i3[b3].start.x, A3 = i3[b3].start.y;
                    O2.call(this, i3[b3].deltas, L3, A3), g3 = true;
                  }
                n3 && k2.call(this, n3), e2 && I2.call(this);
              }
            }, S2 = function(t) {
              var e2 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r2 = e2 * (this.pdf.internal.getLineHeightFactor() - 1);
              switch (this.ctx.textBaseline) {
                case "bottom":
                  return t - r2;
                case "top":
                  return t + e2 - r2;
                case "hanging":
                  return t + e2 - 2 * r2;
                case "middle":
                  return t + e2 / 2 - r2;
                case "ideographic":
                  return t;
                case "alphabetic":
                default:
                  return t;
              }
            }, _2 = function(t) {
              return t + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
            };
            p2.prototype.createLinearGradient = function() {
              var t = function() {
              };
              return t.colorStops = [], t.addColorStop = function(t2, e2) {
                this.colorStops.push([t2, e2]);
              }, t.getColor = function() {
                return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
              }, t.isCanvasGradient = true, t;
            }, p2.prototype.createPattern = function() {
              return this.createLinearGradient();
            }, p2.prototype.createRadialGradient = function() {
              return this.createLinearGradient();
            };
            var P2 = function(t, e2, r2, n3, i3, a2, o3, s3, c3) {
              for (var u3 = M2.call(this, r2, n3, i3, a2), h3 = 0; h3 < u3.length; h3++) {
                var l3 = u3[h3];
                h3 === 0 && (c3 ? F2.call(this, l3.x1 + t, l3.y1 + e2) : j2.call(this, l3.x1 + t, l3.y1 + e2)), B2.call(this, t, e2, l3.x2, l3.y2, l3.x3, l3.y3, l3.x4, l3.y4);
              }
              s3 ? I2.call(this) : k2.call(this, o3);
            }, k2 = function(t) {
              switch (t) {
                case "stroke":
                  this.pdf.internal.out("S");
                  break;
                case "fill":
                  this.pdf.internal.out("f");
              }
            }, I2 = function() {
              this.pdf.clip(), this.pdf.discardPath();
            }, F2 = function(t, e2) {
              this.pdf.internal.out(n2(t) + " " + i2(e2) + " m");
            }, C2 = function(t) {
              var e2;
              switch (t.align) {
                case "right":
                case "end":
                  e2 = "right";
                  break;
                case "center":
                  e2 = "center";
                  break;
                case "left":
                case "start":
                default:
                  e2 = "left";
              }
              var r2 = this.pdf.getTextDimensions(t.text), n3 = S2.call(this, t.y), i3 = _2.call(this, n3) - r2.h, a2 = this.ctx.transform.applyToPoint(new c2(t.x, n3)), o3 = this.ctx.transform.decompose(), s3 = new h2();
              s3 = (s3 = (s3 = s3.multiply(o3.translate)).multiply(o3.skew)).multiply(o3.scale);
              for (var l3, f2, d3, p3 = this.ctx.transform.applyToRectangle(new u2(t.x, n3, r2.w, r2.h)), g3 = s3.applyToRectangle(new u2(t.x, i3, r2.w, r2.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1)
                v3.indexOf(m3[w3]) === -1 && v3.push(m3[w3]);
              if (L2(v3), this.autoPaging)
                for (var A3 = v3[0], P3 = v3[v3.length - 1], k3 = A3; k3 < P3 + 1; k3++) {
                  this.pdf.setPage(k3);
                  var I3 = k3 === 1 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B3 = O3 - this.margin[3], M3 = k3 === 1 ? 0 : F3 + (k3 - 2) * j3;
                  if (this.ctx.clip_path.length !== 0) {
                    var E3 = this.path;
                    l3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(l3, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
                  }
                  var q3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
                  t.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t.scale), d3 = this.lineWidth, this.lineWidth = d3 * t.scale);
                  var D3 = this.autoPaging !== "text";
                  if (D3 || q3.y + q3.h <= C3) {
                    if (D3 || q3.y >= I3 && q3.x <= O3) {
                      var R3 = D3 ? t.text : this.pdf.splitTextToSize(t.text, t.maxWidth || O3 - q3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], z2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
                      z2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B3, j3, null).clip().discardPath()), this.pdf.text(R3, T3.x, T3.y, { angle: t.angle, align: e2, renderingMode: t.renderingMode }), z2 && this.pdf.restoreGraphicsState();
                    }
                  } else
                    q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
                  t.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
                }
              else
                t.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t.scale), d3 = this.lineWidth, this.lineWidth = d3 * t.scale), this.pdf.text(t.text, a2.x + this.posX, a2.y + this.posY, { angle: t.angle, align: e2, renderingMode: t.renderingMode, maxWidth: t.maxWidth }), t.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
            }, j2 = function(t, e2, r2, a2) {
              r2 = r2 || 0, a2 = a2 || 0, this.pdf.internal.out(n2(t + r2) + " " + i2(e2 + a2) + " l");
            }, O2 = function(t, e2, r2) {
              return this.pdf.lines(t, e2, r2, null, null);
            }, B2 = function(t, e2, n3, i3, a2, c3, u3, h3) {
              this.pdf.internal.out([r(o2(n3 + t)), r(s2(i3 + e2)), r(o2(a2 + t)), r(s2(c3 + e2)), r(o2(u3 + t)), r(s2(h3 + e2)), "c"].join(" "));
            }, M2 = function(t, e2, r2, n3) {
              for (var i3 = 2 * Math.PI, a2 = Math.PI / 2; e2 > r2; )
                e2 -= i3;
              var o3 = Math.abs(r2 - e2);
              o3 < i3 && n3 && (o3 = i3 - o3);
              for (var s3 = [], c3 = n3 ? -1 : 1, u3 = e2; o3 > 1e-5; ) {
                var h3 = u3 + c3 * Math.min(o3, a2);
                s3.push(E2.call(this, t, u3, h3)), o3 -= Math.abs(h3 - u3), u3 = h3;
              }
              return s3;
            }, E2 = function(t, e2, r2) {
              var n3 = (r2 - e2) / 2, i3 = t * Math.cos(n3), a2 = t * Math.sin(n3), o3 = i3, s3 = -a2, c3 = o3 * o3 + s3 * s3, u3 = c3 + o3 * i3 + s3 * a2, h3 = 4 / 3 * (Math.sqrt(2 * c3 * u3) - u3) / (o3 * a2 - s3 * i3), l3 = o3 - h3 * s3, f2 = s3 + h3 * o3, d3 = l3, p3 = -f2, g3 = n3 + e2, m3 = Math.cos(g3), v3 = Math.sin(g3);
              return { x1: t * Math.cos(e2), y1: t * Math.sin(e2), x2: l3 * m3 - f2 * v3, y2: l3 * v3 + f2 * m3, x3: d3 * m3 - p3 * v3, y3: d3 * v3 + p3 * m3, x4: t * Math.cos(r2), y4: t * Math.sin(r2) };
            }, q2 = function(t) {
              return 180 * t / Math.PI;
            }, D2 = function(t, e2, r2, n3, i3, a2) {
              var o3 = t + 0.5 * (r2 - t), s3 = e2 + 0.5 * (n3 - e2), c3 = i3 + 0.5 * (r2 - i3), h3 = a2 + 0.5 * (n3 - a2), l3 = Math.min(t, i3, o3, c3), f2 = Math.max(t, i3, o3, c3), d3 = Math.min(e2, a2, s3, h3), p3 = Math.max(e2, a2, s3, h3);
              return new u2(l3, d3, f2 - l3, p3 - d3);
            }, R2 = function(t, e2, r2, n3, i3, a2, o3, s3) {
              var c3, h3, l3, f2, d3, p3, g3, m3, v3, b3, y3, w3, N3, L3, A3 = r2 - t, x3 = n3 - e2, S3 = i3 - r2, _3 = a2 - n3, P3 = o3 - i3, k3 = s3 - a2;
              for (h3 = 0; h3 < 41; h3++)
                v3 = (g3 = (l3 = t + (c3 = h3 / 40) * A3) + c3 * ((d3 = r2 + c3 * S3) - l3)) + c3 * (d3 + c3 * (i3 + c3 * P3 - d3) - g3), b3 = (m3 = (f2 = e2 + c3 * x3) + c3 * ((p3 = n3 + c3 * _3) - f2)) + c3 * (p3 + c3 * (a2 + c3 * k3 - p3) - m3), h3 == 0 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
              return new u2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
            }, T2 = function() {
              if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
                var t, e2, r2 = (t = this.ctx.lineDash, e2 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t, lineDashOffset: e2 }));
                this.prevLineDash !== r2 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r2);
              }
            };
          }(E.API), function(t) {
            var r = function(t2) {
              var e, r2, n3, i3, a3, o2, s2, c2, u2, h2;
              for (/[^\x00-\xFF]/.test(t2), r2 = [], n3 = 0, i3 = (t2 += e = "\0\0\0\0".slice(t2.length % 4 || 4)).length; i3 > n3; n3 += 4)
                (a3 = (t2.charCodeAt(n3) << 24) + (t2.charCodeAt(n3 + 1) << 16) + (t2.charCodeAt(n3 + 2) << 8) + t2.charCodeAt(n3 + 3)) !== 0 ? (o2 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (h2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, r2.push(o2 + 33, s2 + 33, c2 + 33, u2 + 33, h2 + 33)) : r2.push(122);
              return function(t3, e2) {
                for (var r3 = e2; r3 > 0; r3--)
                  t3.pop();
              }(r2, e.length), String.fromCharCode.apply(String, r2) + "~>";
            }, n2 = function(t2) {
              var e, r2, n3, i3, a3, o2 = String, s2 = "length", c2 = 255, u2 = "charCodeAt", h2 = "slice", l2 = "replace";
              for (t2[h2](-2), t2 = t2[h2](0, -2)[l2](/\s/g, "")[l2]("z", "!!!!!"), n3 = [], i3 = 0, a3 = (t2 += e = "uuuuu"[h2](t2[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5)
                r2 = 52200625 * (t2[u2](i3) - 33) + 614125 * (t2[u2](i3 + 1) - 33) + 7225 * (t2[u2](i3 + 2) - 33) + 85 * (t2[u2](i3 + 3) - 33) + (t2[u2](i3 + 4) - 33), n3.push(c2 & r2 >> 24, c2 & r2 >> 16, c2 & r2 >> 8, c2 & r2);
              return function(t3, e2) {
                for (var r3 = e2; r3 > 0; r3--)
                  t3.pop();
              }(n3, e[s2]), o2.fromCharCode.apply(o2, n3);
            }, i2 = function(t2) {
              var e = new RegExp(/^([0-9A-Fa-f]{2})+$/);
              if ((t2 = t2.replace(/\s/g, "")).indexOf(">") !== -1 && (t2 = t2.substr(0, t2.indexOf(">"))), t2.length % 2 && (t2 += "0"), e.test(t2) === false)
                return "";
              for (var r2 = "", n3 = 0; n3 < t2.length; n3 += 2)
                r2 += String.fromCharCode("0x" + (t2[n3] + t2[n3 + 1]));
              return r2;
            }, a2 = function(t2) {
              for (var r2 = new Uint8Array(t2.length), n3 = t2.length; n3--; )
                r2[n3] = t2.charCodeAt(n3);
              return t2 = (r2 = Object(fflate__WEBPACK_IMPORTED_MODULE_1__["b"])(r2)).reduce(function(t3, e) {
                return t3 + String.fromCharCode(e);
              }, "");
            };
            t.processDataByFilters = function(t2, e) {
              var o2 = 0, s2 = t2 || "", c2 = [];
              for (typeof (e = e || []) == "string" && (e = [e]), o2 = 0; o2 < e.length; o2 += 1)
                switch (e[o2]) {
                  case "ASCII85Decode":
                  case "/ASCII85Decode":
                    s2 = n2(s2), c2.push("/ASCII85Encode");
                    break;
                  case "ASCII85Encode":
                  case "/ASCII85Encode":
                    s2 = r(s2), c2.push("/ASCII85Decode");
                    break;
                  case "ASCIIHexDecode":
                  case "/ASCIIHexDecode":
                    s2 = i2(s2), c2.push("/ASCIIHexEncode");
                    break;
                  case "ASCIIHexEncode":
                  case "/ASCIIHexEncode":
                    s2 = s2.split("").map(function(t3) {
                      return ("0" + t3.charCodeAt().toString(16)).slice(-2);
                    }).join("") + ">", c2.push("/ASCIIHexDecode");
                    break;
                  case "FlateEncode":
                  case "/FlateEncode":
                    s2 = a2(s2), c2.push("/FlateDecode");
                    break;
                  default:
                    throw new Error('The filter: "' + e[o2] + '" is not implemented');
                }
              return { data: s2, reverseChain: c2.reverse().join(" ") };
            };
          }(E.API), function(t) {
            t.loadFile = function(t2, e, r) {
              return function(t3, e2, r2) {
                e2 = e2 !== false, r2 = typeof r2 == "function" ? r2 : function() {
                };
                var n2 = void 0;
                try {
                  n2 = function(t4, e3, r3) {
                    var n3 = new XMLHttpRequest(), i2 = 0, a2 = function(t5) {
                      var e4 = t5.length, r4 = [], n4 = String.fromCharCode;
                      for (i2 = 0; i2 < e4; i2 += 1)
                        r4.push(n4(255 & t5.charCodeAt(i2)));
                      return r4.join("");
                    };
                    if (n3.open("GET", t4, !e3), n3.overrideMimeType("text/plain; charset=x-user-defined"), e3 === false && (n3.onload = function() {
                      n3.status === 200 ? r3(a2(this.responseText)) : r3(void 0);
                    }), n3.send(null), e3 && n3.status === 200)
                      return a2(n3.responseText);
                  }(t3, e2, r2);
                } catch (t4) {
                }
                return n2;
              }(t2, e, r);
            }, t.loadImageFile = t.loadFile;
          }(E.API), function(e) {
            function r() {
              return (n.html2canvas ? Promise.resolve(n.html2canvas) : __webpack_require__.e(3).then(__webpack_require__.t.bind(null, "c0e9", 7))).catch(function(t) {
                return Promise.reject(new Error("Could not load html2canvas: " + t));
              }).then(function(t) {
                return t.default ? t.default : t;
              });
            }
            function i2() {
              return (n.DOMPurify ? Promise.resolve(n.DOMPurify) : __webpack_require__.e(2).then(__webpack_require__.t.bind(null, "c0c4", 7))).catch(function(t) {
                return Promise.reject(new Error("Could not load dompurify: " + t));
              }).then(function(t) {
                return t.default ? t.default : t;
              });
            }
            var a2 = function(e2) {
              var r2 = _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e2);
              return r2 === "undefined" ? "undefined" : r2 === "string" || e2 instanceof String ? "string" : r2 === "number" || e2 instanceof Number ? "number" : r2 === "function" || e2 instanceof Function ? "function" : e2 && e2.constructor === Array ? "array" : e2 && e2.nodeType === 1 ? "element" : r2 === "object" ? "object" : "unknown";
            }, o2 = function(t, e2) {
              var r2 = document.createElement(t);
              for (var n2 in e2.className && (r2.className = e2.className), e2.innerHTML && e2.dompurify && (r2.innerHTML = e2.dompurify.sanitize(e2.innerHTML)), e2.style)
                r2.style[n2] = e2.style[n2];
              return r2;
            }, s2 = function t(e2) {
              var r2 = Object.assign(t.convert(Promise.resolve()), JSON.parse(JSON.stringify(t.template))), n2 = t.convert(Promise.resolve(), r2);
              return n2 = (n2 = n2.setProgress(1, t, 1, [t])).set(e2);
            };
            (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t, e2) {
              return t.__proto__ = e2 || s2.prototype, t;
            }, s2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
            } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s2.prototype.from = function(t, e2) {
              return this.then(function() {
                switch (e2 = e2 || function(t2) {
                  switch (a2(t2)) {
                    case "string":
                      return "string";
                    case "element":
                      return t2.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
                    default:
                      return "unknown";
                  }
                }(t)) {
                  case "string":
                    return this.then(i2).then(function(e3) {
                      return this.set({ src: o2("div", { innerHTML: t, dompurify: e3 }) });
                    });
                  case "element":
                    return this.set({ src: t });
                  case "canvas":
                    return this.set({ canvas: t });
                  case "img":
                    return this.set({ img: t });
                  default:
                    return this.error("Unknown source type.");
                }
              });
            }, s2.prototype.to = function(t) {
              switch (t) {
                case "container":
                  return this.toContainer();
                case "canvas":
                  return this.toCanvas();
                case "img":
                  return this.toImg();
                case "pdf":
                  return this.toPdf();
                default:
                  return this.error("Invalid target.");
              }
            }, s2.prototype.toContainer = function() {
              return this.thenList([function() {
                return this.prop.src || this.error("Cannot duplicate - no source HTML.");
              }, function() {
                return this.prop.pageSize || this.setPageSize();
              }]).then(function() {
                var t = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e2 = function t2(e3, r2) {
                  for (var n2 = e3.nodeType === 3 ? document.createTextNode(e3.nodeValue) : e3.cloneNode(false), i3 = e3.firstChild; i3; i3 = i3.nextSibling)
                    r2 !== true && i3.nodeType === 1 && i3.nodeName === "SCRIPT" || n2.appendChild(t2(i3, r2));
                  return e3.nodeType === 1 && (e3.nodeName === "CANVAS" ? (n2.width = e3.width, n2.height = e3.height, n2.getContext("2d").drawImage(e3, 0, 0)) : e3.nodeName !== "TEXTAREA" && e3.nodeName !== "SELECT" || (n2.value = e3.value), n2.addEventListener("load", function() {
                    n2.scrollTop = e3.scrollTop, n2.scrollLeft = e3.scrollLeft;
                  }, true)), n2;
                }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
                e2.tagName === "BODY" && (t.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t }), this.prop.container.appendChild(e2), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
              });
            }, s2.prototype.toCanvas = function() {
              var t = [function() {
                return document.body.contains(this.prop.container) || this.toContainer();
              }];
              return this.thenList(t).then(r).then(function(t2) {
                var e2 = Object.assign({}, this.opt.html2canvas);
                return delete e2.onrendered, t2(this.prop.container, e2);
              }).then(function(t2) {
                (this.opt.html2canvas.onrendered || function() {
                })(t2), this.prop.canvas = t2, document.body.removeChild(this.prop.overlay);
              });
            }, s2.prototype.toContext2d = function() {
              var t = [function() {
                return document.body.contains(this.prop.container) || this.toContainer();
              }];
              return this.thenList(t).then(r).then(function(t2) {
                var e2 = this.opt.jsPDF, r2 = this.opt.fontFaces, n2 = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i3 = Object.assign({ async: true, allowTaint: true, scale: n2, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
                if (delete i3.onrendered, e2.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, e2.context2d.posX = this.opt.x, e2.context2d.posY = this.opt.y, e2.context2d.margin = this.opt.margin, e2.context2d.fontFaces = r2, r2)
                  for (var a3 = 0; a3 < r2.length; ++a3) {
                    var o3 = r2[a3], s3 = o3.src.find(function(t3) {
                      return t3.format === "truetype";
                    });
                    s3 && e2.addFont(s3.url, o3.ref.name, o3.ref.style);
                  }
                return i3.windowHeight = i3.windowHeight || 0, i3.windowHeight = i3.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i3.windowHeight, e2.context2d.save(true), t2(this.prop.container, i3);
              }).then(function(t2) {
                this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
                })(t2), this.prop.canvas = t2, document.body.removeChild(this.prop.overlay);
              });
            }, s2.prototype.toImg = function() {
              return this.thenList([function() {
                return this.prop.canvas || this.toCanvas();
              }]).then(function() {
                var t = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
                this.prop.img = document.createElement("img"), this.prop.img.src = t;
              });
            }, s2.prototype.toPdf = function() {
              return this.thenList([function() {
                return this.toContext2d();
              }]).then(function() {
                this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
              });
            }, s2.prototype.output = function(t, e2, r2) {
              return (r2 = r2 || "pdf").toLowerCase() === "img" || r2.toLowerCase() === "image" ? this.outputImg(t, e2) : this.outputPdf(t, e2);
            }, s2.prototype.outputPdf = function(t, e2) {
              return this.thenList([function() {
                return this.prop.pdf || this.toPdf();
              }]).then(function() {
                return this.prop.pdf.output(t, e2);
              });
            }, s2.prototype.outputImg = function(t) {
              return this.thenList([function() {
                return this.prop.img || this.toImg();
              }]).then(function() {
                switch (t) {
                  case void 0:
                  case "img":
                    return this.prop.img;
                  case "datauristring":
                  case "dataurlstring":
                    return this.prop.img.src;
                  case "datauri":
                  case "dataurl":
                    return document.location.href = this.prop.img.src;
                  default:
                    throw 'Image output type "' + t + '" is not supported.';
                }
              });
            }, s2.prototype.save = function(t) {
              return this.thenList([function() {
                return this.prop.pdf || this.toPdf();
              }]).set(t ? { filename: t } : null).then(function() {
                this.prop.pdf.save(this.opt.filename);
              });
            }, s2.prototype.doCallback = function() {
              return this.thenList([function() {
                return this.prop.pdf || this.toPdf();
              }]).then(function() {
                this.prop.callback(this.prop.pdf);
              });
            }, s2.prototype.set = function(t) {
              if (a2(t) !== "object")
                return this;
              var e2 = Object.keys(t || {}).map(function(e3) {
                if (e3 in s2.template.prop)
                  return function() {
                    this.prop[e3] = t[e3];
                  };
                switch (e3) {
                  case "margin":
                    return this.setMargin.bind(this, t.margin);
                  case "jsPDF":
                    return function() {
                      return this.opt.jsPDF = t.jsPDF, this.setPageSize();
                    };
                  case "pageSize":
                    return this.setPageSize.bind(this, t.pageSize);
                  default:
                    return function() {
                      this.opt[e3] = t[e3];
                    };
                }
              }, this);
              return this.then(function() {
                return this.thenList(e2);
              });
            }, s2.prototype.get = function(t, e2) {
              return this.then(function() {
                var r2 = t in s2.template.prop ? this.prop[t] : this.opt[t];
                return e2 ? e2(r2) : r2;
              });
            }, s2.prototype.setMargin = function(t) {
              return this.then(function() {
                switch (a2(t)) {
                  case "number":
                    t = [t, t, t, t];
                  case "array":
                    if (t.length === 2 && (t = [t[0], t[1], t[0], t[1]]), t.length === 4)
                      break;
                  default:
                    return this.error("Invalid margin array.");
                }
                this.opt.margin = t;
              }).then(this.setPageSize);
            }, s2.prototype.setPageSize = function(t) {
              function e2(t2, e3) {
                return Math.floor(t2 * e3 / 72 * 96);
              }
              return this.then(function() {
                (t = t || E.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t.inner = { width: t.width - this.opt.margin[1] - this.opt.margin[3], height: t.height - this.opt.margin[0] - this.opt.margin[2] }, t.inner.px = { width: e2(t.inner.width, t.k), height: e2(t.inner.height, t.k) }, t.inner.ratio = t.inner.height / t.inner.width), this.prop.pageSize = t;
              });
            }, s2.prototype.setProgress = function(t, e2, r2, n2) {
              return t != null && (this.progress.val = t), e2 != null && (this.progress.state = e2), r2 != null && (this.progress.n = r2), n2 != null && (this.progress.stack = n2), this.progress.ratio = this.progress.val / this.progress.state, this;
            }, s2.prototype.updateProgress = function(t, e2, r2, n2) {
              return this.setProgress(t ? this.progress.val + t : null, e2 || null, r2 ? this.progress.n + r2 : null, n2 ? this.progress.stack.concat(n2) : null);
            }, s2.prototype.then = function(t, e2) {
              var r2 = this;
              return this.thenCore(t, e2, function(t2, e3) {
                return r2.updateProgress(null, null, 1, [t2]), Promise.prototype.then.call(this, function(e4) {
                  return r2.updateProgress(null, t2), e4;
                }).then(t2, e3).then(function(t3) {
                  return r2.updateProgress(1), t3;
                });
              });
            }, s2.prototype.thenCore = function(t, e2, r2) {
              r2 = r2 || Promise.prototype.then;
              t && (t = t.bind(this)), e2 && (e2 = e2.bind(this));
              var n2 = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s2.convert(Object.assign({}, this), Promise.prototype), i3 = r2.call(n2, t, e2);
              return s2.convert(i3, this.__proto__);
            }, s2.prototype.thenExternal = function(t, e2) {
              return Promise.prototype.then.call(this, t, e2);
            }, s2.prototype.thenList = function(t) {
              var e2 = this;
              return t.forEach(function(t2) {
                e2 = e2.thenCore(t2);
              }), e2;
            }, s2.prototype.catch = function(t) {
              t && (t = t.bind(this));
              var e2 = Promise.prototype.catch.call(this, t);
              return s2.convert(e2, this);
            }, s2.prototype.catchExternal = function(t) {
              return Promise.prototype.catch.call(this, t);
            }, s2.prototype.error = function(t) {
              return this.then(function() {
                throw new Error(t);
              });
            }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, E.getPageSize = function(e2, r2, n2) {
              if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e2) === "object") {
                var i3 = e2;
                e2 = i3.orientation, r2 = i3.unit || r2, n2 = i3.format || n2;
              }
              r2 = r2 || "mm", n2 = n2 || "a4", e2 = ("" + (e2 || "P")).toLowerCase();
              var a3, o3 = ("" + n2).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
              switch (r2) {
                case "pt":
                  a3 = 1;
                  break;
                case "mm":
                  a3 = 72 / 25.4;
                  break;
                case "cm":
                  a3 = 72 / 2.54;
                  break;
                case "in":
                  a3 = 72;
                  break;
                case "px":
                  a3 = 0.75;
                  break;
                case "pc":
                case "em":
                  a3 = 12;
                  break;
                case "ex":
                  a3 = 6;
                  break;
                default:
                  throw "Invalid unit: " + r2;
              }
              var c2, u2 = 0, h2 = 0;
              if (s3.hasOwnProperty(o3))
                u2 = s3[o3][1] / a3, h2 = s3[o3][0] / a3;
              else
                try {
                  u2 = n2[1], h2 = n2[0];
                } catch (t) {
                  throw new Error("Invalid format: " + n2);
                }
              if (e2 === "p" || e2 === "portrait")
                e2 = "p", h2 > u2 && (c2 = h2, h2 = u2, u2 = c2);
              else {
                if (e2 !== "l" && e2 !== "landscape")
                  throw "Invalid orientation: " + e2;
                e2 = "l", u2 > h2 && (c2 = h2, h2 = u2, u2 = c2);
              }
              return { width: h2, height: u2, unit: r2, k: a3, orientation: e2 };
            }, e.html = function(t, e2) {
              (e2 = e2 || {}).callback = e2.callback || function() {
              }, e2.html2canvas = e2.html2canvas || {}, e2.html2canvas.canvas = e2.html2canvas.canvas || this.canvas, e2.jsPDF = e2.jsPDF || this, e2.fontFaces = e2.fontFaces ? e2.fontFaces.map(jt) : null;
              var r2 = new s2(e2);
              return e2.worker ? r2 : r2.from(t).doCallback();
            };
          }(E.API), E.API.addJS = function(t) {
            return Ht = t, this.internal.events.subscribe("postPutResources", function() {
              zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (zt + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
            }), this.internal.events.subscribe("putCatalog", function() {
              zt !== void 0 && Ut !== void 0 && this.internal.out("/Names <</JavaScript " + zt + " 0 R>>");
            }), this;
          }, function(t) {
            var e;
            t.events.push(["postPutResources", function() {
              var t2 = this, r = /^(\d+) 0 obj$/;
              if (this.outline.root.children.length > 0)
                for (var n2 = t2.outline.render().split(/\r\n/), i2 = 0; i2 < n2.length; i2++) {
                  var a2 = n2[i2], o2 = r.exec(a2);
                  if (o2 != null) {
                    var s2 = o2[1];
                    t2.internal.newObjectDeferredBegin(s2, false);
                  }
                  t2.internal.write(a2);
                }
              if (this.outline.createNamedDestinations) {
                var c2 = this.internal.pages.length, u2 = [];
                for (i2 = 0; i2 < c2; i2++) {
                  var h2 = t2.internal.newObject();
                  u2.push(h2);
                  var l2 = t2.internal.getPageInfo(i2 + 1);
                  t2.internal.write("<< /D[" + l2.objId + " 0 R /XYZ null null null]>> endobj");
                }
                var f2 = t2.internal.newObject();
                t2.internal.write("<< /Names [ ");
                for (i2 = 0; i2 < u2.length; i2++)
                  t2.internal.write("(page_" + (i2 + 1) + ")" + u2[i2] + " 0 R");
                t2.internal.write(" ] >>", "endobj"), e = t2.internal.newObject(), t2.internal.write("<< /Dests " + f2 + " 0 R"), t2.internal.write(">>", "endobj");
              }
            }]), t.events.push(["putCatalog", function() {
              this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
            }]), t.events.push(["initialized", function() {
              var t2 = this;
              t2.outline = { createNamedDestinations: false, root: { children: [] } }, t2.outline.add = function(t3, e2, r) {
                var n2 = { title: e2, options: r, children: [] };
                return t3 == null && (t3 = this.root), t3.children.push(n2), n2;
              }, t2.outline.render = function() {
                return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t2, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
              }, t2.outline.genIds_r = function(e2) {
                e2.id = t2.internal.newObjectDeferred();
                for (var r = 0; r < e2.children.length; r++)
                  this.genIds_r(e2.children[r]);
              }, t2.outline.renderRoot = function(t3) {
                this.objStart(t3), this.line("/Type /Outlines"), t3.children.length > 0 && (this.line("/First " + this.makeRef(t3.children[0])), this.line("/Last " + this.makeRef(t3.children[t3.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t3)), this.objEnd();
              }, t2.outline.renderItems = function(e2) {
                for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e2.children.length; n2++) {
                  var i2 = e2.children[n2];
                  this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e2)), n2 > 0 && this.line("/Prev " + this.makeRef(e2.children[n2 - 1])), n2 < e2.children.length - 1 && this.line("/Next " + this.makeRef(e2.children[n2 + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
                  var a2 = this.count = this.count_r({ count: 0 }, i2);
                  if (a2 > 0 && this.line("/Count " + a2), i2.options && i2.options.pageNumber) {
                    var o2 = t2.internal.getPageInfo(i2.options.pageNumber);
                    this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
                  }
                  this.objEnd();
                }
                for (var s2 = 0; s2 < e2.children.length; s2++)
                  this.renderItems(e2.children[s2]);
              }, t2.outline.line = function(t3) {
                this.ctx.val += t3 + "\r\n";
              }, t2.outline.makeRef = function(t3) {
                return t3.id + " 0 R";
              }, t2.outline.makeString = function(e2) {
                return "(" + t2.internal.pdfEscape(e2) + ")";
              }, t2.outline.objStart = function(t3) {
                this.ctx.val += "\r\n" + t3.id + " 0 obj\r\n<<\r\n";
              }, t2.outline.objEnd = function() {
                this.ctx.val += ">> \r\nendobj\r\n";
              }, t2.outline.count_r = function(t3, e2) {
                for (var r = 0; r < e2.children.length; r++)
                  t3.count++, this.count_r(t3, e2.children[r]);
                return t3.count;
              };
            }]);
          }(E.API), function(t) {
            var e = [192, 193, 194, 195, 196, 197, 198, 199];
            t.processJPEG = function(t2, r, n2, i2, a2, o2) {
              var s2, c2 = this.decode.DCT_DECODE, u2 = null;
              if (typeof t2 == "string" || this.__addimage__.isArrayBuffer(t2) || this.__addimage__.isArrayBufferView(t2)) {
                switch (t2 = a2 || t2, t2 = this.__addimage__.isArrayBuffer(t2) ? new Uint8Array(t2) : t2, (s2 = function(t3) {
                  for (var r2, n3 = 256 * t3.charCodeAt(4) + t3.charCodeAt(5), i3 = t3.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {
                    if (o3 += n3, e.indexOf(t3.charCodeAt(o3 + 1)) !== -1) {
                      r2 = 256 * t3.charCodeAt(o3 + 5) + t3.charCodeAt(o3 + 6), a3 = { width: 256 * t3.charCodeAt(o3 + 7) + t3.charCodeAt(o3 + 8), height: r2, numcomponents: t3.charCodeAt(o3 + 9) };
                      break;
                    }
                    n3 = 256 * t3.charCodeAt(o3 + 2) + t3.charCodeAt(o3 + 3);
                  }
                  return a3;
                }(t2 = this.__addimage__.isArrayBufferView(t2) ? this.__addimage__.arrayBufferToBinaryString(t2) : t2)).numcomponents) {
                  case 1:
                    o2 = this.color_spaces.DEVICE_GRAY;
                    break;
                  case 4:
                    o2 = this.color_spaces.DEVICE_CMYK;
                    break;
                  case 3:
                    o2 = this.color_spaces.DEVICE_RGB;
                }
                u2 = { data: t2, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: c2, index: r, alias: n2 };
              }
              return u2;
            };
          }(E.API);
          var Vt, Gt, Yt, Jt, Xt, Kt = function() {
            var t, e, i2;
            function a2(t2) {
              var e2, r, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2, d2, p2;
              for (this.data = t2, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o3 = null; ; ) {
                switch (e2 = this.readUInt32(), u2 = function() {
                  var t3, e3;
                  for (e3 = [], t3 = 0; t3 < 4; ++t3)
                    e3.push(String.fromCharCode(this.data[this.pos++]));
                  return e3;
                }.call(this).join("")) {
                  case "IHDR":
                    this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
                    break;
                  case "acTL":
                    this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
                    break;
                  case "PLTE":
                    this.palette = this.read(e2);
                    break;
                  case "fcTL":
                    o3 && this.animation.frames.push(o3), this.pos += 4, o3 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a3 = this.readUInt16(), i3 = this.readUInt16() || 100, o3.delay = 1e3 * a3 / i3, o3.disposeOp = this.data[this.pos++], o3.blendOp = this.data[this.pos++], o3.data = [];
                    break;
                  case "IDAT":
                  case "fdAT":
                    for (u2 === "fdAT" && (this.pos += 4, e2 -= 4), t2 = (o3 != null ? o3.data : void 0) || this.imgData, f2 = 0; 0 <= e2 ? f2 < e2 : f2 > e2; 0 <= e2 ? ++f2 : --f2)
                      t2.push(this.data[this.pos++]);
                    break;
                  case "tRNS":
                    switch (this.transparency = {}, this.colorType) {
                      case 3:
                        if (n2 = this.palette.length / 3, this.transparency.indexed = this.read(e2), this.transparency.indexed.length > n2)
                          throw new Error("More transparent colors than palette size");
                        if ((h2 = n2 - this.transparency.indexed.length) > 0)
                          for (d2 = 0; 0 <= h2 ? d2 < h2 : d2 > h2; 0 <= h2 ? ++d2 : --d2)
                            this.transparency.indexed.push(255);
                        break;
                      case 0:
                        this.transparency.grayscale = this.read(e2)[0];
                        break;
                      case 2:
                        this.transparency.rgb = this.read(e2);
                    }
                    break;
                  case "tEXt":
                    s2 = (l2 = this.read(e2)).indexOf(0), c2 = String.fromCharCode.apply(String, l2.slice(0, s2)), this.text[c2] = String.fromCharCode.apply(String, l2.slice(s2 + 1));
                    break;
                  case "IEND":
                    return o3 && this.animation.frames.push(o3), this.colors = function() {
                      switch (this.colorType) {
                        case 0:
                        case 3:
                        case 4:
                          return 1;
                        case 2:
                        case 6:
                          return 3;
                      }
                    }.call(this), this.hasAlphaChannel = (p2 = this.colorType) === 4 || p2 === 6, r = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r, this.colorSpace = function() {
                      switch (this.colors) {
                        case 1:
                          return "DeviceGray";
                        case 3:
                          return "DeviceRGB";
                      }
                    }.call(this), void (this.imgData = new Uint8Array(this.imgData));
                  default:
                    this.pos += e2;
                }
                if (this.pos += 4, this.pos > this.data.length)
                  throw new Error("Incomplete or corrupt PNG file");
              }
            }
            a2.prototype.read = function(t2) {
              var e2, r;
              for (r = [], e2 = 0; 0 <= t2 ? e2 < t2 : e2 > t2; 0 <= t2 ? ++e2 : --e2)
                r.push(this.data[this.pos++]);
              return r;
            }, a2.prototype.readUInt32 = function() {
              return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
            }, a2.prototype.readUInt16 = function() {
              return this.data[this.pos++] << 8 | this.data[this.pos++];
            }, a2.prototype.decodePixels = function(t2) {
              var e2 = this.pixelBitlength / 8, n2 = new Uint8Array(this.width * this.height * e2), i3 = 0, a3 = this;
              if (t2 == null && (t2 = this.imgData), t2.length === 0)
                return new Uint8Array(0);
              function o3(r, o4, s2, c2) {
                var u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2 = Math.ceil((a3.width - r) / s2), C2 = Math.ceil((a3.height - o4) / c2), j2 = a3.width == F2 && a3.height == C2;
                for (L2 = e2 * F2, w2 = j2 ? n2 : new Uint8Array(L2 * C2), p2 = t2.length, N2 = 0, h2 = 0; N2 < C2 && i3 < p2; ) {
                  switch (t2[i3++]) {
                    case 0:
                      for (f2 = S2 = 0; S2 < L2; f2 = S2 += 1)
                        w2[h2++] = t2[i3++];
                      break;
                    case 1:
                      for (f2 = _2 = 0; _2 < L2; f2 = _2 += 1)
                        u2 = t2[i3++], d2 = f2 < e2 ? 0 : w2[h2 - e2], w2[h2++] = (u2 + d2) % 256;
                      break;
                    case 2:
                      for (f2 = P2 = 0; P2 < L2; f2 = P2 += 1)
                        u2 = t2[i3++], l2 = (f2 - f2 % e2) / e2, A2 = N2 && w2[(N2 - 1) * L2 + l2 * e2 + f2 % e2], w2[h2++] = (A2 + u2) % 256;
                      break;
                    case 3:
                      for (f2 = k2 = 0; k2 < L2; f2 = k2 += 1)
                        u2 = t2[i3++], l2 = (f2 - f2 % e2) / e2, d2 = f2 < e2 ? 0 : w2[h2 - e2], A2 = N2 && w2[(N2 - 1) * L2 + l2 * e2 + f2 % e2], w2[h2++] = (u2 + Math.floor((d2 + A2) / 2)) % 256;
                      break;
                    case 4:
                      for (f2 = I2 = 0; I2 < L2; f2 = I2 += 1)
                        u2 = t2[i3++], l2 = (f2 - f2 % e2) / e2, d2 = f2 < e2 ? 0 : w2[h2 - e2], N2 === 0 ? A2 = x2 = 0 : (A2 = w2[(N2 - 1) * L2 + l2 * e2 + f2 % e2], x2 = l2 && w2[(N2 - 1) * L2 + (l2 - 1) * e2 + f2 % e2]), g2 = d2 + A2 - x2, m2 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y2 = Math.abs(g2 - x2), v2 = m2 <= b2 && m2 <= y2 ? d2 : b2 <= y2 ? A2 : x2, w2[h2++] = (u2 + v2) % 256;
                      break;
                    default:
                      throw new Error("Invalid filter algorithm: " + t2[i3 - 1]);
                  }
                  if (!j2) {
                    var O2 = ((o4 + N2 * c2) * a3.width + r) * e2, B2 = N2 * L2;
                    for (f2 = 0; f2 < F2; f2 += 1) {
                      for (var M2 = 0; M2 < e2; M2 += 1)
                        n2[O2++] = w2[B2++];
                      O2 += (s2 - 1) * e2;
                    }
                  }
                  N2++;
                }
              }
              return t2 = Object(fflate__WEBPACK_IMPORTED_MODULE_1__["a"])(t2), a3.interlaceMethod == 1 ? (o3(0, 0, 8, 8), o3(4, 0, 8, 8), o3(0, 4, 4, 8), o3(2, 0, 4, 4), o3(0, 2, 2, 4), o3(1, 0, 2, 2), o3(0, 1, 1, 2)) : o3(0, 0, 1, 1), n2;
            }, a2.prototype.decodePalette = function() {
              var t2, e2, r, n2, i3, a3, o3, s2, c2;
              for (r = this.palette, a3 = this.transparency.indexed || [], i3 = new Uint8Array((a3.length || 0) + r.length), n2 = 0, t2 = 0, e2 = o3 = 0, s2 = r.length; o3 < s2; e2 = o3 += 3)
                i3[n2++] = r[e2], i3[n2++] = r[e2 + 1], i3[n2++] = r[e2 + 2], i3[n2++] = (c2 = a3[t2++]) != null ? c2 : 255;
              return i3;
            }, a2.prototype.copyToImageData = function(t2, e2) {
              var r, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2;
              if (n2 = this.colors, h2 = null, r = this.hasAlphaChannel, this.palette.length && (h2 = (f2 = this._decodedPalette) != null ? f2 : this._decodedPalette = this.decodePalette(), n2 = 4, r = true), u2 = (i3 = t2.data || t2).length, o3 = h2 || e2, a3 = s2 = 0, n2 === 1)
                for (; a3 < u2; )
                  c2 = h2 ? 4 * e2[a3 / 4] : s2, l2 = o3[c2++], i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = r ? o3[c2++] : 255, s2 = c2;
              else
                for (; a3 < u2; )
                  c2 = h2 ? 4 * e2[a3 / 4] : s2, i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = r ? o3[c2++] : 255, s2 = c2;
            }, a2.prototype.decode = function() {
              var t2;
              return t2 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t2, this.decodePixels()), t2;
            };
            var o2 = function() {
              if (Object.prototype.toString.call(n) === "[object Window]") {
                try {
                  e = n.document.createElement("canvas"), i2 = e.getContext("2d");
                } catch (t2) {
                  return false;
                }
                return true;
              }
              return false;
            };
            return o2(), t = function(t2) {
              var r;
              if (o2() === true)
                return i2.width = t2.width, i2.height = t2.height, i2.clearRect(0, 0, t2.width, t2.height), i2.putImageData(t2, 0, 0), (r = new Image()).src = e.toDataURL(), r;
              throw new Error("This method requires a Browser with Canvas-capability.");
            }, a2.prototype.decodeFrames = function(e2) {
              var r, n2, i3, a3, o3, s2, c2, u2;
              if (this.animation) {
                for (u2 = [], n2 = o3 = 0, s2 = (c2 = this.animation.frames).length; o3 < s2; n2 = ++o3)
                  r = c2[n2], i3 = e2.createImageData(r.width, r.height), a3 = this.decodePixels(new Uint8Array(r.data)), this.copyToImageData(i3, a3), r.imageData = i3, u2.push(r.image = t(i3));
                return u2;
              }
            }, a2.prototype.renderFrame = function(t2, e2) {
              var r, n2, i3;
              return r = (n2 = this.animation.frames)[e2], i3 = n2[e2 - 1], e2 === 0 && t2.clearRect(0, 0, this.width, this.height), (i3 != null ? i3.disposeOp : void 0) === 1 ? t2.clearRect(i3.xOffset, i3.yOffset, i3.width, i3.height) : (i3 != null ? i3.disposeOp : void 0) === 2 && t2.putImageData(i3.imageData, i3.xOffset, i3.yOffset), r.blendOp === 0 && t2.clearRect(r.xOffset, r.yOffset, r.width, r.height), t2.drawImage(r.image, r.xOffset, r.yOffset);
            }, a2.prototype.animate = function(t2) {
              var e2, r, n2, i3, a3, o3, s2 = this;
              return r = 0, o3 = this.animation, i3 = o3.numFrames, n2 = o3.frames, a3 = o3.numPlays, (e2 = function() {
                var o4, c2;
                if (o4 = r++ % i3, c2 = n2[o4], s2.renderFrame(t2, o4), i3 > 1 && r / i3 < a3)
                  return s2.animation._timeout = setTimeout(e2, c2.delay);
              })();
            }, a2.prototype.stopAnimation = function() {
              var t2;
              return clearTimeout((t2 = this.animation) != null ? t2._timeout : void 0);
            }, a2.prototype.render = function(t2) {
              var e2, r;
              return t2._png && t2._png.stopAnimation(), t2._png = this, t2.width = this.width, t2.height = this.height, e2 = t2.getContext("2d"), this.animation ? (this.decodeFrames(e2), this.animate(e2)) : (r = e2.createImageData(this.width, this.height), this.copyToImageData(r, this.decodePixels()), e2.putImageData(r, 0, 0));
            }, a2;
          }();
          function Zt(t) {
            var e = 0;
            if (t[e++] !== 71 || t[e++] !== 73 || t[e++] !== 70 || t[e++] !== 56 || (t[e++] + 1 & 253) != 56 || t[e++] !== 97)
              throw new Error("Invalid GIF 87a/89a header.");
            var r = t[e++] | t[e++] << 8, n2 = t[e++] | t[e++] << 8, i2 = t[e++], a2 = i2 >> 7, o2 = 1 << (7 & i2) + 1;
            t[e++];
            t[e++];
            var s2 = null, c2 = null;
            a2 && (s2 = e, c2 = o2, e += 3 * o2);
            var u2 = true, h2 = [], l2 = 0, f2 = null, d2 = 0, p2 = null;
            for (this.width = r, this.height = n2; u2 && e < t.length; )
              switch (t[e++]) {
                case 33:
                  switch (t[e++]) {
                    case 255:
                      if (t[e] !== 11 || t[e + 1] == 78 && t[e + 2] == 69 && t[e + 3] == 84 && t[e + 4] == 83 && t[e + 5] == 67 && t[e + 6] == 65 && t[e + 7] == 80 && t[e + 8] == 69 && t[e + 9] == 50 && t[e + 10] == 46 && t[e + 11] == 48 && t[e + 12] == 3 && t[e + 13] == 1 && t[e + 16] == 0)
                        e += 14, p2 = t[e++] | t[e++] << 8, e++;
                      else
                        for (e += 12; ; ) {
                          if (!((P2 = t[e++]) >= 0))
                            throw Error("Invalid block size");
                          if (P2 === 0)
                            break;
                          e += P2;
                        }
                      break;
                    case 249:
                      if (t[e++] !== 4 || t[e + 4] !== 0)
                        throw new Error("Invalid graphics extension block.");
                      var g2 = t[e++];
                      l2 = t[e++] | t[e++] << 8, f2 = t[e++], (1 & g2) == 0 && (f2 = null), d2 = g2 >> 2 & 7, e++;
                      break;
                    case 254:
                      for (; ; ) {
                        if (!((P2 = t[e++]) >= 0))
                          throw Error("Invalid block size");
                        if (P2 === 0)
                          break;
                        e += P2;
                      }
                      break;
                    default:
                      throw new Error("Unknown graphic control label: 0x" + t[e - 1].toString(16));
                  }
                  break;
                case 44:
                  var m2 = t[e++] | t[e++] << 8, v2 = t[e++] | t[e++] << 8, b2 = t[e++] | t[e++] << 8, y2 = t[e++] | t[e++] << 8, w2 = t[e++], N2 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s2, x2 = c2, S2 = false;
                  if (w2 >> 7) {
                    S2 = true;
                    A2 = e, x2 = L2, e += 3 * L2;
                  }
                  var _2 = e;
                  for (e++; ; ) {
                    var P2;
                    if (!((P2 = t[e++]) >= 0))
                      throw Error("Invalid block size");
                    if (P2 === 0)
                      break;
                    e += P2;
                  }
                  h2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _2, data_length: e - _2, transparent_index: f2, interlaced: !!N2, delay: l2, disposal: d2 });
                  break;
                case 59:
                  u2 = false;
                  break;
                default:
                  throw new Error("Unknown gif block: 0x" + t[e - 1].toString(16));
              }
            this.numFrames = function() {
              return h2.length;
            }, this.loopCount = function() {
              return p2;
            }, this.frameInfo = function(t2) {
              if (t2 < 0 || t2 >= h2.length)
                throw new Error("Frame index out of range.");
              return h2[t2];
            }, this.decodeAndBlitFrameBGRA = function(e2, n3) {
              var i3 = this.frameInfo(e2), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
              $t(t, i3.data_offset, o3, a3);
              var s3 = i3.palette_offset, c3 = i3.transparent_index;
              c3 === null && (c3 = 256);
              var u3 = i3.width, h3 = r - u3, l3 = u3, f3 = 4 * (i3.y * r + i3.x), d3 = 4 * ((i3.y + i3.height) * r + i3.x), p3 = f3, g3 = 4 * h3;
              i3.interlaced === true && (g3 += 4 * r * 7);
              for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
                var y3 = o3[v3];
                if (l3 === 0 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h3 + 4 * r * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)
                  p3 += 4;
                else {
                  var w3 = t[s3 + 3 * y3], N3 = t[s3 + 3 * y3 + 1], L3 = t[s3 + 3 * y3 + 2];
                  n3[p3++] = L3, n3[p3++] = N3, n3[p3++] = w3, n3[p3++] = 255;
                }
                --l3;
              }
            }, this.decodeAndBlitFrameRGBA = function(e2, n3) {
              var i3 = this.frameInfo(e2), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
              $t(t, i3.data_offset, o3, a3);
              var s3 = i3.palette_offset, c3 = i3.transparent_index;
              c3 === null && (c3 = 256);
              var u3 = i3.width, h3 = r - u3, l3 = u3, f3 = 4 * (i3.y * r + i3.x), d3 = 4 * ((i3.y + i3.height) * r + i3.x), p3 = f3, g3 = 4 * h3;
              i3.interlaced === true && (g3 += 4 * r * 7);
              for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
                var y3 = o3[v3];
                if (l3 === 0 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h3 + 4 * r * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)
                  p3 += 4;
                else {
                  var w3 = t[s3 + 3 * y3], N3 = t[s3 + 3 * y3 + 1], L3 = t[s3 + 3 * y3 + 2];
                  n3[p3++] = w3, n3[p3++] = N3, n3[p3++] = L3, n3[p3++] = 255;
                }
                --l3;
              }
            };
          }
          function $t(t, e, r, n2) {
            for (var i2 = t[e++], o2 = 1 << i2, s2 = o2 + 1, c2 = s2 + 1, u2 = i2 + 1, h2 = (1 << u2) - 1, l2 = 0, f2 = 0, d2 = 0, p2 = t[e++], g2 = new Int32Array(4096), m2 = null; ; ) {
              for (; l2 < 16 && p2 !== 0; )
                f2 |= t[e++] << l2, l2 += 8, p2 === 1 ? p2 = t[e++] : --p2;
              if (l2 < u2)
                break;
              var v2 = f2 & h2;
              if (f2 >>= u2, l2 -= u2, v2 !== o2) {
                if (v2 === s2)
                  break;
                for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > o2; )
                  w2 = g2[w2] >> 8, ++y2;
                var N2 = w2;
                if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2)
                  return void a.log("Warning, gif stream longer than expected.");
                r[d2++] = N2;
                var L2 = d2 += y2;
                for (b2 !== v2 && (r[d2++] = N2), w2 = b2; y2--; )
                  w2 = g2[w2], r[--L2] = 255 & w2, w2 >>= 8;
                m2 !== null && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= h2 + 1 && u2 < 12 && (++u2, h2 = h2 << 1 | 1)), m2 = v2;
              } else
                c2 = s2 + 1, h2 = (1 << (u2 = i2 + 1)) - 1, m2 = null;
            }
            return d2 !== n2 && a.log("Warning, gif stream shorter than expected."), r;
          }
          function Qt(t) {
            var e, r, n2, i2, a2, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u2 = new Array(64), h2 = new Array(64), l2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p2 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
            function j2(t2, e2) {
              for (var r2 = 0, n3 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {
                for (var o3 = 1; o3 <= t2[a3]; o3++)
                  i3[e2[n3]] = [], i3[e2[n3]][0] = r2, i3[e2[n3]][1] = a3, n3++, r2++;
                r2 *= 2;
              }
              return i3;
            }
            function O2(t2) {
              for (var e2 = t2[0], r2 = t2[1] - 1; r2 >= 0; )
                e2 & 1 << r2 && (m2 |= 1 << v2), r2--, --v2 < 0 && (m2 == 255 ? (B2(255), B2(0)) : B2(m2), v2 = 7, m2 = 0);
            }
            function B2(t2) {
              g2.push(t2);
            }
            function M2(t2) {
              B2(t2 >> 8 & 255), B2(255 & t2);
            }
            function E2(t2, e2, r2, n3, i3) {
              for (var a3, o3 = i3[0], s3 = i3[240], c3 = function(t3, e3) {
                var r3, n4, i4, a4, o4, s4, c4, u4, h4, l3, f3 = 0;
                for (h4 = 0; h4 < 8; ++h4) {
                  r3 = t3[f3], n4 = t3[f3 + 1], i4 = t3[f3 + 2], a4 = t3[f3 + 3], o4 = t3[f3 + 4], s4 = t3[f3 + 5], c4 = t3[f3 + 6];
                  var p3 = r3 + (u4 = t3[f3 + 7]), g4 = r3 - u4, m4 = n4 + c4, v4 = n4 - c4, b4 = i4 + s4, y4 = i4 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p3 + w4, A3 = p3 - w4, x3 = m4 + b4, S3 = m4 - b4;
                  t3[f3] = L3 + x3, t3[f3 + 4] = L3 - x3;
                  var _3 = 0.707106781 * (S3 + A3);
                  t3[f3 + 2] = A3 + _3, t3[f3 + 6] = A3 - _3;
                  var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y4 + v4), C3 = g4 + F3, j3 = g4 - F3;
                  t3[f3 + 5] = j3 + k3, t3[f3 + 3] = j3 - k3, t3[f3 + 1] = C3 + I3, t3[f3 + 7] = C3 - I3, f3 += 8;
                }
                for (f3 = 0, h4 = 0; h4 < 8; ++h4) {
                  r3 = t3[f3], n4 = t3[f3 + 8], i4 = t3[f3 + 16], a4 = t3[f3 + 24], o4 = t3[f3 + 32], s4 = t3[f3 + 40], c4 = t3[f3 + 48];
                  var O3 = r3 + (u4 = t3[f3 + 56]), B3 = r3 - u4, M3 = n4 + c4, E3 = n4 - c4, q3 = i4 + s4, D2 = i4 - s4, R2 = a4 + o4, T2 = a4 - o4, z2 = O3 + R2, U2 = O3 - R2, H2 = M3 + q3, W2 = M3 - q3;
                  t3[f3] = z2 + H2, t3[f3 + 32] = z2 - H2;
                  var V2 = 0.707106781 * (W2 + U2);
                  t3[f3 + 16] = U2 + V2, t3[f3 + 48] = U2 - V2;
                  var G2 = 0.382683433 * ((z2 = T2 + D2) - (W2 = E3 + B3)), Y2 = 0.5411961 * z2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H2 = D2 + E3), K2 = B3 + X2, Z2 = B3 - X2;
                  t3[f3 + 40] = Z2 + Y2, t3[f3 + 24] = Z2 - Y2, t3[f3 + 8] = K2 + J2, t3[f3 + 56] = K2 - J2, f3++;
                }
                for (h4 = 0; h4 < 64; ++h4)
                  l3 = t3[h4] * e3[h4], d2[h4] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;
                return d2;
              }(t2, e2), u3 = 0; u3 < 64; ++u3)
                p2[A2[u3]] = c3[u3];
              var h3 = p2[0] - r2;
              r2 = p2[0], h3 == 0 ? O2(n3[0]) : (O2(n3[f2[a3 = 32767 + h3]]), O2(l2[a3]));
              for (var g3 = 63; g3 > 0 && p2[g3] == 0; )
                g3--;
              if (g3 == 0)
                return O2(o3), r2;
              for (var m3, v3 = 1; v3 <= g3; ) {
                for (var b3 = v3; p2[v3] == 0 && v3 <= g3; )
                  ++v3;
                var y3 = v3 - b3;
                if (y3 >= 16) {
                  m3 = y3 >> 4;
                  for (var w3 = 1; w3 <= m3; ++w3)
                    O2(s3);
                  y3 &= 15;
                }
                a3 = 32767 + p2[v3], O2(i3[(y3 << 4) + f2[a3]]), O2(l2[a3]), v3++;
              }
              return g3 != 63 && O2(o3), r2;
            }
            function q2(t2) {
              (t2 = Math.min(Math.max(t2, 1), 100), a2 != t2) && (!function(t3) {
                for (var e2 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r2 = 0; r2 < 64; r2++) {
                  var n3 = o2((e2[r2] * t3 + 50) / 100);
                  n3 = Math.min(Math.max(n3, 1), 255), s2[A2[r2]] = n3;
                }
                for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
                  var l3 = o2((i3[a3] * t3 + 50) / 100);
                  l3 = Math.min(Math.max(l3, 1), 255), c2[A2[a3]] = l3;
                }
                for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p3 = 0; p3 < 8; p3++)
                  for (var g3 = 0; g3 < 8; g3++)
                    u2[d3] = 1 / (s2[A2[d3]] * f3[p3] * f3[g3] * 8), h2[d3] = 1 / (c2[A2[d3]] * f3[p3] * f3[g3] * 8), d3++;
              }(t2 < 50 ? Math.floor(5e3 / t2) : Math.floor(200 - 2 * t2)), a2 = t2);
            }
            this.encode = function(t2, a3) {
              a3 && q2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B2(74), B2(70), B2(73), B2(70), B2(0), B2(1), B2(1), B2(0), M2(1), M2(1), B2(0), B2(0), function() {
                M2(65499), M2(132), B2(0);
                for (var t3 = 0; t3 < 64; t3++)
                  B2(s2[t3]);
                B2(1);
                for (var e2 = 0; e2 < 64; e2++)
                  B2(c2[e2]);
              }(), function(t3, e2) {
                M2(65472), M2(17), B2(8), M2(e2), M2(t3), B2(3), B2(1), B2(17), B2(0), B2(2), B2(17), B2(1), B2(3), B2(17), B2(1);
              }(t2.width, t2.height), function() {
                M2(65476), M2(418), B2(0);
                for (var t3 = 0; t3 < 16; t3++)
                  B2(x2[t3 + 1]);
                for (var e2 = 0; e2 <= 11; e2++)
                  B2(S2[e2]);
                B2(16);
                for (var r2 = 0; r2 < 16; r2++)
                  B2(_2[r2 + 1]);
                for (var n3 = 0; n3 <= 161; n3++)
                  B2(P2[n3]);
                B2(1);
                for (var i3 = 0; i3 < 16; i3++)
                  B2(k2[i3 + 1]);
                for (var a4 = 0; a4 <= 11; a4++)
                  B2(I2[a4]);
                B2(17);
                for (var o4 = 0; o4 < 16; o4++)
                  B2(F2[o4 + 1]);
                for (var s3 = 0; s3 <= 161; s3++)
                  B2(C2[s3]);
              }(), M2(65498), M2(12), B2(3), B2(1), B2(0), B2(2), B2(17), B2(3), B2(17), B2(0), B2(63), B2(0);
              var o3 = 0, l3 = 0, f3 = 0;
              m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
              for (var d3, p3, N3, A3, j3, D2, R2, T2, z2, U2 = t2.data, H2 = t2.width, W2 = t2.height, V2 = 4 * H2, G2 = 0; G2 < W2; ) {
                for (d3 = 0; d3 < V2; ) {
                  for (j3 = V2 * G2 + d3, R2 = -1, T2 = 0, z2 = 0; z2 < 64; z2++)
                    D2 = j3 + (T2 = z2 >> 3) * V2 + (R2 = 4 * (7 & z2)), G2 + T2 >= W2 && (D2 -= V2 * (G2 + 1 + T2 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p3 = U2[D2++], N3 = U2[D2++], A3 = U2[D2++], b2[z2] = (L2[p3] + L2[N3 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y2[z2] = (L2[p3 + 768 >> 0] + L2[N3 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[z2] = (L2[p3 + 1280 >> 0] + L2[N3 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
                  o3 = E2(b2, u2, o3, e, n2), l3 = E2(y2, h2, l3, r, i2), f3 = E2(w2, h2, f3, r, i2), d3 += 32;
                }
                G2 += 8;
              }
              if (v2 >= 0) {
                var Y2 = [];
                Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
              }
              return M2(65497), new Uint8Array(g2);
            }, t = t || 50, function() {
              for (var t2 = String.fromCharCode, e2 = 0; e2 < 256; e2++)
                N2[e2] = t2(e2);
            }(), e = j2(x2, S2), r = j2(k2, I2), n2 = j2(_2, P2), i2 = j2(F2, C2), function() {
              for (var t2 = 1, e2 = 2, r2 = 1; r2 <= 15; r2++) {
                for (var n3 = t2; n3 < e2; n3++)
                  f2[32767 + n3] = r2, l2[32767 + n3] = [], l2[32767 + n3][1] = r2, l2[32767 + n3][0] = n3;
                for (var i3 = -(e2 - 1); i3 <= -t2; i3++)
                  f2[32767 + i3] = r2, l2[32767 + i3] = [], l2[32767 + i3][1] = r2, l2[32767 + i3][0] = e2 - 1 + i3;
                t2 <<= 1, e2 <<= 1;
              }
            }(), function() {
              for (var t2 = 0; t2 < 256; t2++)
                L2[t2] = 19595 * t2, L2[t2 + 256 >> 0] = 38470 * t2, L2[t2 + 512 >> 0] = 7471 * t2 + 32768, L2[t2 + 768 >> 0] = -11059 * t2, L2[t2 + 1024 >> 0] = -21709 * t2, L2[t2 + 1280 >> 0] = 32768 * t2 + 8421375, L2[t2 + 1536 >> 0] = -27439 * t2, L2[t2 + 1792 >> 0] = -5329 * t2;
            }(), q2(t);
          }
          function te(t, e) {
            if (this.pos = 0, this.buffer = t, this.datav = new DataView(t.buffer), this.is_with_alpha = !!e, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1)
              throw new Error("Invalid BMP File");
            this.parseHeader(), this.parseBGR();
          }
          function ee(t) {
            function e(t2) {
              if (!t2)
                throw Error("assert :P");
            }
            function r(t2, e2, r2) {
              for (var n3 = 0; 4 > n3; n3++)
                if (t2[e2 + n3] != r2.charCodeAt(n3))
                  return true;
              return false;
            }
            function n2(t2, e2, r2, n3, i3) {
              for (var a3 = 0; a3 < i3; a3++)
                t2[e2 + a3] = r2[n3 + a3];
            }
            function i2(t2, e2, r2, n3) {
              for (var i3 = 0; i3 < n3; i3++)
                t2[e2 + i3] = r2;
            }
            function a2(t2) {
              return new Int32Array(t2);
            }
            function o2(t2, e2) {
              for (var r2 = [], n3 = 0; n3 < t2; n3++)
                r2.push(new e2());
              return r2;
            }
            function s2(t2, e2) {
              var r2 = [];
              return function t3(r3, n3, i3) {
                for (var a3 = i3[n3], o3 = 0; o3 < a3 && (r3.push(i3.length > n3 + 1 ? [] : new e2()), !(i3.length < n3 + 1)); o3++)
                  t3(r3[o3], n3 + 1, i3);
              }(r2, 0, t2), r2;
            }
            var c2 = function() {
              var t2 = this;
              function c3(t3, e2) {
                for (var r2 = 1 << e2 - 1 >>> 0; t3 & r2; )
                  r2 >>>= 1;
                return r2 ? (t3 & r2 - 1) + r2 : t3;
              }
              function u3(t3, r2, n3, i3, a3) {
                e(!(i3 % n3));
                do {
                  t3[r2 + (i3 -= n3)] = a3;
                } while (0 < i3);
              }
              function h3(t3, r2, n3, i3, o3) {
                if (e(2328 >= o3), 512 >= o3)
                  var s3 = a2(512);
                else if ((s3 = a2(o3)) == null)
                  return 0;
                return function(t4, r3, n4, i4, o4, s4) {
                  var h4, f4, d4 = r3, p4 = 1 << n4, g4 = a2(16), m4 = a2(16);
                  for (e(o4 != 0), e(i4 != null), e(t4 != null), e(0 < n4), f4 = 0; f4 < o4; ++f4) {
                    if (15 < i4[f4])
                      return 0;
                    ++g4[i4[f4]];
                  }
                  if (g4[0] == o4)
                    return 0;
                  for (m4[1] = 0, h4 = 1; 15 > h4; ++h4) {
                    if (g4[h4] > 1 << h4)
                      return 0;
                    m4[h4 + 1] = m4[h4] + g4[h4];
                  }
                  for (f4 = 0; f4 < o4; ++f4)
                    h4 = i4[f4], 0 < i4[f4] && (s4[m4[h4]++] = f4);
                  if (m4[15] == 1)
                    return (i4 = new l3()).g = 0, i4.value = s4[0], u3(t4, d4, 1, p4, i4), p4;
                  var v4, b4 = -1, y4 = p4 - 1, w4 = 0, N4 = 1, L4 = 1, A4 = 1 << n4;
                  for (f4 = 0, h4 = 1, o4 = 2; h4 <= n4; ++h4, o4 <<= 1) {
                    if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))
                      return 0;
                    for (; 0 < g4[h4]; --g4[h4])
                      (i4 = new l3()).g = h4, i4.value = s4[f4++], u3(t4, d4 + w4, o4, A4, i4), w4 = c3(w4, h4);
                  }
                  for (h4 = n4 + 1, o4 = 2; 15 >= h4; ++h4, o4 <<= 1) {
                    if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))
                      return 0;
                    for (; 0 < g4[h4]; --g4[h4]) {
                      if (i4 = new l3(), (w4 & y4) != b4) {
                        for (d4 += A4, v4 = 1 << (b4 = h4) - n4; 15 > b4 && !(0 >= (v4 -= g4[b4])); )
                          ++b4, v4 <<= 1;
                        p4 += A4 = 1 << (v4 = b4 - n4), t4[r3 + (b4 = w4 & y4)].g = v4 + n4, t4[r3 + b4].value = d4 - r3 - b4;
                      }
                      i4.g = h4 - n4, i4.value = s4[f4++], u3(t4, d4 + (w4 >> n4), o4, A4, i4), w4 = c3(w4, h4);
                    }
                  }
                  return N4 != 2 * m4[15] - 1 ? 0 : p4;
                }(t3, r2, n3, i3, o3, s3);
              }
              function l3() {
                this.value = this.g = 0;
              }
              function f3() {
                this.value = this.g = 0;
              }
              function d3() {
                this.G = o2(5, l3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Dr, f3);
              }
              function p3(t3, r2, n3, i3) {
                e(t3 != null), e(r2 != null), e(2147483648 > i3), t3.Ca = 254, t3.I = 0, t3.b = -8, t3.Ka = 0, t3.oa = r2, t3.pa = n3, t3.Jd = r2, t3.Yc = n3 + i3, t3.Zc = 4 <= i3 ? n3 + i3 - 4 + 1 : n3, _2(t3);
              }
              function g3(t3, e2) {
                for (var r2 = 0; 0 < e2--; )
                  r2 |= k2(t3, 128) << e2;
                return r2;
              }
              function m3(t3, e2) {
                var r2 = g3(t3, e2);
                return P2(t3) ? -r2 : r2;
              }
              function v3(t3, r2, n3, i3) {
                var a3, o3 = 0;
                for (e(t3 != null), e(r2 != null), e(4294967288 > i3), t3.Sb = i3, t3.Ra = 0, t3.u = 0, t3.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3)
                  o3 += r2[n3 + a3] << 8 * a3;
                t3.Ra = o3, t3.bb = i3, t3.oa = r2, t3.pa = n3;
              }
              function b3(t3) {
                for (; 8 <= t3.u && t3.bb < t3.Sb; )
                  t3.Ra >>>= 8, t3.Ra += t3.oa[t3.pa + t3.bb] << zr - 8 >>> 0, ++t3.bb, t3.u -= 8;
                A3(t3) && (t3.h = 1, t3.u = 0);
              }
              function y3(t3, r2) {
                if (e(0 <= r2), !t3.h && r2 <= Tr) {
                  var n3 = L3(t3) & Rr[r2];
                  return t3.u += r2, b3(t3), n3;
                }
                return t3.h = 1, t3.u = 0;
              }
              function w3() {
                this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
              }
              function N3() {
                this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
              }
              function L3(t3) {
                return t3.Ra >>> (t3.u & zr - 1) >>> 0;
              }
              function A3(t3) {
                return e(t3.bb <= t3.Sb), t3.h || t3.bb == t3.Sb && t3.u > zr;
              }
              function x2(t3, e2) {
                t3.u = e2, t3.h = A3(t3);
              }
              function S2(t3) {
                t3.u >= Ur && (e(t3.u >= Ur), b3(t3));
              }
              function _2(t3) {
                e(t3 != null && t3.oa != null), t3.pa < t3.Zc ? (t3.I = (t3.oa[t3.pa++] | t3.I << 8) >>> 0, t3.b += 8) : (e(t3 != null && t3.oa != null), t3.pa < t3.Yc ? (t3.b += 8, t3.I = t3.oa[t3.pa++] | t3.I << 8) : t3.Ka ? t3.b = 0 : (t3.I <<= 8, t3.b += 8, t3.Ka = 1));
              }
              function P2(t3) {
                return g3(t3, 1);
              }
              function k2(t3, e2) {
                var r2 = t3.Ca;
                0 > t3.b && _2(t3);
                var n3 = t3.b, i3 = r2 * e2 >>> 8, a3 = (t3.I >>> n3 > i3) + 0;
                for (a3 ? (r2 -= i3, t3.I -= i3 + 1 << n3 >>> 0) : r2 = i3 + 1, n3 = r2, i3 = 0; 256 <= n3; )
                  i3 += 8, n3 >>= 8;
                return n3 = 7 ^ i3 + Hr[n3], t3.b -= n3, t3.Ca = (r2 << n3) - 1, a3;
              }
              function I2(t3, e2, r2) {
                t3[e2 + 0] = r2 >> 24 & 255, t3[e2 + 1] = r2 >> 16 & 255, t3[e2 + 2] = r2 >> 8 & 255, t3[e2 + 3] = r2 >> 0 & 255;
              }
              function F2(t3, e2) {
                return t3[e2 + 0] << 0 | t3[e2 + 1] << 8;
              }
              function C2(t3, e2) {
                return F2(t3, e2) | t3[e2 + 2] << 16;
              }
              function j2(t3, e2) {
                return F2(t3, e2) | F2(t3, e2 + 2) << 16;
              }
              function O2(t3, r2) {
                var n3 = 1 << r2;
                return e(t3 != null), e(0 < r2), t3.X = a2(n3), t3.X == null ? 0 : (t3.Mb = 32 - r2, t3.Xa = r2, 1);
              }
              function B2(t3, r2) {
                e(t3 != null), e(r2 != null), e(t3.Xa == r2.Xa), n2(r2.X, 0, t3.X, 0, 1 << r2.Xa);
              }
              function M2() {
                this.X = [], this.Xa = this.Mb = 0;
              }
              function E2(t3, r2, n3, i3) {
                e(n3 != null), e(i3 != null);
                var a3 = n3[0], o3 = i3[0];
                return a3 == 0 && (a3 = (t3 * o3 + r2 / 2) / r2), o3 == 0 && (o3 = (r2 * a3 + t3 / 2) / t3), 0 >= a3 || 0 >= o3 ? 0 : (n3[0] = a3, i3[0] = o3, 1);
              }
              function q2(t3, e2) {
                return t3 + (1 << e2) - 1 >>> e2;
              }
              function D2(t3, e2) {
                return ((4278255360 & t3) + (4278255360 & e2) >>> 0 & 4278255360) + ((16711935 & t3) + (16711935 & e2) >>> 0 & 16711935) >>> 0;
              }
              function R2(e2, r2) {
                t2[r2] = function(r3, n3, i3, a3, o3, s3, c4) {
                  var u4;
                  for (u4 = 0; u4 < o3; ++u4) {
                    var h4 = t2[e2](s3[c4 + u4 - 1], i3, a3 + u4);
                    s3[c4 + u4] = D2(r3[n3 + u4], h4);
                  }
                };
              }
              function T2() {
                this.ud = this.hd = this.jd = 0;
              }
              function z2(t3, e2) {
                return ((4278124286 & (t3 ^ e2)) >>> 1) + (t3 & e2) >>> 0;
              }
              function U2(t3) {
                return 0 <= t3 && 256 > t3 ? t3 : 0 > t3 ? 0 : 255 < t3 ? 255 : void 0;
              }
              function H2(t3, e2) {
                return U2(t3 + (t3 - e2 + 0.5 >> 1));
              }
              function W2(t3, e2, r2) {
                return Math.abs(e2 - r2) - Math.abs(t3 - r2);
              }
              function V2(t3, e2, r2, n3, i3, a3, o3) {
                for (n3 = a3[o3 - 1], r2 = 0; r2 < i3; ++r2)
                  a3[o3 + r2] = n3 = D2(t3[e2 + r2], n3);
              }
              function G2(t3, e2, r2, n3, i3) {
                var a3;
                for (a3 = 0; a3 < r2; ++a3) {
                  var o3 = t3[e2 + a3], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));
                  n3[i3 + a3] = (4278255360 & o3) + c4 >>> 0;
                }
              }
              function Y2(t3, e2) {
                e2.jd = t3 >> 0 & 255, e2.hd = t3 >> 8 & 255, e2.ud = t3 >> 16 & 255;
              }
              function J2(t3, e2, r2, n3, i3, a3) {
                var o3;
                for (o3 = 0; o3 < n3; ++o3) {
                  var s3 = e2[r2 + o3], c4 = s3 >>> 8, u4 = s3, h4 = 255 & (h4 = (h4 = s3 >>> 16) + ((t3.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));
                  u4 = 255 & (u4 = (u4 = u4 + ((t3.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5)) + ((t3.ud << 24 >> 24) * (h4 << 24 >> 24) >>> 5));
                  i3[a3 + o3] = (4278255360 & s3) + (h4 << 16) + u4;
                }
              }
              function X2(e2, r2, n3, i3, a3) {
                t2[r2] = function(t3, e3, r3, n4, o3, s3, c4, u4, h4) {
                  for (n4 = c4; n4 < u4; ++n4)
                    for (c4 = 0; c4 < h4; ++c4)
                      o3[s3++] = a3(r3[i3(t3[e3++])]);
                }, t2[e2] = function(e3, r3, o3, s3, c4, u4, h4) {
                  var l4 = 8 >> e3.b, f4 = e3.Ea, d4 = e3.K[0], p4 = e3.w;
                  if (8 > l4)
                    for (e3 = (1 << e3.b) - 1, p4 = (1 << l4) - 1; r3 < o3; ++r3) {
                      var g4, m4 = 0;
                      for (g4 = 0; g4 < f4; ++g4)
                        g4 & e3 || (m4 = i3(s3[c4++])), u4[h4++] = a3(d4[m4 & p4]), m4 >>= l4;
                    }
                  else
                    t2["VP8LMapColor" + n3](s3, c4, d4, p4, u4, h4, r3, o3, f4);
                };
              }
              function K2(t3, e2, r2, n3, i3) {
                for (r2 = e2 + r2; e2 < r2; ) {
                  var a3 = t3[e2++];
                  n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255;
                }
              }
              function Z2(t3, e2, r2, n3, i3) {
                for (r2 = e2 + r2; e2 < r2; ) {
                  var a3 = t3[e2++];
                  n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 24 & 255;
                }
              }
              function $2(t3, e2, r2, n3, i3) {
                for (r2 = e2 + r2; e2 < r2; ) {
                  var a3 = (o3 = t3[e2++]) >> 16 & 240 | o3 >> 12 & 15, o3 = o3 >> 0 & 240 | o3 >> 28 & 15;
                  n3[i3++] = a3, n3[i3++] = o3;
                }
              }
              function Q2(t3, e2, r2, n3, i3) {
                for (r2 = e2 + r2; e2 < r2; ) {
                  var a3 = (o3 = t3[e2++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
                  n3[i3++] = a3, n3[i3++] = o3;
                }
              }
              function tt2(t3, e2, r2, n3, i3) {
                for (r2 = e2 + r2; e2 < r2; ) {
                  var a3 = t3[e2++];
                  n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 16 & 255;
                }
              }
              function et2(t3, e2, r2, i3, a3, o3) {
                if (o3 == 0)
                  for (r2 = e2 + r2; e2 < r2; )
                    I2(i3, ((o3 = t3[e2++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
                else
                  n2(i3, a3, t3, e2, r2);
              }
              function rt2(e2, r2) {
                t2[r2][0] = t2[e2 + "0"], t2[r2][1] = t2[e2 + "1"], t2[r2][2] = t2[e2 + "2"], t2[r2][3] = t2[e2 + "3"], t2[r2][4] = t2[e2 + "4"], t2[r2][5] = t2[e2 + "5"], t2[r2][6] = t2[e2 + "6"], t2[r2][7] = t2[e2 + "7"], t2[r2][8] = t2[e2 + "8"], t2[r2][9] = t2[e2 + "9"], t2[r2][10] = t2[e2 + "10"], t2[r2][11] = t2[e2 + "11"], t2[r2][12] = t2[e2 + "12"], t2[r2][13] = t2[e2 + "13"], t2[r2][14] = t2[e2 + "0"], t2[r2][15] = t2[e2 + "0"];
              }
              function nt2(t3) {
                return t3 == Hn || t3 == Wn || t3 == Vn || t3 == Gn;
              }
              function it2() {
                this.eb = [], this.size = this.A = this.fb = 0;
              }
              function at2() {
                this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
              }
              function ot2() {
                this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
              }
              function st2() {
                this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
              }
              function ct2() {
                this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
              }
              function ut2(t3) {
                return alert("todo:WebPSamplerProcessPlane"), t3.T;
              }
              function ht2(t3, e2) {
                var r2 = t3.T, i3 = e2.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t3.ka * i3.A, s3 = vi[e2.ba.S], c4 = t3.y, u4 = t3.O, h4 = t3.f, l4 = t3.N, f4 = t3.ea, d4 = t3.W, p4 = e2.cc, g4 = e2.dc, m4 = e2.Mc, v4 = e2.Nc, b4 = t3.ka, y4 = t3.ka + t3.T, w4 = t3.U, N4 = w4 + 1 >> 1;
                for (b4 == 0 ? s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3, null, null, w4) : (s3(e2.ec, e2.fc, c4, u4, p4, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4), ++r2); b4 + 2 < y4; b4 += 2)
                  p4 = h4, g4 = l4, m4 = f4, v4 = d4, l4 += t3.Rc, d4 += t3.Rc, o3 += 2 * i3.A, s3(c4, (u4 += 2 * t3.fa) - t3.fa, c4, u4, p4, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4);
                return u4 += t3.fa, t3.j + y4 < t3.o ? (n2(e2.ec, e2.fc, c4, u4, w4), n2(e2.cc, e2.dc, h4, l4, N4), n2(e2.Mc, e2.Nc, f4, d4, N4), r2--) : 1 & y4 || s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3 + i3.A, null, null, w4), r2;
              }
              function lt2(t3, r2, n3) {
                var i3 = t3.F, a3 = [t3.J];
                if (i3 != null) {
                  var o3 = t3.U, s3 = r2.ba.S, c4 = s3 == Tn || s3 == Vn;
                  r2 = r2.ba.f.RGBA;
                  var u4 = [0], h4 = t3.ka;
                  u4[0] = t3.T, t3.Kb && (h4 == 0 ? --u4[0] : (--h4, a3[0] -= t3.width), t3.j + t3.ka + t3.T == t3.o && (u4[0] = t3.o - t3.j - h4));
                  var l4 = r2.eb;
                  h4 = r2.fb + h4 * r2.A;
                  t3 = Sn(i3, a3[0], t3.width, o3, u4, l4, h4 + (c4 ? 0 : 3), r2.A), e(n3 == u4), t3 && nt2(s3) && An(l4, h4, c4, o3, u4, r2.A);
                }
                return 0;
              }
              function ft2(t3) {
                var e2 = t3.ma, r2 = e2.ba.S, n3 = 11 > r2, i3 = r2 == qn || r2 == Rn || r2 == Tn || r2 == zn || r2 == 12 || nt2(r2);
                if (e2.memory = null, e2.Ib = null, e2.Jb = null, e2.Nd = null, !Mr(e2.Oa, t3, i3 ? 11 : 12))
                  return 0;
                if (i3 && nt2(r2) && br(), t3.da)
                  alert("todo:use_scaling");
                else {
                  if (n3) {
                    if (e2.Ib = ut2, t3.Kb) {
                      if (r2 = t3.U + 1 >> 1, e2.memory = a2(t3.U + 2 * r2), e2.memory == null)
                        return 0;
                      e2.ec = e2.memory, e2.fc = 0, e2.cc = e2.ec, e2.dc = e2.fc + t3.U, e2.Mc = e2.cc, e2.Nc = e2.dc + r2, e2.Ib = ht2, br();
                    }
                  } else
                    alert("todo:EmitYUV");
                  i3 && (e2.Jb = lt2, n3 && mr());
                }
                if (n3 && !Ci) {
                  for (t3 = 0; 256 > t3; ++t3)
                    ji[t3] = 89858 * (t3 - 128) + _i >> Si, Mi[t3] = -22014 * (t3 - 128) + _i, Bi[t3] = -45773 * (t3 - 128), Oi[t3] = 113618 * (t3 - 128) + _i >> Si;
                  for (t3 = Pi; t3 < ki; ++t3)
                    e2 = 76283 * (t3 - 16) + _i >> Si, Ei[t3 - Pi] = Vt2(e2, 255), qi[t3 - Pi] = Vt2(e2 + 8 >> 4, 15);
                  Ci = 1;
                }
                return 1;
              }
              function dt2(t3) {
                var r2 = t3.ma, n3 = t3.U, i3 = t3.T;
                return e(!(1 & t3.ka)), 0 >= n3 || 0 >= i3 ? 0 : (n3 = r2.Ib(t3, r2), r2.Jb != null && r2.Jb(t3, r2, n3), r2.Dc += n3, 1);
              }
              function pt2(t3) {
                t3.ma.memory = null;
              }
              function gt2(t3, e2, r2, n3) {
                return y3(t3, 8) != 47 ? 0 : (e2[0] = y3(t3, 14) + 1, r2[0] = y3(t3, 14) + 1, n3[0] = y3(t3, 1), y3(t3, 3) != 0 ? 0 : !t3.h);
              }
              function mt2(t3, e2) {
                if (4 > t3)
                  return t3 + 1;
                var r2 = t3 - 2 >> 1;
                return (2 + (1 & t3) << r2) + y3(e2, r2) + 1;
              }
              function vt2(t3, e2) {
                return 120 < e2 ? e2 - 120 : 1 <= (r2 = ((r2 = $n[e2 - 1]) >> 4) * t3 + (8 - (15 & r2))) ? r2 : 1;
                var r2;
              }
              function bt2(t3, e2, r2) {
                var n3 = L3(r2), i3 = t3[e2 += 255 & n3].g - 8;
                return 0 < i3 && (x2(r2, r2.u + 8), n3 = L3(r2), e2 += t3[e2].value, e2 += n3 & (1 << i3) - 1), x2(r2, r2.u + t3[e2].g), t3[e2].value;
              }
              function yt2(t3, r2, n3) {
                return n3.g += t3.g, n3.value += t3.value << r2 >>> 0, e(8 >= n3.g), t3.g;
              }
              function wt2(t3, r2, n3) {
                var i3 = t3.xc;
                return e((r2 = i3 == 0 ? 0 : t3.vc[t3.md * (n3 >> i3) + (r2 >> i3)]) < t3.Wb), t3.Ya[r2];
              }
              function Nt2(t3, r2, i3, a3) {
                var o3 = t3.ab, s3 = t3.c * r2, c4 = t3.C;
                r2 = c4 + r2;
                var u4 = i3, h4 = a3;
                for (a3 = t3.Ta, i3 = t3.Ua; 0 < o3--; ) {
                  var l4 = t3.gc[o3], f4 = c4, d4 = r2, p4 = u4, g4 = h4, m4 = (h4 = a3, u4 = i3, l4.Ea);
                  switch (e(f4 < d4), e(d4 <= l4.nc), l4.hc) {
                    case 2:
                      Gr(p4, g4, (d4 - f4) * m4, h4, u4);
                      break;
                    case 0:
                      var v4 = f4, b4 = d4, y4 = h4, w4 = u4, N4 = (_3 = l4).Ea;
                      v4 == 0 && (Wr(p4, g4, null, null, 1, y4, w4), V2(p4, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
                      for (var L4 = 1 << _3.b, A4 = L4 - 1, x3 = q2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * x3; v4 < b4; ) {
                        var P3 = S3, k3 = _3, I3 = 1;
                        for (Vr(p4, g4, y4, w4 - N4, 1, y4, w4); I3 < N4; ) {
                          var F3 = (I3 & ~A4) + L4;
                          F3 > N4 && (F3 = N4), (0, Zr[P3[k3++] >> 8 & 15])(p4, g4 + +I3, y4, w4 + I3 - N4, F3 - I3, y4, w4 + I3), I3 = F3;
                        }
                        g4 += N4, w4 += N4, ++v4 & A4 || (_3 += x3);
                      }
                      d4 != l4.nc && n2(h4, u4 - m4, h4, u4 + (d4 - f4 - 1) * m4, m4);
                      break;
                    case 1:
                      for (m4 = p4, b4 = g4, N4 = (p4 = l4.Ea) - (w4 = p4 & ~(y4 = (g4 = 1 << l4.b) - 1)), v4 = q2(p4, l4.b), L4 = l4.K, l4 = l4.w + (f4 >> l4.b) * v4; f4 < d4; ) {
                        for (A4 = L4, x3 = l4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p4; b4 < _3; )
                          Y2(A4[x3++], S3), $r(S3, m4, b4, g4, h4, u4), b4 += g4, u4 += g4;
                        b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m4, b4, N4, h4, u4), b4 += N4, u4 += N4), ++f4 & y4 || (l4 += v4);
                      }
                      break;
                    case 3:
                      if (p4 == h4 && g4 == u4 && 0 < l4.b) {
                        for (b4 = h4, p4 = m4 = u4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * q2(l4.Ea, l4.b)), g4 = h4, y4 = u4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4)
                          v4[w4] = g4[y4 + w4];
                        for (w4 = N4 - 1; 0 <= w4; --w4)
                          b4[p4 + w4] = v4[w4];
                        Yr(l4, f4, d4, h4, m4, h4, u4);
                      } else
                        Yr(l4, f4, d4, p4, g4, h4, u4);
                  }
                  u4 = a3, h4 = i3;
                }
                h4 != i3 && n2(a3, i3, u4, h4, s3);
              }
              function Lt2(t3, r2) {
                var n3 = t3.V, i3 = t3.Ba + t3.c * t3.C, a3 = r2 - t3.C;
                if (e(r2 <= t3.l.o), e(16 >= a3), 0 < a3) {
                  var o3 = t3.l, s3 = t3.Ta, c4 = t3.Ua, u4 = o3.width;
                  if (Nt2(t3, a3, n3, i3), a3 = c4 = [c4], e((n3 = t3.C) < (i3 = r2)), e(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), n3 < o3.j) {
                    var h4 = o3.j - n3;
                    n3 = o3.j;
                    a3[0] += h4 * u4;
                  }
                  if (n3 >= i3 ? n3 = 0 : (a3[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - n3, n3 = 1), n3) {
                    if (c4 = c4[0], 11 > (n3 = t3.ca).S) {
                      var l4 = n3.f.RGBA, f4 = (i3 = n3.S, a3 = o3.U, o3 = o3.T, h4 = l4.eb, l4.A), d4 = o3;
                      for (l4 = l4.fb + t3.Ma * l4.A; 0 < d4--; ) {
                        var p4 = s3, g4 = c4, m4 = a3, v4 = h4, b4 = l4;
                        switch (i3) {
                          case En:
                            Qr(p4, g4, m4, v4, b4);
                            break;
                          case qn:
                            tn(p4, g4, m4, v4, b4);
                            break;
                          case Hn:
                            tn(p4, g4, m4, v4, b4), An(v4, b4, 0, m4, 1, 0);
                            break;
                          case Dn:
                            nn(p4, g4, m4, v4, b4);
                            break;
                          case Rn:
                            et2(p4, g4, m4, v4, b4, 1);
                            break;
                          case Wn:
                            et2(p4, g4, m4, v4, b4, 1), An(v4, b4, 0, m4, 1, 0);
                            break;
                          case Tn:
                            et2(p4, g4, m4, v4, b4, 0);
                            break;
                          case Vn:
                            et2(p4, g4, m4, v4, b4, 0), An(v4, b4, 1, m4, 1, 0);
                            break;
                          case zn:
                            en(p4, g4, m4, v4, b4);
                            break;
                          case Gn:
                            en(p4, g4, m4, v4, b4), xn(v4, b4, m4, 1, 0);
                            break;
                          case Un:
                            rn(p4, g4, m4, v4, b4);
                            break;
                          default:
                            e(0);
                        }
                        c4 += u4, l4 += f4;
                      }
                      t3.Ma += o3;
                    } else
                      alert("todo:EmitRescaledRowsYUVA");
                    e(t3.Ma <= n3.height);
                  }
                }
                t3.C = r2, e(t3.C <= t3.i);
              }
              function At2(t3) {
                var e2;
                if (0 < t3.ua)
                  return 0;
                for (e2 = 0; e2 < t3.Wb; ++e2) {
                  var r2 = t3.Ya[e2].G, n3 = t3.Ya[e2].H;
                  if (0 < r2[1][n3[1] + 0].g || 0 < r2[2][n3[2] + 0].g || 0 < r2[3][n3[3] + 0].g)
                    return 0;
                }
                return 1;
              }
              function xt2(t3, r2, n3, i3, a3, o3) {
                if (t3.Z != 0) {
                  var s3 = t3.qd, c4 = t3.rd;
                  for (e(mi[t3.Z] != null); r2 < n3; ++r2)
                    mi[t3.Z](s3, c4, i3, a3, i3, a3, o3), s3 = i3, c4 = a3, a3 += o3;
                  t3.qd = s3, t3.rd = c4;
                }
              }
              function St2(t3, r2) {
                var n3 = t3.l.ma, i3 = n3.Z == 0 || n3.Z == 1 ? t3.l.j : t3.C;
                i3 = t3.C < i3 ? i3 : t3.C;
                if (e(r2 <= t3.l.o), r2 > i3) {
                  var a3 = t3.l.width, o3 = n3.ca, s3 = n3.tb + a3 * i3, c4 = t3.V, u4 = t3.Ba + t3.c * i3, h4 = t3.gc;
                  e(t3.ab == 1), e(h4[0].hc == 3), Xr(h4[0], i3, r2, c4, u4, o3, s3), xt2(n3, i3, r2, o3, s3, a3);
                }
                t3.C = t3.Ma = r2;
              }
              function _t2(t3, r2, n3, i3, a3, o3, s3) {
                var c4 = t3.$ / i3, u4 = t3.$ % i3, h4 = t3.m, l4 = t3.s, f4 = n3 + t3.$, d4 = f4;
                a3 = n3 + i3 * a3;
                var p4 = n3 + i3 * o3, g4 = 280 + l4.ua, m4 = t3.Pb ? c4 : 16777216, v4 = 0 < l4.ua ? l4.Wa : null, b4 = l4.wc, y4 = f4 < p4 ? wt2(l4, u4, c4) : null;
                e(t3.C < o3), e(p4 <= a3);
                var w4 = false;
                t:
                  for (; ; ) {
                    for (; w4 || f4 < p4; ) {
                      var N4 = 0;
                      if (c4 >= m4) {
                        var _3 = f4 - n3;
                        e((m4 = t3).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B2(m4.s.Wa, m4.s.vb), m4 = c4 + ti;
                      }
                      if (u4 & b4 || (y4 = wt2(l4, u4, c4)), e(y4 != null), y4.Qb && (r2[f4] = y4.qb, w4 = true), !w4)
                        if (S2(h4), y4.jc) {
                          N4 = h4, _3 = r2;
                          var P3 = f4, k3 = y4.pd[L3(N4) & Dr - 1];
                          e(y4.jc), 256 > k3.g ? (x2(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (x2(N4, N4.u + k3.g - 256), e(256 <= k3.value), N4 = k3.value), N4 == 0 && (w4 = true);
                        } else
                          N4 = bt2(y4.G[0], y4.H[0], h4);
                      if (h4.h)
                        break;
                      if (w4 || 256 > N4) {
                        if (!w4)
                          if (y4.nd)
                            r2[f4] = (y4.qb | N4 << 8) >>> 0;
                          else {
                            if (S2(h4), w4 = bt2(y4.G[1], y4.H[1], h4), S2(h4), _3 = bt2(y4.G[2], y4.H[2], h4), P3 = bt2(y4.G[3], y4.H[3], h4), h4.h)
                              break;
                            r2[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
                          }
                        if (w4 = false, ++f4, ++u4 >= i3 && (u4 = 0, ++c4, s3 != null && c4 <= o3 && !(c4 % 16) && s3(t3, c4), v4 != null))
                          for (; d4 < f4; )
                            N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
                      } else if (280 > N4) {
                        if (N4 = mt2(N4 - 256, h4), _3 = bt2(y4.G[4], y4.H[4], h4), S2(h4), _3 = vt2(i3, _3 = mt2(_3, h4)), h4.h)
                          break;
                        if (f4 - n3 < _3 || a3 - f4 < N4)
                          break t;
                        for (P3 = 0; P3 < N4; ++P3)
                          r2[f4 + P3] = r2[f4 + P3 - _3];
                        for (f4 += N4, u4 += N4; u4 >= i3; )
                          u4 -= i3, ++c4, s3 != null && c4 <= o3 && !(c4 % 16) && s3(t3, c4);
                        if (e(f4 <= a3), u4 & b4 && (y4 = wt2(l4, u4, c4)), v4 != null)
                          for (; d4 < f4; )
                            N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
                      } else {
                        if (!(N4 < g4))
                          break t;
                        for (w4 = N4 - 280, e(v4 != null); d4 < f4; )
                          N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
                        N4 = f4, e(!(w4 >>> (_3 = v4).Xa)), r2[N4] = _3.X[w4], w4 = true;
                      }
                      w4 || e(h4.h == A3(h4));
                    }
                    if (t3.Pb && h4.h && f4 < a3)
                      e(t3.m.h), t3.a = 5, t3.m = t3.wd, t3.$ = t3.xd, 0 < t3.s.ua && B2(t3.s.vb, t3.s.Wa);
                    else {
                      if (h4.h)
                        break t;
                      s3 != null && s3(t3, c4 > o3 ? o3 : c4), t3.a = 0, t3.$ = f4 - n3;
                    }
                    return 1;
                  }
                return t3.a = 3, 0;
              }
              function Pt2(t3) {
                e(t3 != null), t3.vc = null, t3.yc = null, t3.Ya = null;
                var r2 = t3.Wa;
                r2 != null && (r2.X = null), t3.vb = null, e(t3 != null);
              }
              function kt2() {
                var e2 = new or();
                return e2 == null ? null : (e2.a = 0, e2.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t2.VP8LMapColor32b = Jr, t2.VP8LMapColor8b = Kr, e2);
              }
              function It2(t3, r2, n3, s3, c4) {
                var u4 = 1, f4 = [t3], p4 = [r2], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
                t:
                  for (; ; ) {
                    if (n3)
                      for (; u4 && y3(g4, 1); ) {
                        var w4 = f4, N4 = p4, A4 = s3, _3 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y3(P3, 2);
                        if (A4.Oc & 1 << I3)
                          u4 = 0;
                        else {
                          switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++A4.ab, e(4 >= A4.ab), I3) {
                            case 0:
                            case 1:
                              k3.b = y3(P3, 3) + 2, _3 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                              break;
                            case 3:
                              var F3, C3 = y3(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                              if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _3 = It2(C3, 1, 0, A4, k3.K)) {
                                var B3, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T3 = a2(R3);
                                if (T3 == null)
                                  F3 = 0;
                                else {
                                  var z3 = E3.K[0], U3 = E3.w;
                                  for (T3[0] = E3.K[0][0], B3 = 1; B3 < 1 * M3; ++B3)
                                    T3[B3] = D2(z3[U3 + B3], T3[B3 - 1]);
                                  for (; B3 < 4 * R3; ++B3)
                                    T3[B3] = 0;
                                  E3.K[0] = null, E3.K[0] = T3, F3 = 1;
                                }
                              }
                              _3 = F3;
                              break;
                            case 2:
                              break;
                            default:
                              e(0);
                          }
                          u4 = _3;
                        }
                      }
                    if (f4 = f4[0], p4 = p4[0], u4 && y3(g4, 1) && !(u4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
                      s3.a = 3;
                      break t;
                    }
                    var H3;
                    if (H3 = u4)
                      e: {
                        var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p4, K3 = b4, Z3 = n3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, rt3 = 0, nt3 = Qn[K3];
                        r:
                          for (; ; ) {
                            if (Z3 && y3($3, 1)) {
                              var it3 = y3($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
                              if (!It2(at3, ot3, 0, Y3, tt3))
                                break r;
                              for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                                var ct3 = tt3[W3] >> 8 & 65535;
                                tt3[W3] = ct3, ct3 >= et3 && (et3 = ct3 + 1);
                              }
                            }
                            if ($3.h)
                              break r;
                            for (V3 = 0; 5 > V3; ++V3) {
                              var ut3 = Xn[V3];
                              !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
                            }
                            var ht3 = o2(et3 * nt3, l3), lt3 = et3, ft3 = o2(lt3, d3);
                            if (ft3 == null)
                              var dt3 = null;
                            else
                              e(65536 >= lt3), dt3 = ft3;
                            var pt3 = a2(rt3);
                            if (dt3 == null || pt3 == null || ht3 == null) {
                              Y3.a = 1;
                              break r;
                            }
                            var gt3 = ht3;
                            for (W3 = G3 = 0; W3 < et3; ++W3) {
                              var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                              for (V3 = 0; 5 > V3; ++V3) {
                                ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                                n: {
                                  var At3, xt3 = ut3, St3 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St3.m, Bt3 = y3(Ot3, 1);
                                  if (i2(kt3, 0, 0, xt3), Bt3) {
                                    var Mt3 = y3(Ot3, 1) + 1, Et3 = y3(Ot3, 1), qt3 = y3(Ot3, Et3 == 0 ? 1 : 8);
                                    kt3[qt3] = 1, Mt3 == 2 && (kt3[qt3 = y3(Ot3, 8)] = 1);
                                    var Dt3 = 1;
                                  } else {
                                    var Rt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                                    if (19 < Tt3) {
                                      St3.a = 3;
                                      var zt3 = 0;
                                      break n;
                                    }
                                    for (At3 = 0; At3 < Tt3; ++At3)
                                      Rt3[Zn[At3]] = y3(Ot3, 3);
                                    var Ut3 = void 0, Ht3 = void 0, Wt3 = St3, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, l3);
                                    i:
                                      for (; h3(Zt3, 0, 7, Vt3, 19); ) {
                                        if (y3(Xt3, 1)) {
                                          var $t3 = 2 + 2 * y3(Xt3, 3);
                                          if ((Ut3 = 2 + y3(Xt3, $t3)) > Gt3)
                                            break i;
                                        } else
                                          Ut3 = Gt3;
                                        for (Ht3 = 0; Ht3 < Gt3 && Ut3--; ) {
                                          S2(Xt3);
                                          var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                                          x2(Xt3, Xt3.u + Qt3.g);
                                          var te3 = Qt3.value;
                                          if (16 > te3)
                                            Yt3[Ht3++] = te3, te3 != 0 && (Kt3 = te3);
                                          else {
                                            var ee3 = te3 == 16, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y3(Xt3, Yn[re3]) + ne3;
                                            if (Ht3 + ie3 > Gt3)
                                              break i;
                                            for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; )
                                              Yt3[Ht3++] = ae3;
                                          }
                                        }
                                        Jt3 = 1;
                                        break i;
                                      }
                                    Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                                  }
                                  (Dt3 = Dt3 && !Ot3.h) && (jt3 = h3(Ft3, Ct3, 8, kt3, xt3)), Dt3 && jt3 != 0 ? zt3 = jt3 : (St3.a = 3, zt3 = 0);
                                }
                                if (zt3 == 0)
                                  break r;
                                if (Nt3 && Kn[V3] == 1 && (Nt3 = gt3[G3].g == 0), wt3 += gt3[G3].g, G3 += zt3, 3 >= V3) {
                                  var oe3, se3 = pt3[0];
                                  for (oe3 = 1; oe3 < ut3; ++oe3)
                                    pt3[oe3] > se3 && (se3 = pt3[oe3]);
                                  Lt3 += se3;
                                }
                              }
                              if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, wt3 == 0 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                                var ce3, ue3 = mt3;
                                for (ce3 = 0; ce3 < Dr; ++ce3) {
                                  var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                                  256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                                }
                              }
                            }
                            Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = ht3, H3 = 1;
                            break e;
                          }
                        H3 = 0;
                      }
                    if (!(u4 = H3)) {
                      s3.a = 3;
                      break t;
                    }
                    if (0 < b4) {
                      if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
                        s3.a = 1, u4 = 0;
                        break t;
                      }
                    } else
                      m4.ua = 0;
                    var de3 = s3, pe3 = f4, ge3 = p4, me3 = de3.s, ve3 = me3.xc;
                    if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = ve3 == 0 ? -1 : (1 << ve3) - 1, n3) {
                      s3.xb = pi;
                      break t;
                    }
                    if ((v4 = a2(f4 * p4)) == null) {
                      s3.a = 1, u4 = 0;
                      break t;
                    }
                    u4 = (u4 = _t2(s3, v4, 0, f4, p4, p4, null)) && !g4.h;
                    break t;
                  }
                return u4 ? (c4 != null ? c4[0] = v4 : (e(v4 == null), e(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u4;
              }
              function Ft2(t3, r2) {
                var n3 = t3.c * t3.i, i3 = n3 + r2 + 16 * r2;
                return e(t3.c <= r2), t3.V = a2(i3), t3.V == null ? (t3.Ta = null, t3.Ua = 0, t3.a = 1, 0) : (t3.Ta = t3.V, t3.Ua = t3.Ba + n3 + r2, 1);
              }
              function Ct2(t3, r2) {
                var n3 = t3.C, i3 = r2 - n3, a3 = t3.V, o3 = t3.Ba + t3.c * n3;
                for (e(r2 <= t3.l.o); 0 < i3; ) {
                  var s3 = 16 < i3 ? 16 : i3, c4 = t3.l.ma, u4 = t3.l.width, h4 = u4 * s3, l4 = c4.ca, f4 = c4.tb + u4 * n3, d4 = t3.Ta, p4 = t3.Ua;
                  Nt2(t3, s3, a3, o3), _n(d4, p4, l4, f4, h4), xt2(c4, n3, n3 + s3, l4, f4, u4), i3 -= s3, a3 += s3 * t3.c, n3 += s3;
                }
                e(n3 == r2), t3.C = t3.Ma = r2;
              }
              function jt2() {
                this.ub = this.yd = this.td = this.Rb = 0;
              }
              function Ot2() {
                this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
              }
              function Bt2() {
                this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
              }
              function Mt2() {
                this.Yb = function() {
                  var t3 = [];
                  return function t4(e2, r2, n3) {
                    for (var i3 = n3[r2], a3 = 0; a3 < i3 && (e2.push(n3.length > r2 + 1 ? [] : 0), !(n3.length < r2 + 1)); a3++)
                      t4(e2[a3], r2 + 1, n3);
                  }(t3, 0, [3, 11]), t3;
                }();
              }
              function Et2() {
                this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
              }
              function qt2() {
                this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
              }
              function Dt2() {
                this.ld = this.La = this.dd = this.tc = 0;
              }
              function Rt2() {
                this.Na = this.la = 0;
              }
              function Tt2() {
                this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
              }
              function zt2() {
                this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
              }
              function Ut2() {
                this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new zt2()), this.aa = 0, this.l = new Gt2();
              }
              function Ht2() {
                this.y = a2(16), this.f = a2(8), this.ea = a2(8);
              }
              function Wt2() {
                this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new Ut2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new zt2()), this.L = this.aa = 0, this.gd = s2([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
              }
              function Vt2(t3, e2) {
                return 0 > t3 ? 0 : t3 > e2 ? e2 : t3;
              }
              function Gt2() {
                this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
              }
              function Yt2() {
                var t3 = new Wt2();
                return t3 != null && (t3.a = 0, t3.sc = "OK", t3.cb = 0, t3.Xb = 0, ni || (ni = Zt2)), t3;
              }
              function Jt2(t3, e2, r2) {
                return t3.a == 0 && (t3.a = e2, t3.sc = r2, t3.cb = 0), 0;
              }
              function Xt2(t3, e2, r2) {
                return 3 <= r2 && t3[e2 + 0] == 157 && t3[e2 + 1] == 1 && t3[e2 + 2] == 42;
              }
              function Kt2(t3, r2) {
                if (t3 == null)
                  return 0;
                if (t3.a = 0, t3.sc = "OK", r2 == null)
                  return Jt2(t3, 2, "null VP8Io passed to VP8GetHeaders()");
                var n3 = r2.data, a3 = r2.w, o3 = r2.ha;
                if (4 > o3)
                  return Jt2(t3, 7, "Truncated header.");
                var s3 = n3[a3 + 0] | n3[a3 + 1] << 8 | n3[a3 + 2] << 16, c4 = t3.Od;
                if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td)
                  return Jt2(t3, 3, "Incorrect keyframe parameters.");
                if (!c4.yd)
                  return Jt2(t3, 4, "Frame not displayable.");
                a3 += 3, o3 -= 3;
                var u4 = t3.Kc;
                if (c4.Rb) {
                  if (7 > o3)
                    return Jt2(t3, 7, "cannot parse picture header");
                  if (!Xt2(n3, a3, o3))
                    return Jt2(t3, 3, "Bad code word");
                  u4.c = 16383 & (n3[a3 + 4] << 8 | n3[a3 + 3]), u4.Td = n3[a3 + 4] >> 6, u4.i = 16383 & (n3[a3 + 6] << 8 | n3[a3 + 5]), u4.Ud = n3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t3.za = u4.c + 15 >> 4, t3.Ub = u4.i + 15 >> 4, r2.width = u4.c, r2.height = u4.i, r2.Da = 0, r2.j = 0, r2.v = 0, r2.va = r2.width, r2.o = r2.height, r2.da = 0, r2.ib = r2.width, r2.hb = r2.height, r2.U = r2.width, r2.T = r2.height, i2((s3 = t3.Pa).jb, 0, 255, s3.jb.length), e((s3 = t3.Qa) != null), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
                }
                if (c4.ub > o3)
                  return Jt2(t3, 7, "bad partition length");
                p3(s3 = t3.m, n3, a3, c4.ub), a3 += c4.ub, o3 -= c4.ub, c4.Rb && (u4.Ld = P2(s3), u4.Kd = P2(s3)), u4 = t3.Qa;
                var h4, l4 = t3.Pa;
                if (e(s3 != null), e(u4 != null), u4.Cb = P2(s3), u4.Cb) {
                  if (u4.Bb = P2(s3), P2(s3)) {
                    for (u4.Fb = P2(s3), h4 = 0; 4 > h4; ++h4)
                      u4.Zb[h4] = P2(s3) ? m3(s3, 7) : 0;
                    for (h4 = 0; 4 > h4; ++h4)
                      u4.Lb[h4] = P2(s3) ? m3(s3, 6) : 0;
                  }
                  if (u4.Bb)
                    for (h4 = 0; 3 > h4; ++h4)
                      l4.jb[h4] = P2(s3) ? g3(s3, 8) : 255;
                } else
                  u4.Bb = 0;
                if (s3.Ka)
                  return Jt2(t3, 3, "cannot parse segment header");
                if ((u4 = t3.ed).zd = P2(s3), u4.Tb = g3(s3, 6), u4.wb = g3(s3, 3), u4.Pc = P2(s3), u4.Pc && P2(s3)) {
                  for (l4 = 0; 4 > l4; ++l4)
                    P2(s3) && (u4.vd[l4] = m3(s3, 6));
                  for (l4 = 0; 4 > l4; ++l4)
                    P2(s3) && (u4.od[l4] = m3(s3, 6));
                }
                if (t3.L = u4.Tb == 0 ? 0 : u4.zd ? 1 : 2, s3.Ka)
                  return Jt2(t3, 3, "cannot parse filter header");
                var f4 = o3;
                if (o3 = h4 = a3, a3 = h4 + f4, u4 = f4, t3.Xb = (1 << g3(t3.m, 2)) - 1, f4 < 3 * (l4 = t3.Xb))
                  n3 = 7;
                else {
                  for (h4 += 3 * l4, u4 -= 3 * l4, f4 = 0; f4 < l4; ++f4) {
                    var d4 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;
                    d4 > u4 && (d4 = u4), p3(t3.Jc[+f4], n3, h4, d4), h4 += d4, u4 -= d4, o3 += 3;
                  }
                  p3(t3.Jc[+l4], n3, h4, u4), n3 = h4 < a3 ? 0 : 5;
                }
                if (n3 != 0)
                  return Jt2(t3, n3, "cannot parse partitions");
                for (n3 = g3(h4 = t3.m, 7), o3 = P2(h4) ? m3(h4, 4) : 0, a3 = P2(h4) ? m3(h4, 4) : 0, u4 = P2(h4) ? m3(h4, 4) : 0, l4 = P2(h4) ? m3(h4, 4) : 0, h4 = P2(h4) ? m3(h4, 4) : 0, f4 = t3.Qa, d4 = 0; 4 > d4; ++d4) {
                  if (f4.Cb) {
                    var v4 = f4.Zb[d4];
                    f4.Fb || (v4 += n3);
                  } else {
                    if (0 < d4) {
                      t3.pb[d4] = t3.pb[0];
                      continue;
                    }
                    v4 = n3;
                  }
                  var b4 = t3.pb[d4];
                  b4.Sc[0] = ei[Vt2(v4 + o3, 127)], b4.Sc[1] = ri[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ri[Vt2(v4 + u4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v4 + l4, 117)], b4.Qc[1] = ri[Vt2(v4 + h4, 127)], b4.lc = v4 + h4;
                }
                if (!c4.Rb)
                  return Jt2(t3, 4, "Not a key frame.");
                for (P2(s3), c4 = t3.Pa, n3 = 0; 4 > n3; ++n3) {
                  for (o3 = 0; 8 > o3; ++o3)
                    for (a3 = 0; 3 > a3; ++a3)
                      for (u4 = 0; 11 > u4; ++u4)
                        l4 = k2(s3, ui[n3][o3][a3][u4]) ? g3(s3, 8) : si[n3][o3][a3][u4], c4.Wc[n3][o3].Yb[a3][u4] = l4;
                  for (o3 = 0; 17 > o3; ++o3)
                    c4.Xc[n3][o3] = c4.Wc[n3][hi[o3]];
                }
                return t3.kc = P2(s3), t3.kc && (t3.Bd = g3(s3, 8)), t3.cb = 1;
              }
              function Zt2(t3, e2, r2, n3, i3, a3, o3) {
                var s3 = e2[i3].Yb[r2];
                for (r2 = 0; 16 > i3; ++i3) {
                  if (!k2(t3, s3[r2 + 0]))
                    return i3;
                  for (; !k2(t3, s3[r2 + 1]); )
                    if (s3 = e2[++i3].Yb[0], r2 = 0, i3 == 16)
                      return 16;
                  var c4 = e2[i3 + 1].Yb;
                  if (k2(t3, s3[r2 + 2])) {
                    var u4 = t3, h4 = 0;
                    if (k2(u4, (f4 = s3)[(l4 = r2) + 3]))
                      if (k2(u4, f4[l4 + 6])) {
                        for (s3 = 0, l4 = 2 * (h4 = k2(u4, f4[l4 + 8])) + (f4 = k2(u4, f4[l4 + 9 + h4])), h4 = 0, f4 = ii[l4]; f4[s3]; ++s3)
                          h4 += h4 + k2(u4, f4[s3]);
                        h4 += 3 + (8 << l4);
                      } else
                        k2(u4, f4[l4 + 7]) ? (h4 = 7 + 2 * k2(u4, 165), h4 += k2(u4, 145)) : h4 = 5 + k2(u4, 159);
                    else
                      h4 = k2(u4, f4[l4 + 4]) ? 3 + k2(u4, f4[l4 + 5]) : 2;
                    s3 = c4[2];
                  } else
                    h4 = 1, s3 = c4[1];
                  c4 = o3 + ai[i3], 0 > (u4 = t3).b && _2(u4);
                  var l4, f4 = u4.b, d4 = (l4 = u4.Ca >> 1) - (u4.I >> f4) >> 31;
                  --u4.b, u4.Ca += d4, u4.Ca |= 1, u4.I -= (l4 + 1 & d4) << f4, a3[c4] = ((h4 ^ d4) - d4) * n3[(0 < i3) + 0];
                }
                return 16;
              }
              function $t2(t3) {
                var e2 = t3.rb[t3.sb - 1];
                e2.la = 0, e2.Na = 0, i2(t3.zc, 0, 0, t3.zc.length), t3.ja = 0;
              }
              function Qt2(t3, r2) {
                if (t3 == null)
                  return 0;
                if (r2 == null)
                  return Jt2(t3, 2, "NULL VP8Io parameter in VP8Decode().");
                if (!t3.cb && !Kt2(t3, r2))
                  return 0;
                if (e(t3.cb), r2.ac == null || r2.ac(r2)) {
                  r2.ob && (t3.L = 0);
                  var s3 = Ri[t3.L];
                  if (t3.L == 2 ? (t3.yb = 0, t3.zb = 0) : (t3.yb = r2.v - s3 >> 4, t3.zb = r2.j - s3 >> 4, 0 > t3.yb && (t3.yb = 0), 0 > t3.zb && (t3.zb = 0)), t3.Va = r2.o + 15 + s3 >> 4, t3.Hb = r2.va + 15 + s3 >> 4, t3.Hb > t3.za && (t3.Hb = t3.za), t3.Va > t3.Ub && (t3.Va = t3.Ub), 0 < t3.L) {
                    var c4 = t3.ed;
                    for (s3 = 0; 4 > s3; ++s3) {
                      var u4;
                      if (t3.Qa.Cb) {
                        var h4 = t3.Qa.Lb[s3];
                        t3.Qa.Fb || (h4 += c4.Tb);
                      } else
                        h4 = c4.Tb;
                      for (u4 = 0; 1 >= u4; ++u4) {
                        var l4 = t3.gd[s3][u4], f4 = h4;
                        if (c4.Pc && (f4 += c4.vd[0], u4 && (f4 += c4.od[0])), 0 < (f4 = 0 > f4 ? 0 : 63 < f4 ? 63 : f4)) {
                          var d4 = f4;
                          0 < c4.wb && ((d4 = 4 < c4.wb ? d4 >> 2 : d4 >> 1) > 9 - c4.wb && (d4 = 9 - c4.wb)), 1 > d4 && (d4 = 1), l4.dd = d4, l4.tc = 2 * f4 + d4, l4.ld = 40 <= f4 ? 2 : 15 <= f4 ? 1 : 0;
                        } else
                          l4.tc = 0;
                        l4.La = u4;
                      }
                    }
                  }
                  s3 = 0;
                } else
                  Jt2(t3, 6, "Frame setup failed"), s3 = t3.a;
                if (s3 = s3 == 0) {
                  if (s3) {
                    t3.$c = 0, 0 < t3.Aa || (t3.Ic = zi);
                    t: {
                      s3 = t3.Ic;
                      c4 = 4 * (d4 = t3.za);
                      var p4 = 32 * d4, g4 = d4 + 1, m4 = 0 < t3.L ? d4 * (0 < t3.Aa ? 2 : 1) : 0, v4 = (t3.Aa == 2 ? 2 : 1) * d4;
                      if ((l4 = c4 + 832 + (u4 = 3 * (16 * s3 + Ri[t3.L]) / 2 * p4) + (h4 = t3.Fa != null && 0 < t3.Fa.length ? t3.Kc.c * t3.Kc.i : 0)) != l4)
                        s3 = 0;
                      else {
                        if (l4 > t3.Vb) {
                          if (t3.Vb = 0, t3.Ec = a2(l4), t3.Fc = 0, t3.Ec == null) {
                            s3 = Jt2(t3, 1, "no memory during frame initialization.");
                            break t;
                          }
                          t3.Vb = l4;
                        }
                        l4 = t3.Ec, f4 = t3.Fc, t3.Ac = l4, t3.Bc = f4, f4 += c4, t3.Gd = o2(p4, Ht2), t3.Hd = 0, t3.rb = o2(g4 + 1, Rt2), t3.sb = 1, t3.wa = m4 ? o2(m4, Dt2) : null, t3.Y = 0, t3.D.Nb = 0, t3.D.wa = t3.wa, t3.D.Y = t3.Y, 0 < t3.Aa && (t3.D.Y += d4), e(true), t3.oc = l4, t3.pc = f4, f4 += 832, t3.ya = o2(v4, zt2), t3.aa = 0, t3.D.ya = t3.ya, t3.D.aa = t3.aa, t3.Aa == 2 && (t3.D.aa += d4), t3.R = 16 * d4, t3.B = 8 * d4, d4 = (p4 = Ri[t3.L]) * t3.R, p4 = p4 / 2 * t3.B, t3.sa = l4, t3.ta = f4 + d4, t3.qa = t3.sa, t3.ra = t3.ta + 16 * s3 * t3.R + p4, t3.Ha = t3.qa, t3.Ia = t3.ra + 8 * s3 * t3.B + p4, t3.$c = 0, f4 += u4, t3.mb = h4 ? l4 : null, t3.nb = h4 ? f4 : null, e(f4 + h4 <= t3.Fc + t3.Vb), $t2(t3), i2(t3.Ac, t3.Bc, 0, c4), s3 = 1;
                      }
                    }
                    if (s3) {
                      if (r2.ka = 0, r2.y = t3.sa, r2.O = t3.ta, r2.f = t3.qa, r2.N = t3.ra, r2.ea = t3.Ha, r2.Vd = t3.Ia, r2.fa = t3.R, r2.Rc = t3.B, r2.F = null, r2.J = 0, !Cn) {
                        for (s3 = -255; 255 >= s3; ++s3)
                          Pn[255 + s3] = 0 > s3 ? -s3 : s3;
                        for (s3 = -1020; 1020 >= s3; ++s3)
                          kn[1020 + s3] = -128 > s3 ? -128 : 127 < s3 ? 127 : s3;
                        for (s3 = -112; 112 >= s3; ++s3)
                          In[112 + s3] = -16 > s3 ? -16 : 15 < s3 ? 15 : s3;
                        for (s3 = -255; 510 >= s3; ++s3)
                          Fn[255 + s3] = 0 > s3 ? 0 : 255 < s3 ? 255 : s3;
                        Cn = 1;
                      }
                      an = ue2, on = ae2, cn = oe2, un = se2, hn = ce2, sn = ie2, ln = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = Ue, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve2, li[1] = de2, li[2] = pe2, li[3] = ge2, li[4] = be2, li[5] = ye2, li[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s3 = 1;
                    } else
                      s3 = 0;
                  }
                  s3 && (s3 = function(t4, r3) {
                    for (t4.M = 0; t4.M < t4.Va; ++t4.M) {
                      var o3, s4 = t4.Jc[t4.M & t4.Xb], c5 = t4.m, u5 = t4;
                      for (o3 = 0; o3 < u5.za; ++o3) {
                        var h5 = c5, l5 = u5, f5 = l5.Ac, d5 = l5.Bc + 4 * o3, p5 = l5.zc, g5 = l5.ya[l5.aa + o3];
                        if (l5.Qa.Bb ? g5.$b = k2(h5, l5.Pa.jb[0]) ? 2 + k2(h5, l5.Pa.jb[2]) : k2(h5, l5.Pa.jb[1]) : g5.$b = 0, l5.kc && (g5.Ad = k2(h5, l5.Bd)), g5.Za = !k2(h5, 145) + 0, g5.Za) {
                          var m5 = g5.Ob, v5 = 0;
                          for (l5 = 0; 4 > l5; ++l5) {
                            var b4, y4 = p5[0 + l5];
                            for (b4 = 0; 4 > b4; ++b4) {
                              y4 = ci[f5[d5 + b4]][y4];
                              for (var w4 = oi[k2(h5, y4[0])]; 0 < w4; )
                                w4 = oi[2 * w4 + k2(h5, y4[w4])];
                              y4 = -w4, f5[d5 + b4] = y4;
                            }
                            n2(m5, v5, f5, d5, 4), v5 += 4, p5[0 + l5] = y4;
                          }
                        } else
                          y4 = k2(h5, 156) ? k2(h5, 128) ? 1 : 3 : k2(h5, 163) ? 2 : 0, g5.Ob[0] = y4, i2(f5, d5, y4, 4), i2(p5, 0, y4, 4);
                        g5.Dd = k2(h5, 142) ? k2(h5, 114) ? k2(h5, 183) ? 1 : 3 : 2 : 0;
                      }
                      if (u5.m.Ka)
                        return Jt2(t4, 7, "Premature end-of-partition0 encountered.");
                      for (; t4.ja < t4.za; ++t4.ja) {
                        if (u5 = s4, h5 = (c5 = t4).rb[c5.sb - 1], f5 = c5.rb[c5.sb + c5.ja], o3 = c5.ya[c5.aa + c5.ja], d5 = c5.kc ? o3.Ad : 0)
                          h5.la = f5.la = 0, o3.Za || (h5.Na = f5.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
                        else {
                          var N4, L4;
                          h5 = f5, f5 = u5, d5 = c5.Pa.Xc, p5 = c5.ya[c5.aa + c5.ja], g5 = c5.pb[p5.$b];
                          if (l5 = p5.ad, m5 = 0, v5 = c5.rb[c5.sb - 1], y4 = b4 = 0, i2(l5, m5, 0, 384), p5.Za)
                            var A4 = 0, x3 = d5[3];
                          else {
                            w4 = a2(16);
                            var S3 = h5.Na + v5.Na;
                            if (S3 = ni(f5, d5[1], S3, g5.Eb, 0, w4, 0), h5.Na = v5.Na = (0 < S3) + 0, 1 < S3)
                              an(w4, 0, l5, m5);
                            else {
                              var _3 = w4[0] + 3 >> 3;
                              for (w4 = 0; 256 > w4; w4 += 16)
                                l5[m5 + w4] = _3;
                            }
                            A4 = 1, x3 = d5[0];
                          }
                          var P3 = 15 & h5.la, I3 = 15 & v5.la;
                          for (w4 = 0; 4 > w4; ++w4) {
                            var F3 = 1 & I3;
                            for (_3 = L4 = 0; 4 > _3; ++_3)
                              P3 = P3 >> 1 | (F3 = (S3 = ni(f5, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l5, m5)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : l5[m5 + 0] != 0), m5 += 16;
                            P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                          }
                          for (x3 = P3, A4 = I3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                            for (L4 = 0, P3 = h5.la >> 4 + N4, I3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                              for (F3 = 1 & I3, _3 = 0; 2 > _3; ++_3)
                                S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f5, d5[2], S3, g5.Qc, 0, l5, m5))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : l5[m5 + 0] != 0), m5 += 16;
                              P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                            }
                            y4 |= L4 << 4 * N4, x3 |= P3 << 4 << N4, A4 |= (240 & I3) << N4;
                          }
                          h5.la = x3, v5.la = A4, p5.Hc = b4, p5.Gc = y4, p5.ia = 43690 & y4 ? 0 : g5.ia, d5 = !(b4 | y4);
                        }
                        if (0 < c5.L && (c5.wa[c5.Y + c5.ja] = c5.gd[o3.$b][o3.Za], c5.wa[c5.Y + c5.ja].La |= !d5), u5.Ka)
                          return Jt2(t4, 7, "Premature end-of-file encountered.");
                      }
                      if ($t2(t4), c5 = r3, u5 = 1, o3 = (s4 = t4).D, h5 = 0 < s4.L && s4.M >= s4.zb && s4.M <= s4.Va, s4.Aa == 0)
                        t: {
                          if (o3.M = s4.M, o3.uc = h5, Or(s4, o3), u5 = 1, o3 = (L4 = s4.D).Nb, h5 = (y4 = Ri[s4.L]) * s4.R, f5 = y4 / 2 * s4.B, w4 = 16 * o3 * s4.R, _3 = 8 * o3 * s4.B, d5 = s4.sa, p5 = s4.ta - h5 + w4, g5 = s4.qa, l5 = s4.ra - f5 + _3, m5 = s4.Ha, v5 = s4.Ia - f5 + _3, I3 = (P3 = L4.M) == 0, b4 = P3 >= s4.Va - 1, s4.Aa == 2 && Or(s4, L4), L4.uc)
                            for (F3 = (S3 = s4).D.M, e(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                              A4 = L4, x3 = F3;
                              var C3 = (j3 = (z3 = S3).D).Nb;
                              N4 = z3.R;
                              var j3 = j3.wa[j3.Y + A4], O3 = z3.sa, B3 = z3.ta + 16 * C3 * N4 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                              if (E3 != 0)
                                if (e(3 <= E3), z3.L == 1)
                                  0 < A4 && wn(O3, B3, N4, E3 + 4), j3.La && Ln(O3, B3, N4, E3), 0 < x3 && yn(O3, B3, N4, E3 + 4), j3.La && Nn(O3, B3, N4, E3);
                                else {
                                  var q3 = z3.B, D3 = z3.qa, R3 = z3.ra + 8 * C3 * q3 + 8 * A4, T3 = z3.Ha, z3 = z3.Ia + 8 * C3 * q3 + 8 * A4;
                                  C3 = j3.ld;
                                  0 < A4 && (fn(O3, B3, N4, E3 + 4, M3, C3), pn(D3, R3, T3, z3, q3, E3 + 4, M3, C3)), j3.La && (mn(O3, B3, N4, E3, M3, C3), bn(D3, R3, T3, z3, q3, E3, M3, C3)), 0 < x3 && (ln(O3, B3, N4, E3 + 4, M3, C3), dn(D3, R3, T3, z3, q3, E3 + 4, M3, C3)), j3.La && (gn(O3, B3, N4, E3, M3, C3), vn(D3, R3, T3, z3, q3, E3, M3, C3));
                                }
                            }
                          if (s4.ia && alert("todo:DitherRow"), c5.put != null) {
                            if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c5.y = s4.sa, c5.O = s4.ta + w4, c5.f = s4.qa, c5.N = s4.ra + _3, c5.ea = s4.Ha, c5.W = s4.Ia + _3) : (L4 -= y4, c5.y = d5, c5.O = p5, c5.f = g5, c5.N = l5, c5.ea = m5, c5.W = v5), b4 || (P3 -= y4), P3 > c5.o && (P3 = c5.o), c5.F = null, c5.J = null, s4.Fa != null && 0 < s4.Fa.length && L4 < P3 && (c5.J = lr(s4, c5, L4, P3 - L4), c5.F = s4.mb, c5.F == null && c5.F.length == 0)) {
                              u5 = Jt2(s4, 3, "Could not decode alpha data.");
                              break t;
                            }
                            L4 < c5.j && (y4 = c5.j - L4, L4 = c5.j, e(!(1 & y4)), c5.O += s4.R * y4, c5.N += s4.B * (y4 >> 1), c5.W += s4.B * (y4 >> 1), c5.F != null && (c5.J += c5.width * y4)), L4 < P3 && (c5.O += c5.v, c5.N += c5.v >> 1, c5.W += c5.v >> 1, c5.F != null && (c5.J += c5.v), c5.ka = L4 - c5.j, c5.U = c5.va - c5.v, c5.T = P3 - L4, u5 = c5.put(c5));
                          }
                          o3 + 1 != s4.Ic || b4 || (n2(s4.sa, s4.ta - h5, d5, p5 + 16 * s4.R, h5), n2(s4.qa, s4.ra - f5, g5, l5 + 8 * s4.B, f5), n2(s4.Ha, s4.Ia - f5, m5, v5 + 8 * s4.B, f5));
                        }
                      if (!u5)
                        return Jt2(t4, 6, "Output aborted.");
                    }
                    return 1;
                  }(t3, r2)), r2.bc != null && r2.bc(r2), s3 &= 1;
                }
                return s3 ? (t3.cb = 0, s3) : 0;
              }
              function te2(t3, e2, r2, n3, i3) {
                i3 = t3[e2 + r2 + 32 * n3] + (i3 >> 3), t3[e2 + r2 + 32 * n3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
              }
              function ee2(t3, e2, r2, n3, i3, a3) {
                te2(t3, e2, 0, r2, n3 + i3), te2(t3, e2, 1, r2, n3 + a3), te2(t3, e2, 2, r2, n3 - a3), te2(t3, e2, 3, r2, n3 - i3);
              }
              function re2(t3) {
                return (20091 * t3 >> 16) + t3;
              }
              function ne2(t3, e2, r2, n3) {
                var i3, o3 = 0, s3 = a2(16);
                for (i3 = 0; 4 > i3; ++i3) {
                  var c4 = t3[e2 + 0] + t3[e2 + 8], u4 = t3[e2 + 0] - t3[e2 + 8], h4 = (35468 * t3[e2 + 4] >> 16) - re2(t3[e2 + 12]), l4 = re2(t3[e2 + 4]) + (35468 * t3[e2 + 12] >> 16);
                  s3[o3 + 0] = c4 + l4, s3[o3 + 1] = u4 + h4, s3[o3 + 2] = u4 - h4, s3[o3 + 3] = c4 - l4, o3 += 4, e2++;
                }
                for (i3 = o3 = 0; 4 > i3; ++i3)
                  c4 = (t3 = s3[o3 + 0] + 4) + s3[o3 + 8], u4 = t3 - s3[o3 + 8], h4 = (35468 * s3[o3 + 4] >> 16) - re2(s3[o3 + 12]), te2(r2, n3, 0, 0, c4 + (l4 = re2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), te2(r2, n3, 1, 0, u4 + h4), te2(r2, n3, 2, 0, u4 - h4), te2(r2, n3, 3, 0, c4 - l4), o3++, n3 += 32;
              }
              function ie2(t3, e2, r2, n3) {
                var i3 = t3[e2 + 0] + 4, a3 = 35468 * t3[e2 + 4] >> 16, o3 = re2(t3[e2 + 4]), s3 = 35468 * t3[e2 + 1] >> 16;
                ee2(r2, n3, 0, i3 + o3, t3 = re2(t3[e2 + 1]), s3), ee2(r2, n3, 1, i3 + a3, t3, s3), ee2(r2, n3, 2, i3 - a3, t3, s3), ee2(r2, n3, 3, i3 - o3, t3, s3);
              }
              function ae2(t3, e2, r2, n3, i3) {
                ne2(t3, e2, r2, n3), i3 && ne2(t3, e2 + 16, r2, n3 + 4);
              }
              function oe2(t3, e2, r2, n3) {
                on(t3, e2 + 0, r2, n3, 1), on(t3, e2 + 32, r2, n3 + 128, 1);
              }
              function se2(t3, e2, r2, n3) {
                var i3;
                for (t3 = t3[e2 + 0] + 4, i3 = 0; 4 > i3; ++i3)
                  for (e2 = 0; 4 > e2; ++e2)
                    te2(r2, n3, e2, i3, t3);
              }
              function ce2(t3, e2, r2, n3) {
                t3[e2 + 0] && un(t3, e2 + 0, r2, n3), t3[e2 + 16] && un(t3, e2 + 16, r2, n3 + 4), t3[e2 + 32] && un(t3, e2 + 32, r2, n3 + 128), t3[e2 + 48] && un(t3, e2 + 48, r2, n3 + 128 + 4);
              }
              function ue2(t3, e2, r2, n3) {
                var i3, o3 = a2(16);
                for (i3 = 0; 4 > i3; ++i3) {
                  var s3 = t3[e2 + 0 + i3] + t3[e2 + 12 + i3], c4 = t3[e2 + 4 + i3] + t3[e2 + 8 + i3], u4 = t3[e2 + 4 + i3] - t3[e2 + 8 + i3], h4 = t3[e2 + 0 + i3] - t3[e2 + 12 + i3];
                  o3[0 + i3] = s3 + c4, o3[8 + i3] = s3 - c4, o3[4 + i3] = h4 + u4, o3[12 + i3] = h4 - u4;
                }
                for (i3 = 0; 4 > i3; ++i3)
                  s3 = (t3 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], c4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], u4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], h4 = t3 - o3[3 + 4 * i3], r2[n3 + 0] = s3 + c4 >> 3, r2[n3 + 16] = h4 + u4 >> 3, r2[n3 + 32] = s3 - c4 >> 3, r2[n3 + 48] = h4 - u4 >> 3, n3 += 64;
              }
              function he2(t3, e2, r2) {
                var n3, i3 = e2 - 32, a3 = Bn, o3 = 255 - t3[i3 - 1];
                for (n3 = 0; n3 < r2; ++n3) {
                  var s3, c4 = a3, u4 = o3 + t3[e2 - 1];
                  for (s3 = 0; s3 < r2; ++s3)
                    t3[e2 + s3] = c4[u4 + t3[i3 + s3]];
                  e2 += 32;
                }
              }
              function le2(t3, e2) {
                he2(t3, e2, 4);
              }
              function fe2(t3, e2) {
                he2(t3, e2, 8);
              }
              function de2(t3, e2) {
                he2(t3, e2, 16);
              }
              function pe2(t3, e2) {
                var r2;
                for (r2 = 0; 16 > r2; ++r2)
                  n2(t3, e2 + 32 * r2, t3, e2 - 32, 16);
              }
              function ge2(t3, e2) {
                var r2;
                for (r2 = 16; 0 < r2; --r2)
                  i2(t3, e2, t3[e2 - 1], 16), e2 += 32;
              }
              function me2(t3, e2, r2) {
                var n3;
                for (n3 = 0; 16 > n3; ++n3)
                  i2(e2, r2 + 32 * n3, t3, 16);
              }
              function ve2(t3, e2) {
                var r2, n3 = 16;
                for (r2 = 0; 16 > r2; ++r2)
                  n3 += t3[e2 - 1 + 32 * r2] + t3[e2 + r2 - 32];
                me2(n3 >> 5, t3, e2);
              }
              function be2(t3, e2) {
                var r2, n3 = 8;
                for (r2 = 0; 16 > r2; ++r2)
                  n3 += t3[e2 - 1 + 32 * r2];
                me2(n3 >> 4, t3, e2);
              }
              function ye2(t3, e2) {
                var r2, n3 = 8;
                for (r2 = 0; 16 > r2; ++r2)
                  n3 += t3[e2 + r2 - 32];
                me2(n3 >> 4, t3, e2);
              }
              function we2(t3, e2) {
                me2(128, t3, e2);
              }
              function Ne2(t3, e2, r2) {
                return t3 + 2 * e2 + r2 + 2 >> 2;
              }
              function Le2(t3, e2) {
                var r2, i3 = e2 - 32;
                i3 = new Uint8Array([Ne2(t3[i3 - 1], t3[i3 + 0], t3[i3 + 1]), Ne2(t3[i3 + 0], t3[i3 + 1], t3[i3 + 2]), Ne2(t3[i3 + 1], t3[i3 + 2], t3[i3 + 3]), Ne2(t3[i3 + 2], t3[i3 + 3], t3[i3 + 4])]);
                for (r2 = 0; 4 > r2; ++r2)
                  n2(t3, e2 + 32 * r2, i3, 0, i3.length);
              }
              function Ae(t3, e2) {
                var r2 = t3[e2 - 1], n3 = t3[e2 - 1 + 32], i3 = t3[e2 - 1 + 64], a3 = t3[e2 - 1 + 96];
                I2(t3, e2 + 0, 16843009 * Ne2(t3[e2 - 1 - 32], r2, n3)), I2(t3, e2 + 32, 16843009 * Ne2(r2, n3, i3)), I2(t3, e2 + 64, 16843009 * Ne2(n3, i3, a3)), I2(t3, e2 + 96, 16843009 * Ne2(i3, a3, a3));
              }
              function xe(t3, e2) {
                var r2, n3 = 4;
                for (r2 = 0; 4 > r2; ++r2)
                  n3 += t3[e2 + r2 - 32] + t3[e2 - 1 + 32 * r2];
                for (n3 >>= 3, r2 = 0; 4 > r2; ++r2)
                  i2(t3, e2 + 32 * r2, n3, 4);
              }
              function Se(t3, e2) {
                var r2 = t3[e2 - 1 + 0], n3 = t3[e2 - 1 + 32], i3 = t3[e2 - 1 + 64], a3 = t3[e2 - 1 - 32], o3 = t3[e2 + 0 - 32], s3 = t3[e2 + 1 - 32], c4 = t3[e2 + 2 - 32], u4 = t3[e2 + 3 - 32];
                t3[e2 + 0 + 96] = Ne2(n3, i3, t3[e2 - 1 + 96]), t3[e2 + 1 + 96] = t3[e2 + 0 + 64] = Ne2(r2, n3, i3), t3[e2 + 2 + 96] = t3[e2 + 1 + 64] = t3[e2 + 0 + 32] = Ne2(a3, r2, n3), t3[e2 + 3 + 96] = t3[e2 + 2 + 64] = t3[e2 + 1 + 32] = t3[e2 + 0 + 0] = Ne2(o3, a3, r2), t3[e2 + 3 + 64] = t3[e2 + 2 + 32] = t3[e2 + 1 + 0] = Ne2(s3, o3, a3), t3[e2 + 3 + 32] = t3[e2 + 2 + 0] = Ne2(c4, s3, o3), t3[e2 + 3 + 0] = Ne2(u4, c4, s3);
              }
              function _e(t3, e2) {
                var r2 = t3[e2 + 1 - 32], n3 = t3[e2 + 2 - 32], i3 = t3[e2 + 3 - 32], a3 = t3[e2 + 4 - 32], o3 = t3[e2 + 5 - 32], s3 = t3[e2 + 6 - 32], c4 = t3[e2 + 7 - 32];
                t3[e2 + 0 + 0] = Ne2(t3[e2 + 0 - 32], r2, n3), t3[e2 + 1 + 0] = t3[e2 + 0 + 32] = Ne2(r2, n3, i3), t3[e2 + 2 + 0] = t3[e2 + 1 + 32] = t3[e2 + 0 + 64] = Ne2(n3, i3, a3), t3[e2 + 3 + 0] = t3[e2 + 2 + 32] = t3[e2 + 1 + 64] = t3[e2 + 0 + 96] = Ne2(i3, a3, o3), t3[e2 + 3 + 32] = t3[e2 + 2 + 64] = t3[e2 + 1 + 96] = Ne2(a3, o3, s3), t3[e2 + 3 + 64] = t3[e2 + 2 + 96] = Ne2(o3, s3, c4), t3[e2 + 3 + 96] = Ne2(s3, c4, c4);
              }
              function Pe(t3, e2) {
                var r2 = t3[e2 - 1 + 0], n3 = t3[e2 - 1 + 32], i3 = t3[e2 - 1 + 64], a3 = t3[e2 - 1 - 32], o3 = t3[e2 + 0 - 32], s3 = t3[e2 + 1 - 32], c4 = t3[e2 + 2 - 32], u4 = t3[e2 + 3 - 32];
                t3[e2 + 0 + 0] = t3[e2 + 1 + 64] = a3 + o3 + 1 >> 1, t3[e2 + 1 + 0] = t3[e2 + 2 + 64] = o3 + s3 + 1 >> 1, t3[e2 + 2 + 0] = t3[e2 + 3 + 64] = s3 + c4 + 1 >> 1, t3[e2 + 3 + 0] = c4 + u4 + 1 >> 1, t3[e2 + 0 + 96] = Ne2(i3, n3, r2), t3[e2 + 0 + 64] = Ne2(n3, r2, a3), t3[e2 + 0 + 32] = t3[e2 + 1 + 96] = Ne2(r2, a3, o3), t3[e2 + 1 + 32] = t3[e2 + 2 + 96] = Ne2(a3, o3, s3), t3[e2 + 2 + 32] = t3[e2 + 3 + 96] = Ne2(o3, s3, c4), t3[e2 + 3 + 32] = Ne2(s3, c4, u4);
              }
              function ke(t3, e2) {
                var r2 = t3[e2 + 0 - 32], n3 = t3[e2 + 1 - 32], i3 = t3[e2 + 2 - 32], a3 = t3[e2 + 3 - 32], o3 = t3[e2 + 4 - 32], s3 = t3[e2 + 5 - 32], c4 = t3[e2 + 6 - 32], u4 = t3[e2 + 7 - 32];
                t3[e2 + 0 + 0] = r2 + n3 + 1 >> 1, t3[e2 + 1 + 0] = t3[e2 + 0 + 64] = n3 + i3 + 1 >> 1, t3[e2 + 2 + 0] = t3[e2 + 1 + 64] = i3 + a3 + 1 >> 1, t3[e2 + 3 + 0] = t3[e2 + 2 + 64] = a3 + o3 + 1 >> 1, t3[e2 + 0 + 32] = Ne2(r2, n3, i3), t3[e2 + 1 + 32] = t3[e2 + 0 + 96] = Ne2(n3, i3, a3), t3[e2 + 2 + 32] = t3[e2 + 1 + 96] = Ne2(i3, a3, o3), t3[e2 + 3 + 32] = t3[e2 + 2 + 96] = Ne2(a3, o3, s3), t3[e2 + 3 + 64] = Ne2(o3, s3, c4), t3[e2 + 3 + 96] = Ne2(s3, c4, u4);
              }
              function Ie(t3, e2) {
                var r2 = t3[e2 - 1 + 0], n3 = t3[e2 - 1 + 32], i3 = t3[e2 - 1 + 64], a3 = t3[e2 - 1 + 96];
                t3[e2 + 0 + 0] = r2 + n3 + 1 >> 1, t3[e2 + 2 + 0] = t3[e2 + 0 + 32] = n3 + i3 + 1 >> 1, t3[e2 + 2 + 32] = t3[e2 + 0 + 64] = i3 + a3 + 1 >> 1, t3[e2 + 1 + 0] = Ne2(r2, n3, i3), t3[e2 + 3 + 0] = t3[e2 + 1 + 32] = Ne2(n3, i3, a3), t3[e2 + 3 + 32] = t3[e2 + 1 + 64] = Ne2(i3, a3, a3), t3[e2 + 3 + 64] = t3[e2 + 2 + 64] = t3[e2 + 0 + 96] = t3[e2 + 1 + 96] = t3[e2 + 2 + 96] = t3[e2 + 3 + 96] = a3;
              }
              function Fe(t3, e2) {
                var r2 = t3[e2 - 1 + 0], n3 = t3[e2 - 1 + 32], i3 = t3[e2 - 1 + 64], a3 = t3[e2 - 1 + 96], o3 = t3[e2 - 1 - 32], s3 = t3[e2 + 0 - 32], c4 = t3[e2 + 1 - 32], u4 = t3[e2 + 2 - 32];
                t3[e2 + 0 + 0] = t3[e2 + 2 + 32] = r2 + o3 + 1 >> 1, t3[e2 + 0 + 32] = t3[e2 + 2 + 64] = n3 + r2 + 1 >> 1, t3[e2 + 0 + 64] = t3[e2 + 2 + 96] = i3 + n3 + 1 >> 1, t3[e2 + 0 + 96] = a3 + i3 + 1 >> 1, t3[e2 + 3 + 0] = Ne2(s3, c4, u4), t3[e2 + 2 + 0] = Ne2(o3, s3, c4), t3[e2 + 1 + 0] = t3[e2 + 3 + 32] = Ne2(r2, o3, s3), t3[e2 + 1 + 32] = t3[e2 + 3 + 64] = Ne2(n3, r2, o3), t3[e2 + 1 + 64] = t3[e2 + 3 + 96] = Ne2(i3, n3, r2), t3[e2 + 1 + 96] = Ne2(a3, i3, n3);
              }
              function Ce(t3, e2) {
                var r2;
                for (r2 = 0; 8 > r2; ++r2)
                  n2(t3, e2 + 32 * r2, t3, e2 - 32, 8);
              }
              function je(t3, e2) {
                var r2;
                for (r2 = 0; 8 > r2; ++r2)
                  i2(t3, e2, t3[e2 - 1], 8), e2 += 32;
              }
              function Oe(t3, e2, r2) {
                var n3;
                for (n3 = 0; 8 > n3; ++n3)
                  i2(e2, r2 + 32 * n3, t3, 8);
              }
              function Be(t3, e2) {
                var r2, n3 = 8;
                for (r2 = 0; 8 > r2; ++r2)
                  n3 += t3[e2 + r2 - 32] + t3[e2 - 1 + 32 * r2];
                Oe(n3 >> 4, t3, e2);
              }
              function Me(t3, e2) {
                var r2, n3 = 4;
                for (r2 = 0; 8 > r2; ++r2)
                  n3 += t3[e2 + r2 - 32];
                Oe(n3 >> 3, t3, e2);
              }
              function Ee(t3, e2) {
                var r2, n3 = 4;
                for (r2 = 0; 8 > r2; ++r2)
                  n3 += t3[e2 - 1 + 32 * r2];
                Oe(n3 >> 3, t3, e2);
              }
              function qe(t3, e2) {
                Oe(128, t3, e2);
              }
              function De(t3, e2, r2) {
                var n3 = t3[e2 - r2], i3 = t3[e2 + 0], a3 = 3 * (i3 - n3) + jn[1020 + t3[e2 - 2 * r2] - t3[e2 + r2]], o3 = On[112 + (a3 + 4 >> 3)];
                t3[e2 - r2] = Bn[255 + n3 + On[112 + (a3 + 3 >> 3)]], t3[e2 + 0] = Bn[255 + i3 - o3];
              }
              function Re(t3, e2, r2, n3) {
                var i3 = t3[e2 + 0], a3 = t3[e2 + r2];
                return Mn[255 + t3[e2 - 2 * r2] - t3[e2 - r2]] > n3 || Mn[255 + a3 - i3] > n3;
              }
              function Te(t3, e2, r2, n3) {
                return 4 * Mn[255 + t3[e2 - r2] - t3[e2 + 0]] + Mn[255 + t3[e2 - 2 * r2] - t3[e2 + r2]] <= n3;
              }
              function ze(t3, e2, r2, n3, i3) {
                var a3 = t3[e2 - 3 * r2], o3 = t3[e2 - 2 * r2], s3 = t3[e2 - r2], c4 = t3[e2 + 0], u4 = t3[e2 + r2], h4 = t3[e2 + 2 * r2], l4 = t3[e2 + 3 * r2];
                return 4 * Mn[255 + s3 - c4] + Mn[255 + o3 - u4] > n3 ? 0 : Mn[255 + t3[e2 - 4 * r2] - a3] <= i3 && Mn[255 + a3 - o3] <= i3 && Mn[255 + o3 - s3] <= i3 && Mn[255 + l4 - h4] <= i3 && Mn[255 + h4 - u4] <= i3 && Mn[255 + u4 - c4] <= i3;
              }
              function Ue(t3, e2, r2, n3) {
                var i3 = 2 * n3 + 1;
                for (n3 = 0; 16 > n3; ++n3)
                  Te(t3, e2 + n3, r2, i3) && De(t3, e2 + n3, r2);
              }
              function He(t3, e2, r2, n3) {
                var i3 = 2 * n3 + 1;
                for (n3 = 0; 16 > n3; ++n3)
                  Te(t3, e2 + n3 * r2, 1, i3) && De(t3, e2 + n3 * r2, 1);
              }
              function We(t3, e2, r2, n3) {
                var i3;
                for (i3 = 3; 0 < i3; --i3)
                  Ue(t3, e2 += 4 * r2, r2, n3);
              }
              function Ve(t3, e2, r2, n3) {
                var i3;
                for (i3 = 3; 0 < i3; --i3)
                  He(t3, e2 += 4, r2, n3);
              }
              function Ge(t3, e2, r2, n3, i3, a3, o3, s3) {
                for (a3 = 2 * a3 + 1; 0 < i3--; ) {
                  if (ze(t3, e2, r2, a3, o3))
                    if (Re(t3, e2, r2, s3))
                      De(t3, e2, r2);
                    else {
                      var c4 = t3, u4 = e2, h4 = r2, l4 = c4[u4 - 2 * h4], f4 = c4[u4 - h4], d4 = c4[u4 + 0], p4 = c4[u4 + h4], g4 = c4[u4 + 2 * h4], m4 = 27 * (b4 = jn[1020 + 3 * (d4 - f4) + jn[1020 + l4 - p4]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
                      c4[u4 - 3 * h4] = Bn[255 + c4[u4 - 3 * h4] + b4], c4[u4 - 2 * h4] = Bn[255 + l4 + v4], c4[u4 - h4] = Bn[255 + f4 + m4], c4[u4 + 0] = Bn[255 + d4 - m4], c4[u4 + h4] = Bn[255 + p4 - v4], c4[u4 + 2 * h4] = Bn[255 + g4 - b4];
                    }
                  e2 += n3;
                }
              }
              function Ye(t3, e2, r2, n3, i3, a3, o3, s3) {
                for (a3 = 2 * a3 + 1; 0 < i3--; ) {
                  if (ze(t3, e2, r2, a3, o3))
                    if (Re(t3, e2, r2, s3))
                      De(t3, e2, r2);
                    else {
                      var c4 = t3, u4 = e2, h4 = r2, l4 = c4[u4 - h4], f4 = c4[u4 + 0], d4 = c4[u4 + h4], p4 = On[112 + ((g4 = 3 * (f4 - l4)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m4 = p4 + 1 >> 1;
                      c4[u4 - 2 * h4] = Bn[255 + c4[u4 - 2 * h4] + m4], c4[u4 - h4] = Bn[255 + l4 + g4], c4[u4 + 0] = Bn[255 + f4 - p4], c4[u4 + h4] = Bn[255 + d4 - m4];
                    }
                  e2 += n3;
                }
              }
              function Je(t3, e2, r2, n3, i3, a3) {
                Ge(t3, e2, r2, 1, 16, n3, i3, a3);
              }
              function Xe(t3, e2, r2, n3, i3, a3) {
                Ge(t3, e2, 1, r2, 16, n3, i3, a3);
              }
              function Ke(t3, e2, r2, n3, i3, a3) {
                var o3;
                for (o3 = 3; 0 < o3; --o3)
                  Ye(t3, e2 += 4 * r2, r2, 1, 16, n3, i3, a3);
              }
              function Ze(t3, e2, r2, n3, i3, a3) {
                var o3;
                for (o3 = 3; 0 < o3; --o3)
                  Ye(t3, e2 += 4, 1, r2, 16, n3, i3, a3);
              }
              function $e(t3, e2, r2, n3, i3, a3, o3, s3) {
                Ge(t3, e2, i3, 1, 8, a3, o3, s3), Ge(r2, n3, i3, 1, 8, a3, o3, s3);
              }
              function Qe(t3, e2, r2, n3, i3, a3, o3, s3) {
                Ge(t3, e2, 1, i3, 8, a3, o3, s3), Ge(r2, n3, 1, i3, 8, a3, o3, s3);
              }
              function tr(t3, e2, r2, n3, i3, a3, o3, s3) {
                Ye(t3, e2 + 4 * i3, i3, 1, 8, a3, o3, s3), Ye(r2, n3 + 4 * i3, i3, 1, 8, a3, o3, s3);
              }
              function er(t3, e2, r2, n3, i3, a3, o3, s3) {
                Ye(t3, e2 + 4, 1, i3, 8, a3, o3, s3), Ye(r2, n3 + 4, 1, i3, 8, a3, o3, s3);
              }
              function rr() {
                this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
              }
              function nr() {
                this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
              }
              function ir() {
                this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
              }
              function ar() {
                this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new l3();
              }
              function or() {
                this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o2(4, ir), this.Oc = 0;
              }
              function sr() {
                this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
              }
              function cr(t3, e2, r2, n3, i3, a3, o3) {
                for (t3 = t3 == null ? 0 : t3[e2 + 0], e2 = 0; e2 < o3; ++e2)
                  i3[a3 + e2] = t3 + r2[n3 + e2] & 255, t3 = i3[a3 + e2];
              }
              function ur(t3, e2, r2, n3, i3, a3, o3) {
                var s3;
                if (t3 == null)
                  cr(null, null, r2, n3, i3, a3, o3);
                else
                  for (s3 = 0; s3 < o3; ++s3)
                    i3[a3 + s3] = t3[e2 + s3] + r2[n3 + s3] & 255;
              }
              function hr(t3, e2, r2, n3, i3, a3, o3) {
                if (t3 == null)
                  cr(null, null, r2, n3, i3, a3, o3);
                else {
                  var s3, c4 = t3[e2 + 0], u4 = c4, h4 = c4;
                  for (s3 = 0; s3 < o3; ++s3)
                    u4 = h4 + (c4 = t3[e2 + s3]) - u4, h4 = r2[n3 + s3] + (-256 & u4 ? 0 > u4 ? 0 : 255 : u4) & 255, u4 = c4, i3[a3 + s3] = h4;
                }
              }
              function lr(t3, r2, i3, o3) {
                var s3 = r2.width, c4 = r2.o;
                if (e(t3 != null && r2 != null), 0 > i3 || 0 >= o3 || i3 + o3 > c4)
                  return null;
                if (!t3.Cc) {
                  if (t3.ga == null) {
                    var u4;
                    if (t3.ga = new sr(), (u4 = t3.ga == null) || (u4 = r2.width * r2.o, e(t3.Gb.length == 0), t3.Gb = a2(u4), t3.Uc = 0, t3.Gb == null ? u4 = 0 : (t3.mb = t3.Gb, t3.nb = t3.Uc, t3.rc = null, u4 = 1), u4 = !u4), !u4) {
                      u4 = t3.ga;
                      var h4 = t3.Fa, l4 = t3.P, f4 = t3.qc, d4 = t3.mb, p4 = t3.nb, g4 = l4 + 1, m4 = f4 - 1, b4 = u4.l;
                      if (e(h4 != null && d4 != null && r2 != null), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u4.ca = d4, u4.tb = p4, u4.c = r2.width, u4.i = r2.height, e(0 < u4.c && 0 < u4.i), 1 >= f4)
                        r2 = 0;
                      else if (u4.$a = h4[l4 + 0] >> 0 & 3, u4.Z = h4[l4 + 0] >> 2 & 3, u4.Lc = h4[l4 + 0] >> 4 & 3, l4 = h4[l4 + 0] >> 6 & 3, 0 > u4.$a || 1 < u4.$a || 4 <= u4.Z || 1 < u4.Lc || l4)
                        r2 = 0;
                      else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u4, b4.width = r2.width, b4.height = r2.height, b4.Da = r2.Da, b4.v = r2.v, b4.va = r2.va, b4.j = r2.j, b4.o = r2.o, u4.$a)
                        t: {
                          e(u4.$a == 1), r2 = kt2();
                          e:
                            for (; ; ) {
                              if (r2 == null) {
                                r2 = 0;
                                break t;
                              }
                              if (e(u4 != null), u4.mc = r2, r2.c = u4.c, r2.i = u4.i, r2.l = u4.l, r2.l.ma = u4, r2.l.width = u4.c, r2.l.height = u4.i, r2.a = 0, v3(r2.m, h4, g4, m4), !It2(u4.c, u4.i, 1, r2, null))
                                break e;
                              if (r2.ab == 1 && r2.gc[0].hc == 3 && At2(r2.s) ? (u4.ic = 1, h4 = r2.c * r2.i, r2.Ta = null, r2.Ua = 0, r2.V = a2(h4), r2.Ba = 0, r2.V == null ? (r2.a = 1, r2 = 0) : r2 = 1) : (u4.ic = 0, r2 = Ft2(r2, u4.c)), !r2)
                                break e;
                              r2 = 1;
                              break t;
                            }
                          u4.mc = null, r2 = 0;
                        }
                      else
                        r2 = m4 >= u4.c * u4.i;
                      u4 = !r2;
                    }
                    if (u4)
                      return null;
                    t3.ga.Lc != 1 ? t3.Ga = 0 : o3 = c4 - i3;
                  }
                  e(t3.ga != null), e(i3 + o3 <= c4);
                  t: {
                    if (r2 = (h4 = t3.ga).c, c4 = h4.l.o, h4.$a == 0) {
                      if (g4 = t3.rc, m4 = t3.Vc, b4 = t3.Fa, l4 = t3.P + 1 + i3 * r2, f4 = t3.mb, d4 = t3.nb + i3 * r2, e(l4 <= t3.P + t3.qc), h4.Z != 0)
                        for (e(mi[h4.Z] != null), u4 = 0; u4 < o3; ++u4)
                          mi[h4.Z](g4, m4, b4, l4, f4, d4, r2), g4 = f4, m4 = d4, d4 += r2, l4 += r2;
                      else
                        for (u4 = 0; u4 < o3; ++u4)
                          n2(f4, d4, b4, l4, r2), g4 = f4, m4 = d4, d4 += r2, l4 += r2;
                      t3.rc = g4, t3.Vc = m4;
                    } else {
                      if (e(h4.mc != null), r2 = i3 + o3, e((u4 = h4.mc) != null), e(r2 <= u4.i), u4.C >= r2)
                        r2 = 1;
                      else if (h4.ic || mr(), h4.ic) {
                        h4 = u4.V, g4 = u4.Ba, m4 = u4.c;
                        var y4 = u4.i, w4 = (b4 = 1, l4 = u4.$ / m4, f4 = u4.$ % m4, d4 = u4.m, p4 = u4.s, u4.$), N4 = m4 * y4, L4 = m4 * r2, x3 = p4.wc, _3 = w4 < L4 ? wt2(p4, f4, l4) : null;
                        e(w4 <= N4), e(r2 <= y4), e(At2(p4));
                        e:
                          for (; ; ) {
                            for (; !d4.h && w4 < L4; ) {
                              if (f4 & x3 || (_3 = wt2(p4, f4, l4)), e(_3 != null), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4)))
                                h4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++l4 <= r2 && !(l4 % 16) && St2(u4, l4));
                              else {
                                if (!(280 > y4)) {
                                  b4 = 0;
                                  break e;
                                }
                                y4 = mt2(y4 - 256, d4);
                                var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                                if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                                  b4 = 0;
                                  break e;
                                }
                                for (P3 = 0; P3 < y4; ++P3)
                                  h4[g4 + w4 + P3] = h4[g4 + w4 + P3 - k3];
                                for (w4 += y4, f4 += y4; f4 >= m4; )
                                  f4 -= m4, ++l4 <= r2 && !(l4 % 16) && St2(u4, l4);
                                w4 < L4 && f4 & x3 && (_3 = wt2(p4, f4, l4));
                              }
                              e(d4.h == A3(d4));
                            }
                            St2(u4, l4 > r2 ? r2 : l4);
                            break e;
                          }
                        !b4 || d4.h && w4 < N4 ? (b4 = 0, u4.a = d4.h ? 5 : 3) : u4.$ = w4, r2 = b4;
                      } else
                        r2 = _t2(u4, u4.V, u4.Ba, u4.c, u4.i, r2, Ct2);
                      if (!r2) {
                        o3 = 0;
                        break t;
                      }
                    }
                    i3 + o3 >= c4 && (t3.Cc = 1), o3 = 1;
                  }
                  if (!o3)
                    return null;
                  if (t3.Cc && ((o3 = t3.ga) != null && (o3.mc = null), t3.ga = null, 0 < t3.Ga))
                    return alert("todo:WebPDequantizeLevels"), null;
                }
                return t3.nb + i3 * s3;
              }
              function fr(t3, e2, r2, n3, i3, a3) {
                for (; 0 < i3--; ) {
                  var o3, s3 = t3, c4 = e2 + (r2 ? 1 : 0), u4 = t3, h4 = e2 + (r2 ? 0 : 3);
                  for (o3 = 0; o3 < n3; ++o3) {
                    var l4 = u4[h4 + 4 * o3];
                    l4 != 255 && (l4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * l4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * l4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * l4 >> 23);
                  }
                  e2 += a3;
                }
              }
              function dr(t3, e2, r2, n3, i3) {
                for (; 0 < n3--; ) {
                  var a3;
                  for (a3 = 0; a3 < r2; ++a3) {
                    var o3 = t3[e2 + 2 * a3 + 0], s3 = 15 & (u4 = t3[e2 + 2 * a3 + 1]), c4 = 4369 * s3, u4 = (240 & u4 | u4 >> 4) * c4 >> 16;
                    t3[e2 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t3[e2 + 2 * a3 + 1] = 240 & u4 | s3;
                  }
                  e2 += i3;
                }
              }
              function pr(t3, e2, r2, n3, i3, a3, o3, s3) {
                var c4, u4, h4 = 255;
                for (u4 = 0; u4 < i3; ++u4) {
                  for (c4 = 0; c4 < n3; ++c4) {
                    var l4 = t3[e2 + c4];
                    a3[o3 + 4 * c4] = l4, h4 &= l4;
                  }
                  e2 += r2, o3 += s3;
                }
                return h4 != 255;
              }
              function gr(t3, e2, r2, n3, i3) {
                var a3;
                for (a3 = 0; a3 < i3; ++a3)
                  r2[n3 + a3] = t3[e2 + a3] >> 8;
              }
              function mr() {
                An = fr, xn = dr, Sn = pr, _n = gr;
              }
              function vr(r2, n3, i3) {
                t2[r2] = function(t3, r3, a3, o3, s3, c4, u4, h4, l4, f4, d4, p4, g4, m4, v4, b4, y4) {
                  var w4, N4 = y4 - 1 >> 1, L4 = s3[c4 + 0] | u4[h4 + 0] << 16, A4 = l4[f4 + 0] | d4[p4 + 0] << 16;
                  e(t3 != null);
                  var x3 = 3 * L4 + A4 + 131074 >> 2;
                  for (n3(t3[r3 + 0], 255 & x3, x3 >> 16, g4, m4), a3 != null && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + 0], 255 & x3, x3 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
                    var S3 = s3[c4 + w4] | u4[h4 + w4] << 16, _3 = l4[f4 + w4] | d4[p4 + w4] << 16, P3 = L4 + S3 + A4 + _3 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
                    x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, n3(t3[r3 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m4 + (2 * w4 - 1) * i3), n3(t3[r3 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i3), a3 != null && (x3 = P3 + A4 >> 1, L4 = k3 + _3 >> 1, n3(a3[o3 + 2 * w4 - 1], 255 & x3, x3 >> 16, v4, b4 + (2 * w4 - 1) * i3), n3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i3)), L4 = S3, A4 = _3;
                  }
                  1 & y4 || (x3 = 3 * L4 + A4 + 131074 >> 2, n3(t3[r3 + y4 - 1], 255 & x3, x3 >> 16, g4, m4 + (y4 - 1) * i3), a3 != null && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + y4 - 1], 255 & x3, x3 >> 16, v4, b4 + (y4 - 1) * i3)));
                };
              }
              function br() {
                vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[zn] = Ai, vi[Un] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
              }
              function yr(t3) {
                return t3 & ~Fi ? 0 > t3 ? 0 : 255 : t3 >> Ii;
              }
              function wr(t3, e2) {
                return yr((19077 * t3 >> 8) + (26149 * e2 >> 8) - 14234);
              }
              function Nr(t3, e2, r2) {
                return yr((19077 * t3 >> 8) - (6419 * e2 >> 8) - (13320 * r2 >> 8) + 8708);
              }
              function Lr(t3, e2) {
                return yr((19077 * t3 >> 8) + (33050 * e2 >> 8) - 17685);
              }
              function Ar(t3, e2, r2, n3, i3) {
                n3[i3 + 0] = wr(t3, r2), n3[i3 + 1] = Nr(t3, e2, r2), n3[i3 + 2] = Lr(t3, e2);
              }
              function xr(t3, e2, r2, n3, i3) {
                n3[i3 + 0] = Lr(t3, e2), n3[i3 + 1] = Nr(t3, e2, r2), n3[i3 + 2] = wr(t3, r2);
              }
              function Sr(t3, e2, r2, n3, i3) {
                var a3 = Nr(t3, e2, r2);
                e2 = a3 << 3 & 224 | Lr(t3, e2) >> 3, n3[i3 + 0] = 248 & wr(t3, r2) | a3 >> 5, n3[i3 + 1] = e2;
              }
              function _r(t3, e2, r2, n3, i3) {
                var a3 = 240 & Lr(t3, e2) | 15;
                n3[i3 + 0] = 240 & wr(t3, r2) | Nr(t3, e2, r2) >> 4, n3[i3 + 1] = a3;
              }
              function Pr(t3, e2, r2, n3, i3) {
                n3[i3 + 0] = 255, Ar(t3, e2, r2, n3, i3 + 1);
              }
              function kr(t3, e2, r2, n3, i3) {
                xr(t3, e2, r2, n3, i3), n3[i3 + 3] = 255;
              }
              function Ir(t3, e2, r2, n3, i3) {
                Ar(t3, e2, r2, n3, i3), n3[i3 + 3] = 255;
              }
              function Vt2(t3, e2) {
                return 0 > t3 ? 0 : t3 > e2 ? e2 : t3;
              }
              function Fr(e2, r2, n3) {
                t2[e2] = function(t3, e3, i3, a3, o3, s3, c4, u4, h4) {
                  for (var l4 = u4 + (-2 & h4) * n3; u4 != l4; )
                    r2(t3[e3 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4), r2(t3[e3 + 1], i3[a3 + 0], o3[s3 + 0], c4, u4 + n3), e3 += 2, ++a3, ++s3, u4 += 2 * n3;
                  1 & h4 && r2(t3[e3 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4);
                };
              }
              function Cr(t3, e2, r2) {
                return r2 == 0 ? t3 == 0 ? e2 == 0 ? 6 : 5 : e2 == 0 ? 4 : 0 : r2;
              }
              function jr(t3, e2, r2, n3, i3) {
                switch (t3 >>> 30) {
                  case 3:
                    on(e2, r2, n3, i3, 0);
                    break;
                  case 2:
                    sn(e2, r2, n3, i3);
                    break;
                  case 1:
                    un(e2, r2, n3, i3);
                }
              }
              function Or(t3, e2) {
                var r2, a3, o3 = e2.M, s3 = e2.Nb, c4 = t3.oc, u4 = t3.pc + 40, h4 = t3.oc, l4 = t3.pc + 584, f4 = t3.oc, d4 = t3.pc + 600;
                for (r2 = 0; 16 > r2; ++r2)
                  c4[u4 + 32 * r2 - 1] = 129;
                for (r2 = 0; 8 > r2; ++r2)
                  h4[l4 + 32 * r2 - 1] = 129, f4[d4 + 32 * r2 - 1] = 129;
                for (0 < o3 ? c4[u4 - 1 - 32] = h4[l4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i2(c4, u4 - 32 - 1, 127, 21), i2(h4, l4 - 32 - 1, 127, 9), i2(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t3.za; ++a3) {
                  var p4 = e2.ya[e2.aa + a3];
                  if (0 < a3) {
                    for (r2 = -1; 16 > r2; ++r2)
                      n2(c4, u4 + 32 * r2 - 4, c4, u4 + 32 * r2 + 12, 4);
                    for (r2 = -1; 8 > r2; ++r2)
                      n2(h4, l4 + 32 * r2 - 4, h4, l4 + 32 * r2 + 4, 4), n2(f4, d4 + 32 * r2 - 4, f4, d4 + 32 * r2 + 4, 4);
                  }
                  var g4 = t3.Gd, m4 = t3.Hd + a3, v4 = p4.ad, b4 = p4.Hc;
                  if (0 < o3 && (n2(c4, u4 - 32, g4[m4].y, 0, 16), n2(h4, l4 - 32, g4[m4].f, 0, 8), n2(f4, d4 - 32, g4[m4].ea, 0, 8)), p4.Za) {
                    var y4 = c4, w4 = u4 - 32 + 16;
                    for (0 < o3 && (a3 >= t3.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r2 = 0; 4 > r2; r2++)
                      y4[w4 + 128 + r2] = y4[w4 + 256 + r2] = y4[w4 + 384 + r2] = y4[w4 + 0 + r2];
                    for (r2 = 0; 16 > r2; ++r2, b4 <<= 2)
                      y4 = c4, w4 = u4 + Di[r2], fi[p4.Ob[r2]](y4, w4), jr(b4, v4, 16 * +r2, y4, w4);
                  } else if (y4 = Cr(a3, o3, p4.Ob[0]), li[y4](c4, u4), b4 != 0)
                    for (r2 = 0; 16 > r2; ++r2, b4 <<= 2)
                      jr(b4, v4, 16 * +r2, c4, u4 + Di[r2]);
                  for (r2 = p4.Gc, y4 = Cr(a3, o3, p4.Dd), di[y4](h4, l4), di[y4](f4, d4), b4 = v4, y4 = h4, w4 = l4, 255 & (p4 = r2 >> 0) && (170 & p4 ? cn(b4, 256, y4, w4) : hn(b4, 256, y4, w4)), p4 = f4, b4 = d4, 255 & (r2 >>= 8) && (170 & r2 ? cn(v4, 320, p4, b4) : hn(v4, 320, p4, b4)), o3 < t3.Ub - 1 && (n2(g4[m4].y, 0, c4, u4 + 480, 16), n2(g4[m4].f, 0, h4, l4 + 224, 8), n2(g4[m4].ea, 0, f4, d4 + 224, 8)), r2 = 8 * s3 * t3.B, g4 = t3.sa, m4 = t3.ta + 16 * a3 + 16 * s3 * t3.R, v4 = t3.qa, p4 = t3.ra + 8 * a3 + r2, b4 = t3.Ha, y4 = t3.Ia + 8 * a3 + r2, r2 = 0; 16 > r2; ++r2)
                    n2(g4, m4 + r2 * t3.R, c4, u4 + 32 * r2, 16);
                  for (r2 = 0; 8 > r2; ++r2)
                    n2(v4, p4 + r2 * t3.B, h4, l4 + 32 * r2, 8), n2(b4, y4 + r2 * t3.B, f4, d4 + 32 * r2, 8);
                }
              }
              function Br(t3, n3, i3, a3, o3, s3, c4, u4, h4) {
                var l4 = [0], f4 = [0], d4 = 0, p4 = h4 != null ? h4.kd : 0, g4 = h4 != null ? h4 : new nr();
                if (t3 == null || 12 > i3)
                  return 7;
                g4.data = t3, g4.w = n3, g4.ha = i3, n3 = [n3], i3 = [i3], g4.gb = [g4.gb];
                t: {
                  var m4 = n3, b4 = i3, y4 = g4.gb;
                  if (e(t3 != null), e(b4 != null), e(y4 != null), y4[0] = 0, 12 <= b4[0] && !r(t3, m4[0], "RIFF")) {
                    if (r(t3, m4[0] + 8, "WEBP")) {
                      y4 = 3;
                      break t;
                    }
                    var w4 = j2(t3, m4[0] + 4);
                    if (12 > w4 || 4294967286 < w4) {
                      y4 = 3;
                      break t;
                    }
                    if (p4 && w4 > b4[0] - 8) {
                      y4 = 7;
                      break t;
                    }
                    y4[0] = w4, m4[0] += 12, b4[0] -= 12;
                  }
                  y4 = 0;
                }
                if (y4 != 0)
                  return y4;
                for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
                  t: {
                    var L4 = t3;
                    b4 = n3, y4 = i3;
                    var A4 = l4, x3 = f4, S3 = m4 = [0];
                    if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0])
                      y4 = 7;
                    else {
                      if (!r(L4, b4[0], "VP8X")) {
                        if (j2(L4, b4[0] + 4) != 10) {
                          y4 = 3;
                          break t;
                        }
                        if (18 > y4[0]) {
                          y4 = 7;
                          break t;
                        }
                        var _3 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
                        if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                          y4 = 3;
                          break t;
                        }
                        S3 != null && (S3[0] = _3), A4 != null && (A4[0] = P3), x3 != null && (x3[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
                      }
                      y4 = 0;
                    }
                  }
                  if (d4 = d4[0], m4 = m4[0], y4 != 0)
                    return y4;
                  if (b4 = !!(2 & m4), !w4 && d4)
                    return 3;
                  if (s3 != null && (s3[0] = !!(16 & m4)), c4 != null && (c4[0] = b4), u4 != null && (u4[0] = 0), c4 = l4[0], m4 = f4[0], d4 && b4 && h4 == null) {
                    y4 = 0;
                    break;
                  }
                  if (4 > i3) {
                    y4 = 7;
                    break;
                  }
                  if (w4 && d4 || !w4 && !d4 && !r(t3, n3[0], "ALPH")) {
                    i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
                    t: {
                      _3 = t3, y4 = n3, w4 = i3;
                      var k3 = g4.gb;
                      A4 = g4.na, x3 = g4.P, S3 = g4.Sa;
                      P3 = 22, e(_3 != null), e(w4 != null), L4 = y4[0];
                      var I3 = w4[0];
                      for (e(A4 != null), e(S3 != null), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
                        if (y4[0] = L4, w4[0] = I3, 8 > I3) {
                          y4 = 7;
                          break t;
                        }
                        var F3 = j2(_3, L4 + 4);
                        if (4294967286 < F3) {
                          y4 = 3;
                          break t;
                        }
                        var O3 = 8 + F3 + 1 & -2;
                        if (P3 += O3, 0 < k3 && P3 > k3) {
                          y4 = 3;
                          break t;
                        }
                        if (!r(_3, L4, "VP8 ") || !r(_3, L4, "VP8L")) {
                          y4 = 0;
                          break t;
                        }
                        if (I3[0] < O3) {
                          y4 = 7;
                          break t;
                        }
                        r(_3, L4, "ALPH") || (A4[0] = _3, x3[0] = L4 + 8, S3[0] = F3), L4 += O3, I3 -= O3;
                      }
                    }
                    if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], y4 != 0)
                      break;
                  }
                  i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
                  t:
                    if (k3 = t3, y4 = n3, w4 = i3, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !r(k3, _3, "VP8 "), P3 = !r(k3, _3, "VP8L"), e(k3 != null), e(w4 != null), e(x3 != null), e(S3 != null), 8 > w4[0])
                      y4 = 7;
                    else {
                      if (L4 || P3) {
                        if (k3 = j2(k3, _3 + 4), 12 <= A4 && k3 > A4 - 12) {
                          y4 = 3;
                          break t;
                        }
                        if (p4 && k3 > w4[0] - 8) {
                          y4 = 7;
                          break t;
                        }
                        x3[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
                      } else
                        S3[0] = 5 <= w4[0] && k3[_3 + 0] == 47 && !(k3[_3 + 4] >> 5), x3[0] = w4[0];
                      y4 = 0;
                    }
                  if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], y4 != 0)
                    break;
                  if (4294967286 < g4.Ja)
                    return 3;
                  if (u4 == null || b4 || (u4[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {
                    if (5 > i3) {
                      y4 = 7;
                      break;
                    }
                    u4 = c4, p4 = m4, b4 = s3, t3 == null || 5 > i3 ? t3 = 0 : 5 <= i3 && t3[n3 + 0] == 47 && !(t3[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v3(x3 = new N3(), t3, n3, i3), gt2(x3, w4, k3, A4) ? (u4 != null && (u4[0] = w4[0]), p4 != null && (p4[0] = k3[0]), b4 != null && (b4[0] = A4[0]), t3 = 1) : t3 = 0) : t3 = 0;
                  } else {
                    if (10 > i3) {
                      y4 = 7;
                      break;
                    }
                    u4 = m4, t3 == null || 10 > i3 || !Xt2(t3, n3 + 3, i3 - 3) ? t3 = 0 : (p4 = t3[n3 + 0] | t3[n3 + 1] << 8 | t3[n3 + 2] << 16, b4 = 16383 & (t3[n3 + 7] << 8 | t3[n3 + 6]), t3 = 16383 & (t3[n3 + 9] << 8 | t3[n3 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b4 || !t3 ? t3 = 0 : (c4 && (c4[0] = b4), u4 && (u4[0] = t3), t3 = 1));
                  }
                  if (!t3)
                    return 3;
                  if (c4 = c4[0], m4 = m4[0], d4 && (l4[0] != c4 || f4[0] != m4))
                    return 3;
                  h4 != null && (h4[0] = g4, h4.offset = n3 - h4.w, e(4294967286 > n3 - h4.w), e(h4.offset == h4.ha - i3));
                  break;
                }
                return y4 == 0 || y4 == 7 && d4 && h4 == null ? (s3 != null && (s3[0] |= g4.na != null && 0 < g4.na.length), a3 != null && (a3[0] = c4), o3 != null && (o3[0] = m4), 0) : y4;
              }
              function Mr(t3, e2, r2) {
                var n3 = e2.width, i3 = e2.height, a3 = 0, o3 = 0, s3 = n3, c4 = i3;
                if (e2.Da = t3 != null && 0 < t3.Da, e2.Da && (s3 = t3.cd, c4 = t3.bd, a3 = t3.v, o3 = t3.j, 11 > r2 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= c4 || a3 + s3 > n3 || o3 + c4 > i3))
                  return 0;
                if (e2.v = a3, e2.j = o3, e2.va = a3 + s3, e2.o = o3 + c4, e2.U = s3, e2.T = c4, e2.da = t3 != null && 0 < t3.da, e2.da) {
                  if (!E2(s3, c4, r2 = [t3.ib], a3 = [t3.hb]))
                    return 0;
                  e2.ib = r2[0], e2.hb = a3[0];
                }
                return e2.ob = t3 != null && t3.ob, e2.Kb = t3 == null || !t3.Sd, e2.da && (e2.ob = e2.ib < 3 * n3 / 4 && e2.hb < 3 * i3 / 4, e2.Kb = 0), 1;
              }
              function Er(t3) {
                if (t3 == null)
                  return 2;
                if (11 > t3.S) {
                  var e2 = t3.f.RGBA;
                  e2.fb += (t3.height - 1) * e2.A, e2.A = -e2.A;
                } else
                  e2 = t3.f.kb, t3 = t3.height, e2.O += (t3 - 1) * e2.fa, e2.fa = -e2.fa, e2.N += (t3 - 1 >> 1) * e2.Ab, e2.Ab = -e2.Ab, e2.W += (t3 - 1 >> 1) * e2.Db, e2.Db = -e2.Db, e2.F != null && (e2.J += (t3 - 1) * e2.lb, e2.lb = -e2.lb);
                return 0;
              }
              function qr(t3, e2, r2, n3) {
                if (n3 == null || 0 >= t3 || 0 >= e2)
                  return 2;
                if (r2 != null) {
                  if (r2.Da) {
                    var i3 = r2.cd, o3 = r2.bd, s3 = -2 & r2.v, c4 = -2 & r2.j;
                    if (0 > s3 || 0 > c4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t3 || c4 + o3 > e2)
                      return 2;
                    t3 = i3, e2 = o3;
                  }
                  if (r2.da) {
                    if (!E2(t3, e2, i3 = [r2.ib], o3 = [r2.hb]))
                      return 2;
                    t3 = i3[0], e2 = o3[0];
                  }
                }
                n3.width = t3, n3.height = e2;
                t: {
                  var u4 = n3.width, h4 = n3.height;
                  if (t3 = n3.S, 0 >= u4 || 0 >= h4 || !(t3 >= En && 13 > t3))
                    t3 = 2;
                  else {
                    if (0 >= n3.Rd && n3.sd == null) {
                      s3 = o3 = i3 = e2 = 0;
                      var l4 = (c4 = u4 * Ui[t3]) * h4;
                      if (11 > t3 || (o3 = (h4 + 1) / 2 * (e2 = (u4 + 1) / 2), t3 == 12 && (s3 = (i3 = u4) * h4)), (h4 = a2(l4 + 2 * o3 + s3)) == null) {
                        t3 = 1;
                        break t;
                      }
                      n3.sd = h4, 11 > t3 ? ((u4 = n3.f.RGBA).eb = h4, u4.fb = 0, u4.A = c4, u4.size = l4) : ((u4 = n3.f.kb).y = h4, u4.O = 0, u4.fa = c4, u4.Fd = l4, u4.f = h4, u4.N = 0 + l4, u4.Ab = e2, u4.Cd = o3, u4.ea = h4, u4.W = 0 + l4 + o3, u4.Db = e2, u4.Ed = o3, t3 == 12 && (u4.F = h4, u4.J = 0 + l4 + 2 * o3), u4.Tc = s3, u4.lb = i3);
                    }
                    if (e2 = 1, i3 = n3.S, o3 = n3.width, s3 = n3.height, i3 >= En && 13 > i3)
                      if (11 > i3)
                        t3 = n3.f.RGBA, e2 &= (c4 = Math.abs(t3.A)) * (s3 - 1) + o3 <= t3.size, e2 &= c4 >= o3 * Ui[i3], e2 &= t3.eb != null;
                      else {
                        t3 = n3.f.kb, c4 = (o3 + 1) / 2, l4 = (s3 + 1) / 2, u4 = Math.abs(t3.fa);
                        h4 = Math.abs(t3.Ab);
                        var f4 = Math.abs(t3.Db), d4 = Math.abs(t3.lb), p4 = d4 * (s3 - 1) + o3;
                        e2 &= u4 * (s3 - 1) + o3 <= t3.Fd, e2 &= h4 * (l4 - 1) + c4 <= t3.Cd, e2 = (e2 &= f4 * (l4 - 1) + c4 <= t3.Ed) & u4 >= o3 & h4 >= c4 & f4 >= c4, e2 &= t3.y != null, e2 &= t3.f != null, e2 &= t3.ea != null, i3 == 12 && (e2 &= d4 >= o3, e2 &= p4 <= t3.Tc, e2 &= t3.F != null);
                      }
                    else
                      e2 = 0;
                    t3 = e2 ? 0 : 2;
                  }
                }
                return t3 != 0 || r2 != null && r2.fd && (t3 = Er(n3)), t3;
              }
              var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, zr = 32, Ur = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
              R2("Predictor0", "PredictorAdd0"), t2.Predictor0 = function() {
                return 4278190080;
              }, t2.Predictor1 = function(t3) {
                return t3;
              }, t2.Predictor2 = function(t3, e2, r2) {
                return e2[r2 + 0];
              }, t2.Predictor3 = function(t3, e2, r2) {
                return e2[r2 + 1];
              }, t2.Predictor4 = function(t3, e2, r2) {
                return e2[r2 - 1];
              }, t2.Predictor5 = function(t3, e2, r2) {
                return z2(z2(t3, e2[r2 + 1]), e2[r2 + 0]);
              }, t2.Predictor6 = function(t3, e2, r2) {
                return z2(t3, e2[r2 - 1]);
              }, t2.Predictor7 = function(t3, e2, r2) {
                return z2(t3, e2[r2 + 0]);
              }, t2.Predictor8 = function(t3, e2, r2) {
                return z2(e2[r2 - 1], e2[r2 + 0]);
              }, t2.Predictor9 = function(t3, e2, r2) {
                return z2(e2[r2 + 0], e2[r2 + 1]);
              }, t2.Predictor10 = function(t3, e2, r2) {
                return z2(z2(t3, e2[r2 - 1]), z2(e2[r2 + 0], e2[r2 + 1]));
              }, t2.Predictor11 = function(t3, e2, r2) {
                var n3 = e2[r2 + 0];
                return 0 >= W2(n3 >> 24 & 255, t3 >> 24 & 255, (e2 = e2[r2 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t3 >> 16 & 255, e2 >> 16 & 255) + W2(n3 >> 8 & 255, t3 >> 8 & 255, e2 >> 8 & 255) + W2(255 & n3, 255 & t3, 255 & e2) ? n3 : t3;
              }, t2.Predictor12 = function(t3, e2, r2) {
                var n3 = e2[r2 + 0];
                return (U2((t3 >> 24 & 255) + (n3 >> 24 & 255) - ((e2 = e2[r2 - 1]) >> 24 & 255)) << 24 | U2((t3 >> 16 & 255) + (n3 >> 16 & 255) - (e2 >> 16 & 255)) << 16 | U2((t3 >> 8 & 255) + (n3 >> 8 & 255) - (e2 >> 8 & 255)) << 8 | U2((255 & t3) + (255 & n3) - (255 & e2))) >>> 0;
              }, t2.Predictor13 = function(t3, e2, r2) {
                var n3 = e2[r2 - 1];
                return (H2((t3 = z2(t3, e2[r2 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H2(t3 >> 16 & 255, n3 >> 16 & 255) << 16 | H2(t3 >> 8 & 255, n3 >> 8 & 255) << 8 | H2(t3 >> 0 & 255, n3 >> 0 & 255)) >>> 0;
              };
              var Wr = t2.PredictorAdd0;
              t2.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
              var Vr = t2.PredictorAdd2;
              X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t3) {
                return t3 >> 8 & 255;
              }, function(t3) {
                return t3;
              }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t3) {
                return t3;
              }, function(t3) {
                return t3 >> 8 & 255;
              });
              var Gr, Yr = t2.ColorIndexInverseTransform, Jr = t2.MapARGB, Xr = t2.VP8LColorIndexInverseTransformAlpha, Kr = t2.MapAlpha, Zr = t2.VP8LPredictorsAdd = [];
              Zr.length = 16, (t2.VP8LPredictors = []).length = 16, (t2.VP8LPredictorsAdd_C = []).length = 16, (t2.VP8LPredictors_C = []).length = 16;
              var $r, Qr, tn, en, rn, nn, an, on, sn, cn, un, hn, ln, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a2(511), kn = a2(2041), In = a2(225), Fn = a2(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, zn = 5, Un = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
              vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
              var bi = t2.UpsampleRgbLinePair, yi = t2.UpsampleBgrLinePair, wi = t2.UpsampleRgbaLinePair, Ni = t2.UpsampleBgraLinePair, Li = t2.UpsampleArgbLinePair, Ai = t2.UpsampleRgba4444LinePair, xi = t2.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(256), Ei = a2(ki - Pi), qi = a2(ki - Pi);
              Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
              var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], zi = 1;
              this.WebPDecodeRGBA = function(t3, r2, n3, i3, a3) {
                var o3 = qn, s3 = new rr(), c4 = new ot2();
                s3.ba = c4, c4.S = o3, c4.width = [c4.width], c4.height = [c4.height];
                var u4 = c4.width, h4 = c4.height, l4 = new st2();
                if (l4 == null || t3 == null)
                  var f4 = 2;
                else
                  e(l4 != null), f4 = Br(t3, r2, n3, l4.width, l4.height, l4.Pd, l4.Qd, l4.format, null);
                if (f4 != 0 ? u4 = 0 : (u4 != null && (u4[0] = l4.width[0]), h4 != null && (h4[0] = l4.height[0]), u4 = 1), u4) {
                  c4.width = c4.width[0], c4.height = c4.height[0], i3 != null && (i3[0] = c4.width), a3 != null && (a3[0] = c4.height);
                  t: {
                    if (i3 = new Gt2(), (a3 = new nr()).data = t3, a3.w = r2, a3.ha = n3, a3.kd = 1, r2 = [0], e(a3 != null), ((t3 = Br(a3.data, a3.w, a3.ha, null, null, null, r2, null, a3)) == 0 || t3 == 7) && r2[0] && (t3 = 4), (r2 = t3) == 0) {
                      if (e(s3 != null), i3.data = a3.data, i3.w = a3.w + a3.offset, i3.ha = a3.ha - a3.offset, i3.put = dt2, i3.ac = ft2, i3.bc = pt2, i3.ma = s3, a3.xa) {
                        if ((t3 = kt2()) == null) {
                          s3 = 1;
                          break t;
                        }
                        if (function(t4, r3) {
                          var n4 = [0], i4 = [0], a4 = [0];
                          e:
                            for (; ; ) {
                              if (t4 == null)
                                return 0;
                              if (r3 == null)
                                return t4.a = 2, 0;
                              if (t4.l = r3, t4.a = 0, v3(t4.m, r3.data, r3.w, r3.ha), !gt2(t4.m, n4, i4, a4)) {
                                t4.a = 3;
                                break e;
                              }
                              if (t4.xb = gi, r3.width = n4[0], r3.height = i4[0], !It2(n4[0], i4[0], 1, t4, null))
                                break e;
                              return 1;
                            }
                          return e(t4.a != 0), 0;
                        }(t3, i3)) {
                          if (i3 = (r2 = qr(i3.width, i3.height, s3.Oa, s3.ba)) == 0) {
                            e: {
                              i3 = t3;
                              r:
                                for (; ; ) {
                                  if (i3 == null) {
                                    i3 = 0;
                                    break e;
                                  }
                                  if (e(i3.s.yc != null), e(i3.s.Ya != null), e(0 < i3.s.Wb), e((n3 = i3.l) != null), e((a3 = n3.ma) != null), i3.xb != 0) {
                                    if (i3.ca = a3.ba, i3.tb = a3.tb, e(i3.ca != null), !Mr(a3.Oa, n3, Rn)) {
                                      i3.a = 2;
                                      break r;
                                    }
                                    if (!Ft2(i3, n3.width))
                                      break r;
                                    if (n3.da)
                                      break r;
                                    if ((n3.da || nt2(i3.ca.S)) && mr(), 11 > i3.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), i3.ca.f.kb.F != null && mr()), i3.Pb && 0 < i3.s.ua && i3.s.vb.X == null && !O2(i3.s.vb, i3.s.Wa.Xa)) {
                                      i3.a = 1;
                                      break r;
                                    }
                                    i3.xb = 0;
                                  }
                                  if (!_t2(i3, i3.V, i3.Ba, i3.c, i3.i, n3.o, Lt2))
                                    break r;
                                  a3.Dc = i3.Ma, i3 = 1;
                                  break e;
                                }
                              e(i3.a != 0), i3 = 0;
                            }
                            i3 = !i3;
                          }
                          i3 && (r2 = t3.a);
                        } else
                          r2 = t3.a;
                      } else {
                        if ((t3 = new Yt2()) == null) {
                          s3 = 1;
                          break t;
                        }
                        if (t3.Fa = a3.na, t3.P = a3.P, t3.qc = a3.Sa, Kt2(t3, i3)) {
                          if ((r2 = qr(i3.width, i3.height, s3.Oa, s3.ba)) == 0) {
                            if (t3.Aa = 0, n3 = s3.Oa, e((a3 = t3) != null), n3 != null) {
                              if (0 < (u4 = 0 > (u4 = n3.Md) ? 0 : 100 < u4 ? 255 : 255 * u4 / 100)) {
                                for (h4 = l4 = 0; 4 > h4; ++h4)
                                  12 > (f4 = a3.pb[h4]).lc && (f4.ia = u4 * Ti[0 > f4.lc ? 0 : f4.lc] >> 3), l4 |= f4.ia;
                                l4 && (alert("todo:VP8InitRandom"), a3.ia = 1);
                              }
                              a3.Ga = n3.Id, 100 < a3.Ga ? a3.Ga = 100 : 0 > a3.Ga && (a3.Ga = 0);
                            }
                            Qt2(t3, i3) || (r2 = t3.a);
                          }
                        } else
                          r2 = t3.a;
                      }
                      r2 == 0 && s3.Oa != null && s3.Oa.fd && (r2 = Er(s3.ba));
                    }
                    s3 = r2;
                  }
                  o3 = s3 != 0 ? null : 11 > o3 ? c4.f.RGBA.eb : c4.f.kb.y;
                } else
                  o3 = null;
                return o3;
              };
              var Ui = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
            };
            function u2(t2, e2) {
              for (var r2 = "", n3 = 0; n3 < 4; n3++)
                r2 += String.fromCharCode(t2[e2++]);
              return r2;
            }
            function h2(t2, e2) {
              return (t2[e2 + 0] << 0 | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) >>> 0;
            }
            function l2(t2, e2) {
              return (t2[e2 + 0] << 0 | t2[e2 + 1] << 8 | t2[e2 + 2] << 16 | t2[e2 + 3] << 24) >>> 0;
            }
            new c2();
            var f2 = [0], d2 = [0], p2 = [], g2 = new c2(), m2 = t, v2 = function(t2, e2) {
              var r2 = {}, n3 = 0, i3 = false, a3 = 0, o3 = 0;
              if (r2.frames = [], !function(t3, e3, r3, n4) {
                for (var i4 = 0; i4 < n4; i4++)
                  if (t3[e3 + i4] != r3.charCodeAt(i4))
                    return true;
                return false;
              }(t2, e2, "RIFF", 4)) {
                var s3, c3;
                l2(t2, e2 += 4);
                for (e2 += 8; e2 < t2.length; ) {
                  var f3 = u2(t2, e2), d3 = l2(t2, e2 += 4);
                  e2 += 4;
                  var p3 = d3 + (1 & d3);
                  switch (f3) {
                    case "VP8 ":
                    case "VP8L":
                      r2.frames[n3] === void 0 && (r2.frames[n3] = {});
                      (v3 = r2.frames[n3]).src_off = i3 ? o3 : e2 - 8, v3.src_size = a3 + d3 + 8, n3++, i3 && (i3 = false, a3 = 0, o3 = 0);
                      break;
                    case "VP8X":
                      (v3 = r2.header = {}).feature_flags = t2[e2];
                      var g3 = e2 + 4;
                      v3.canvas_width = 1 + h2(t2, g3);
                      g3 += 3;
                      v3.canvas_height = 1 + h2(t2, g3);
                      g3 += 3;
                      break;
                    case "ALPH":
                      i3 = true, a3 = p3 + 8, o3 = e2 - 8;
                      break;
                    case "ANIM":
                      (v3 = r2.header).bgcolor = l2(t2, e2);
                      g3 = e2 + 4;
                      v3.loop_count = (s3 = t2)[(c3 = g3) + 0] << 0 | s3[c3 + 1] << 8;
                      g3 += 2;
                      break;
                    case "ANMF":
                      var m3, v3;
                      (v3 = r2.frames[n3] = {}).offset_x = 2 * h2(t2, e2), e2 += 3, v3.offset_y = 2 * h2(t2, e2), e2 += 3, v3.width = 1 + h2(t2, e2), e2 += 3, v3.height = 1 + h2(t2, e2), e2 += 3, v3.duration = h2(t2, e2), e2 += 3, m3 = t2[e2++], v3.dispose = 1 & m3, v3.blend = m3 >> 1 & 1;
                  }
                  f3 != "ANMF" && (e2 += p3);
                }
                return r2;
              }
            }(m2, 0);
            v2.response = m2, v2.rgbaoutput = true, v2.dataurl = false;
            var b2 = v2.header ? v2.header : null, y2 = v2.frames ? v2.frames : null;
            if (b2) {
              b2.loop_counter = b2.loop_count, f2 = [b2.canvas_height], d2 = [b2.canvas_width];
              for (var w2 = 0; w2 < y2.length && y2[w2].blend != 0; w2++)
                ;
            }
            var N2 = y2[0], L2 = g2.WebPDecodeRGBA(m2, N2.src_off, N2.src_size, d2, f2);
            N2.rgba = L2, N2.imgwidth = d2[0], N2.imgheight = f2[0];
            for (var A2 = 0; A2 < d2[0] * f2[0] * 4; A2++)
              p2[A2] = L2[A2];
            return this.width = d2, this.height = f2, this.data = p2, this;
          }
          !function(t) {
            var r = function() {
              return typeof fflate__WEBPACK_IMPORTED_MODULE_1__["b"] == "function";
            }, n2 = function(r2, n3, a3, h3) {
              var l3 = 4, f3 = s2;
              switch (h3) {
                case t.image_compression.FAST:
                  l3 = 1, f3 = o2;
                  break;
                case t.image_compression.MEDIUM:
                  l3 = 6, f3 = c2;
                  break;
                case t.image_compression.SLOW:
                  l3 = 9, f3 = u2;
              }
              r2 = i2(r2, n3, a3, f3);
              var d2 = Object(fflate__WEBPACK_IMPORTED_MODULE_1__["b"])(r2, { level: l3 });
              return t.__addimage__.arrayBufferToBinaryString(d2);
            }, i2 = function(t2, e, r2, n3) {
              for (var i3, a3, o3, s3 = t2.length / e, c3 = new Uint8Array(t2.length + s3), u3 = l2(), h3 = 0; h3 < s3; h3 += 1) {
                if (o3 = h3 * e, i3 = t2.subarray(o3, o3 + e), n3)
                  c3.set(n3(i3, r2, a3), o3 + h3);
                else {
                  for (var d2, p2 = u3.length, g2 = []; d2 < p2; d2 += 1)
                    g2[d2] = u3[d2](i3, r2, a3);
                  var m2 = f2(g2.concat());
                  c3.set(g2[m2], o3 + h3);
                }
                a3 = i3;
              }
              return c3;
            }, a2 = function(t2) {
              var e = Array.apply([], t2);
              return e.unshift(0), e;
            }, o2 = function(t2, e) {
              var r2, n3 = [], i3 = t2.length;
              n3[0] = 1;
              for (var a3 = 0; a3 < i3; a3 += 1)
                r2 = t2[a3 - e] || 0, n3[a3 + 1] = t2[a3] - r2 + 256 & 255;
              return n3;
            }, s2 = function(t2, e, r2) {
              var n3, i3 = [], a3 = t2.length;
              i3[0] = 2;
              for (var o3 = 0; o3 < a3; o3 += 1)
                n3 = r2 && r2[o3] || 0, i3[o3 + 1] = t2[o3] - n3 + 256 & 255;
              return i3;
            }, c2 = function(t2, e, r2) {
              var n3, i3, a3 = [], o3 = t2.length;
              a3[0] = 3;
              for (var s3 = 0; s3 < o3; s3 += 1)
                n3 = t2[s3 - e] || 0, i3 = r2 && r2[s3] || 0, a3[s3 + 1] = t2[s3] + 256 - (n3 + i3 >>> 1) & 255;
              return a3;
            }, u2 = function(t2, e, r2) {
              var n3, i3, a3, o3, s3 = [], c3 = t2.length;
              s3[0] = 4;
              for (var u3 = 0; u3 < c3; u3 += 1)
                n3 = t2[u3 - e] || 0, i3 = r2 && r2[u3] || 0, a3 = r2 && r2[u3 - e] || 0, o3 = h2(n3, i3, a3), s3[u3 + 1] = t2[u3] - o3 + 256 & 255;
              return s3;
            }, h2 = function(t2, e, r2) {
              if (t2 === e && e === r2)
                return t2;
              var n3 = Math.abs(e - r2), i3 = Math.abs(t2 - r2), a3 = Math.abs(t2 + e - r2 - r2);
              return n3 <= i3 && n3 <= a3 ? t2 : i3 <= a3 ? e : r2;
            }, l2 = function() {
              return [a2, o2, s2, c2, u2];
            }, f2 = function(t2) {
              var e = t2.map(function(t3) {
                return t3.reduce(function(t4, e2) {
                  return t4 + Math.abs(e2);
                }, 0);
              });
              return e.indexOf(Math.min.apply(null, e));
            };
            t.processPNG = function(e, i3, a3, o3) {
              var s3, c3, u3, h3, l3, f3, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2 = this.decode.FLATE_DECODE, A2 = "";
              if (this.__addimage__.isArrayBuffer(e) && (e = new Uint8Array(e)), this.__addimage__.isArrayBufferView(e)) {
                if (e = (u3 = new Kt(e)).imgData, c3 = u3.bits, s3 = u3.colorSpace, l3 = u3.colors, [4, 6].indexOf(u3.colorType) !== -1) {
                  if (u3.bits === 8) {
                    g2 = (p2 = u3.pixelBitlength == 32 ? new Uint32Array(u3.decodePixels().buffer) : u3.pixelBitlength == 16 ? new Uint16Array(u3.decodePixels().buffer) : new Uint8Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * u3.colors), m2 = new Uint8Array(g2);
                    var x2, S2 = u3.pixelBitlength - u3.bits;
                    for (w2 = 0, N2 = 0; w2 < g2; w2++) {
                      for (y2 = p2[w2], x2 = 0; x2 < S2; )
                        v2[N2++] = y2 >>> x2 & 255, x2 += u3.bits;
                      m2[w2] = y2 >>> x2 & 255;
                    }
                  }
                  if (u3.bits === 16) {
                    g2 = (p2 = new Uint32Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * (32 / u3.pixelBitlength) * u3.colors), m2 = new Uint8Array(g2 * (32 / u3.pixelBitlength)), b2 = u3.colors > 1, w2 = 0, N2 = 0;
                    for (var _2 = 0; w2 < g2; )
                      y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255, b2 && (v2[N2++] = y2 >>> 16 & 255, y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255), m2[_2++] = y2 >>> 16 & 255;
                    c3 = 8;
                  }
                  o3 !== t.image_compression.NONE && r() ? (e = n2(v2, u3.width * u3.colors, u3.colors, o3), d2 = n2(m2, u3.width, 1, o3)) : (e = v2, d2 = m2, L2 = void 0);
                }
                if (u3.colorType === 3 && (s3 = this.color_spaces.INDEXED, f3 = u3.palette, u3.transparency.indexed)) {
                  var P2 = u3.transparency.indexed, k2 = 0;
                  for (w2 = 0, g2 = P2.length; w2 < g2; ++w2)
                    k2 += P2[w2];
                  if ((k2 /= 255) === g2 - 1 && P2.indexOf(0) !== -1)
                    h3 = [P2.indexOf(0)];
                  else if (k2 !== g2) {
                    for (p2 = u3.decodePixels(), m2 = new Uint8Array(p2.length), w2 = 0, g2 = p2.length; w2 < g2; w2++)
                      m2[w2] = P2[p2[w2]];
                    d2 = n2(m2, u3.width, 1);
                  }
                }
                var I2 = function(e2) {
                  var r2;
                  switch (e2) {
                    case t.image_compression.FAST:
                      r2 = 11;
                      break;
                    case t.image_compression.MEDIUM:
                      r2 = 13;
                      break;
                    case t.image_compression.SLOW:
                      r2 = 14;
                      break;
                    default:
                      r2 = 12;
                  }
                  return r2;
                }(o3);
                return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l3 + " /BitsPerComponent " + c3 + " /Columns " + u3.width, (this.__addimage__.isArrayBuffer(e) || this.__addimage__.isArrayBufferView(e)) && (e = this.__addimage__.arrayBufferToBinaryString(e)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a3, data: e, index: i3, filter: L2, decodeParameters: A2, transparency: h3, palette: f3, sMask: d2, predictor: I2, width: u3.width, height: u3.height, bitsPerComponent: c3, colorSpace: s3 };
              }
            };
          }(E.API), function(t) {
            t.processGIF89A = function(e, r, n2, i2) {
              var a2 = new Zt(e), o2 = a2.width, s2 = a2.height, c2 = [];
              a2.decodeAndBlitFrameRGBA(0, c2);
              var u2 = { data: c2, width: o2, height: s2 }, h2 = new Qt(100).encode(u2, 100);
              return t.processJPEG.call(this, h2, r, n2, i2);
            }, t.processGIF87A = t.processGIF89A;
          }(E.API), te.prototype.parseHeader = function() {
            if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
              var t = this.colors === 0 ? 1 << this.bitPP : this.colors;
              this.palette = new Array(t);
              for (var e = 0; e < t; e++) {
                var r = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
                this.palette[e] = { red: i2, green: n2, blue: r, quad: a2 };
              }
            }
            this.height < 0 && (this.height *= -1, this.bottom_up = false);
          }, te.prototype.parseBGR = function() {
            this.pos = this.offset;
            try {
              var t = "bit" + this.bitPP, e = this.width * this.height * 4;
              this.data = new Uint8Array(e), this[t]();
            } catch (t2) {
              a.log("bit decode error:" + t2);
            }
          }, te.prototype.bit1 = function() {
            var t, e = Math.ceil(this.width / 8), r = e % 4;
            for (t = this.height - 1; t >= 0; t--) {
              for (var n2 = this.bottom_up ? t : this.height - 1 - t, i2 = 0; i2 < e; i2++)
                for (var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
                  var c2 = this.palette[a2 >> 7 - s2 & 1];
                  this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;
                }
              r !== 0 && (this.pos += 4 - r);
            }
          }, te.prototype.bit4 = function() {
            for (var t = Math.ceil(this.width / 2), e = t % 4, r = this.height - 1; r >= 0; r--) {
              for (var n2 = this.bottom_up ? r : this.height - 1 - r, i2 = 0; i2 < t; i2++) {
                var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, c2 = 15 & a2, u2 = this.palette[s2];
                if (this.data[o2] = u2.blue, this.data[o2 + 1] = u2.green, this.data[o2 + 2] = u2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width)
                  break;
                u2 = this.palette[c2], this.data[o2 + 4] = u2.blue, this.data[o2 + 4 + 1] = u2.green, this.data[o2 + 4 + 2] = u2.red, this.data[o2 + 4 + 3] = 255;
              }
              e !== 0 && (this.pos += 4 - e);
            }
          }, te.prototype.bit8 = function() {
            for (var t = this.width % 4, e = this.height - 1; e >= 0; e--) {
              for (var r = this.bottom_up ? e : this.height - 1 - e, n2 = 0; n2 < this.width; n2++) {
                var i2 = this.datav.getUint8(this.pos++, true), a2 = r * this.width * 4 + 4 * n2;
                if (i2 < this.palette.length) {
                  var o2 = this.palette[i2];
                  this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
                } else
                  this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
              }
              t !== 0 && (this.pos += 4 - t);
            }
          }, te.prototype.bit15 = function() {
            for (var t = this.width % 3, e = parseInt("11111", 2), r = this.height - 1; r >= 0; r--) {
              for (var n2 = this.bottom_up ? r : this.height - 1 - r, i2 = 0; i2 < this.width; i2++) {
                var a2 = this.datav.getUint16(this.pos, true);
                this.pos += 2;
                var o2 = (a2 & e) / e * 255 | 0, s2 = (a2 >> 5 & e) / e * 255 | 0, c2 = (a2 >> 10 & e) / e * 255 | 0, u2 = a2 >> 15 ? 255 : 0, h2 = n2 * this.width * 4 + 4 * i2;
                this.data[h2] = c2, this.data[h2 + 1] = s2, this.data[h2 + 2] = o2, this.data[h2 + 3] = u2;
              }
              this.pos += t;
            }
          }, te.prototype.bit16 = function() {
            for (var t = this.width % 3, e = parseInt("11111", 2), r = parseInt("111111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
              for (var i2 = this.bottom_up ? n2 : this.height - 1 - n2, a2 = 0; a2 < this.width; a2++) {
                var o2 = this.datav.getUint16(this.pos, true);
                this.pos += 2;
                var s2 = (o2 & e) / e * 255 | 0, c2 = (o2 >> 5 & r) / r * 255 | 0, u2 = (o2 >> 11) / e * 255 | 0, h2 = i2 * this.width * 4 + 4 * a2;
                this.data[h2] = u2, this.data[h2 + 1] = c2, this.data[h2 + 2] = s2, this.data[h2 + 3] = 255;
              }
              this.pos += t;
            }
          }, te.prototype.bit24 = function() {
            for (var t = this.height - 1; t >= 0; t--) {
              for (var e = this.bottom_up ? t : this.height - 1 - t, r = 0; r < this.width; r++) {
                var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e * this.width * 4 + 4 * r;
                this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;
              }
              this.pos += this.width % 4;
            }
          }, te.prototype.bit32 = function() {
            for (var t = this.height - 1; t >= 0; t--)
              for (var e = this.bottom_up ? t : this.height - 1 - t, r = 0; r < this.width; r++) {
                var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e * this.width * 4 + 4 * r;
                this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;
              }
          }, te.prototype.getData = function() {
            return this.data;
          }, function(t) {
            t.processBMP = function(e, r, n2, i2) {
              var a2 = new te(e, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
              return t.processJPEG.call(this, u2, r, n2, i2);
            };
          }(E.API), ee.prototype.getData = function() {
            return this.data;
          }, function(t) {
            t.processWEBP = function(e, r, n2, i2) {
              var a2 = new ee(e, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
              return t.processJPEG.call(this, u2, r, n2, i2);
            };
          }(E.API), E.API.processRGBA = function(t, e, r) {
            for (var n2 = t.data, i2 = n2.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, c2 = 0, u2 = 0; u2 < i2; u2 += 4) {
              var h2 = n2[u2], l2 = n2[u2 + 1], f2 = n2[u2 + 2], d2 = n2[u2 + 3];
              a2[s2++] = h2, a2[s2++] = l2, a2[s2++] = f2, o2[c2++] = d2;
            }
            var p2 = this.__addimage__.arrayBufferToBinaryString(a2);
            return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p2, index: e, alias: r, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t.width, height: t.height };
          }, E.API.setLanguage = function(t) {
            return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t] !== void 0 && (this.internal.languageSettings.languageCode = t, this.internal.languageSettings.isSubscribed === false && (this.internal.events.subscribe("putCatalog", function() {
              this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
            }), this.internal.languageSettings.isSubscribed = true)), this;
          }, Vt = E.API, Gt = Vt.getCharWidthsArray = function(e, r) {
            var n2, i2, a2 = (r = r || {}).font || this.internal.getFont(), o2 = r.fontSize || this.internal.getFontSize(), s2 = r.charSpace || this.internal.getCharSpace(), c2 = r.widths ? r.widths : a2.metadata.Unicode.widths, u2 = c2.fof ? c2.fof : 1, h2 = r.kerning ? r.kerning : a2.metadata.Unicode.kerning, l2 = h2.fof ? h2.fof : 1, f2 = r.doKerning !== false, d2 = 0, p2 = e.length, g2 = 0, m2 = c2[0] || u2, v2 = [];
            for (n2 = 0; n2 < p2; n2++)
              i2 = e.charCodeAt(n2), typeof a2.metadata.widthOfString == "function" ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(h2[i2]) === "object" && !isNaN(parseInt(h2[i2][g2], 10)) ? h2[i2][g2] / l2 : 0, v2.push((c2[i2] || m2) / u2 + d2)), g2 = i2;
            return v2;
          }, Yt = Vt.getStringUnitWidth = function(t, e) {
            var r = (e = e || {}).fontSize || this.internal.getFontSize(), n2 = e.font || this.internal.getFont(), i2 = e.charSpace || this.internal.getCharSpace();
            return Vt.processArabic && (t = Vt.processArabic(t)), typeof n2.metadata.widthOfString == "function" ? n2.metadata.widthOfString(t, r, i2) / r : Gt.apply(this, arguments).reduce(function(t2, e2) {
              return t2 + e2;
            }, 0);
          }, Jt = function(t, e, r, n2) {
            for (var i2 = [], a2 = 0, o2 = t.length, s2 = 0; a2 !== o2 && s2 + e[a2] < r; )
              s2 += e[a2], a2++;
            i2.push(t.slice(0, a2));
            var c2 = a2;
            for (s2 = 0; a2 !== o2; )
              s2 + e[a2] > n2 && (i2.push(t.slice(c2, a2)), s2 = 0, c2 = a2), s2 += e[a2], a2++;
            return c2 !== a2 && i2.push(t.slice(c2, a2)), i2;
          }, Xt = function(t, e, r) {
            r || (r = {});
            var n2, i2, a2, o2, s2, c2, u2, h2 = [], l2 = [h2], f2 = r.textIndent || 0, d2 = 0, p2 = 0, g2 = t.split(" "), m2 = Gt.apply(this, [" ", r])[0];
            if (c2 = r.lineIndent === -1 ? g2[0].length + 2 : r.lineIndent || 0) {
              var v2 = Array(c2).join(" "), b2 = [];
              g2.map(function(t2) {
                (t2 = t2.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t2.map(function(t3, e2) {
                  return (e2 && t3.length ? "\n" : "") + t3;
                })) : b2.push(t2[0]);
              }), g2 = b2, c2 = Yt.apply(this, [v2, r]);
            }
            for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
              var y2 = 0;
              if (n2 = g2[a2], c2 && n2[0] == "\n" && (n2 = n2.substr(1), y2 = 1), f2 + d2 + (p2 = (i2 = Gt.apply(this, [n2, r])).reduce(function(t2, e2) {
                return t2 + e2;
              }, 0)) > e || y2) {
                if (p2 > e) {
                  for (s2 = Jt.apply(this, [n2, i2, e - (f2 + d2), e]), h2.push(s2.shift()), h2 = [s2.pop()]; s2.length; )
                    l2.push([s2.shift()]);
                  p2 = i2.slice(n2.length - (h2[0] ? h2[0].length : 0)).reduce(function(t2, e2) {
                    return t2 + e2;
                  }, 0);
                } else
                  h2 = [n2];
                l2.push(h2), f2 = p2 + c2, d2 = m2;
              } else
                h2.push(n2), f2 += d2 + p2, d2 = m2;
            }
            return u2 = c2 ? function(t2, e2) {
              return (e2 ? v2 : "") + t2.join(" ");
            } : function(t2) {
              return t2.join(" ");
            }, l2.map(u2);
          }, Vt.splitTextToSize = function(t, e, r) {
            var n2, i2 = (r = r || {}).fontSize || this.internal.getFontSize(), a2 = function(t2) {
              if (t2.widths && t2.kerning)
                return { widths: t2.widths, kerning: t2.kerning };
              var e2 = this.internal.getFont(t2.fontName, t2.fontStyle);
              return e2.metadata.Unicode ? { widths: e2.metadata.Unicode.widths || { 0: 1 }, kerning: e2.metadata.Unicode.kerning || {} } : { font: e2.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
            }.call(this, r);
            n2 = Array.isArray(t) ? t : String(t).split(/\r?\n/);
            var o2 = 1 * this.internal.scaleFactor * e / i2;
            a2.textIndent = r.textIndent ? 1 * r.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = r.lineIndent;
            var s2, c2, u2 = [];
            for (s2 = 0, c2 = n2.length; s2 < c2; s2++)
              u2 = u2.concat(Xt.apply(this, [n2[s2], o2, a2]));
            return u2;
          }, function(e) {
            e.__fontmetrics__ = e.__fontmetrics__ || {};
            for (var r = "klmnopqrstuvwxyz", n2 = {}, i2 = {}, a2 = 0; a2 < r.length; a2++)
              n2[r[a2]] = "0123456789abcdef"[a2], i2["0123456789abcdef"[a2]] = r[a2];
            var o2 = function(t) {
              return "0x" + parseInt(t, 10).toString(16);
            }, s2 = e.__fontmetrics__.compress = function(e2) {
              var r2, n3, a3, c3, u3 = ["{"];
              for (var h3 in e2) {
                if (r2 = e2[h3], isNaN(parseInt(h3, 10)) ? n3 = "'" + h3 + "'" : (h3 = parseInt(h3, 10), n3 = (n3 = o2(h3).slice(2)).slice(0, -1) + i2[n3.slice(-1)]), typeof r2 == "number")
                  r2 < 0 ? (a3 = o2(r2).slice(3), c3 = "-") : (a3 = o2(r2).slice(2), c3 = ""), a3 = c3 + a3.slice(0, -1) + i2[a3.slice(-1)];
                else {
                  if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(r2) !== "object")
                    throw new Error("Don't know what to do with value type " + _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(r2) + ".");
                  a3 = s2(r2);
                }
                u3.push(n3 + a3);
              }
              return u3.push("}"), u3.join("");
            }, c2 = e.__fontmetrics__.uncompress = function(t) {
              if (typeof t != "string")
                throw new Error("Invalid argument passed to uncompress.");
              for (var e2, r2, i3, a3, o3 = {}, s3 = 1, c3 = o3, u3 = [], h3 = "", l3 = "", f2 = t.length - 1, d2 = 1; d2 < f2; d2 += 1)
                (a3 = t[d2]) == "'" ? e2 ? (i3 = e2.join(""), e2 = void 0) : e2 = [] : e2 ? e2.push(a3) : a3 == "{" ? (u3.push([c3, i3]), c3 = {}, i3 = void 0) : a3 == "}" ? ((r2 = u3.pop())[0][r2[1]] = c3, i3 = void 0, c3 = r2[0]) : a3 == "-" ? s3 = -1 : i3 === void 0 ? n2.hasOwnProperty(a3) ? (h3 += n2[a3], i3 = parseInt(h3, 16) * s3, s3 = 1, h3 = "") : h3 += a3 : n2.hasOwnProperty(a3) ? (l3 += n2[a3], c3[i3] = parseInt(l3, 16) * s3, s3 = 1, i3 = void 0, l3 = "") : l3 += a3;
              return o3;
            }, u2 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h2 = { Unicode: { Courier: u2, "Courier-Bold": u2, "Courier-BoldOblique": u2, "Courier-Oblique": u2, Helvetica: u2, "Helvetica-Bold": u2, "Helvetica-BoldOblique": u2, "Helvetica-Oblique": u2, "Times-Roman": u2, "Times-Bold": u2, "Times-BoldItalic": u2, "Times-Italic": u2 } }, l2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
            e.events.push(["addFont", function(t) {
              var e2 = t.font, r2 = l2.Unicode[e2.postScriptName];
              r2 && (e2.metadata.Unicode = {}, e2.metadata.Unicode.widths = r2.widths, e2.metadata.Unicode.kerning = r2.kerning);
              var n3 = h2.Unicode[e2.postScriptName];
              n3 && (e2.metadata.Unicode.encoding = n3, e2.encoding = n3.codePages[0]);
            }]);
          }(E.API), function(t) {
            var e = function(t2) {
              for (var e2 = t2.length, r = new Uint8Array(e2), n2 = 0; n2 < e2; n2++)
                r[n2] = t2.charCodeAt(n2);
              return r;
            };
            t.API.events.push(["addFont", function(r) {
              var n2 = void 0, i2 = r.font, a2 = r.instance;
              if (!i2.isStandardFont) {
                if (a2 === void 0)
                  throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
                if (typeof (n2 = a2.existsFileInVFS(i2.postScriptName) === false ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName)) != "string")
                  throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
                !function(r2, n3) {
                  n3 = /^\x00\x01\x00\x00/.test(n3) ? e(n3) : e(u(n3)), r2.metadata = t.API.TTFFont.open(n3), r2.metadata.Unicode = r2.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r2.metadata.glyIdsUsed = [0];
                }(i2, n2);
              }
            }]);
          }(E), function(t) {
            function e() {
              return (n.canvg ? Promise.resolve(n.canvg) : __webpack_require__.e(1).then(__webpack_require__.bind(null, "0d73"))).catch(function(t2) {
                return Promise.reject(new Error("Could not load canvg: " + t2));
              }).then(function(t2) {
                return t2.default ? t2.default : t2;
              });
            }
            E.API.addSvgAsImage = function(t2, r, n2, i2, o2, s2, c2, u2) {
              if (isNaN(r) || isNaN(n2))
                throw a.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
              if (isNaN(i2) || isNaN(o2))
                throw a.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
              var h2 = document.createElement("canvas");
              h2.width = i2, h2.height = o2;
              var l2 = h2.getContext("2d");
              l2.fillStyle = "#fff", l2.fillRect(0, 0, h2.width, h2.height);
              var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
              return e().then(function(e2) {
                return e2.fromString(l2, t2, f2);
              }, function() {
                return Promise.reject(new Error("Could not load canvg."));
              }).then(function(t3) {
                return t3.render(f2);
              }).then(function() {
                d2.addImage(h2.toDataURL("image/jpeg", 1), r, n2, i2, o2, c2, u2);
              });
            };
          }(), E.API.putTotalPages = function(t) {
            var e, r = 0;
            parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(t, "g"), r = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(t, this.internal.getFont()), "g"), r = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
            for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++)
              for (var i2 = 0; i2 < this.internal.pages[n2].length; i2++)
                this.internal.pages[n2][i2] = this.internal.pages[n2][i2].replace(e, r);
            return this;
          }, E.API.viewerPreferences = function(e, r) {
            var n2;
            e = e || {}, r = r || false;
            var i2, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c2 = Object.keys(s2), u2 = [], h2 = 0, l2 = 0, f2 = 0;
            function d2(t, e2) {
              var r2, n3 = false;
              for (r2 = 0; r2 < t.length; r2 += 1)
                t[r2] === e2 && (n3 = true);
              return n3;
            }
            if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), n2 = this.internal.viewerpreferences.configuration, e === "reset" || r === true) {
              var p2 = c2.length;
              for (f2 = 0; f2 < p2; f2 += 1)
                n2[c2[f2]].value = n2[c2[f2]].defaultValue, n2[c2[f2]].explicitSet = false;
            }
            if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(e) === "object") {
              for (a2 in e)
                if (o2 = e[a2], d2(c2, a2) && o2 !== void 0) {
                  if (n2[a2].type === "boolean" && typeof o2 == "boolean")
                    n2[a2].value = o2;
                  else if (n2[a2].type === "name" && d2(n2[a2].valueSet, o2))
                    n2[a2].value = o2;
                  else if (n2[a2].type === "integer" && Number.isInteger(o2))
                    n2[a2].value = o2;
                  else if (n2[a2].type === "array") {
                    for (h2 = 0; h2 < o2.length; h2 += 1)
                      if (i2 = true, o2[h2].length === 1 && typeof o2[h2][0] == "number")
                        u2.push(String(o2[h2] - 1));
                      else if (o2[h2].length > 1) {
                        for (l2 = 0; l2 < o2[h2].length; l2 += 1)
                          typeof o2[h2][l2] != "number" && (i2 = false);
                        i2 === true && u2.push([o2[h2][0] - 1, o2[h2][1] - 1].join(" "));
                      }
                    n2[a2].value = "[" + u2.join(" ") + "]";
                  } else
                    n2[a2].value = n2[a2].defaultValue;
                  n2[a2].explicitSet = true;
                }
            }
            return this.internal.viewerpreferences.isSubscribed === false && (this.internal.events.subscribe("putCatalog", function() {
              var t, e2 = [];
              for (t in n2)
                n2[t].explicitSet === true && (n2[t].type === "name" ? e2.push("/" + t + " /" + n2[t].value) : e2.push("/" + t + " " + n2[t].value));
              e2.length !== 0 && this.internal.write("/ViewerPreferences\n<<\n" + e2.join("\n") + "\n>>");
            }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n2, this;
          }, function(t) {
            var e = function() {
              var t2 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e2 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r2 = unescape(encodeURIComponent(t2)), n2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = r2.length + n2.length + i2.length + e2.length + a2.length;
              this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e2 + r2 + n2 + i2 + a2), this.internal.write("endstream"), this.internal.write("endobj");
            }, r = function() {
              this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
            };
            t.addMetadata = function(t2, n2) {
              return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: t2, namespaceuri: n2 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r), this.internal.events.subscribe("postPutResources", e)), this;
            };
          }(E.API), function(t) {
            var e = t.API, r = e.pdfEscape16 = function(t2, e2) {
              for (var r2, n3 = e2.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t2.length; o2 < s2; ++o2) {
                if (r2 = e2.metadata.characterToGlyph(t2.charCodeAt(o2)), e2.metadata.glyIdsUsed.push(r2), e2.metadata.toUnicode[r2] = t2.charCodeAt(o2), n3.indexOf(r2) == -1 && (n3.push(r2), n3.push([parseInt(e2.metadata.widthOfGlyph(r2), 10)])), r2 == "0")
                  return a2.join("");
                r2 = r2.toString(16), a2.push(i3[4 - r2.length], r2);
              }
              return a2.join("");
            }, n2 = function(t2) {
              var e2, r2, n3, i3, a2, o2, s2;
              for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n3 = [], o2 = 0, s2 = (r2 = Object.keys(t2).sort(function(t3, e3) {
                return t3 - e3;
              })).length; o2 < s2; o2++)
                e2 = r2[o2], n3.length >= 100 && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar", n3 = []), t2[e2] !== void 0 && t2[e2] !== null && typeof t2[e2].toString == "function" && (i3 = ("0000" + t2[e2].toString(16)).slice(-4), e2 = ("0000" + (+e2).toString(16)).slice(-4), n3.push("<" + e2 + "><" + i3 + ">"));
              return n3.length && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar\n"), a2 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
            };
            e.events.push(["putFont", function(e2) {
              !function(e3) {
                var r2 = e3.font, i3 = e3.out, a2 = e3.newObject, o2 = e3.putStream;
                if (r2.metadata instanceof t.API.TTFFont && r2.encoding === "Identity-H") {
                  for (var s2 = r2.metadata.Unicode.widths, c2 = r2.metadata.subset.encode(r2.metadata.glyIdsUsed, 1), u2 = "", h2 = 0; h2 < c2.length; h2++)
                    u2 += String.fromCharCode(c2[h2]);
                  var l2 = a2();
                  o2({ data: u2, addLength1: true, objectId: l2 }), i3("endobj");
                  var f2 = a2();
                  o2({ data: n2(r2.metadata.toUnicode), addLength1: true, objectId: f2 }), i3("endobj");
                  var d2 = a2();
                  i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + F(r2.fontName)), i3("/FontFile2 " + l2 + " 0 R"), i3("/FontBBox " + t.API.PDFObject.convert(r2.metadata.bbox)), i3("/Flags " + r2.metadata.flags), i3("/StemV " + r2.metadata.stemV), i3("/ItalicAngle " + r2.metadata.italicAngle), i3("/Ascent " + r2.metadata.ascender), i3("/Descent " + r2.metadata.decender), i3("/CapHeight " + r2.metadata.capHeight), i3(">>"), i3("endobj");
                  var p2 = a2();
                  i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + F(r2.fontName)), i3("/FontDescriptor " + d2 + " 0 R"), i3("/W " + t.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + r2.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), r2.objectNumber = a2(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f2 + " 0 R"), i3("/BaseFont /" + F(r2.fontName)), i3("/Encoding /" + r2.encoding), i3("/DescendantFonts [" + p2 + " 0 R]"), i3(">>"), i3("endobj"), r2.isAlreadyPutted = true;
                }
              }(e2);
            }]);
            e.events.push(["putFont", function(e2) {
              !function(e3) {
                var r2 = e3.font, i3 = e3.out, a2 = e3.newObject, o2 = e3.putStream;
                if (r2.metadata instanceof t.API.TTFFont && r2.encoding === "WinAnsiEncoding") {
                  for (var s2 = r2.metadata.rawData, c2 = "", u2 = 0; u2 < s2.length; u2++)
                    c2 += String.fromCharCode(s2[u2]);
                  var h2 = a2();
                  o2({ data: c2, addLength1: true, objectId: h2 }), i3("endobj");
                  var l2 = a2();
                  o2({ data: n2(r2.metadata.toUnicode), addLength1: true, objectId: l2 }), i3("endobj");
                  var f2 = a2();
                  i3("<<"), i3("/Descent " + r2.metadata.decender), i3("/CapHeight " + r2.metadata.capHeight), i3("/StemV " + r2.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + h2 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t.API.PDFObject.convert(r2.metadata.bbox)), i3("/FontName /" + F(r2.fontName)), i3("/ItalicAngle " + r2.metadata.italicAngle), i3("/Ascent " + r2.metadata.ascender), i3(">>"), i3("endobj"), r2.objectNumber = a2();
                  for (var d2 = 0; d2 < r2.metadata.hmtx.widths.length; d2++)
                    r2.metadata.hmtx.widths[d2] = parseInt(r2.metadata.hmtx.widths[d2] * (1e3 / r2.metadata.head.unitsPerEm));
                  i3("<</Subtype/TrueType/Type/Font/ToUnicode " + l2 + " 0 R/BaseFont/" + F(r2.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + r2.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t.API.PDFObject.convert(r2.metadata.hmtx.widths) + ">>"), i3("endobj"), r2.isAlreadyPutted = true;
                }
              }(e2);
            }]);
            var i2 = function(t2) {
              var e2, n3 = t2.text || "", i3 = t2.x, a2 = t2.y, o2 = t2.options || {}, s2 = t2.mutex || {}, c2 = s2.pdfEscape, u2 = s2.activeFontKey, h2 = s2.fonts, l2 = u2, f2 = "", d2 = 0, p2 = "", g2 = h2[l2].encoding;
              if (h2[l2].encoding !== "Identity-H")
                return { text: n3, x: i3, y: a2, options: o2, mutex: s2 };
              for (p2 = n3, l2 = u2, Array.isArray(n3) && (p2 = n3[0]), d2 = 0; d2 < p2.length; d2 += 1)
                h2[l2].metadata.hasOwnProperty("cmap") && (e2 = h2[l2].metadata.cmap.unicode.codeMap[p2[d2].charCodeAt(0)]), e2 || p2[d2].charCodeAt(0) < 256 && h2[l2].metadata.hasOwnProperty("Unicode") ? f2 += p2[d2] : f2 += "";
              var m2 = "";
              return parseInt(l2.slice(1)) < 14 || g2 === "WinAnsiEncoding" ? m2 = c2(f2, l2).split("").map(function(t3) {
                return t3.charCodeAt(0).toString(16);
              }).join("") : g2 === "Identity-H" && (m2 = r(f2, h2[l2])), s2.isHex = true, { text: m2, x: i3, y: a2, options: o2, mutex: s2 };
            };
            e.events.push(["postProcessText", function(t2) {
              var e2 = t2.text || "", r2 = [], n3 = { text: e2, x: t2.x, y: t2.y, options: t2.options, mutex: t2.mutex };
              if (Array.isArray(e2)) {
                var a2 = 0;
                for (a2 = 0; a2 < e2.length; a2 += 1)
                  Array.isArray(e2[a2]) && e2[a2].length === 3 ? r2.push([i2(Object.assign({}, n3, { text: e2[a2][0] })).text, e2[a2][1], e2[a2][2]]) : r2.push(i2(Object.assign({}, n3, { text: e2[a2] })).text);
                t2.text = r2;
              } else
                t2.text = i2(Object.assign({}, n3, { text: e2 })).text;
            }]);
          }(E), function(t) {
            var e = function() {
              return this.internal.vFS === void 0 && (this.internal.vFS = {}), true;
            };
            t.existsFileInVFS = function(t2) {
              return e.call(this), this.internal.vFS[t2] !== void 0;
            }, t.addFileToVFS = function(t2, r) {
              return e.call(this), this.internal.vFS[t2] = r, this;
            }, t.getFileFromVFS = function(t2) {
              return e.call(this), this.internal.vFS[t2] !== void 0 ? this.internal.vFS[t2] : null;
            };
          }(E.API), function(t) {
            t.__bidiEngine__ = t.prototype.__bidiEngine__ = function(t2) {
              var r2, n2, i2, a2, o2, s2, c2, u2 = e, h2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "\xAB", "\xBB", "\xAB", "\u2039", "\u203A", "\u2039", "\u2045", "\u2046", "\u2045", "\u207D", "\u207E", "\u207D", "\u208D", "\u208E", "\u208D", "\u2264", "\u2265", "\u2264", "\u2329", "\u232A", "\u2329", "\uFE59", "\uFE5A", "\uFE59", "\uFE5B", "\uFE5C", "\uFE5B", "\uFE5D", "\uFE5E", "\uFE5D", "\uFE64", "\uFE65", "\uFE64"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
              this.__bidiEngine__ = {};
              var b2 = function(t3) {
                var e2 = t3.charCodeAt(), r3 = e2 >> 8, n3 = d2[r3];
                return n3 !== void 0 ? u2[256 * n3 + (255 & e2)] : r3 === 252 || r3 === 253 ? "AL" : g2.test(r3) ? "L" : r3 === 8 ? "R" : "N";
              }, y2 = function(t3) {
                for (var e2, r3 = 0; r3 < t3.length; r3++) {
                  if ((e2 = b2(t3.charAt(r3))) === "L")
                    return false;
                  if (e2 === "R")
                    return true;
                }
                return false;
              }, w2 = function(t3, e2, o3, s3) {
                var c3, u3, h3, l3, f3 = e2[s3];
                switch (f3) {
                  case "L":
                  case "R":
                    m2 = false;
                    break;
                  case "N":
                  case "AN":
                    break;
                  case "EN":
                    m2 && (f3 = "AN");
                    break;
                  case "AL":
                    m2 = true, f3 = "R";
                    break;
                  case "WS":
                    f3 = "N";
                    break;
                  case "CS":
                    s3 < 1 || s3 + 1 >= e2.length || (c3 = o3[s3 - 1]) !== "EN" && c3 !== "AN" || (u3 = e2[s3 + 1]) !== "EN" && u3 !== "AN" ? f3 = "N" : m2 && (u3 = "AN"), f3 = u3 === c3 ? u3 : "N";
                    break;
                  case "ES":
                    f3 = (c3 = s3 > 0 ? o3[s3 - 1] : "B") === "EN" && s3 + 1 < e2.length && e2[s3 + 1] === "EN" ? "EN" : "N";
                    break;
                  case "ET":
                    if (s3 > 0 && o3[s3 - 1] === "EN") {
                      f3 = "EN";
                      break;
                    }
                    if (m2) {
                      f3 = "N";
                      break;
                    }
                    for (h3 = s3 + 1, l3 = e2.length; h3 < l3 && e2[h3] === "ET"; )
                      h3++;
                    f3 = h3 < l3 && e2[h3] === "EN" ? "EN" : "N";
                    break;
                  case "NSM":
                    if (i2 && !a2) {
                      for (l3 = e2.length, h3 = s3 + 1; h3 < l3 && e2[h3] === "NSM"; )
                        h3++;
                      if (h3 < l3) {
                        var d3 = t3[s3], p3 = d3 >= 1425 && d3 <= 2303 || d3 === 64286;
                        if (c3 = e2[h3], p3 && (c3 === "R" || c3 === "AL")) {
                          f3 = "R";
                          break;
                        }
                      }
                    }
                    f3 = s3 < 1 || (c3 = e2[s3 - 1]) === "B" ? "N" : o3[s3 - 1];
                    break;
                  case "B":
                    m2 = false, r2 = true, f3 = v2;
                    break;
                  case "S":
                    n2 = true, f3 = "N";
                    break;
                  case "LRE":
                  case "RLE":
                  case "LRO":
                  case "RLO":
                  case "PDF":
                    m2 = false;
                    break;
                  case "BN":
                    f3 = "N";
                }
                return f3;
              }, N2 = function(t3, e2, r3) {
                var n3 = t3.split("");
                return r3 && L2(n3, r3, { hiLevel: v2 }), n3.reverse(), e2 && e2.reverse(), n3.join("");
              }, L2 = function(t3, e2, i3) {
                var a3, o3, s3, c3, u3, d3 = -1, p3 = t3.length, g3 = 0, y3 = [], N3 = v2 ? l2 : h2, L3 = [];
                for (m2 = false, r2 = false, n2 = false, o3 = 0; o3 < p3; o3++)
                  L3[o3] = b2(t3[o3]);
                for (s3 = 0; s3 < p3; s3++) {
                  if (u3 = g3, y3[s3] = w2(t3, L3, y3, s3), a3 = 240 & (g3 = N3[u3][f2[y3[s3]]]), g3 &= 15, e2[s3] = c3 = N3[g3][5], a3 > 0)
                    if (a3 === 16) {
                      for (o3 = d3; o3 < s3; o3++)
                        e2[o3] = 1;
                      d3 = -1;
                    } else
                      d3 = -1;
                  if (N3[g3][6])
                    d3 === -1 && (d3 = s3);
                  else if (d3 > -1) {
                    for (o3 = d3; o3 < s3; o3++)
                      e2[o3] = c3;
                    d3 = -1;
                  }
                  L3[s3] === "B" && (e2[s3] = 0), i3.hiLevel |= c3;
                }
                n2 && function(t4, e3, r3) {
                  for (var n3 = 0; n3 < r3; n3++)
                    if (t4[n3] === "S") {
                      e3[n3] = v2;
                      for (var i4 = n3 - 1; i4 >= 0 && t4[i4] === "WS"; i4--)
                        e3[i4] = v2;
                    }
                }(L3, e2, p3);
              }, A2 = function(t3, e2, n3, i3, a3) {
                if (!(a3.hiLevel < t3)) {
                  if (t3 === 1 && v2 === 1 && !r2)
                    return e2.reverse(), void (n3 && n3.reverse());
                  for (var o3, s3, c3, u3, h3 = e2.length, l3 = 0; l3 < h3; ) {
                    if (i3[l3] >= t3) {
                      for (c3 = l3 + 1; c3 < h3 && i3[c3] >= t3; )
                        c3++;
                      for (u3 = l3, s3 = c3 - 1; u3 < s3; u3++, s3--)
                        o3 = e2[u3], e2[u3] = e2[s3], e2[s3] = o3, n3 && (o3 = n3[u3], n3[u3] = n3[s3], n3[s3] = o3);
                      l3 = c3;
                    }
                    l3++;
                  }
                }
              }, x2 = function(t3, e2, r3) {
                var n3 = t3.split(""), i3 = { hiLevel: v2 };
                return r3 || (r3 = []), L2(n3, r3, i3), function(t4, e3, r4) {
                  if (r4.hiLevel !== 0 && c2)
                    for (var n4, i4 = 0; i4 < t4.length; i4++)
                      e3[i4] === 1 && (n4 = p2.indexOf(t4[i4])) >= 0 && (t4[i4] = p2[n4 + 1]);
                }(n3, r3, i3), A2(2, n3, e2, r3, i3), A2(1, n3, e2, r3, i3), n3.join("");
              };
              return this.__bidiEngine__.doBidiReorder = function(t3, e2, r3) {
                if (function(t4, e3) {
                  if (e3)
                    for (var r4 = 0; r4 < t4.length; r4++)
                      e3[r4] = r4;
                  a2 === void 0 && (a2 = y2(t4)), s2 === void 0 && (s2 = y2(t4));
                }(t3, e2), i2 || !o2 || s2)
                  if (i2 && o2 && a2 ^ s2)
                    v2 = a2 ? 1 : 0, t3 = N2(t3, e2, r3);
                  else if (!i2 && o2 && s2)
                    v2 = a2 ? 1 : 0, t3 = x2(t3, e2, r3), t3 = N2(t3, e2);
                  else if (!i2 || a2 || o2 || s2) {
                    if (i2 && !o2 && a2 ^ s2)
                      t3 = N2(t3, e2), a2 ? (v2 = 0, t3 = x2(t3, e2, r3)) : (v2 = 1, t3 = x2(t3, e2, r3), t3 = N2(t3, e2));
                    else if (i2 && a2 && !o2 && s2)
                      v2 = 1, t3 = x2(t3, e2, r3), t3 = N2(t3, e2);
                    else if (!i2 && !o2 && a2 ^ s2) {
                      var n3 = c2;
                      a2 ? (v2 = 1, t3 = x2(t3, e2, r3), v2 = 0, c2 = false, t3 = x2(t3, e2, r3), c2 = n3) : (v2 = 0, t3 = x2(t3, e2, r3), t3 = N2(t3, e2), v2 = 1, c2 = false, t3 = x2(t3, e2, r3), c2 = n3, t3 = N2(t3, e2));
                    }
                  } else
                    v2 = 0, t3 = x2(t3, e2, r3);
                else
                  v2 = a2 ? 1 : 0, t3 = x2(t3, e2, r3);
                return t3;
              }, this.__bidiEngine__.setOptions = function(t3) {
                t3 && (i2 = t3.isInputVisual, o2 = t3.isOutputVisual, a2 = t3.isInputRtl, s2 = t3.isOutputRtl, c2 = t3.isSymmetricSwapping);
              }, this.__bidiEngine__.setOptions(t2), this.__bidiEngine__;
            };
            var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r = new t.__bidiEngine__({ isInputVisual: true });
            t.API.events.push(["postProcessText", function(t2) {
              var e2 = t2.text, n2 = (t2.x, t2.y, t2.options || {}), i2 = (t2.mutex, n2.lang, []);
              if (n2.isInputVisual = typeof n2.isInputVisual != "boolean" || n2.isInputVisual, r.setOptions(n2), Object.prototype.toString.call(e2) === "[object Array]") {
                var a2 = 0;
                for (i2 = [], a2 = 0; a2 < e2.length; a2 += 1)
                  Object.prototype.toString.call(e2[a2]) === "[object Array]" ? i2.push([r.doBidiReorder(e2[a2][0]), e2[a2][1], e2[a2][2]]) : i2.push([r.doBidiReorder(e2[a2])]);
                t2.text = i2;
              } else
                t2.text = r.doBidiReorder(e2);
              r.setOptions({ isInputVisual: true });
            }]);
          }(E), E.API.TTFFont = function() {
            function t(t2) {
              var e;
              if (this.rawData = t2, e = this.contents = new ne(t2), this.contents.pos = 4, e.readString(4) === "ttcf")
                throw new Error("TTCF not supported.");
              e.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
            }
            return t.open = function(e) {
              return new t(e);
            }, t.prototype.parse = function() {
              return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
            }, t.prototype.registerTTF = function() {
              var t2, e, r, n2, i2;
              if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {
                var e2, r2, n3, i3;
                for (i3 = [], e2 = 0, r2 = (n3 = this.bbox).length; e2 < r2; e2++)
                  t2 = n3[e2], i3.push(Math.round(t2 * this.scaleFactor));
                return i3;
              }.call(this), this.stemV = 0, this.post.exists ? (r = 255 & (n2 = this.post.italic_angle), (32768 & (e = n2 >> 16)) != 0 && (e = -(1 + (65535 ^ e))), this.italicAngle = +(e + "." + r)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (i2 = this.familyClass) === 1 || i2 === 2 || i2 === 3 || i2 === 4 || i2 === 5 || i2 === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
                throw new Error("No unicode cmap for font");
            }, t.prototype.characterToGlyph = function(t2) {
              var e;
              return ((e = this.cmap.unicode) != null ? e.codeMap[t2] : void 0) || 0;
            }, t.prototype.widthOfGlyph = function(t2) {
              var e;
              return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t2).advance * e;
            }, t.prototype.widthOfString = function(t2, e, r) {
              var n2, i2, a2, o2;
              for (a2 = 0, i2 = 0, o2 = (t2 = "" + t2).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2)
                n2 = t2.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(n2)) + r * (1e3 / e) || 0;
              return a2 * (e / 1e3);
            }, t.prototype.lineHeight = function(t2, e) {
              var r;
              return e == null && (e = false), r = e ? this.lineGap : 0, (this.ascender + r - this.decender) / 1e3 * t2;
            }, t;
          }();
          var re, ne = function() {
            function t(t2) {
              this.data = t2 != null ? t2 : [], this.pos = 0, this.length = this.data.length;
            }
            return t.prototype.readByte = function() {
              return this.data[this.pos++];
            }, t.prototype.writeByte = function(t2) {
              return this.data[this.pos++] = t2;
            }, t.prototype.readUInt32 = function() {
              return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
            }, t.prototype.writeUInt32 = function(t2) {
              return this.writeByte(t2 >>> 24 & 255), this.writeByte(t2 >> 16 & 255), this.writeByte(t2 >> 8 & 255), this.writeByte(255 & t2);
            }, t.prototype.readInt32 = function() {
              var t2;
              return (t2 = this.readUInt32()) >= 2147483648 ? t2 - 4294967296 : t2;
            }, t.prototype.writeInt32 = function(t2) {
              return t2 < 0 && (t2 += 4294967296), this.writeUInt32(t2);
            }, t.prototype.readUInt16 = function() {
              return this.readByte() << 8 | this.readByte();
            }, t.prototype.writeUInt16 = function(t2) {
              return this.writeByte(t2 >> 8 & 255), this.writeByte(255 & t2);
            }, t.prototype.readInt16 = function() {
              var t2;
              return (t2 = this.readUInt16()) >= 32768 ? t2 - 65536 : t2;
            }, t.prototype.writeInt16 = function(t2) {
              return t2 < 0 && (t2 += 65536), this.writeUInt16(t2);
            }, t.prototype.readString = function(t2) {
              var e, r;
              for (r = [], e = 0; 0 <= t2 ? e < t2 : e > t2; e = 0 <= t2 ? ++e : --e)
                r[e] = String.fromCharCode(this.readByte());
              return r.join("");
            }, t.prototype.writeString = function(t2) {
              var e, r, n2;
              for (n2 = [], e = 0, r = t2.length; 0 <= r ? e < r : e > r; e = 0 <= r ? ++e : --e)
                n2.push(this.writeByte(t2.charCodeAt(e)));
              return n2;
            }, t.prototype.readShort = function() {
              return this.readInt16();
            }, t.prototype.writeShort = function(t2) {
              return this.writeInt16(t2);
            }, t.prototype.readLongLong = function() {
              var t2, e, r, n2, i2, a2, o2, s2;
              return t2 = this.readByte(), e = this.readByte(), r = this.readByte(), n2 = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t2 ? -1 * (72057594037927940 * (255 ^ t2) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ r) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t2 + 281474976710656 * e + 1099511627776 * r + 4294967296 * n2 + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;
            }, t.prototype.writeLongLong = function(t2) {
              var e, r;
              return e = Math.floor(t2 / 4294967296), r = 4294967295 & t2, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(r >> 24 & 255), this.writeByte(r >> 16 & 255), this.writeByte(r >> 8 & 255), this.writeByte(255 & r);
            }, t.prototype.readInt = function() {
              return this.readInt32();
            }, t.prototype.writeInt = function(t2) {
              return this.writeInt32(t2);
            }, t.prototype.read = function(t2) {
              var e, r;
              for (e = [], r = 0; 0 <= t2 ? r < t2 : r > t2; r = 0 <= t2 ? ++r : --r)
                e.push(this.readByte());
              return e;
            }, t.prototype.write = function(t2) {
              var e, r, n2, i2;
              for (i2 = [], r = 0, n2 = t2.length; r < n2; r++)
                e = t2[r], i2.push(this.writeByte(e));
              return i2;
            }, t;
          }(), ie = function() {
            var t;
            function e(t2) {
              var e2, r, n2;
              for (this.scalarType = t2.readInt(), this.tableCount = t2.readShort(), this.searchRange = t2.readShort(), this.entrySelector = t2.readShort(), this.rangeShift = t2.readShort(), this.tables = {}, r = 0, n2 = this.tableCount; 0 <= n2 ? r < n2 : r > n2; r = 0 <= n2 ? ++r : --r)
                e2 = { tag: t2.readString(4), checksum: t2.readInt(), offset: t2.readInt(), length: t2.readInt() }, this.tables[e2.tag] = e2;
            }
            return e.prototype.encode = function(e2) {
              var r, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2;
              for (p2 in f2 = Object.keys(e2).length, s2 = Math.log(2), h2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(h2 / s2), u2 = 16 * f2 - h2, (n2 = new ne()).writeInt(this.scalarType), n2.writeShort(f2), n2.writeShort(h2), n2.writeShort(a2), n2.writeShort(u2), i2 = 16 * f2, c2 = n2.pos + i2, o2 = null, d2 = [], e2)
                for (l2 = e2[p2], n2.writeString(p2), n2.writeInt(t(l2)), n2.writeInt(c2), n2.writeInt(l2.length), d2 = d2.concat(l2), p2 === "head" && (o2 = c2), c2 += l2.length; c2 % 4; )
                  d2.push(0), c2++;
              return n2.write(d2), r = 2981146554 - t(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r), n2.data;
            }, t = function(t2) {
              var e2, r, n2, i2;
              for (t2 = ve.call(t2); t2.length % 4; )
                t2.push(0);
              for (n2 = new ne(t2), r = 0, e2 = 0, i2 = t2.length; e2 < i2; e2 = e2 += 4)
                r += n2.readUInt32();
              return 4294967295 & r;
            }, e;
          }(), ae = {}.hasOwnProperty, oe = function(t, e) {
            for (var r in e)
              ae.call(e, r) && (t[r] = e[r]);
            function n2() {
              this.constructor = t;
            }
            return n2.prototype = e.prototype, t.prototype = new n2(), t.__super__ = e.prototype, t;
          };
          re = function() {
            function t(t2) {
              var e;
              this.file = t2, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
            }
            return t.prototype.parse = function() {
            }, t.prototype.encode = function() {
            }, t.prototype.raw = function() {
              return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
            }, t;
          }();
          var se = function(t) {
            function e() {
              return e.__super__.constructor.apply(this, arguments);
            }
            return oe(e, re), e.prototype.tag = "head", e.prototype.parse = function(t2) {
              return t2.pos = this.offset, this.version = t2.readInt(), this.revision = t2.readInt(), this.checkSumAdjustment = t2.readInt(), this.magicNumber = t2.readInt(), this.flags = t2.readShort(), this.unitsPerEm = t2.readShort(), this.created = t2.readLongLong(), this.modified = t2.readLongLong(), this.xMin = t2.readShort(), this.yMin = t2.readShort(), this.xMax = t2.readShort(), this.yMax = t2.readShort(), this.macStyle = t2.readShort(), this.lowestRecPPEM = t2.readShort(), this.fontDirectionHint = t2.readShort(), this.indexToLocFormat = t2.readShort(), this.glyphDataFormat = t2.readShort();
            }, e.prototype.encode = function(t2) {
              var e2;
              return (e2 = new ne()).writeInt(this.version), e2.writeInt(this.revision), e2.writeInt(this.checkSumAdjustment), e2.writeInt(this.magicNumber), e2.writeShort(this.flags), e2.writeShort(this.unitsPerEm), e2.writeLongLong(this.created), e2.writeLongLong(this.modified), e2.writeShort(this.xMin), e2.writeShort(this.yMin), e2.writeShort(this.xMax), e2.writeShort(this.yMax), e2.writeShort(this.macStyle), e2.writeShort(this.lowestRecPPEM), e2.writeShort(this.fontDirectionHint), e2.writeShort(t2), e2.writeShort(this.glyphDataFormat), e2.data;
            }, e;
          }(), ce = function() {
            function t(t2, e) {
              var r, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2;
              switch (this.platformID = t2.readUInt16(), this.encodingID = t2.readShort(), this.offset = e + t2.readInt(), h2 = t2.pos, t2.pos = this.offset, this.format = t2.readUInt16(), this.length = t2.readUInt16(), this.language = t2.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
                case 0:
                  for (s2 = 0; s2 < 256; ++s2)
                    this.codeMap[s2] = t2.readByte();
                  break;
                case 4:
                  for (f2 = t2.readUInt16(), l2 = f2 / 2, t2.pos += 6, i2 = function() {
                    var e2, r2;
                    for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
                      r2.push(t2.readUInt16());
                    return r2;
                  }(), t2.pos += 2, p2 = function() {
                    var e2, r2;
                    for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
                      r2.push(t2.readUInt16());
                    return r2;
                  }(), c2 = function() {
                    var e2, r2;
                    for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
                      r2.push(t2.readUInt16());
                    return r2;
                  }(), u2 = function() {
                    var e2, r2;
                    for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
                      r2.push(t2.readUInt16());
                    return r2;
                  }(), n2 = (this.length - t2.pos + this.offset) / 2, o2 = function() {
                    var e2, r2;
                    for (r2 = [], s2 = e2 = 0; 0 <= n2 ? e2 < n2 : e2 > n2; s2 = 0 <= n2 ? ++e2 : --e2)
                      r2.push(t2.readUInt16());
                    return r2;
                  }(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2)
                    for (g2 = i2[s2], r = v2 = d2 = p2[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r = d2 <= g2 ? ++v2 : --v2)
                      u2[s2] === 0 ? a2 = r + c2[s2] : (a2 = o2[u2[s2] / 2 + (r - d2) - (l2 - s2)] || 0) !== 0 && (a2 += c2[s2]), this.codeMap[r] = 65535 & a2;
              }
              t2.pos = h2;
            }
            return t.encode = function(t2, e) {
              var r, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2, C2, j2, O2, B2, M2, E2, q2, D2, R2, T2, z2, U2, H2, W2, V2, G2, Y2;
              switch (I2 = new ne(), a2 = Object.keys(t2).sort(function(t3, e2) {
                return t3 - e2;
              }), e) {
                case "macroman":
                  for (p2 = 0, g2 = function() {
                    var t3 = [];
                    for (d2 = 0; d2 < 256; ++d2)
                      t3.push(0);
                    return t3;
                  }(), v2 = { 0: 0 }, i2 = {}, F2 = 0, B2 = a2.length; F2 < B2; F2++)
                    v2[W2 = t2[n2 = a2[F2]]] == null && (v2[W2] = ++p2), i2[n2] = { old: t2[n2], new: v2[t2[n2]] }, g2[n2] = v2[t2[n2]];
                  return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i2, subtable: I2.data, maxGlyphID: p2 + 1 };
                case "unicode":
                  for (P2 = [], h2 = [], b2 = 0, v2 = {}, r = {}, m2 = c2 = null, C2 = 0, M2 = a2.length; C2 < M2; C2++)
                    v2[w2 = t2[n2 = a2[C2]]] == null && (v2[w2] = ++b2), r[n2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - n2, m2 != null && o2 === c2 || (m2 && h2.push(m2), P2.push(n2), c2 = o2), m2 = n2;
                  for (m2 && h2.push(m2), h2.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l2 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s2 = [], N2 = [], f2 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {
                    if (_2 = P2[d2], u2 = h2[d2], _2 === 65535) {
                      s2.push(0), N2.push(0);
                      break;
                    }
                    if (_2 - (k2 = r[_2].new) >= 32768)
                      for (s2.push(0), N2.push(2 * (f2.length + x2 - d2)), n2 = O2 = _2; _2 <= u2 ? O2 <= u2 : O2 >= u2; n2 = _2 <= u2 ? ++O2 : --O2)
                        f2.push(r[n2].new);
                    else
                      s2.push(k2 - _2), N2.push(0);
                  }
                  for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f2.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l2), I2.writeUInt16(L2), U2 = 0, q2 = h2.length; U2 < q2; U2++)
                    n2 = h2[U2], I2.writeUInt16(n2);
                  for (I2.writeUInt16(0), H2 = 0, D2 = P2.length; H2 < D2; H2++)
                    n2 = P2[H2], I2.writeUInt16(n2);
                  for (V2 = 0, R2 = s2.length; V2 < R2; V2++)
                    o2 = s2[V2], I2.writeUInt16(o2);
                  for (G2 = 0, T2 = N2.length; G2 < T2; G2++)
                    y2 = N2[G2], I2.writeUInt16(y2);
                  for (Y2 = 0, z2 = f2.length; Y2 < z2; Y2++)
                    p2 = f2[Y2], I2.writeUInt16(p2);
                  return { charMap: r, subtable: I2.data, maxGlyphID: b2 + 1 };
              }
            }, t;
          }(), ue = function(t) {
            function e() {
              return e.__super__.constructor.apply(this, arguments);
            }
            return oe(e, re), e.prototype.tag = "cmap", e.prototype.parse = function(t2) {
              var e2, r, n2;
              for (t2.pos = this.offset, this.version = t2.readUInt16(), n2 = t2.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= n2 ? r < n2 : r > n2; r = 0 <= n2 ? ++r : --r)
                e2 = new ce(t2, this.offset), this.tables.push(e2), e2.isUnicode && this.unicode == null && (this.unicode = e2);
              return true;
            }, e.encode = function(t2, e2) {
              var r, n2;
              return e2 == null && (e2 = "macroman"), r = ce.encode(t2, e2), (n2 = new ne()).writeUInt16(0), n2.writeUInt16(1), r.table = n2.data.concat(r.subtable), r;
            }, e;
          }(), he = function(t) {
            function e() {
              return e.__super__.constructor.apply(this, arguments);
            }
            return oe(e, re), e.prototype.tag = "hhea", e.prototype.parse = function(t2) {
              return t2.pos = this.offset, this.version = t2.readInt(), this.ascender = t2.readShort(), this.decender = t2.readShort(), this.lineGap = t2.readShort(), this.advanceWidthMax = t2.readShort(), this.minLeftSideBearing = t2.readShort(), this.minRightSideBearing = t2.readShort(), this.xMaxExtent = t2.readShort(), this.caretSlopeRise = t2.readShort(), this.caretSlopeRun = t2.readShort(), this.caretOffset = t2.readShort(), t2.pos += 8, this.metricDataFormat = t2.readShort(), this.numberOfMetrics = t2.readUInt16();
            }, e;
          }(), le = function(t) {
            function e() {
              return e.__super__.constructor.apply(this, arguments);
            }
            return oe(e, re), e.prototype.tag = "OS/2", e.prototype.parse = function(t2) {
              if (t2.pos = this.offset, this.version = t2.readUInt16(), this.averageCharWidth = t2.readShort(), this.weightClass = t2.readUInt16(), this.widthClass = t2.readUInt16(), this.type = t2.readShort(), this.ySubscriptXSize = t2.readShort(), this.ySubscriptYSize = t2.readShort(), this.ySubscriptXOffset = t2.readShort(), this.ySubscriptYOffset = t2.readShort(), this.ySuperscriptXSize = t2.readShort(), this.ySuperscriptYSize = t2.readShort(), this.ySuperscriptXOffset = t2.readShort(), this.ySuperscriptYOffset = t2.readShort(), this.yStrikeoutSize = t2.readShort(), this.yStrikeoutPosition = t2.readShort(), this.familyClass = t2.readShort(), this.panose = function() {
                var e2, r;
                for (r = [], e2 = 0; e2 < 10; ++e2)
                  r.push(t2.readByte());
                return r;
              }(), this.charRange = function() {
                var e2, r;
                for (r = [], e2 = 0; e2 < 4; ++e2)
                  r.push(t2.readInt());
                return r;
              }(), this.vendorID = t2.readString(4), this.selection = t2.readShort(), this.firstCharIndex = t2.readShort(), this.lastCharIndex = t2.readShort(), this.version > 0 && (this.ascent = t2.readShort(), this.descent = t2.readShort(), this.lineGap = t2.readShort(), this.winAscent = t2.readShort(), this.winDescent = t2.readShort(), this.codePageRange = function() {
                var e2, r;
                for (r = [], e2 = 0; e2 < 2; e2 = ++e2)
                  r.push(t2.readInt());
                return r;
              }(), this.version > 1))
                return this.xHeight = t2.readShort(), this.capHeight = t2.readShort(), this.defaultChar = t2.readShort(), this.breakChar = t2.readShort(), this.maxContext = t2.readShort();
            }, e;
          }(), fe = function(t) {
            function e() {
              return e.__super__.constructor.apply(this, arguments);
            }
            return oe(e, re), e.prototype.tag = "post", e.prototype.parse = function(t2) {
              var e2, r, n2;
              switch (t2.pos = this.offset, this.format = t2.readInt(), this.italicAngle = t2.readInt(), this.underlinePosition = t2.readShort(), this.underlineThickness = t2.readShort(), this.isFixedPitch = t2.readInt(), this.minMemType42 = t2.readInt(), this.maxMemType42 = t2.readInt(), this.minMemType1 = t2.readInt(), this.maxMemType1 = t2.readInt(), this.format) {
                case 65536:
                  break;
                case 131072:
                  var i2;
                  for (r = t2.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= r ? i2 < r : i2 > r; i2 = 0 <= r ? ++i2 : --i2)
                    this.glyphNameIndex.push(t2.readUInt16());
                  for (this.names = [], n2 = []; t2.pos < this.offset + this.length; )
                    e2 = t2.readByte(), n2.push(this.names.push(t2.readString(e2)));
                  return n2;
                case 151552:
                  return r = t2.readUInt16(), this.offsets = t2.read(r);
                case 196608:
                  break;
                case 262144:
                  return this.map = function() {
                    var e3, r2, n3;
                    for (n3 = [], i2 = e3 = 0, r2 = this.file.maxp.numGlyphs; 0 <= r2 ? e3 < r2 : e3 > r2; i2 = 0 <= r2 ? ++e3 : --e3)
                      n3.push(t2.readUInt32());
                    return n3;
                  }.call(this);
              }
            }, e;
          }(), de = function(t, e) {
            this.raw = t, this.length = t.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
          }, pe = function(t) {
            function e() {
              return e.__super__.constructor.apply(this, arguments);
            }
            return oe(e, re), e.prototype.tag = "name", e.prototype.parse = function(t2) {
              var e2, r, n2, i2, a2, o2, s2, c2, u2, h2, l2;
              for (t2.pos = this.offset, t2.readShort(), e2 = t2.readShort(), o2 = t2.readShort(), r = [], i2 = 0; 0 <= e2 ? i2 < e2 : i2 > e2; i2 = 0 <= e2 ? ++i2 : --i2)
                r.push({ platformID: t2.readShort(), encodingID: t2.readShort(), languageID: t2.readShort(), nameID: t2.readShort(), length: t2.readShort(), offset: this.offset + o2 + t2.readShort() });
              for (s2 = {}, i2 = u2 = 0, h2 = r.length; u2 < h2; i2 = ++u2)
                n2 = r[i2], t2.pos = n2.offset, c2 = t2.readString(n2.length), a2 = new de(c2, n2), s2[l2 = n2.nameID] == null && (s2[l2] = []), s2[n2.nameID].push(a2);
              this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
              try {
                this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
              } catch (t3) {
                this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
              }
              return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
            }, e;
          }(), ge = function(t) {
            function e() {
              return e.__super__.constructor.apply(this, arguments);
            }
            return oe(e, re), e.prototype.tag = "maxp", e.prototype.parse = function(t2) {
              return t2.pos = this.offset, this.version = t2.readInt(), this.numGlyphs = t2.readUInt16(), this.maxPoints = t2.readUInt16(), this.maxContours = t2.readUInt16(), this.maxCompositePoints = t2.readUInt16(), this.maxComponentContours = t2.readUInt16(), this.maxZones = t2.readUInt16(), this.maxTwilightPoints = t2.readUInt16(), this.maxStorage = t2.readUInt16(), this.maxFunctionDefs = t2.readUInt16(), this.maxInstructionDefs = t2.readUInt16(), this.maxStackElements = t2.readUInt16(), this.maxSizeOfInstructions = t2.readUInt16(), this.maxComponentElements = t2.readUInt16(), this.maxComponentDepth = t2.readUInt16();
            }, e;
          }(), me = function(t) {
            function e() {
              return e.__super__.constructor.apply(this, arguments);
            }
            return oe(e, re), e.prototype.tag = "hmtx", e.prototype.parse = function(t2) {
              var e2, r, n2, i2, a2, o2, s2;
              for (t2.pos = this.offset, this.metrics = [], e2 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e2 < o2 : e2 > o2; e2 = 0 <= o2 ? ++e2 : --e2)
                this.metrics.push({ advance: t2.readUInt16(), lsb: t2.readInt16() });
              for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
                var r2, i3;
                for (i3 = [], e2 = r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; e2 = 0 <= n2 ? ++r2 : --r2)
                  i3.push(t2.readInt16());
                return i3;
              }(), this.widths = function() {
                var t3, e3, r2, n3;
                for (n3 = [], t3 = 0, e3 = (r2 = this.metrics).length; t3 < e3; t3++)
                  i2 = r2[t3], n3.push(i2.advance);
                return n3;
              }.call(this), r = this.widths[this.widths.length - 1], s2 = [], e2 = a2 = 0; 0 <= n2 ? a2 < n2 : a2 > n2; e2 = 0 <= n2 ? ++a2 : --a2)
                s2.push(this.widths.push(r));
              return s2;
            }, e.prototype.forGlyph = function(t2) {
              return t2 in this.metrics ? this.metrics[t2] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t2 - this.metrics.length] };
            }, e;
          }(), ve = [].slice, be = function(t) {
            function e() {
              return e.__super__.constructor.apply(this, arguments);
            }
            return oe(e, re), e.prototype.tag = "glyf", e.prototype.parse = function() {
              return this.cache = {};
            }, e.prototype.glyphFor = function(t2) {
              var e2, r, n2, i2, a2, o2, s2, c2, u2, h2;
              return t2 in this.cache ? this.cache[t2] : (i2 = this.file.loca, e2 = this.file.contents, r = i2.indexOf(t2), (n2 = i2.lengthOf(t2)) === 0 ? this.cache[t2] = null : (e2.pos = this.offset + r, a2 = (o2 = new ne(e2.read(n2))).readShort(), c2 = o2.readShort(), h2 = o2.readShort(), s2 = o2.readShort(), u2 = o2.readShort(), this.cache[t2] = a2 === -1 ? new we(o2, c2, h2, s2, u2) : new ye(o2, a2, c2, h2, s2, u2), this.cache[t2]));
            }, e.prototype.encode = function(t2, e2, r) {
              var n2, i2, a2, o2, s2;
              for (a2 = [], i2 = [], o2 = 0, s2 = e2.length; o2 < s2; o2++)
                n2 = t2[e2[o2]], i2.push(a2.length), n2 && (a2 = a2.concat(n2.encode(r)));
              return i2.push(a2.length), { table: a2, offsets: i2 };
            }, e;
          }(), ye = function() {
            function t(t2, e, r, n2, i2, a2) {
              this.raw = t2, this.numberOfContours = e, this.xMin = r, this.yMin = n2, this.xMax = i2, this.yMax = a2, this.compound = false;
            }
            return t.prototype.encode = function() {
              return this.raw.data;
            }, t;
          }(), we = function() {
            function t(t2, e, r, n2, i2) {
              var a2, o2;
              for (this.raw = t2, this.xMin = e, this.yMin = r, this.xMax = n2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; )
                a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
            }
            return 1, 8, 32, 64, 128, t.prototype.encode = function() {
              var t2, e, r;
              for (e = new ne(ve.call(this.raw.data)), t2 = 0, r = this.glyphIDs.length; t2 < r; ++t2)
                e.pos = this.glyphOffsets[t2];
              return e.data;
            }, t;
          }(), Ne = function(t) {
            function e() {
              return e.__super__.constructor.apply(this, arguments);
            }
            return oe(e, re), e.prototype.tag = "loca", e.prototype.parse = function(t2) {
              var e2, r;
              return t2.pos = this.offset, e2 = this.file.head.indexToLocFormat, this.offsets = e2 === 0 ? function() {
                var e3, n2;
                for (n2 = [], r = 0, e3 = this.length; r < e3; r += 2)
                  n2.push(2 * t2.readUInt16());
                return n2;
              }.call(this) : function() {
                var e3, n2;
                for (n2 = [], r = 0, e3 = this.length; r < e3; r += 4)
                  n2.push(t2.readUInt32());
                return n2;
              }.call(this);
            }, e.prototype.indexOf = function(t2) {
              return this.offsets[t2];
            }, e.prototype.lengthOf = function(t2) {
              return this.offsets[t2 + 1] - this.offsets[t2];
            }, e.prototype.encode = function(t2, e2) {
              for (var r = new Uint32Array(this.offsets.length), n2 = 0, i2 = 0, a2 = 0; a2 < r.length; ++a2)
                if (r[a2] = n2, i2 < e2.length && e2[i2] == a2) {
                  ++i2, r[a2] = n2;
                  var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
                  s2 > 0 && (n2 += s2);
                }
              for (var c2 = new Array(4 * r.length), u2 = 0; u2 < r.length; ++u2)
                c2[4 * u2 + 3] = 255 & r[u2], c2[4 * u2 + 2] = (65280 & r[u2]) >> 8, c2[4 * u2 + 1] = (16711680 & r[u2]) >> 16, c2[4 * u2] = (4278190080 & r[u2]) >> 24;
              return c2;
            }, e;
          }(), Le = function() {
            function t(t2) {
              this.font = t2, this.subset = {}, this.unicodes = {}, this.next = 33;
            }
            return t.prototype.generateCmap = function() {
              var t2, e, r, n2, i2;
              for (e in n2 = this.font.cmap.tables[0].codeMap, t2 = {}, i2 = this.subset)
                r = i2[e], t2[e] = n2[r];
              return t2;
            }, t.prototype.glyphsFor = function(t2) {
              var e, r, n2, i2, a2, o2, s2;
              for (n2 = {}, a2 = 0, o2 = t2.length; a2 < o2; a2++)
                n2[i2 = t2[a2]] = this.font.glyf.glyphFor(i2);
              for (i2 in e = [], n2)
                ((r = n2[i2]) != null ? r.compound : void 0) && e.push.apply(e, r.glyphIDs);
              if (e.length > 0)
                for (i2 in s2 = this.glyphsFor(e))
                  r = s2[i2], n2[i2] = r;
              return n2;
            }, t.prototype.encode = function(t2, e) {
              var r, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2;
              for (n2 in r = ue.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t2), f2 = { 0: 0 }, m2 = r.charMap)
                f2[(s2 = m2[n2]).old] = s2.new;
              for (d2 in l2 = r.maxGlyphID, a2)
                d2 in f2 || (f2[d2] = l2++);
              return u2 = function(t3) {
                var e2, r2;
                for (e2 in r2 = {}, t3)
                  r2[t3[e2]] = e2;
                return r2;
              }(f2), h2 = Object.keys(u2).sort(function(t3, e2) {
                return t3 - e2;
              }), p2 = function() {
                var t3, e2, r2;
                for (r2 = [], t3 = 0, e2 = h2.length; t3 < e2; t3++)
                  o2 = h2[t3], r2.push(u2[o2]);
                return r2;
              }(), i2 = this.font.glyf.encode(a2, p2, f2), c2 = this.font.loca.encode(i2.offsets, p2), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: c2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
            }, t;
          }();
          E.API.PDFObject = function() {
            var t;
            function e() {
            }
            return t = function(t2, e2) {
              return (Array(e2 + 1).join("0") + t2).slice(-e2);
            }, e.convert = function(r) {
              var n2, i2, a2, o2;
              if (Array.isArray(r))
                return "[" + function() {
                  var t2, i3, a3;
                  for (a3 = [], t2 = 0, i3 = r.length; t2 < i3; t2++)
                    n2 = r[t2], a3.push(e.convert(n2));
                  return a3;
                }().join(" ") + "]";
              if (typeof r == "string")
                return "/" + r;
              if (r != null ? r.isString : void 0)
                return "(" + r + ")";
              if (r instanceof Date)
                return "(D:" + t(r.getUTCFullYear(), 4) + t(r.getUTCMonth(), 2) + t(r.getUTCDate(), 2) + t(r.getUTCHours(), 2) + t(r.getUTCMinutes(), 2) + t(r.getUTCSeconds(), 2) + "Z)";
              if ({}.toString.call(r) === "[object Object]") {
                for (i2 in a2 = ["<<"], r)
                  o2 = r[i2], a2.push("/" + i2 + " " + e.convert(o2));
                return a2.push(">>"), a2.join("\n");
              }
              return "" + r;
            }, e;
          }();
          var _unused_webpack_default_export = E;
        }).call(this, __webpack_require__("c8ba"));
      },
      "8bbf": function(module2, exports2) {
        module2.exports = require_vue();
      },
      "90e3": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var id = 0;
        var postfix = Math.random();
        var toString = uncurryThis(1 .toString);
        module2.exports = function(key) {
          return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
        };
      },
      "9112": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var definePropertyModule = __webpack_require__("9bf2");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        module2.exports = DESCRIPTORS ? function(object, key, value) {
          return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
        } : function(object, key, value) {
          object[key] = value;
          return object;
        };
      },
      "9152": function(module2, exports2) {
        exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
      },
      "9263": function(module2, exports2, __webpack_require__) {
        "use strict";
        var call = __webpack_require__("c65b");
        var uncurryThis = __webpack_require__("e330");
        var toString = __webpack_require__("577e");
        var regexpFlags = __webpack_require__("ad6d");
        var stickyHelpers = __webpack_require__("9f7f");
        var shared = __webpack_require__("5692");
        var create = __webpack_require__("7c73");
        var getInternalState = __webpack_require__("69f3").get;
        var UNSUPPORTED_DOT_ALL = __webpack_require__("fce3");
        var UNSUPPORTED_NCG = __webpack_require__("107c");
        var nativeReplace = shared("native-string-replace", String.prototype.replace);
        var nativeExec = RegExp.prototype.exec;
        var patchedExec = nativeExec;
        var charAt = uncurryThis("".charAt);
        var indexOf = uncurryThis("".indexOf);
        var replace = uncurryThis("".replace);
        var stringSlice = uncurryThis("".slice);
        var UPDATES_LAST_INDEX_WRONG = function() {
          var re1 = /a/;
          var re2 = /b*/g;
          call(nativeExec, re1, "a");
          call(nativeExec, re2, "a");
          return re1.lastIndex !== 0 || re2.lastIndex !== 0;
        }();
        var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
        var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
        if (PATCH) {
          patchedExec = function exec(string) {
            var re = this;
            var state = getInternalState(re);
            var str = toString(string);
            var raw = state.raw;
            var result, reCopy, lastIndex, match, i, object, group;
            if (raw) {
              raw.lastIndex = re.lastIndex;
              result = call(patchedExec, raw, str);
              re.lastIndex = raw.lastIndex;
              return result;
            }
            var groups = state.groups;
            var sticky = UNSUPPORTED_Y && re.sticky;
            var flags = call(regexpFlags, re);
            var source = re.source;
            var charsAdded = 0;
            var strCopy = str;
            if (sticky) {
              flags = replace(flags, "y", "");
              if (indexOf(flags, "g") === -1) {
                flags += "g";
              }
              strCopy = stringSlice(str, re.lastIndex);
              if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
                source = "(?: " + source + ")";
                strCopy = " " + strCopy;
                charsAdded++;
              }
              reCopy = new RegExp("^(?:" + source + ")", flags);
            }
            if (NPCG_INCLUDED) {
              reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
            }
            if (UPDATES_LAST_INDEX_WRONG)
              lastIndex = re.lastIndex;
            match = call(nativeExec, sticky ? reCopy : re, strCopy);
            if (sticky) {
              if (match) {
                match.input = stringSlice(match.input, charsAdded);
                match[0] = stringSlice(match[0], charsAdded);
                match.index = re.lastIndex;
                re.lastIndex += match[0].length;
              } else
                re.lastIndex = 0;
            } else if (UPDATES_LAST_INDEX_WRONG && match) {
              re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
            }
            if (NPCG_INCLUDED && match && match.length > 1) {
              call(nativeReplace, match[0], reCopy, function() {
                for (i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === void 0)
                    match[i] = void 0;
                }
              });
            }
            if (match && groups) {
              match.groups = object = create(null);
              for (i = 0; i < groups.length; i++) {
                group = groups[i];
                object[group[0]] = match[group[1]];
              }
            }
            return match;
          };
        }
        module2.exports = patchedExec;
      },
      "94ca": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var isCallable = __webpack_require__("1626");
        var replacement = /#|\.prototype\./;
        var isForced = function(feature, detection) {
          var value = data[normalize(feature)];
          return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
        };
        var normalize = isForced.normalize = function(string) {
          return String(string).replace(replacement, ".").toLowerCase();
        };
        var data = isForced.data = {};
        var NATIVE = isForced.NATIVE = "N";
        var POLYFILL = isForced.POLYFILL = "P";
        module2.exports = isForced;
      },
      "99af": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var global = __webpack_require__("da84");
        var fails = __webpack_require__("d039");
        var isArray2 = __webpack_require__("e8b5");
        var isObject2 = __webpack_require__("861d");
        var toObject = __webpack_require__("7b0b");
        var lengthOfArrayLike = __webpack_require__("07fa");
        var createProperty = __webpack_require__("8418");
        var arraySpeciesCreate = __webpack_require__("65f0");
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var wellKnownSymbol = __webpack_require__("b622");
        var V8_VERSION = __webpack_require__("2d00");
        var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
        var MAX_SAFE_INTEGER = 9007199254740991;
        var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
        var TypeError2 = global.TypeError;
        var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
          var array = [];
          array[IS_CONCAT_SPREADABLE] = false;
          return array.concat()[0] !== array;
        });
        var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
        var isConcatSpreadable = function(O) {
          if (!isObject2(O))
            return false;
          var spreadable = O[IS_CONCAT_SPREADABLE];
          return spreadable !== void 0 ? !!spreadable : isArray2(O);
        };
        var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
        $({ target: "Array", proto: true, forced: FORCED }, {
          concat: function concat(arg) {
            var O = toObject(this);
            var A = arraySpeciesCreate(O, 0);
            var n = 0;
            var i, k, length, len, E;
            for (i = -1, length = arguments.length; i < length; i++) {
              E = i === -1 ? O : arguments[i];
              if (isConcatSpreadable(E)) {
                len = lengthOfArrayLike(E);
                if (n + len > MAX_SAFE_INTEGER)
                  throw TypeError2(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                for (k = 0; k < len; k++, n++)
                  if (k in E)
                    createProperty(A, n, E[k]);
              } else {
                if (n >= MAX_SAFE_INTEGER)
                  throw TypeError2(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                createProperty(A, n++, E);
              }
            }
            A.length = n;
            return A;
          }
        });
      },
      "9a1f": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var call = __webpack_require__("c65b");
        var aCallable = __webpack_require__("59ed");
        var anObject = __webpack_require__("825a");
        var tryToString = __webpack_require__("0d51");
        var getIteratorMethod = __webpack_require__("35a1");
        var TypeError2 = global.TypeError;
        module2.exports = function(argument, usingIterator) {
          var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
          if (aCallable(iteratorMethod))
            return anObject(call(iteratorMethod, argument));
          throw TypeError2(tryToString(argument) + " is not iterable");
        };
      },
      "9bdd": function(module2, exports2, __webpack_require__) {
        var anObject = __webpack_require__("825a");
        var iteratorClose = __webpack_require__("2a62");
        module2.exports = function(iterator, fn, value, ENTRIES) {
          try {
            return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
          } catch (error) {
            iteratorClose(iterator, "throw", error);
          }
        };
      },
      "9bf2": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var DESCRIPTORS = __webpack_require__("83ab");
        var IE8_DOM_DEFINE = __webpack_require__("0cfb");
        var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__("aed9");
        var anObject = __webpack_require__("825a");
        var toPropertyKey = __webpack_require__("a04b");
        var TypeError2 = global.TypeError;
        var $defineProperty = Object.defineProperty;
        var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var ENUMERABLE = "enumerable";
        var CONFIGURABLE = "configurable";
        var WRITABLE = "writable";
        exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPropertyKey(P);
          anObject(Attributes);
          if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
            var current = $getOwnPropertyDescriptor(O, P);
            if (current && current[WRITABLE]) {
              O[P] = Attributes.value;
              Attributes = {
                configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                writable: false
              };
            }
          }
          return $defineProperty(O, P, Attributes);
        } : $defineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPropertyKey(P);
          anObject(Attributes);
          if (IE8_DOM_DEFINE)
            try {
              return $defineProperty(O, P, Attributes);
            } catch (error) {
            }
          if ("get" in Attributes || "set" in Attributes)
            throw TypeError2("Accessors not supported");
          if ("value" in Attributes)
            O[P] = Attributes.value;
          return O;
        };
      },
      "9ed3": function(module2, exports2, __webpack_require__) {
        "use strict";
        var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
        var create = __webpack_require__("7c73");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        var setToStringTag = __webpack_require__("d44e");
        var Iterators = __webpack_require__("3f8c");
        var returnThis = function() {
          return this;
        };
        module2.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
          var TO_STRING_TAG = NAME + " Iterator";
          IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
          setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
          Iterators[TO_STRING_TAG] = returnThis;
          return IteratorConstructor;
        };
      },
      "9f5e": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", function() {
          return binarySearch;
        });
        __webpack_require__.d(__webpack_exports__, "i", function() {
          return numberSafeCompareFunction;
        });
        __webpack_require__.d(__webpack_exports__, "f", function() {
          return includes;
        });
        __webpack_require__.d(__webpack_exports__, "h", function() {
          return linearFindNearest;
        });
        __webpack_require__.d(__webpack_exports__, "j", function() {
          return reverseSubArray;
        });
        __webpack_require__.d(__webpack_exports__, "c", function() {
          return extend2;
        });
        __webpack_require__.d(__webpack_exports__, "d", function() {
          return find;
        });
        __webpack_require__.d(__webpack_exports__, "b", function() {
          return equals;
        });
        __webpack_require__.d(__webpack_exports__, "e", function() {
          return findIndex;
        });
        __webpack_require__.d(__webpack_exports__, "g", function() {
          return isSorted;
        });
        function binarySearch(haystack, needle, opt_comparator) {
          var mid, cmp;
          var comparator = opt_comparator || numberSafeCompareFunction;
          var low = 0;
          var high = haystack.length;
          var found = false;
          while (low < high) {
            mid = low + (high - low >> 1);
            cmp = +comparator(haystack[mid], needle);
            if (cmp < 0) {
              low = mid + 1;
            } else {
              high = mid;
              found = !cmp;
            }
          }
          return found ? low : ~low;
        }
        function numberSafeCompareFunction(a, b) {
          return a > b ? 1 : a < b ? -1 : 0;
        }
        function includes(arr, obj) {
          return arr.indexOf(obj) >= 0;
        }
        function linearFindNearest(arr, target, direction) {
          var n = arr.length;
          if (arr[0] <= target) {
            return 0;
          } else if (target <= arr[n - 1]) {
            return n - 1;
          } else {
            var i = void 0;
            if (direction > 0) {
              for (i = 1; i < n; ++i) {
                if (arr[i] < target) {
                  return i - 1;
                }
              }
            } else if (direction < 0) {
              for (i = 1; i < n; ++i) {
                if (arr[i] <= target) {
                  return i;
                }
              }
            } else {
              for (i = 1; i < n; ++i) {
                if (arr[i] == target) {
                  return i;
                } else if (arr[i] < target) {
                  if (typeof direction === "function") {
                    if (direction(target, arr[i - 1], arr[i]) > 0) {
                      return i - 1;
                    } else {
                      return i;
                    }
                  } else if (arr[i - 1] - target < target - arr[i]) {
                    return i - 1;
                  } else {
                    return i;
                  }
                }
              }
            }
            return n - 1;
          }
        }
        function reverseSubArray(arr, begin, end) {
          while (begin < end) {
            var tmp = arr[begin];
            arr[begin] = arr[end];
            arr[end] = tmp;
            ++begin;
            --end;
          }
        }
        function extend2(arr, data) {
          var extension = Array.isArray(data) ? data : [data];
          var length = extension.length;
          for (var i = 0; i < length; i++) {
            arr[arr.length] = extension[i];
          }
        }
        function remove(arr, obj) {
          var i = arr.indexOf(obj);
          var found = i > -1;
          if (found) {
            arr.splice(i, 1);
          }
          return found;
        }
        function find(arr, func) {
          var length = arr.length >>> 0;
          var value;
          for (var i = 0; i < length; i++) {
            value = arr[i];
            if (func(value, i, arr)) {
              return value;
            }
          }
          return null;
        }
        function equals(arr1, arr2) {
          var len1 = arr1.length;
          if (len1 !== arr2.length) {
            return false;
          }
          for (var i = 0; i < len1; i++) {
            if (arr1[i] !== arr2[i]) {
              return false;
            }
          }
          return true;
        }
        function stableSort(arr, compareFnc) {
          var length = arr.length;
          var tmp = Array(arr.length);
          var i;
          for (i = 0; i < length; i++) {
            tmp[i] = { index: i, value: arr[i] };
          }
          tmp.sort(function(a, b) {
            return compareFnc(a.value, b.value) || a.index - b.index;
          });
          for (i = 0; i < arr.length; i++) {
            arr[i] = tmp[i].value;
          }
        }
        function findIndex(arr, func) {
          var index;
          var found = !arr.every(function(el, idx) {
            index = idx;
            return !func(el, idx, arr);
          });
          return found ? index : -1;
        }
        function isSorted(arr, opt_func, opt_strict) {
          var compare = opt_func || numberSafeCompareFunction;
          return arr.every(function(currentVal, index) {
            if (index === 0) {
              return true;
            }
            var res = compare(arr[index - 1], currentVal);
            return !(res > 0 || opt_strict && res === 0);
          });
        }
      },
      "9f7f": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var global = __webpack_require__("da84");
        var $RegExp = global.RegExp;
        var UNSUPPORTED_Y = fails(function() {
          var re = $RegExp("a", "y");
          re.lastIndex = 2;
          return re.exec("abcd") != null;
        });
        var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
          return !$RegExp("a", "y").sticky;
        });
        var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
          var re = $RegExp("^r", "gy");
          re.lastIndex = 2;
          return re.exec("str") != null;
        });
        module2.exports = {
          BROKEN_CARET,
          MISSED_STICKY,
          UNSUPPORTED_Y
        };
      },
      "a04b": function(module2, exports2, __webpack_require__) {
        var toPrimitive = __webpack_require__("c04e");
        var isSymbol2 = __webpack_require__("d9b5");
        module2.exports = function(argument) {
          var key = toPrimitive(argument, "string");
          return isSymbol2(key) ? key : key + "";
        };
      },
      "a434": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var global = __webpack_require__("da84");
        var toAbsoluteIndex = __webpack_require__("23cb");
        var toIntegerOrInfinity = __webpack_require__("5926");
        var lengthOfArrayLike = __webpack_require__("07fa");
        var toObject = __webpack_require__("7b0b");
        var arraySpeciesCreate = __webpack_require__("65f0");
        var createProperty = __webpack_require__("8418");
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
        var TypeError2 = global.TypeError;
        var max = Math.max;
        var min = Math.min;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
          splice: function splice(start, deleteCount) {
            var O = toObject(this);
            var len = lengthOfArrayLike(O);
            var actualStart = toAbsoluteIndex(start, len);
            var argumentsLength = arguments.length;
            var insertCount, actualDeleteCount, A, k, from, to;
            if (argumentsLength === 0) {
              insertCount = actualDeleteCount = 0;
            } else if (argumentsLength === 1) {
              insertCount = 0;
              actualDeleteCount = len - actualStart;
            } else {
              insertCount = argumentsLength - 2;
              actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
            }
            if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
              throw TypeError2(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
            }
            A = arraySpeciesCreate(O, actualDeleteCount);
            for (k = 0; k < actualDeleteCount; k++) {
              from = actualStart + k;
              if (from in O)
                createProperty(A, k, O[from]);
            }
            A.length = actualDeleteCount;
            if (insertCount < actualDeleteCount) {
              for (k = actualStart; k < len - actualDeleteCount; k++) {
                from = k + actualDeleteCount;
                to = k + insertCount;
                if (from in O)
                  O[to] = O[from];
                else
                  delete O[to];
              }
              for (k = len; k > len - actualDeleteCount + insertCount; k--)
                delete O[k - 1];
            } else if (insertCount > actualDeleteCount) {
              for (k = len - actualDeleteCount; k > actualStart; k--) {
                from = k + actualDeleteCount - 1;
                to = k + insertCount - 1;
                if (from in O)
                  O[to] = O[from];
                else
                  delete O[to];
              }
            }
            for (k = 0; k < insertCount; k++) {
              O[k + actualStart] = arguments[k + 2];
            }
            O.length = len - actualDeleteCount + insertCount;
            return A;
          }
        });
      },
      "a4d3": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var global = __webpack_require__("da84");
        var getBuiltIn = __webpack_require__("d066");
        var apply = __webpack_require__("2ba4");
        var call = __webpack_require__("c65b");
        var uncurryThis = __webpack_require__("e330");
        var IS_PURE = __webpack_require__("c430");
        var DESCRIPTORS = __webpack_require__("83ab");
        var NATIVE_SYMBOL = __webpack_require__("4930");
        var fails = __webpack_require__("d039");
        var hasOwn = __webpack_require__("1a2d");
        var isArray2 = __webpack_require__("e8b5");
        var isCallable = __webpack_require__("1626");
        var isObject2 = __webpack_require__("861d");
        var isPrototypeOf = __webpack_require__("3a9b");
        var isSymbol2 = __webpack_require__("d9b5");
        var anObject = __webpack_require__("825a");
        var toObject = __webpack_require__("7b0b");
        var toIndexedObject = __webpack_require__("fc6a");
        var toPropertyKey = __webpack_require__("a04b");
        var $toString = __webpack_require__("577e");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        var nativeObjectCreate = __webpack_require__("7c73");
        var objectKeys = __webpack_require__("df75");
        var getOwnPropertyNamesModule = __webpack_require__("241c");
        var getOwnPropertyNamesExternal = __webpack_require__("057f");
        var getOwnPropertySymbolsModule = __webpack_require__("7418");
        var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
        var definePropertyModule = __webpack_require__("9bf2");
        var definePropertiesModule = __webpack_require__("37e8");
        var propertyIsEnumerableModule = __webpack_require__("d1e7");
        var arraySlice = __webpack_require__("f36a");
        var redefine = __webpack_require__("6eeb");
        var shared = __webpack_require__("5692");
        var sharedKey = __webpack_require__("f772");
        var hiddenKeys = __webpack_require__("d012");
        var uid = __webpack_require__("90e3");
        var wellKnownSymbol = __webpack_require__("b622");
        var wrappedWellKnownSymbolModule = __webpack_require__("e538");
        var defineWellKnownSymbol = __webpack_require__("746f");
        var setToStringTag = __webpack_require__("d44e");
        var InternalStateModule = __webpack_require__("69f3");
        var $forEach = __webpack_require__("b727").forEach;
        var HIDDEN = sharedKey("hidden");
        var SYMBOL = "Symbol";
        var PROTOTYPE = "prototype";
        var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(SYMBOL);
        var ObjectPrototype = Object[PROTOTYPE];
        var $Symbol = global.Symbol;
        var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
        var TypeError2 = global.TypeError;
        var QObject = global.QObject;
        var $stringify = getBuiltIn("JSON", "stringify");
        var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var nativeDefineProperty = definePropertyModule.f;
        var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
        var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
        var push = uncurryThis([].push);
        var AllSymbols = shared("symbols");
        var ObjectPrototypeSymbols = shared("op-symbols");
        var StringToSymbolRegistry = shared("string-to-symbol-registry");
        var SymbolToStringRegistry = shared("symbol-to-string-registry");
        var WellKnownSymbolsStore = shared("wks");
        var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
        var setSymbolDescriptor = DESCRIPTORS && fails(function() {
          return nativeObjectCreate(nativeDefineProperty({}, "a", {
            get: function() {
              return nativeDefineProperty(this, "a", { value: 7 }).a;
            }
          })).a != 7;
        }) ? function(O, P, Attributes) {
          var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
          if (ObjectPrototypeDescriptor)
            delete ObjectPrototype[P];
          nativeDefineProperty(O, P, Attributes);
          if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
            nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
          }
        } : nativeDefineProperty;
        var wrap = function(tag, description) {
          var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
          setInternalState(symbol, {
            type: SYMBOL,
            tag,
            description
          });
          if (!DESCRIPTORS)
            symbol.description = description;
          return symbol;
        };
        var $defineProperty = function defineProperty(O, P, Attributes) {
          if (O === ObjectPrototype)
            $defineProperty(ObjectPrototypeSymbols, P, Attributes);
          anObject(O);
          var key = toPropertyKey(P);
          anObject(Attributes);
          if (hasOwn(AllSymbols, key)) {
            if (!Attributes.enumerable) {
              if (!hasOwn(O, HIDDEN))
                nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
              O[HIDDEN][key] = true;
            } else {
              if (hasOwn(O, HIDDEN) && O[HIDDEN][key])
                O[HIDDEN][key] = false;
              Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
            }
            return setSymbolDescriptor(O, key, Attributes);
          }
          return nativeDefineProperty(O, key, Attributes);
        };
        var $defineProperties = function defineProperties(O, Properties) {
          anObject(O);
          var properties = toIndexedObject(Properties);
          var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
          $forEach(keys, function(key) {
            if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key))
              $defineProperty(O, key, properties[key]);
          });
          return O;
        };
        var $create = function create(O, Properties) {
          return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
        };
        var $propertyIsEnumerable = function propertyIsEnumerable(V) {
          var P = toPropertyKey(V);
          var enumerable = call(nativePropertyIsEnumerable, this, P);
          if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P))
            return false;
          return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
        };
        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
          var it = toIndexedObject(O);
          var key = toPropertyKey(P);
          if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key))
            return;
          var descriptor = nativeGetOwnPropertyDescriptor(it, key);
          if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
            descriptor.enumerable = true;
          }
          return descriptor;
        };
        var $getOwnPropertyNames = function getOwnPropertyNames(O) {
          var names = nativeGetOwnPropertyNames(toIndexedObject(O));
          var result = [];
          $forEach(names, function(key) {
            if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key))
              push(result, key);
          });
          return result;
        };
        var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
          var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
          var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
          var result = [];
          $forEach(names, function(key) {
            if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
              push(result, AllSymbols[key]);
            }
          });
          return result;
        };
        if (!NATIVE_SYMBOL) {
          $Symbol = function Symbol2() {
            if (isPrototypeOf(SymbolPrototype, this))
              throw TypeError2("Symbol is not a constructor");
            var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
            var tag = uid(description);
            var setter = function(value) {
              if (this === ObjectPrototype)
                call(setter, ObjectPrototypeSymbols, value);
              if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag))
                this[HIDDEN][tag] = false;
              setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
            };
            if (DESCRIPTORS && USE_SETTER)
              setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
            return wrap(tag, description);
          };
          SymbolPrototype = $Symbol[PROTOTYPE];
          redefine(SymbolPrototype, "toString", function toString() {
            return getInternalState(this).tag;
          });
          redefine($Symbol, "withoutSetter", function(description) {
            return wrap(uid(description), description);
          });
          propertyIsEnumerableModule.f = $propertyIsEnumerable;
          definePropertyModule.f = $defineProperty;
          definePropertiesModule.f = $defineProperties;
          getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
          getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
          getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
          wrappedWellKnownSymbolModule.f = function(name) {
            return wrap(wellKnownSymbol(name), name);
          };
          if (DESCRIPTORS) {
            nativeDefineProperty(SymbolPrototype, "description", {
              configurable: true,
              get: function description() {
                return getInternalState(this).description;
              }
            });
            if (!IS_PURE) {
              redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
            }
          }
        }
        $({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
          Symbol: $Symbol
        });
        $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
          defineWellKnownSymbol(name);
        });
        $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
          "for": function(key) {
            var string = $toString(key);
            if (hasOwn(StringToSymbolRegistry, string))
              return StringToSymbolRegistry[string];
            var symbol = $Symbol(string);
            StringToSymbolRegistry[string] = symbol;
            SymbolToStringRegistry[symbol] = string;
            return symbol;
          },
          keyFor: function keyFor(sym) {
            if (!isSymbol2(sym))
              throw TypeError2(sym + " is not a symbol");
            if (hasOwn(SymbolToStringRegistry, sym))
              return SymbolToStringRegistry[sym];
          },
          useSetter: function() {
            USE_SETTER = true;
          },
          useSimple: function() {
            USE_SETTER = false;
          }
        });
        $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
          create: $create,
          defineProperty: $defineProperty,
          defineProperties: $defineProperties,
          getOwnPropertyDescriptor: $getOwnPropertyDescriptor
        });
        $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
          getOwnPropertyNames: $getOwnPropertyNames,
          getOwnPropertySymbols: $getOwnPropertySymbols
        });
        $({ target: "Object", stat: true, forced: fails(function() {
          getOwnPropertySymbolsModule.f(1);
        }) }, {
          getOwnPropertySymbols: function getOwnPropertySymbols(it) {
            return getOwnPropertySymbolsModule.f(toObject(it));
          }
        });
        if ($stringify) {
          var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
            var symbol = $Symbol();
            return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
          });
          $({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
            stringify: function stringify(it, replacer, space) {
              var args = arraySlice(arguments);
              var $replacer = replacer;
              if (!isObject2(replacer) && it === void 0 || isSymbol2(it))
                return;
              if (!isArray2(replacer))
                replacer = function(key, value) {
                  if (isCallable($replacer))
                    value = call($replacer, this, key, value);
                  if (!isSymbol2(value))
                    return value;
                };
              args[1] = replacer;
              return apply($stringify, null, args);
            }
          });
        }
        if (!SymbolPrototype[TO_PRIMITIVE]) {
          var valueOf = SymbolPrototype.valueOf;
          redefine(SymbolPrototype, TO_PRIMITIVE, function(hint) {
            return call(valueOf, this);
          });
        }
        setToStringTag($Symbol, SYMBOL);
        hiddenKeys[HIDDEN] = true;
      },
      "a630": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var from = __webpack_require__("4df4");
        var checkCorrectnessOfIteration = __webpack_require__("1c7e");
        var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
          Array.from(iterable);
        });
        $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
          from
        });
      },
      "a640": function(module2, exports2, __webpack_require__) {
        "use strict";
        var fails = __webpack_require__("d039");
        module2.exports = function(METHOD_NAME, argument) {
          var method = [][METHOD_NAME];
          return !!method && fails(function() {
            method.call(null, argument || function() {
              throw 1;
            }, 1);
          });
        };
      },
      "a9e3": function(module2, exports2, __webpack_require__) {
        "use strict";
        var DESCRIPTORS = __webpack_require__("83ab");
        var global = __webpack_require__("da84");
        var uncurryThis = __webpack_require__("e330");
        var isForced = __webpack_require__("94ca");
        var redefine = __webpack_require__("6eeb");
        var hasOwn = __webpack_require__("1a2d");
        var inheritIfRequired = __webpack_require__("7156");
        var isPrototypeOf = __webpack_require__("3a9b");
        var isSymbol2 = __webpack_require__("d9b5");
        var toPrimitive = __webpack_require__("c04e");
        var fails = __webpack_require__("d039");
        var getOwnPropertyNames = __webpack_require__("241c").f;
        var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
        var defineProperty = __webpack_require__("9bf2").f;
        var thisNumberValue = __webpack_require__("408a");
        var trim = __webpack_require__("58a8").trim;
        var NUMBER = "Number";
        var NativeNumber = global[NUMBER];
        var NumberPrototype = NativeNumber.prototype;
        var TypeError2 = global.TypeError;
        var arraySlice = uncurryThis("".slice);
        var charCodeAt = uncurryThis("".charCodeAt);
        var toNumeric = function(value) {
          var primValue = toPrimitive(value, "number");
          return typeof primValue == "bigint" ? primValue : toNumber(primValue);
        };
        var toNumber = function(argument) {
          var it = toPrimitive(argument, "number");
          var first, third, radix, maxCode, digits, length, index, code;
          if (isSymbol2(it))
            throw TypeError2("Cannot convert a Symbol value to a number");
          if (typeof it == "string" && it.length > 2) {
            it = trim(it);
            first = charCodeAt(it, 0);
            if (first === 43 || first === 45) {
              third = charCodeAt(it, 2);
              if (third === 88 || third === 120)
                return NaN;
            } else if (first === 48) {
              switch (charCodeAt(it, 1)) {
                case 66:
                case 98:
                  radix = 2;
                  maxCode = 49;
                  break;
                case 79:
                case 111:
                  radix = 8;
                  maxCode = 55;
                  break;
                default:
                  return +it;
              }
              digits = arraySlice(it, 2);
              length = digits.length;
              for (index = 0; index < length; index++) {
                code = charCodeAt(digits, index);
                if (code < 48 || code > maxCode)
                  return NaN;
              }
              return parseInt(digits, radix);
            }
          }
          return +it;
        };
        if (isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
          var NumberWrapper = function Number2(value) {
            var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
            var dummy = this;
            return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
              thisNumberValue(dummy);
            }) ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
          };
          for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), j = 0, key; keys.length > j; j++) {
            if (hasOwn(NativeNumber, key = keys[j]) && !hasOwn(NumberWrapper, key)) {
              defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
            }
          }
          NumberWrapper.prototype = NumberPrototype;
          NumberPrototype.constructor = NumberWrapper;
          redefine(global, NUMBER, NumberWrapper);
        }
      },
      "ab13": function(module2, exports2, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var MATCH = wellKnownSymbol("match");
        module2.exports = function(METHOD_NAME) {
          var regexp = /./;
          try {
            "/./"[METHOD_NAME](regexp);
          } catch (error1) {
            try {
              regexp[MATCH] = false;
              return "/./"[METHOD_NAME](regexp);
            } catch (error2) {
            }
          }
          return false;
        };
      },
      "ab36": function(module2, exports2, __webpack_require__) {
        var isObject2 = __webpack_require__("861d");
        var createNonEnumerableProperty = __webpack_require__("9112");
        module2.exports = function(O, options) {
          if (isObject2(options) && "cause" in options) {
            createNonEnumerableProperty(O, "cause", options.cause);
          }
        };
      },
      "ac1f": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var exec = __webpack_require__("9263");
        $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
          exec
        });
      },
      "ad6d": function(module2, exports2, __webpack_require__) {
        "use strict";
        var anObject = __webpack_require__("825a");
        module2.exports = function() {
          var that = anObject(this);
          var result = "";
          if (that.global)
            result += "g";
          if (that.ignoreCase)
            result += "i";
          if (that.multiline)
            result += "m";
          if (that.dotAll)
            result += "s";
          if (that.unicode)
            result += "u";
          if (that.sticky)
            result += "y";
          return result;
        };
      },
      "addb": function(module2, exports2, __webpack_require__) {
        var arraySlice = __webpack_require__("4dae");
        var floor = Math.floor;
        var mergeSort = function(array, comparefn) {
          var length = array.length;
          var middle = floor(length / 2);
          return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
        };
        var insertionSort = function(array, comparefn) {
          var length = array.length;
          var i = 1;
          var element, j;
          while (i < length) {
            j = i;
            element = array[i];
            while (j && comparefn(array[j - 1], element) > 0) {
              array[j] = array[--j];
            }
            if (j !== i++)
              array[j] = element;
          }
          return array;
        };
        var merge = function(array, left, right, comparefn) {
          var llength = left.length;
          var rlength = right.length;
          var lindex = 0;
          var rindex = 0;
          while (lindex < llength || rindex < rlength) {
            array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
          }
          return array;
        };
        module2.exports = mergeSort;
      },
      "ae93": function(module2, exports2, __webpack_require__) {
        "use strict";
        var fails = __webpack_require__("d039");
        var isCallable = __webpack_require__("1626");
        var create = __webpack_require__("7c73");
        var getPrototypeOf = __webpack_require__("e163");
        var redefine = __webpack_require__("6eeb");
        var wellKnownSymbol = __webpack_require__("b622");
        var IS_PURE = __webpack_require__("c430");
        var ITERATOR = wellKnownSymbol("iterator");
        var BUGGY_SAFARI_ITERATORS = false;
        var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
        if ([].keys) {
          arrayIterator = [].keys();
          if (!("next" in arrayIterator))
            BUGGY_SAFARI_ITERATORS = true;
          else {
            PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
            if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
              IteratorPrototype = PrototypeOfArrayIteratorPrototype;
          }
        }
        var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
          var test = {};
          return IteratorPrototype[ITERATOR].call(test) !== test;
        });
        if (NEW_ITERATOR_PROTOTYPE)
          IteratorPrototype = {};
        else if (IS_PURE)
          IteratorPrototype = create(IteratorPrototype);
        if (!isCallable(IteratorPrototype[ITERATOR])) {
          redefine(IteratorPrototype, ITERATOR, function() {
            return this;
          });
        }
        module2.exports = {
          IteratorPrototype,
          BUGGY_SAFARI_ITERATORS
        };
      },
      "aed9": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var fails = __webpack_require__("d039");
        module2.exports = DESCRIPTORS && fails(function() {
          return Object.defineProperty(function() {
          }, "prototype", {
            value: 42,
            writable: false
          }).prototype != 42;
        });
      },
      "b041": function(module2, exports2, __webpack_require__) {
        "use strict";
        var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
        var classof = __webpack_require__("f5df");
        module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
          return "[object " + classof(this) + "]";
        };
      },
      "b0c0": function(module2, exports2, __webpack_require__) {
        var DESCRIPTORS = __webpack_require__("83ab");
        var FUNCTION_NAME_EXISTS = __webpack_require__("5e77").EXISTS;
        var uncurryThis = __webpack_require__("e330");
        var defineProperty = __webpack_require__("9bf2").f;
        var FunctionPrototype = Function.prototype;
        var functionToString = uncurryThis(FunctionPrototype.toString);
        var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
        var regExpExec = uncurryThis(nameRE.exec);
        var NAME = "name";
        if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
          defineProperty(FunctionPrototype, NAME, {
            configurable: true,
            get: function() {
              try {
                return regExpExec(nameRE, functionToString(this))[1];
              } catch (error) {
                return "";
              }
            }
          });
        }
      },
      "b622": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var shared = __webpack_require__("5692");
        var hasOwn = __webpack_require__("1a2d");
        var uid = __webpack_require__("90e3");
        var NATIVE_SYMBOL = __webpack_require__("4930");
        var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
        var WellKnownSymbolsStore = shared("wks");
        var Symbol2 = global.Symbol;
        var symbolFor = Symbol2 && Symbol2["for"];
        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
        module2.exports = function(name) {
          if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
            var description = "Symbol." + name;
            if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
              WellKnownSymbolsStore[name] = Symbol2[name];
            } else if (USE_SYMBOL_AS_UID && symbolFor) {
              WellKnownSymbolsStore[name] = symbolFor(description);
            } else {
              WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
            }
          }
          return WellKnownSymbolsStore[name];
        };
      },
      "b639": function(module2, exports2, __webpack_require__) {
        "use strict";
        (function(global) {
          var base64 = __webpack_require__("1fb5");
          var ieee754 = __webpack_require__("9152");
          var isArray2 = __webpack_require__("e3db");
          exports2.Buffer = Buffer;
          exports2.SlowBuffer = SlowBuffer;
          exports2.INSPECT_MAX_BYTES = 50;
          Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
          exports2.kMaxLength = kMaxLength();
          function typedArraySupport() {
            try {
              var arr = new Uint8Array(1);
              arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } };
              return arr.foo() === 42 && typeof arr.subarray === "function" && arr.subarray(1, 1).byteLength === 0;
            } catch (e) {
              return false;
            }
          }
          function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          function createBuffer(that, length) {
            if (kMaxLength() < length) {
              throw new RangeError("Invalid typed array length");
            }
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              that = new Uint8Array(length);
              that.__proto__ = Buffer.prototype;
            } else {
              if (that === null) {
                that = new Buffer(length);
              }
              that.length = length;
            }
            return that;
          }
          function Buffer(arg, encodingOrOffset, length) {
            if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
              return new Buffer(arg, encodingOrOffset, length);
            }
            if (typeof arg === "number") {
              if (typeof encodingOrOffset === "string") {
                throw new Error("If encoding is specified then the first argument must be a string");
              }
              return allocUnsafe(this, arg);
            }
            return from(this, arg, encodingOrOffset, length);
          }
          Buffer.poolSize = 8192;
          Buffer._augment = function(arr) {
            arr.__proto__ = Buffer.prototype;
            return arr;
          };
          function from(that, value, encodingOrOffset, length) {
            if (typeof value === "number") {
              throw new TypeError('"value" argument must not be a number');
            }
            if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
              return fromArrayBuffer(that, value, encodingOrOffset, length);
            }
            if (typeof value === "string") {
              return fromString(that, value, encodingOrOffset);
            }
            return fromObject(that, value);
          }
          Buffer.from = function(value, encodingOrOffset, length) {
            return from(null, value, encodingOrOffset, length);
          };
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;
            if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
              Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: true
              });
            }
          }
          function assertSize(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be a number');
            } else if (size < 0) {
              throw new RangeError('"size" argument must not be negative');
            }
          }
          function alloc(that, size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(that, size);
            }
            if (fill !== void 0) {
              return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
            }
            return createBuffer(that, size);
          }
          Buffer.alloc = function(size, fill, encoding) {
            return alloc(null, size, fill, encoding);
          };
          function allocUnsafe(that, size) {
            assertSize(size);
            that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              for (var i = 0; i < size; ++i) {
                that[i] = 0;
              }
            }
            return that;
          }
          Buffer.allocUnsafe = function(size) {
            return allocUnsafe(null, size);
          };
          Buffer.allocUnsafeSlow = function(size) {
            return allocUnsafe(null, size);
          };
          function fromString(that, string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8";
            }
            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding');
            }
            var length = byteLength(string, encoding) | 0;
            that = createBuffer(that, length);
            var actual = that.write(string, encoding);
            if (actual !== length) {
              that = that.slice(0, actual);
            }
            return that;
          }
          function fromArrayLike(that, array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            that = createBuffer(that, length);
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255;
            }
            return that;
          }
          function fromArrayBuffer(that, array, byteOffset, length) {
            array.byteLength;
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError("'offset' is out of bounds");
            }
            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError("'length' is out of bounds");
            }
            if (byteOffset === void 0 && length === void 0) {
              array = new Uint8Array(array);
            } else if (length === void 0) {
              array = new Uint8Array(array, byteOffset);
            } else {
              array = new Uint8Array(array, byteOffset, length);
            }
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              that = array;
              that.__proto__ = Buffer.prototype;
            } else {
              that = fromArrayLike(that, array);
            }
            return that;
          }
          function fromObject(that, obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              that = createBuffer(that, len);
              if (that.length === 0) {
                return that;
              }
              obj.copy(that, 0, 0, len);
              return that;
            }
            if (obj) {
              if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
                if (typeof obj.length !== "number" || isnan(obj.length)) {
                  return createBuffer(that, 0);
                }
                return fromArrayLike(that, obj);
              }
              if (obj.type === "Buffer" && isArray2(obj.data)) {
                return fromArrayLike(that, obj.data);
              }
            }
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
          }
          function checked(length) {
            if (length >= kMaxLength()) {
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
            }
            return length | 0;
          }
          function SlowBuffer(length) {
            if (+length != length) {
              length = 0;
            }
            return Buffer.alloc(+length);
          }
          Buffer.isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
          };
          Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError("Arguments must be Buffers");
            }
            if (a === b)
              return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          };
          Buffer.concat = function concat(list, length) {
            if (!isArray2(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list.length === 0) {
              return Buffer.alloc(0);
            }
            var i;
            if (length === void 0) {
              length = 0;
              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }
            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
              var buf = list[i];
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };
          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }
            if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== "string") {
              string = "" + string;
            }
            var len = string.length;
            if (len === 0)
              return 0;
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "ascii":
                case "latin1":
                case "binary":
                  return len;
                case "utf8":
                case "utf-8":
                case void 0:
                  return utf8ToBytes(string).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return len * 2;
                case "hex":
                  return len >>> 1;
                case "base64":
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase)
                    return utf8ToBytes(string).length;
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;
            if (start === void 0 || start < 0) {
              start = 0;
            }
            if (start > this.length) {
              return "";
            }
            if (end === void 0 || end > this.length) {
              end = this.length;
            }
            if (end <= 0) {
              return "";
            }
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
              return "";
            }
            if (!encoding)
              encoding = "utf8";
            while (true) {
              switch (encoding) {
                case "hex":
                  return hexSlice(this, start, end);
                case "utf8":
                case "utf-8":
                  return utf8Slice(this, start, end);
                case "ascii":
                  return asciiSlice(this, start, end);
                case "latin1":
                case "binary":
                  return latin1Slice(this, start, end);
                case "base64":
                  return base64Slice(this, start, end);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = (encoding + "").toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.prototype._isBuffer = true;
          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }
          Buffer.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };
          Buffer.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };
          Buffer.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }
            return this;
          };
          Buffer.prototype.toString = function toString() {
            var length = this.length | 0;
            if (length === 0)
              return "";
            if (arguments.length === 0)
              return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError("Argument must be a Buffer");
            if (this === b)
              return true;
            return Buffer.compare(this, b) === 0;
          };
          Buffer.prototype.inspect = function inspect() {
            var str = "";
            var max = exports2.INSPECT_MAX_BYTES;
            if (this.length > 0) {
              str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
              if (this.length > max)
                str += " ... ";
            }
            return "<Buffer " + str + ">";
          };
          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (!Buffer.isBuffer(target)) {
              throw new TypeError("Argument must be a Buffer");
            }
            if (start === void 0) {
              start = 0;
            }
            if (end === void 0) {
              end = target ? target.length : 0;
            }
            if (thisStart === void 0) {
              thisStart = 0;
            }
            if (thisEnd === void 0) {
              thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError("out of range index");
            }
            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target)
              return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);
            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (buffer.length === 0)
              return -1;
            if (typeof byteOffset === "string") {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 2147483647) {
              byteOffset = 2147483647;
            } else if (byteOffset < -2147483648) {
              byteOffset = -2147483648;
            }
            byteOffset = +byteOffset;
            if (isNaN(byteOffset)) {
              byteOffset = dir ? 0 : buffer.length - 1;
            }
            if (byteOffset < 0)
              byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir)
                return -1;
              else
                byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir)
                byteOffset = 0;
              else
                return -1;
            }
            if (typeof val === "string") {
              val = Buffer.from(val, encoding);
            }
            if (Buffer.isBuffer(val)) {
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === "number") {
              val = val & 255;
              if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }
            throw new TypeError("val must be string, number or Buffer");
          }
          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (encoding !== void 0) {
              encoding = String(encoding).toLowerCase();
              if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }
            function read(buf, i2) {
              if (indexSize === 1) {
                return buf[i2];
              } else {
                return buf.readUInt16BE(i2 * indexSize);
              }
            }
            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1)
                    foundIndex = i;
                  if (i - foundIndex + 1 === valLength)
                    return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1)
                    i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength)
                byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found)
                  return i;
              }
            }
            return -1;
          }
          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };
          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };
          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            var strLen = string.length;
            if (strLen % 2 !== 0)
              throw new TypeError("Invalid hex string");
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (isNaN(parsed))
                return i;
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer.prototype.write = function write(string, offset, length, encoding) {
            if (offset === void 0) {
              encoding = "utf8";
              length = this.length;
              offset = 0;
            } else if (length === void 0 && typeof offset === "string") {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset = offset | 0;
              if (isFinite(length)) {
                length = length | 0;
                if (encoding === void 0)
                  encoding = "utf8";
              } else {
                encoding = length;
                length = void 0;
              }
            } else {
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            }
            var remaining = this.length - offset;
            if (length === void 0 || length > remaining)
              length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError("Attempt to write outside buffer bounds");
            }
            if (!encoding)
              encoding = "utf8";
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "hex":
                  return hexWrite(this, string, offset, length);
                case "utf8":
                case "utf-8":
                  return utf8Write(this, string, offset, length);
                case "ascii":
                  return asciiWrite(this, string, offset, length);
                case "latin1":
                case "binary":
                  return latin1Write(this, string, offset, length);
                case "base64":
                  return base64Write(this, string, offset, length);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 128) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                      tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                      if (tempCodePoint > 127) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                      if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                      if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                codePoint = 65533;
                bytesPerSequence = 1;
              } else if (codePoint > 65535) {
                codePoint -= 65536;
                res.push(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          var MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            var res = "";
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
          }
          function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0)
              start = 0;
            if (!end || end < 0 || end > len)
              end = len;
            var out = "";
            for (var i = start; i < end; ++i) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === void 0 ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0)
                start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0)
                end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start)
              end = start;
            var newBuf;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              newBuf = this.subarray(start, end);
              newBuf.__proto__ = Buffer.prototype;
            } else {
              var sliceLen = end - start;
              newBuf = new Buffer(sliceLen, void 0);
              for (var i = 0; i < sliceLen; ++i) {
                newBuf[i] = this[i + start];
              }
            }
            return newBuf;
          };
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0)
              throw new RangeError("offset is not uint");
            if (offset + ext > length)
              throw new RangeError("Trying to access beyond buffer length");
          }
          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert) {
              checkOffset(offset, byteLength2, this.length);
            }
            var val = this[offset + --byteLength2];
            var mul = 1;
            while (byteLength2 > 0 && (mul *= 256)) {
              val += this[offset + --byteLength2] * mul;
            }
            return val;
          };
          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
          };
          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var i = byteLength2;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
              val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128))
              return this[offset];
            return (255 - this[offset] + 1) * -1;
          };
          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min)
              throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
          }
          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            byteLength2 = byteLength2 | 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 255, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            this[offset] = value & 255;
            return offset + 1;
          };
          function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 65535 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
              buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
            }
          }
          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0)
              value = 4294967295 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
              buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
            }
          }
          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset + 3] = value >>> 24;
              this[offset + 2] = value >>> 16;
              this[offset + 1] = value >>> 8;
              this[offset] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 127, -128);
            if (!Buffer.TYPED_ARRAY_SUPPORT)
              value = Math.floor(value);
            if (value < 0)
              value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
            } else {
              objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 8;
              this[offset + 1] = value & 255;
            } else {
              objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
          };
          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value & 255;
              this[offset + 1] = value >>> 8;
              this[offset + 2] = value >>> 16;
              this[offset + 3] = value >>> 24;
            } else {
              objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
          };
          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset | 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0)
              value = 4294967295 + value + 1;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = value >>> 24;
              this[offset + 1] = value >>> 16;
              this[offset + 2] = value >>> 8;
              this[offset + 3] = value & 255;
            } else {
              objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
            if (offset < 0)
              throw new RangeError("Index out of range");
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!start)
              start = 0;
            if (!end && end !== 0)
              end = this.length;
            if (targetStart >= target.length)
              targetStart = target.length;
            if (!targetStart)
              targetStart = 0;
            if (end > 0 && end < start)
              end = start;
            if (end === start)
              return 0;
            if (target.length === 0 || this.length === 0)
              return 0;
            if (targetStart < 0) {
              throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length)
              throw new RangeError("sourceStart out of bounds");
            if (end < 0)
              throw new RangeError("sourceEnd out of bounds");
            if (end > this.length)
              end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            var i;
            if (this === target && start < targetStart && targetStart < end) {
              for (i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
              for (i = 0; i < len; ++i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
            }
            return len;
          };
          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === "string") {
                encoding = end;
                end = this.length;
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0);
                if (code < 256) {
                  val = code;
                }
              }
              if (encoding !== void 0 && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string");
              }
              if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
            } else if (typeof val === "number") {
              val = val & 255;
            }
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError("Out of range index");
            }
            if (end <= start) {
              return this;
            }
            start = start >>> 0;
            end = end === void 0 ? this.length : end >>> 0;
            if (!val)
              val = 0;
            var i;
            if (typeof val === "number") {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
              var len = bytes.length;
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }
            return this;
          };
          var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
          function base64clean(str) {
            str = stringtrim(str).replace(INVALID_BASE64_RE, "");
            if (str.length < 2)
              return "";
            while (str.length % 4 !== 0) {
              str = str + "=";
            }
            return str;
          }
          function stringtrim(str) {
            if (str.trim)
              return str.trim();
            return str.replace(/^\s+|\s+$/g, "");
          }
          function toHex(n) {
            if (n < 16)
              return "0" + n.toString(16);
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);
              if (codePoint > 55295 && codePoint < 57344) {
                if (!leadSurrogate) {
                  if (codePoint > 56319) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 56320) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  leadSurrogate = codePoint;
                  continue;
                }
                codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
              } else if (leadSurrogate) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
              }
              leadSurrogate = null;
              if (codePoint < 128) {
                if ((units -= 1) < 0)
                  break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0)
                  break;
                bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0)
                  break;
                bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0)
                  break;
                bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else {
                throw new Error("Invalid code point");
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0)
                break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length)
                break;
              dst[i + offset] = src[i];
            }
            return i;
          }
          function isnan(val) {
            return val !== val;
          }
        }).call(this, __webpack_require__("c8ba"));
      },
      "b64b": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var toObject = __webpack_require__("7b0b");
        var nativeKeys = __webpack_require__("df75");
        var fails = __webpack_require__("d039");
        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeKeys(1);
        });
        $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
          keys: function keys(it) {
            return nativeKeys(toObject(it));
          }
        });
      },
      "b727": function(module2, exports2, __webpack_require__) {
        var bind = __webpack_require__("0366");
        var uncurryThis = __webpack_require__("e330");
        var IndexedObject = __webpack_require__("44ad");
        var toObject = __webpack_require__("7b0b");
        var lengthOfArrayLike = __webpack_require__("07fa");
        var arraySpeciesCreate = __webpack_require__("65f0");
        var push = uncurryThis([].push);
        var createMethod = function(TYPE) {
          var IS_MAP = TYPE == 1;
          var IS_FILTER = TYPE == 2;
          var IS_SOME = TYPE == 3;
          var IS_EVERY = TYPE == 4;
          var IS_FIND_INDEX = TYPE == 6;
          var IS_FILTER_REJECT = TYPE == 7;
          var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
          return function($this, callbackfn, that, specificCreate) {
            var O = toObject($this);
            var self2 = IndexedObject(O);
            var boundFunction = bind(callbackfn, that);
            var length = lengthOfArrayLike(self2);
            var index = 0;
            var create = specificCreate || arraySpeciesCreate;
            var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : void 0;
            var value, result;
            for (; length > index; index++)
              if (NO_HOLES || index in self2) {
                value = self2[index];
                result = boundFunction(value, index, O);
                if (TYPE) {
                  if (IS_MAP)
                    target[index] = result;
                  else if (result)
                    switch (TYPE) {
                      case 3:
                        return true;
                      case 5:
                        return value;
                      case 6:
                        return index;
                      case 2:
                        push(target, value);
                    }
                  else
                    switch (TYPE) {
                      case 4:
                        return false;
                      case 7:
                        push(target, value);
                    }
                }
              }
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
          };
        };
        module2.exports = {
          forEach: createMethod(0),
          map: createMethod(1),
          filter: createMethod(2),
          some: createMethod(3),
          every: createMethod(4),
          find: createMethod(5),
          findIndex: createMethod(6),
          filterReject: createMethod(7)
        };
      },
      "b980": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var createPropertyDescriptor = __webpack_require__("5c6c");
        module2.exports = !fails(function() {
          var error = Error("a");
          if (!("stack" in error))
            return true;
          Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
          return error.stack !== 7;
        });
      },
      "c04e": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var call = __webpack_require__("c65b");
        var isObject2 = __webpack_require__("861d");
        var isSymbol2 = __webpack_require__("d9b5");
        var getMethod = __webpack_require__("dc4a");
        var ordinaryToPrimitive = __webpack_require__("485a");
        var wellKnownSymbol = __webpack_require__("b622");
        var TypeError2 = global.TypeError;
        var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
        module2.exports = function(input, pref) {
          if (!isObject2(input) || isSymbol2(input))
            return input;
          var exoticToPrim = getMethod(input, TO_PRIMITIVE);
          var result;
          if (exoticToPrim) {
            if (pref === void 0)
              pref = "default";
            result = call(exoticToPrim, input, pref);
            if (!isObject2(result) || isSymbol2(result))
              return result;
            throw TypeError2("Can't convert object to primitive value");
          }
          if (pref === void 0)
            pref = "number";
          return ordinaryToPrimitive(input, pref);
        };
      },
      "c430": function(module2, exports2) {
        module2.exports = false;
      },
      "c65b": function(module2, exports2, __webpack_require__) {
        var NATIVE_BIND = __webpack_require__("40d5");
        var call = Function.prototype.call;
        module2.exports = NATIVE_BIND ? call.bind(call) : function() {
          return call.apply(call, arguments);
        };
      },
      "c6b6": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var toString = uncurryThis({}.toString);
        var stringSlice = uncurryThis("".slice);
        module2.exports = function(it) {
          return stringSlice(toString(it), 8, -1);
        };
      },
      "c6cd": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var setGlobal = __webpack_require__("ce4e");
        var SHARED = "__core-js_shared__";
        var store = global[SHARED] || setGlobal(SHARED, {});
        module2.exports = store;
      },
      "c740": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $findIndex = __webpack_require__("b727").findIndex;
        var addToUnscopables = __webpack_require__("44d2");
        var FIND_INDEX = "findIndex";
        var SKIPS_HOLES = true;
        if (FIND_INDEX in [])
          Array(1)[FIND_INDEX](function() {
            SKIPS_HOLES = false;
          });
        $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
          findIndex: function findIndex(callbackfn) {
            return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
        addToUnscopables(FIND_INDEX);
      },
      "c770": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var replace = uncurryThis("".replace);
        var TEST = function(arg) {
          return String(Error(arg).stack);
        }("zxcasd");
        var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
        var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
        module2.exports = function(stack, dropEntries) {
          if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string") {
            while (dropEntries--)
              stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
          }
          return stack;
        };
      },
      "c8ba": function(module2, exports2) {
        var g;
        g = function() {
          return this;
        }();
        try {
          g = g || new Function("return this")();
        } catch (e) {
          if (typeof window === "object")
            g = window;
        }
        module2.exports = g;
      },
      "ca84": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var hasOwn = __webpack_require__("1a2d");
        var toIndexedObject = __webpack_require__("fc6a");
        var indexOf = __webpack_require__("4d64").indexOf;
        var hiddenKeys = __webpack_require__("d012");
        var push = uncurryThis([].push);
        module2.exports = function(object, names) {
          var O = toIndexedObject(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O)
            !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
          while (names.length > i)
            if (hasOwn(O, key = names[i++])) {
              ~indexOf(result, key) || push(result, key);
            }
          return result;
        };
      },
      "caad": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $includes = __webpack_require__("4d64").includes;
        var addToUnscopables = __webpack_require__("44d2");
        $({ target: "Array", proto: true }, {
          includes: function includes(el) {
            return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
        addToUnscopables("includes");
      },
      "cc12": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isObject2 = __webpack_require__("861d");
        var document2 = global.document;
        var EXISTS = isObject2(document2) && isObject2(document2.createElement);
        module2.exports = function(it) {
          return EXISTS ? document2.createElement(it) : {};
        };
      },
      "ce4e": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var defineProperty = Object.defineProperty;
        module2.exports = function(key, value) {
          try {
            defineProperty(global, key, { value, configurable: true, writable: true });
          } catch (error) {
            global[key] = value;
          }
          return value;
        };
      },
      "cef7": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", function() {
          return stopPropagation;
        });
        var BaseEvent = function() {
          function BaseEvent2(type) {
            this.propagationStopped;
            this.defaultPrevented;
            this.type = type;
            this.target = null;
          }
          BaseEvent2.prototype.preventDefault = function() {
            this.defaultPrevented = true;
          };
          BaseEvent2.prototype.stopPropagation = function() {
            this.propagationStopped = true;
          };
          return BaseEvent2;
        }();
        function stopPropagation(evt) {
          evt.stopPropagation();
        }
        function preventDefault(evt) {
          evt.preventDefault();
        }
        __webpack_exports__["a"] = BaseEvent;
      },
      "d012": function(module2, exports2) {
        module2.exports = {};
      },
      "d039": function(module2, exports2) {
        module2.exports = function(exec) {
          try {
            return !!exec();
          } catch (error) {
            return true;
          }
        };
      },
      "d066": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var isCallable = __webpack_require__("1626");
        var aFunction = function(argument) {
          return isCallable(argument) ? argument : void 0;
        };
        module2.exports = function(namespace, method) {
          return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
        };
      },
      "d1e7": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $propertyIsEnumerable = {}.propertyIsEnumerable;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
        exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
          var descriptor = getOwnPropertyDescriptor(this, V);
          return !!descriptor && descriptor.enumerable;
        } : $propertyIsEnumerable;
      },
      "d28b": function(module2, exports2, __webpack_require__) {
        var defineWellKnownSymbol = __webpack_require__("746f");
        defineWellKnownSymbol("iterator");
      },
      "d2bb": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        var anObject = __webpack_require__("825a");
        var aPossiblePrototype = __webpack_require__("3bbe");
        module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var CORRECT_SETTER = false;
          var test = {};
          var setter;
          try {
            setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
            setter(test, []);
            CORRECT_SETTER = test instanceof Array;
          } catch (error) {
          }
          return function setPrototypeOf(O, proto) {
            anObject(O);
            aPossiblePrototype(proto);
            if (CORRECT_SETTER)
              setter(O, proto);
            else
              O.__proto__ = proto;
            return O;
          };
        }() : void 0);
      },
      "d3b7": function(module2, exports2, __webpack_require__) {
        var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
        var redefine = __webpack_require__("6eeb");
        var toString = __webpack_require__("b041");
        if (!TO_STRING_TAG_SUPPORT) {
          redefine(Object.prototype, "toString", toString, { unsafe: true });
        }
      },
      "d44e": function(module2, exports2, __webpack_require__) {
        var defineProperty = __webpack_require__("9bf2").f;
        var hasOwn = __webpack_require__("1a2d");
        var wellKnownSymbol = __webpack_require__("b622");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        module2.exports = function(target, TAG, STATIC) {
          if (target && !STATIC)
            target = target.prototype;
          if (target && !hasOwn(target, TO_STRING_TAG)) {
            defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
          }
        };
      },
      "d784": function(module2, exports2, __webpack_require__) {
        "use strict";
        __webpack_require__("ac1f");
        var uncurryThis = __webpack_require__("e330");
        var redefine = __webpack_require__("6eeb");
        var regexpExec = __webpack_require__("9263");
        var fails = __webpack_require__("d039");
        var wellKnownSymbol = __webpack_require__("b622");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var SPECIES = wellKnownSymbol("species");
        var RegExpPrototype = RegExp.prototype;
        module2.exports = function(KEY, exec, FORCED, SHAM) {
          var SYMBOL = wellKnownSymbol(KEY);
          var DELEGATES_TO_SYMBOL = !fails(function() {
            var O = {};
            O[SYMBOL] = function() {
              return 7;
            };
            return ""[KEY](O) != 7;
          });
          var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
            var execCalled = false;
            var re = /a/;
            if (KEY === "split") {
              re = {};
              re.constructor = {};
              re.constructor[SPECIES] = function() {
                return re;
              };
              re.flags = "";
              re[SYMBOL] = /./[SYMBOL];
            }
            re.exec = function() {
              execCalled = true;
              return null;
            };
            re[SYMBOL]("");
            return !execCalled;
          });
          if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
            var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
            var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
              var uncurriedNativeMethod = uncurryThis(nativeMethod);
              var $exec = regexp.exec;
              if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                  return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
                }
                return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
              }
              return { done: false };
            });
            redefine(String.prototype, KEY, methods[0]);
            redefine(RegExpPrototype, SYMBOL, methods[1]);
          }
          if (SHAM)
            createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
        };
      },
      "d81d": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var $map = __webpack_require__("b727").map;
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
          map: function map(callbackfn) {
            return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      },
      "d998": function(module2, exports2, __webpack_require__) {
        var UA = __webpack_require__("342f");
        module2.exports = /MSIE|Trident/.test(UA);
      },
      "d9b5": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var getBuiltIn = __webpack_require__("d066");
        var isCallable = __webpack_require__("1626");
        var isPrototypeOf = __webpack_require__("3a9b");
        var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
        var Object2 = global.Object;
        module2.exports = USE_SYMBOL_AS_UID ? function(it) {
          return typeof it == "symbol";
        } : function(it) {
          var $Symbol = getBuiltIn("Symbol");
          return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object2(it));
        };
      },
      "d9e2": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var global = __webpack_require__("da84");
        var apply = __webpack_require__("2ba4");
        var wrapErrorConstructorWithCause = __webpack_require__("e5cb");
        var WEB_ASSEMBLY = "WebAssembly";
        var WebAssembly = global[WEB_ASSEMBLY];
        var FORCED = Error("e", { cause: 7 }).cause !== 7;
        var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
          var O = {};
          O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
          $({ global: true, forced: FORCED }, O);
        };
        var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
          if (WebAssembly && WebAssembly[ERROR_NAME]) {
            var O = {};
            O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper, FORCED);
            $({ target: WEB_ASSEMBLY, stat: true, forced: FORCED }, O);
          }
        };
        exportGlobalErrorCauseWrapper("Error", function(init) {
          return function Error2(message) {
            return apply(init, this, arguments);
          };
        });
        exportGlobalErrorCauseWrapper("EvalError", function(init) {
          return function EvalError(message) {
            return apply(init, this, arguments);
          };
        });
        exportGlobalErrorCauseWrapper("RangeError", function(init) {
          return function RangeError2(message) {
            return apply(init, this, arguments);
          };
        });
        exportGlobalErrorCauseWrapper("ReferenceError", function(init) {
          return function ReferenceError2(message) {
            return apply(init, this, arguments);
          };
        });
        exportGlobalErrorCauseWrapper("SyntaxError", function(init) {
          return function SyntaxError2(message) {
            return apply(init, this, arguments);
          };
        });
        exportGlobalErrorCauseWrapper("TypeError", function(init) {
          return function TypeError2(message) {
            return apply(init, this, arguments);
          };
        });
        exportGlobalErrorCauseWrapper("URIError", function(init) {
          return function URIError(message) {
            return apply(init, this, arguments);
          };
        });
        exportWebAssemblyErrorCauseWrapper("CompileError", function(init) {
          return function CompileError(message) {
            return apply(init, this, arguments);
          };
        });
        exportWebAssemblyErrorCauseWrapper("LinkError", function(init) {
          return function LinkError(message) {
            return apply(init, this, arguments);
          };
        });
        exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init) {
          return function RuntimeError(message) {
            return apply(init, this, arguments);
          };
        });
      },
      "da5c": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        var Disposable = function() {
          function Disposable2() {
            this.disposed = false;
          }
          Disposable2.prototype.dispose = function() {
            if (!this.disposed) {
              this.disposed = true;
              this.disposeInternal();
            }
          };
          Disposable2.prototype.disposeInternal = function() {
          };
          return Disposable2;
        }();
        __webpack_exports__["a"] = Disposable;
      },
      "da84": function(module2, exports2, __webpack_require__) {
        (function(global) {
          var check = function(it) {
            return it && it.Math == Math && it;
          };
          module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || function() {
            return this;
          }() || Function("return this")();
        }).call(this, __webpack_require__("c8ba"));
      },
      "dbb4": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var DESCRIPTORS = __webpack_require__("83ab");
        var ownKeys = __webpack_require__("56ef");
        var toIndexedObject = __webpack_require__("fc6a");
        var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
        var createProperty = __webpack_require__("8418");
        $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
          getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
            var O = toIndexedObject(object);
            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            var keys = ownKeys(O);
            var result = {};
            var index = 0;
            var key, descriptor;
            while (keys.length > index) {
              descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
              if (descriptor !== void 0)
                createProperty(result, key, descriptor);
            }
            return result;
          }
        });
      },
      "dbd0": function(module2, exports2, __webpack_require__) {
      },
      "dc4a": function(module2, exports2, __webpack_require__) {
        var aCallable = __webpack_require__("59ed");
        module2.exports = function(V, P) {
          var func = V[P];
          return func == null ? void 0 : aCallable(func);
        };
      },
      "ddb0": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var DOMIterables = __webpack_require__("fdbc");
        var DOMTokenListPrototype = __webpack_require__("785a");
        var ArrayIteratorMethods = __webpack_require__("e260");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var wellKnownSymbol = __webpack_require__("b622");
        var ITERATOR = wellKnownSymbol("iterator");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var ArrayValues = ArrayIteratorMethods.values;
        var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
          if (CollectionPrototype) {
            if (CollectionPrototype[ITERATOR] !== ArrayValues)
              try {
                createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
              } catch (error) {
                CollectionPrototype[ITERATOR] = ArrayValues;
              }
            if (!CollectionPrototype[TO_STRING_TAG]) {
              createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME2);
            }
            if (DOMIterables[COLLECTION_NAME2])
              for (var METHOD_NAME in ArrayIteratorMethods) {
                if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                  try {
                    createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                  } catch (error) {
                    CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                  }
              }
          }
        };
        for (var COLLECTION_NAME in DOMIterables) {
          handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype, COLLECTION_NAME);
        }
        handlePrototype(DOMTokenListPrototype, "DOMTokenList");
      },
      "df75": function(module2, exports2, __webpack_require__) {
        var internalObjectKeys = __webpack_require__("ca84");
        var enumBugKeys = __webpack_require__("7839");
        module2.exports = Object.keys || function keys(O) {
          return internalObjectKeys(O, enumBugKeys);
        };
      },
      "e01a": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var DESCRIPTORS = __webpack_require__("83ab");
        var global = __webpack_require__("da84");
        var uncurryThis = __webpack_require__("e330");
        var hasOwn = __webpack_require__("1a2d");
        var isCallable = __webpack_require__("1626");
        var isPrototypeOf = __webpack_require__("3a9b");
        var toString = __webpack_require__("577e");
        var defineProperty = __webpack_require__("9bf2").f;
        var copyConstructorProperties = __webpack_require__("e893");
        var NativeSymbol = global.Symbol;
        var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
        if (DESCRIPTORS && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || NativeSymbol().description !== void 0)) {
          var EmptyStringDescriptionStore = {};
          var SymbolWrapper = function Symbol2() {
            var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString(arguments[0]);
            var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
            if (description === "")
              EmptyStringDescriptionStore[result] = true;
            return result;
          };
          copyConstructorProperties(SymbolWrapper, NativeSymbol);
          SymbolWrapper.prototype = SymbolPrototype;
          SymbolPrototype.constructor = SymbolWrapper;
          var NATIVE_SYMBOL = String(NativeSymbol("test")) == "Symbol(test)";
          var symbolToString = uncurryThis(SymbolPrototype.toString);
          var symbolValueOf = uncurryThis(SymbolPrototype.valueOf);
          var regexp = /^Symbol\((.*)\)[^)]+$/;
          var replace = uncurryThis("".replace);
          var stringSlice = uncurryThis("".slice);
          defineProperty(SymbolPrototype, "description", {
            configurable: true,
            get: function description() {
              var symbol = symbolValueOf(this);
              var string = symbolToString(symbol);
              if (hasOwn(EmptyStringDescriptionStore, symbol))
                return "";
              var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
              return desc === "" ? void 0 : desc;
            }
          });
          $({ global: true, forced: true }, {
            Symbol: SymbolWrapper
          });
        }
      },
      "e163": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var hasOwn = __webpack_require__("1a2d");
        var isCallable = __webpack_require__("1626");
        var toObject = __webpack_require__("7b0b");
        var sharedKey = __webpack_require__("f772");
        var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
        var IE_PROTO = sharedKey("IE_PROTO");
        var Object2 = global.Object;
        var ObjectPrototype = Object2.prototype;
        module2.exports = CORRECT_PROTOTYPE_GETTER ? Object2.getPrototypeOf : function(O) {
          var object = toObject(O);
          if (hasOwn(object, IE_PROTO))
            return object[IE_PROTO];
          var constructor = object.constructor;
          if (isCallable(constructor) && object instanceof constructor) {
            return constructor.prototype;
          }
          return object instanceof Object2 ? ObjectPrototype : null;
        };
      },
      "e177": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        module2.exports = !fails(function() {
          function F() {
          }
          F.prototype.constructor = null;
          return Object.getPrototypeOf(new F()) !== F.prototype;
        });
      },
      "e260": function(module2, exports2, __webpack_require__) {
        "use strict";
        var toIndexedObject = __webpack_require__("fc6a");
        var addToUnscopables = __webpack_require__("44d2");
        var Iterators = __webpack_require__("3f8c");
        var InternalStateModule = __webpack_require__("69f3");
        var defineProperty = __webpack_require__("9bf2").f;
        var defineIterator = __webpack_require__("7dd0");
        var IS_PURE = __webpack_require__("c430");
        var DESCRIPTORS = __webpack_require__("83ab");
        var ARRAY_ITERATOR = "Array Iterator";
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
        module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
          setInternalState(this, {
            type: ARRAY_ITERATOR,
            target: toIndexedObject(iterated),
            index: 0,
            kind
          });
        }, function() {
          var state = getInternalState(this);
          var target = state.target;
          var kind = state.kind;
          var index = state.index++;
          if (!target || index >= target.length) {
            state.target = void 0;
            return { value: void 0, done: true };
          }
          if (kind == "keys")
            return { value: index, done: false };
          if (kind == "values")
            return { value: target[index], done: false };
          return { value: [index, target[index]], done: false };
        }, "values");
        var values = Iterators.Arguments = Iterators.Array;
        addToUnscopables("keys");
        addToUnscopables("values");
        addToUnscopables("entries");
        if (!IS_PURE && DESCRIPTORS && values.name !== "values")
          try {
            defineProperty(values, "name", { value: "values" });
          } catch (error) {
          }
      },
      "e269": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("cef7");
        var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("7b4f");
        var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("35a7");
        var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("38f3");
        var _util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("1300");
        var __extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ObjectEvent = function(_super) {
          __extends(ObjectEvent2, _super);
          function ObjectEvent2(type, key, oldValue) {
            var _this = _super.call(this, type) || this;
            _this.key = key;
            _this.oldValue = oldValue;
            return _this;
          }
          return ObjectEvent2;
        }(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["a"]);
        var BaseObject = function(_super) {
          __extends(BaseObject2, _super);
          function BaseObject2(opt_values) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            Object(_util_js__WEBPACK_IMPORTED_MODULE_4__["c"])(_this);
            _this.values_ = null;
            if (opt_values !== void 0) {
              _this.setProperties(opt_values);
            }
            return _this;
          }
          BaseObject2.prototype.get = function(key) {
            var value;
            if (this.values_ && this.values_.hasOwnProperty(key)) {
              value = this.values_[key];
            }
            return value;
          };
          BaseObject2.prototype.getKeys = function() {
            return this.values_ && Object.keys(this.values_) || [];
          };
          BaseObject2.prototype.getProperties = function() {
            return this.values_ && Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["a"])({}, this.values_) || {};
          };
          BaseObject2.prototype.hasProperties = function() {
            return !!this.values_;
          };
          BaseObject2.prototype.notify = function(key, oldValue) {
            var eventType;
            eventType = "change:" + key;
            this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
            eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__["a"].PROPERTYCHANGE;
            this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
          };
          BaseObject2.prototype.addChangeListener = function(key, listener) {
            this.addEventListener("change:" + key, listener);
          };
          BaseObject2.prototype.removeChangeListener = function(key, listener) {
            this.removeEventListener("change:" + key, listener);
          };
          BaseObject2.prototype.set = function(key, value, opt_silent) {
            var values = this.values_ || (this.values_ = {});
            if (opt_silent) {
              values[key] = value;
            } else {
              var oldValue = values[key];
              values[key] = value;
              if (oldValue !== value) {
                this.notify(key, oldValue);
              }
            }
          };
          BaseObject2.prototype.setProperties = function(values, opt_silent) {
            for (var key in values) {
              this.set(key, values[key], opt_silent);
            }
          };
          BaseObject2.prototype.applyProperties = function(source) {
            if (!source.values_) {
              return;
            }
            Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["a"])(this.values_ || (this.values_ = {}), source.values_);
          };
          BaseObject2.prototype.unset = function(key, opt_silent) {
            if (this.values_ && key in this.values_) {
              var oldValue = this.values_[key];
              delete this.values_[key];
              if (Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["d"])(this.values_)) {
                this.values_ = null;
              }
              if (!opt_silent) {
                this.notify(key, oldValue);
              }
            }
          };
          return BaseObject2;
        }(_Observable_js__WEBPACK_IMPORTED_MODULE_2__["a"]);
        __webpack_exports__["a"] = BaseObject;
      },
      "e330": function(module2, exports2, __webpack_require__) {
        var NATIVE_BIND = __webpack_require__("40d5");
        var FunctionPrototype = Function.prototype;
        var bind = FunctionPrototype.bind;
        var call = FunctionPrototype.call;
        var uncurryThis = NATIVE_BIND && bind.bind(call, call);
        module2.exports = NATIVE_BIND ? function(fn) {
          return fn && uncurryThis(fn);
        } : function(fn) {
          return fn && function() {
            return call.apply(fn, arguments);
          };
        };
      },
      "e391": function(module2, exports2, __webpack_require__) {
        var toString = __webpack_require__("577e");
        module2.exports = function(argument, $default) {
          return argument === void 0 ? arguments.length < 2 ? "" : $default : toString(argument);
        };
      },
      "e3db": function(module2, exports2) {
        var toString = {}.toString;
        module2.exports = Array.isArray || function(arr) {
          return toString.call(arr) == "[object Array]";
        };
      },
      "e439": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var fails = __webpack_require__("d039");
        var toIndexedObject = __webpack_require__("fc6a");
        var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
        var DESCRIPTORS = __webpack_require__("83ab");
        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeGetOwnPropertyDescriptor(1);
        });
        var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
        $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
            return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
          }
        });
      },
      "e4e0": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        (function(global) {
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return jsonp;
          });
          var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1300");
          var __extends = function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (Object.prototype.hasOwnProperty.call(b2, p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          function jsonp(url, callback, opt_errback, opt_callbackParam) {
            var script = document.createElement("script");
            var key = "olc_" + Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["c"])(callback);
            function cleanup() {
              delete window[key];
              script.parentNode.removeChild(script);
            }
            script.async = true;
            script.src = url + (url.indexOf("?") == -1 ? "?" : "&") + (opt_callbackParam || "callback") + "=" + key;
            var timer = setTimeout(function() {
              cleanup();
              if (opt_errback) {
                opt_errback();
              }
            }, 1e4);
            window[key] = function(data) {
              clearTimeout(timer);
              cleanup();
              callback(data);
            };
            document.getElementsByTagName("head")[0].appendChild(script);
          }
          var ResponseError = function(_super) {
            __extends(ResponseError2, _super);
            function ResponseError2(response) {
              var _this = this;
              var message = "Unexpected response status: " + response.status;
              _this = _super.call(this, message) || this;
              _this.name = "ResponseError";
              _this.response = response;
              return _this;
            }
            return ResponseError2;
          }(Error);
          var ClientError = function(_super) {
            __extends(ClientError2, _super);
            function ClientError2(client) {
              var _this = _super.call(this, "Failed to issue request") || this;
              _this.name = "ClientError";
              _this.client = client;
              return _this;
            }
            return ClientError2;
          }(Error);
          function getJSON(url) {
            return new Promise(function(resolve, reject) {
              function onLoad(event) {
                var client2 = event.target;
                if (!client2.status || client2.status >= 200 && client2.status < 300) {
                  var data = void 0;
                  try {
                    data = JSON.parse(client2.responseText);
                  } catch (err) {
                    var message = "Error parsing response text as JSON: " + err.message;
                    reject(new Error(message));
                    return;
                  }
                  resolve(data);
                  return;
                }
                reject(new ResponseError(client2));
              }
              function onError(event) {
                reject(new ClientError(event.target));
              }
              var client = new XMLHttpRequest();
              client.addEventListener("load", onLoad);
              client.addEventListener("error", onError);
              client.open("GET", url);
              client.setRequestHeader("Accept", "application/json");
              client.send();
            });
          }
          function resolveUrl(base, url) {
            if (url.indexOf("://") >= 0) {
              return url;
            }
            return new URL(url, base).href;
          }
          var originalXHR;
          function overrideXHR(xhr) {
            if (typeof XMLHttpRequest !== "undefined") {
              originalXHR = XMLHttpRequest;
            }
            global.XMLHttpRequest = xhr;
          }
          function restoreXHR() {
            global.XMLHttpRequest = originalXHR;
          }
        }).call(this, __webpack_require__("c8ba"));
      },
      "e538": function(module2, exports2, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        exports2.f = wellKnownSymbol;
      },
      "e5cb": function(module2, exports2, __webpack_require__) {
        "use strict";
        var getBuiltIn = __webpack_require__("d066");
        var hasOwn = __webpack_require__("1a2d");
        var createNonEnumerableProperty = __webpack_require__("9112");
        var isPrototypeOf = __webpack_require__("3a9b");
        var setPrototypeOf = __webpack_require__("d2bb");
        var copyConstructorProperties = __webpack_require__("e893");
        var inheritIfRequired = __webpack_require__("7156");
        var normalizeStringArgument = __webpack_require__("e391");
        var installErrorCause = __webpack_require__("ab36");
        var clearErrorStack = __webpack_require__("c770");
        var ERROR_STACK_INSTALLABLE = __webpack_require__("b980");
        var IS_PURE = __webpack_require__("c430");
        module2.exports = function(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
          var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
          var path = FULL_NAME.split(".");
          var ERROR_NAME = path[path.length - 1];
          var OriginalError = getBuiltIn.apply(null, path);
          if (!OriginalError)
            return;
          var OriginalErrorPrototype = OriginalError.prototype;
          if (!IS_PURE && hasOwn(OriginalErrorPrototype, "cause"))
            delete OriginalErrorPrototype.cause;
          if (!FORCED)
            return OriginalError;
          var BaseError = getBuiltIn("Error");
          var WrappedError = wrapper(function(a, b) {
            var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, void 0);
            var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
            if (message !== void 0)
              createNonEnumerableProperty(result, "message", message);
            if (ERROR_STACK_INSTALLABLE)
              createNonEnumerableProperty(result, "stack", clearErrorStack(result.stack, 2));
            if (this && isPrototypeOf(OriginalErrorPrototype, this))
              inheritIfRequired(result, this, WrappedError);
            if (arguments.length > OPTIONS_POSITION)
              installErrorCause(result, arguments[OPTIONS_POSITION]);
            return result;
          });
          WrappedError.prototype = OriginalErrorPrototype;
          if (ERROR_NAME !== "Error") {
            if (setPrototypeOf)
              setPrototypeOf(WrappedError, BaseError);
            else
              copyConstructorProperties(WrappedError, BaseError, { name: true });
          }
          copyConstructorProperties(WrappedError, OriginalError);
          if (!IS_PURE)
            try {
              if (OriginalErrorPrototype.name !== ERROR_NAME) {
                createNonEnumerableProperty(OriginalErrorPrototype, "name", ERROR_NAME);
              }
              OriginalErrorPrototype.constructor = WrappedError;
            } catch (error) {
            }
          return WrappedError;
        };
      },
      "e893": function(module2, exports2, __webpack_require__) {
        var hasOwn = __webpack_require__("1a2d");
        var ownKeys = __webpack_require__("56ef");
        var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
        var definePropertyModule = __webpack_require__("9bf2");
        module2.exports = function(target, source, exceptions) {
          var keys = ownKeys(source);
          var defineProperty = definePropertyModule.f;
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
              defineProperty(target, key, getOwnPropertyDescriptor(source, key));
            }
          }
        };
      },
      "e8b5": function(module2, exports2, __webpack_require__) {
        var classof = __webpack_require__("c6b6");
        module2.exports = Array.isArray || function isArray2(argument) {
          return classof(argument) == "Array";
        };
      },
      "e95a": function(module2, exports2, __webpack_require__) {
        var wellKnownSymbol = __webpack_require__("b622");
        var Iterators = __webpack_require__("3f8c");
        var ITERATOR = wellKnownSymbol("iterator");
        var ArrayPrototype = Array.prototype;
        module2.exports = function(it) {
          return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
        };
      },
      "f36a": function(module2, exports2, __webpack_require__) {
        var uncurryThis = __webpack_require__("e330");
        module2.exports = uncurryThis([].slice);
      },
      "f5df": function(module2, exports2, __webpack_require__) {
        var global = __webpack_require__("da84");
        var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
        var isCallable = __webpack_require__("1626");
        var classofRaw = __webpack_require__("c6b6");
        var wellKnownSymbol = __webpack_require__("b622");
        var TO_STRING_TAG = wellKnownSymbol("toStringTag");
        var Object2 = global.Object;
        var CORRECT_ARGUMENTS = classofRaw(function() {
          return arguments;
        }()) == "Arguments";
        var tryGet = function(it, key) {
          try {
            return it[key];
          } catch (error) {
          }
        };
        module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
          var O, tag, result;
          return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object2(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
        };
      },
      "f772": function(module2, exports2, __webpack_require__) {
        var shared = __webpack_require__("5692");
        var uid = __webpack_require__("90e3");
        var keys = shared("keys");
        module2.exports = function(key) {
          return keys[key] || (keys[key] = uid(key));
        };
      },
      "f8c9": function(module2, exports2, __webpack_require__) {
        var $ = __webpack_require__("23e7");
        var global = __webpack_require__("da84");
        var setToStringTag = __webpack_require__("d44e");
        $({ global: true }, { Reflect: {} });
        setToStringTag(global.Reflect, "Reflect", true);
      },
      "fb15": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, "install", function() {
          return src_install;
        });
        __webpack_require__.d(__webpack_exports__, "Map", function() {
          return map_namespaceObject;
        });
        __webpack_require__.d(__webpack_exports__, "Layers", function() {
          return layers_namespaceObject;
        });
        __webpack_require__.d(__webpack_exports__, "Sources", function() {
          return sources_namespaceObject;
        });
        __webpack_require__.d(__webpack_exports__, "MapControls", function() {
          return mapControls_namespaceObject;
        });
        __webpack_require__.d(__webpack_exports__, "Geometries", function() {
          return geometries_namespaceObject;
        });
        __webpack_require__.d(__webpack_exports__, "Styles", function() {
          return styles_namespaceObject;
        });
        var extent_namespaceObject = {};
        __webpack_require__.r(extent_namespaceObject);
        __webpack_require__.d(extent_namespaceObject, "boundingExtent", function() {
          return boundingExtent;
        });
        __webpack_require__.d(extent_namespaceObject, "buffer", function() {
          return extent_buffer;
        });
        __webpack_require__.d(extent_namespaceObject, "clone", function() {
          return clone;
        });
        __webpack_require__.d(extent_namespaceObject, "closestSquaredDistanceXY", function() {
          return closestSquaredDistanceXY;
        });
        __webpack_require__.d(extent_namespaceObject, "containsCoordinate", function() {
          return containsCoordinate;
        });
        __webpack_require__.d(extent_namespaceObject, "containsExtent", function() {
          return containsExtent;
        });
        __webpack_require__.d(extent_namespaceObject, "containsXY", function() {
          return containsXY;
        });
        __webpack_require__.d(extent_namespaceObject, "coordinateRelationship", function() {
          return coordinateRelationship;
        });
        __webpack_require__.d(extent_namespaceObject, "createEmpty", function() {
          return createEmpty;
        });
        __webpack_require__.d(extent_namespaceObject, "createOrUpdate", function() {
          return createOrUpdate;
        });
        __webpack_require__.d(extent_namespaceObject, "createOrUpdateEmpty", function() {
          return createOrUpdateEmpty;
        });
        __webpack_require__.d(extent_namespaceObject, "createOrUpdateFromCoordinate", function() {
          return createOrUpdateFromCoordinate;
        });
        __webpack_require__.d(extent_namespaceObject, "createOrUpdateFromCoordinates", function() {
          return createOrUpdateFromCoordinates;
        });
        __webpack_require__.d(extent_namespaceObject, "createOrUpdateFromFlatCoordinates", function() {
          return createOrUpdateFromFlatCoordinates;
        });
        __webpack_require__.d(extent_namespaceObject, "createOrUpdateFromRings", function() {
          return createOrUpdateFromRings;
        });
        __webpack_require__.d(extent_namespaceObject, "equals", function() {
          return equals;
        });
        __webpack_require__.d(extent_namespaceObject, "approximatelyEquals", function() {
          return approximatelyEquals;
        });
        __webpack_require__.d(extent_namespaceObject, "extend", function() {
          return extend2;
        });
        __webpack_require__.d(extent_namespaceObject, "extendCoordinate", function() {
          return extendCoordinate;
        });
        __webpack_require__.d(extent_namespaceObject, "extendCoordinates", function() {
          return extendCoordinates;
        });
        __webpack_require__.d(extent_namespaceObject, "extendFlatCoordinates", function() {
          return extendFlatCoordinates;
        });
        __webpack_require__.d(extent_namespaceObject, "extendRings", function() {
          return extendRings;
        });
        __webpack_require__.d(extent_namespaceObject, "extendXY", function() {
          return extendXY;
        });
        __webpack_require__.d(extent_namespaceObject, "forEachCorner", function() {
          return forEachCorner;
        });
        __webpack_require__.d(extent_namespaceObject, "getArea", function() {
          return getArea;
        });
        __webpack_require__.d(extent_namespaceObject, "getBottomLeft", function() {
          return getBottomLeft;
        });
        __webpack_require__.d(extent_namespaceObject, "getBottomRight", function() {
          return getBottomRight;
        });
        __webpack_require__.d(extent_namespaceObject, "getCenter", function() {
          return extent_getCenter;
        });
        __webpack_require__.d(extent_namespaceObject, "getCorner", function() {
          return getCorner;
        });
        __webpack_require__.d(extent_namespaceObject, "getEnlargedArea", function() {
          return getEnlargedArea;
        });
        __webpack_require__.d(extent_namespaceObject, "getForViewAndSize", function() {
          return getForViewAndSize;
        });
        __webpack_require__.d(extent_namespaceObject, "getHeight", function() {
          return getHeight;
        });
        __webpack_require__.d(extent_namespaceObject, "getIntersectionArea", function() {
          return getIntersectionArea;
        });
        __webpack_require__.d(extent_namespaceObject, "getIntersection", function() {
          return getIntersection;
        });
        __webpack_require__.d(extent_namespaceObject, "getMargin", function() {
          return getMargin;
        });
        __webpack_require__.d(extent_namespaceObject, "getSize", function() {
          return getSize;
        });
        __webpack_require__.d(extent_namespaceObject, "getTopLeft", function() {
          return getTopLeft;
        });
        __webpack_require__.d(extent_namespaceObject, "getTopRight", function() {
          return getTopRight;
        });
        __webpack_require__.d(extent_namespaceObject, "getWidth", function() {
          return getWidth;
        });
        __webpack_require__.d(extent_namespaceObject, "intersects", function() {
          return extent_intersects;
        });
        __webpack_require__.d(extent_namespaceObject, "isEmpty", function() {
          return extent_isEmpty;
        });
        __webpack_require__.d(extent_namespaceObject, "returnOrUpdate", function() {
          return returnOrUpdate;
        });
        __webpack_require__.d(extent_namespaceObject, "scaleFromCenter", function() {
          return scaleFromCenter;
        });
        __webpack_require__.d(extent_namespaceObject, "intersectsSegment", function() {
          return intersectsSegment;
        });
        __webpack_require__.d(extent_namespaceObject, "applyTransform", function() {
          return applyTransform;
        });
        __webpack_require__.d(extent_namespaceObject, "wrapX", function() {
          return extent_wrapX;
        });
        var easing_namespaceObject = {};
        __webpack_require__.r(easing_namespaceObject);
        __webpack_require__.d(easing_namespaceObject, "easeIn", function() {
          return easeIn;
        });
        __webpack_require__.d(easing_namespaceObject, "easeOut", function() {
          return easeOut;
        });
        __webpack_require__.d(easing_namespaceObject, "inAndOut", function() {
          return inAndOut;
        });
        __webpack_require__.d(easing_namespaceObject, "linear", function() {
          return linear;
        });
        __webpack_require__.d(easing_namespaceObject, "upAndDown", function() {
          return upAndDown;
        });
        var condition_namespaceObject = {};
        __webpack_require__.r(condition_namespaceObject);
        __webpack_require__.d(condition_namespaceObject, "all", function() {
          return condition_all;
        });
        __webpack_require__.d(condition_namespaceObject, "altKeyOnly", function() {
          return altKeyOnly;
        });
        __webpack_require__.d(condition_namespaceObject, "altShiftKeysOnly", function() {
          return altShiftKeysOnly;
        });
        __webpack_require__.d(condition_namespaceObject, "focus", function() {
          return condition_focus;
        });
        __webpack_require__.d(condition_namespaceObject, "focusWithTabindex", function() {
          return focusWithTabindex;
        });
        __webpack_require__.d(condition_namespaceObject, "always", function() {
          return always;
        });
        __webpack_require__.d(condition_namespaceObject, "click", function() {
          return click;
        });
        __webpack_require__.d(condition_namespaceObject, "mouseActionButton", function() {
          return mouseActionButton;
        });
        __webpack_require__.d(condition_namespaceObject, "never", function() {
          return never;
        });
        __webpack_require__.d(condition_namespaceObject, "pointerMove", function() {
          return pointerMove;
        });
        __webpack_require__.d(condition_namespaceObject, "singleClick", function() {
          return singleClick;
        });
        __webpack_require__.d(condition_namespaceObject, "doubleClick", function() {
          return doubleClick;
        });
        __webpack_require__.d(condition_namespaceObject, "noModifierKeys", function() {
          return noModifierKeys;
        });
        __webpack_require__.d(condition_namespaceObject, "platformModifierKeyOnly", function() {
          return platformModifierKeyOnly;
        });
        __webpack_require__.d(condition_namespaceObject, "shiftKeyOnly", function() {
          return shiftKeyOnly;
        });
        __webpack_require__.d(condition_namespaceObject, "targetNotEditable", function() {
          return targetNotEditable;
        });
        __webpack_require__.d(condition_namespaceObject, "mouseOnly", function() {
          return mouseOnly;
        });
        __webpack_require__.d(condition_namespaceObject, "touchOnly", function() {
          return touchOnly;
        });
        __webpack_require__.d(condition_namespaceObject, "penOnly", function() {
          return penOnly;
        });
        __webpack_require__.d(condition_namespaceObject, "primaryAction", function() {
          return primaryAction;
        });
        var map_namespaceObject = {};
        __webpack_require__.r(map_namespaceObject);
        __webpack_require__.d(map_namespaceObject, "default", function() {
          return components_map;
        });
        __webpack_require__.d(map_namespaceObject, "install", function() {
          return install;
        });
        __webpack_require__.d(map_namespaceObject, "Map", function() {
          return map_Map;
        });
        __webpack_require__.d(map_namespaceObject, "View", function() {
          return map_View;
        });
        __webpack_require__.d(map_namespaceObject, "Feature", function() {
          return map_Feature;
        });
        __webpack_require__.d(map_namespaceObject, "Overlay", function() {
          return map_Overlay;
        });
        __webpack_require__.d(map_namespaceObject, "GeoLocation", function() {
          return GeoLocation;
        });
        __webpack_require__.d(map_namespaceObject, "Projection", function() {
          return map_Projection;
        });
        var loadingstrategy_namespaceObject = {};
        __webpack_require__.r(loadingstrategy_namespaceObject);
        __webpack_require__.d(loadingstrategy_namespaceObject, "all", function() {
          return loadingstrategy_all;
        });
        __webpack_require__.d(loadingstrategy_namespaceObject, "bbox", function() {
          return loadingstrategy_bbox;
        });
        __webpack_require__.d(loadingstrategy_namespaceObject, "tile", function() {
          return loadingstrategy_tile;
        });
        var layers_namespaceObject = {};
        __webpack_require__.r(layers_namespaceObject);
        __webpack_require__.d(layers_namespaceObject, "default", function() {
          return components_layers;
        });
        __webpack_require__.d(layers_namespaceObject, "install", function() {
          return layers_install;
        });
        __webpack_require__.d(layers_namespaceObject, "TileLayer", function() {
          return layers_TileLayer;
        });
        __webpack_require__.d(layers_namespaceObject, "ImageLayer", function() {
          return layers_ImageLayer;
        });
        __webpack_require__.d(layers_namespaceObject, "VectorLayer", function() {
          return layers_VectorLayer;
        });
        __webpack_require__.d(layers_namespaceObject, "AnimatedClusterLayer", function() {
          return AnimatedClusterLayer;
        });
        var sources_namespaceObject = {};
        __webpack_require__.r(sources_namespaceObject);
        __webpack_require__.d(sources_namespaceObject, "default", function() {
          return components_sources;
        });
        __webpack_require__.d(sources_namespaceObject, "install", function() {
          return sources_install;
        });
        __webpack_require__.d(sources_namespaceObject, "SourceXYZ", function() {
          return SourceXYZ;
        });
        __webpack_require__.d(sources_namespaceObject, "SourceOSM", function() {
          return SourceOSM;
        });
        __webpack_require__.d(sources_namespaceObject, "SourceImageStatic", function() {
          return SourceImageStatic;
        });
        __webpack_require__.d(sources_namespaceObject, "SourceWMTS", function() {
          return SourceWMTS;
        });
        __webpack_require__.d(sources_namespaceObject, "SourceVector", function() {
          return SourceVector;
        });
        __webpack_require__.d(sources_namespaceObject, "SourceCluster", function() {
          return SourceCluster;
        });
        __webpack_require__.d(sources_namespaceObject, "SourceTianDiTu", function() {
          return SourceTianDiTu;
        });
        __webpack_require__.d(sources_namespaceObject, "SourceImageWMS", function() {
          return SourceImageWMS;
        });
        var mapControls_namespaceObject = {};
        __webpack_require__.r(mapControls_namespaceObject);
        __webpack_require__.d(mapControls_namespaceObject, "default", function() {
          return mapControls;
        });
        __webpack_require__.d(mapControls_namespaceObject, "install", function() {
          return mapControls_install;
        });
        __webpack_require__.d(mapControls_namespaceObject, "FullScreenControl", function() {
          return FullScreenControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "MousePositionControl", function() {
          return MousePositionControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "AttributionControl", function() {
          return AttributionControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "OverviewMapControl", function() {
          return OverviewMapControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "ScaleLineControl", function() {
          return ScaleLineControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "ZoomControl", function() {
          return ZoomControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "ZoomSliderControl", function() {
          return ZoomSliderControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "ZoomToExtentControl", function() {
          return ZoomToExtentControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "ContextMenuControl", function() {
          return ContextMenuControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "SwipeControl", function() {
          return SwipeControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "ControlBar", function() {
          return ControlBar;
        });
        __webpack_require__.d(mapControls_namespaceObject, "ToggleControl", function() {
          return ToggleControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "ButtonControl", function() {
          return ButtonControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "PrintDialog", function() {
          return mapControls_PrintDialog;
        });
        __webpack_require__.d(mapControls_namespaceObject, "VideoRecorderControl", function() {
          return VideoRecorderControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "LayerSwitcherControl", function() {
          return LayerSwitcherControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "LayerSwitcherImageControl", function() {
          return LayerSwitcherImageControl;
        });
        __webpack_require__.d(mapControls_namespaceObject, "ZoneControl", function() {
          return ZoneControl;
        });
        var geometries_namespaceObject = {};
        __webpack_require__.r(geometries_namespaceObject);
        __webpack_require__.d(geometries_namespaceObject, "default", function() {
          return components_geometries;
        });
        __webpack_require__.d(geometries_namespaceObject, "install", function() {
          return geometries_install;
        });
        __webpack_require__.d(geometries_namespaceObject, "Point", function() {
          return geometries_Point;
        });
        __webpack_require__.d(geometries_namespaceObject, "LineString", function() {
          return geometries_LineString;
        });
        __webpack_require__.d(geometries_namespaceObject, "Polygon", function() {
          return geometries_Polygon;
        });
        __webpack_require__.d(geometries_namespaceObject, "MultiPoint", function() {
          return geometries_MultiPoint;
        });
        __webpack_require__.d(geometries_namespaceObject, "MultiLineString", function() {
          return geometries_MultiLineString;
        });
        __webpack_require__.d(geometries_namespaceObject, "MultiPolygon", function() {
          return geometries_MultiPolygon;
        });
        var styles_namespaceObject = {};
        __webpack_require__.r(styles_namespaceObject);
        __webpack_require__.d(styles_namespaceObject, "default", function() {
          return components_styles;
        });
        __webpack_require__.d(styles_namespaceObject, "install", function() {
          return styles_install;
        });
        __webpack_require__.d(styles_namespaceObject, "Style", function() {
          return styles_Style;
        });
        __webpack_require__.d(styles_namespaceObject, "Stroke", function() {
          return styles_Stroke;
        });
        __webpack_require__.d(styles_namespaceObject, "Fill", function() {
          return styles_Fill;
        });
        __webpack_require__.d(styles_namespaceObject, "Icon", function() {
          return styles_Icon;
        });
        __webpack_require__.d(styles_namespaceObject, "Text", function() {
          return styles_Text;
        });
        __webpack_require__.d(styles_namespaceObject, "FlowLine", function() {
          return styles_FlowLine;
        });
        var components_interaction_namespaceObject = {};
        __webpack_require__.r(components_interaction_namespaceObject);
        __webpack_require__.d(components_interaction_namespaceObject, "default", function() {
          return components_interaction;
        });
        __webpack_require__.d(components_interaction_namespaceObject, "install", function() {
          return interaction_install;
        });
        __webpack_require__.d(components_interaction_namespaceObject, "SelectInteraction", function() {
          return SelectInteraction;
        });
        __webpack_require__.d(components_interaction_namespaceObject, "ClusterSelectInteraction", function() {
          return ClusterSelectInteraction;
        });
        __webpack_require__.d(components_interaction_namespaceObject, "DrawInteraction", function() {
          return DrawInteraction;
        });
        __webpack_require__.d(components_interaction_namespaceObject, "SnapInteraction", function() {
          return SnapInteraction;
        });
        __webpack_require__.d(components_interaction_namespaceObject, "ModifyInteraction", function() {
          return ModifyInteraction;
        });
        __webpack_require__.d(components_interaction_namespaceObject, "TransformInteraction", function() {
          return TransformInteraction;
        });
        __webpack_require__.d(components_interaction_namespaceObject, "DragRotateAndZoomInteraction", function() {
          return DragRotateAndZoomInteraction;
        });
        var animations_namespaceObject = {};
        __webpack_require__.r(animations_namespaceObject);
        __webpack_require__.d(animations_namespaceObject, "default", function() {
          return animations;
        });
        __webpack_require__.d(animations_namespaceObject, "install", function() {
          return animations_install;
        });
        __webpack_require__.d(animations_namespaceObject, "FeatureAnimation", function() {
          return FeatureAnimation;
        });
        __webpack_require__.d(animations_namespaceObject, "DropAnimation", function() {
          return DropAnimation;
        });
        __webpack_require__.d(animations_namespaceObject, "ShakeAnimation", function() {
          return ShakeAnimation;
        });
        __webpack_require__.d(animations_namespaceObject, "ZoomAnimation", function() {
          return ZoomAnimation;
        });
        __webpack_require__.d(animations_namespaceObject, "TeleportAnimation", function() {
          return TeleportAnimation;
        });
        __webpack_require__.d(animations_namespaceObject, "FadeAnimation", function() {
          return FadeAnimation;
        });
        __webpack_require__.d(animations_namespaceObject, "PathAnimation", function() {
          return PathAnimation;
        });
        __webpack_require__.d(animations_namespaceObject, "SlideAnimation", function() {
          return SlideAnimation;
        });
        var geom_namespaceObject = {};
        __webpack_require__.r(geom_namespaceObject);
        __webpack_require__.d(geom_namespaceObject, "Circle", function() {
          return geom_Circle;
        });
        __webpack_require__.d(geom_namespaceObject, "Geometry", function() {
          return geom_Geometry;
        });
        __webpack_require__.d(geom_namespaceObject, "GeometryCollection", function() {
          return geom_GeometryCollection;
        });
        __webpack_require__.d(geom_namespaceObject, "LinearRing", function() {
          return geom_LinearRing;
        });
        __webpack_require__.d(geom_namespaceObject, "LineString", function() {
          return geom_LineString;
        });
        __webpack_require__.d(geom_namespaceObject, "MultiLineString", function() {
          return geom_MultiLineString;
        });
        __webpack_require__.d(geom_namespaceObject, "MultiPoint", function() {
          return geom_MultiPoint;
        });
        __webpack_require__.d(geom_namespaceObject, "MultiPolygon", function() {
          return geom_MultiPolygon;
        });
        __webpack_require__.d(geom_namespaceObject, "Point", function() {
          return geom_Point;
        });
        __webpack_require__.d(geom_namespaceObject, "Polygon", function() {
          return geom_Polygon;
        });
        __webpack_require__.d(geom_namespaceObject, "SimpleGeometry", function() {
          return geom_SimpleGeometry;
        });
        var format_namespaceObject = {};
        __webpack_require__.r(format_namespaceObject);
        __webpack_require__.d(format_namespaceObject, "EsriJSON", function() {
          return format_EsriJSON;
        });
        __webpack_require__.d(format_namespaceObject, "GeoJSON", function() {
          return format_GeoJSON;
        });
        __webpack_require__.d(format_namespaceObject, "GML", function() {
          return format_GML;
        });
        __webpack_require__.d(format_namespaceObject, "GPX", function() {
          return format_GPX;
        });
        __webpack_require__.d(format_namespaceObject, "IGC", function() {
          return format_IGC;
        });
        __webpack_require__.d(format_namespaceObject, "IIIFInfo", function() {
          return format_IIIFInfo;
        });
        __webpack_require__.d(format_namespaceObject, "KML", function() {
          return format_KML;
        });
        __webpack_require__.d(format_namespaceObject, "MVT", function() {
          return format_MVT;
        });
        __webpack_require__.d(format_namespaceObject, "OWS", function() {
          return format_OWS;
        });
        __webpack_require__.d(format_namespaceObject, "Polyline", function() {
          return format_Polyline;
        });
        __webpack_require__.d(format_namespaceObject, "TopoJSON", function() {
          return format_TopoJSON;
        });
        __webpack_require__.d(format_namespaceObject, "WFS", function() {
          return format_WFS;
        });
        __webpack_require__.d(format_namespaceObject, "WKB", function() {
          return format_WKB;
        });
        __webpack_require__.d(format_namespaceObject, "WKT", function() {
          return format_WKT;
        });
        __webpack_require__.d(format_namespaceObject, "WMSCapabilities", function() {
          return format_WMSCapabilities;
        });
        __webpack_require__.d(format_namespaceObject, "WMSGetFeatureInfo", function() {
          return format_WMSGetFeatureInfo;
        });
        __webpack_require__.d(format_namespaceObject, "WMTSCapabilities", function() {
          return format_WMTSCapabilities;
        });
        if (typeof window !== "undefined") {
          var currentScript = window.document.currentScript;
          if (true) {
            var getCurrentScript = __webpack_require__("8875");
            currentScript = getCurrentScript();
            if (!("currentScript" in document)) {
              Object.defineProperty(document, "currentScript", { get: getCurrentScript });
            }
          }
          var setPublicPath_src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
          if (setPublicPath_src) {
            __webpack_require__.p = setPublicPath_src[1];
          }
        }
        var setPublicPath = null;
        var es_function_name = __webpack_require__("b0c0");
        var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
        function Mapvue_type_template_id_39e43851_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", {
            ref: function ref(el) {
              return $setup.mapRef = el;
            }
          }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")], 512);
        }
        var es_number_constructor = __webpack_require__("a9e3");
        var Disposable = __webpack_require__("da5c");
        var functions = __webpack_require__("57cb");
        var util = __webpack_require__("1300");
        var has = __webpack_require__("617d");
        var __extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var AssertionError_AssertionError = function(_super) {
          __extends(AssertionError, _super);
          function AssertionError(code) {
            var _this = this;
            var path = util["a"] === "latest" ? util["a"] : "v" + util["a"].split("-")[0];
            var message = "Assertion failed. See https://openlayers.org/en/" + path + "/doc/errors/#" + code + " for details.";
            _this = _super.call(this, message) || this;
            _this.code = code;
            _this.name = "AssertionError";
            _this.message = message;
            return _this;
          }
          return AssertionError;
        }(Error);
        var ol_AssertionError = AssertionError_AssertionError;
        function assert2(assertion, errorCode) {
          if (!assertion) {
            throw new ol_AssertionError(errorCode);
          }
        }
        var tmp_ = new Array(6);
        function create() {
          return [1, 0, 0, 1, 0, 0];
        }
        function transform_reset(transform2) {
          return transform_set(transform2, 1, 0, 0, 1, 0, 0);
        }
        function multiply(transform1, transform2) {
          var a1 = transform1[0];
          var b1 = transform1[1];
          var c1 = transform1[2];
          var d1 = transform1[3];
          var e1 = transform1[4];
          var f1 = transform1[5];
          var a2 = transform2[0];
          var b2 = transform2[1];
          var c2 = transform2[2];
          var d2 = transform2[3];
          var e2 = transform2[4];
          var f2 = transform2[5];
          transform1[0] = a1 * a2 + c1 * b2;
          transform1[1] = b1 * a2 + d1 * b2;
          transform1[2] = a1 * c2 + c1 * d2;
          transform1[3] = b1 * c2 + d1 * d2;
          transform1[4] = a1 * e2 + c1 * f2 + e1;
          transform1[5] = b1 * e2 + d1 * f2 + f1;
          return transform1;
        }
        function transform_set(transform2, a, b, c, d, e, f) {
          transform2[0] = a;
          transform2[1] = b;
          transform2[2] = c;
          transform2[3] = d;
          transform2[4] = e;
          transform2[5] = f;
          return transform2;
        }
        function setFromArray(transform1, transform2) {
          transform1[0] = transform2[0];
          transform1[1] = transform2[1];
          transform1[2] = transform2[2];
          transform1[3] = transform2[3];
          transform1[4] = transform2[4];
          transform1[5] = transform2[5];
          return transform1;
        }
        function apply(transform2, coordinate) {
          var x = coordinate[0];
          var y = coordinate[1];
          coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
          coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
          return coordinate;
        }
        function rotate(transform2, angle) {
          var cos = Math.cos(angle);
          var sin = Math.sin(angle);
          return multiply(transform2, transform_set(tmp_, cos, sin, -sin, cos, 0, 0));
        }
        function transform_scale(transform2, x, y) {
          return multiply(transform2, transform_set(tmp_, x, 0, 0, y, 0, 0));
        }
        function makeScale(target, x, y) {
          return transform_set(target, x, 0, 0, y, 0, 0);
        }
        function transform_translate(transform2, dx, dy) {
          return multiply(transform2, transform_set(tmp_, 1, 0, 0, 1, dx, dy));
        }
        function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
          var sin = Math.sin(angle);
          var cos = Math.cos(angle);
          transform2[0] = sx * cos;
          transform2[1] = sy * sin;
          transform2[2] = -sx * sin;
          transform2[3] = sy * cos;
          transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
          transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
          return transform2;
        }
        function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
          return transform_toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
        }
        function invert(source) {
          return makeInverse(source, source);
        }
        function makeInverse(target, source) {
          var det = determinant(source);
          assert2(det !== 0, 32);
          var a = source[0];
          var b = source[1];
          var c = source[2];
          var d = source[3];
          var e = source[4];
          var f = source[5];
          target[0] = d / det;
          target[1] = -b / det;
          target[2] = -c / det;
          target[3] = a / det;
          target[4] = (c * f - d * e) / det;
          target[5] = -(a * f - b * e) / det;
          return target;
        }
        function determinant(mat) {
          return mat[0] * mat[3] - mat[1] * mat[2];
        }
        var transformStringDiv;
        function transform_toString(mat) {
          var transformString = "matrix(" + mat.join(", ") + ")";
          if (has["g"]) {
            return transformString;
          }
          var node = transformStringDiv || (transformStringDiv = document.createElement("div"));
          node.style.transform = transformString;
          return node.style.transform;
        }
        var Corner = {
          BOTTOM_LEFT: "bottom-left",
          BOTTOM_RIGHT: "bottom-right",
          TOP_LEFT: "top-left",
          TOP_RIGHT: "top-right"
        };
        var Relationship = {
          UNKNOWN: 0,
          INTERSECTING: 1,
          ABOVE: 2,
          RIGHT: 4,
          BELOW: 8,
          LEFT: 16
        };
        function boundingExtent(coordinates) {
          var extent = createEmpty();
          for (var i = 0, ii = coordinates.length; i < ii; ++i) {
            extendCoordinate(extent, coordinates[i]);
          }
          return extent;
        }
        function _boundingExtentXYs(xs, ys, opt_extent) {
          var minX = Math.min.apply(null, xs);
          var minY = Math.min.apply(null, ys);
          var maxX = Math.max.apply(null, xs);
          var maxY = Math.max.apply(null, ys);
          return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
        }
        function extent_buffer(extent, value, opt_extent) {
          if (opt_extent) {
            opt_extent[0] = extent[0] - value;
            opt_extent[1] = extent[1] - value;
            opt_extent[2] = extent[2] + value;
            opt_extent[3] = extent[3] + value;
            return opt_extent;
          } else {
            return [
              extent[0] - value,
              extent[1] - value,
              extent[2] + value,
              extent[3] + value
            ];
          }
        }
        function clone(extent, opt_extent) {
          if (opt_extent) {
            opt_extent[0] = extent[0];
            opt_extent[1] = extent[1];
            opt_extent[2] = extent[2];
            opt_extent[3] = extent[3];
            return opt_extent;
          } else {
            return extent.slice();
          }
        }
        function closestSquaredDistanceXY(extent, x, y) {
          var dx, dy;
          if (x < extent[0]) {
            dx = extent[0] - x;
          } else if (extent[2] < x) {
            dx = x - extent[2];
          } else {
            dx = 0;
          }
          if (y < extent[1]) {
            dy = extent[1] - y;
          } else if (extent[3] < y) {
            dy = y - extent[3];
          } else {
            dy = 0;
          }
          return dx * dx + dy * dy;
        }
        function containsCoordinate(extent, coordinate) {
          return containsXY(extent, coordinate[0], coordinate[1]);
        }
        function containsExtent(extent1, extent2) {
          return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
        }
        function containsXY(extent, x, y) {
          return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
        }
        function coordinateRelationship(extent, coordinate) {
          var minX = extent[0];
          var minY = extent[1];
          var maxX = extent[2];
          var maxY = extent[3];
          var x = coordinate[0];
          var y = coordinate[1];
          var relationship = Relationship.UNKNOWN;
          if (x < minX) {
            relationship = relationship | Relationship.LEFT;
          } else if (x > maxX) {
            relationship = relationship | Relationship.RIGHT;
          }
          if (y < minY) {
            relationship = relationship | Relationship.BELOW;
          } else if (y > maxY) {
            relationship = relationship | Relationship.ABOVE;
          }
          if (relationship === Relationship.UNKNOWN) {
            relationship = Relationship.INTERSECTING;
          }
          return relationship;
        }
        function createEmpty() {
          return [Infinity, Infinity, -Infinity, -Infinity];
        }
        function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
          if (opt_extent) {
            opt_extent[0] = minX;
            opt_extent[1] = minY;
            opt_extent[2] = maxX;
            opt_extent[3] = maxY;
            return opt_extent;
          } else {
            return [minX, minY, maxX, maxY];
          }
        }
        function createOrUpdateEmpty(opt_extent) {
          return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
        }
        function createOrUpdateFromCoordinate(coordinate, opt_extent) {
          var x = coordinate[0];
          var y = coordinate[1];
          return createOrUpdate(x, y, x, y, opt_extent);
        }
        function createOrUpdateFromCoordinates(coordinates, opt_extent) {
          var extent = createOrUpdateEmpty(opt_extent);
          return extendCoordinates(extent, coordinates);
        }
        function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
          var extent = createOrUpdateEmpty(opt_extent);
          return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
        }
        function createOrUpdateFromRings(rings, opt_extent) {
          var extent = createOrUpdateEmpty(opt_extent);
          return extendRings(extent, rings);
        }
        function equals(extent1, extent2) {
          return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
        }
        function approximatelyEquals(extent1, extent2, tolerance) {
          return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
        }
        function extend2(extent1, extent2) {
          if (extent2[0] < extent1[0]) {
            extent1[0] = extent2[0];
          }
          if (extent2[2] > extent1[2]) {
            extent1[2] = extent2[2];
          }
          if (extent2[1] < extent1[1]) {
            extent1[1] = extent2[1];
          }
          if (extent2[3] > extent1[3]) {
            extent1[3] = extent2[3];
          }
          return extent1;
        }
        function extendCoordinate(extent, coordinate) {
          if (coordinate[0] < extent[0]) {
            extent[0] = coordinate[0];
          }
          if (coordinate[0] > extent[2]) {
            extent[2] = coordinate[0];
          }
          if (coordinate[1] < extent[1]) {
            extent[1] = coordinate[1];
          }
          if (coordinate[1] > extent[3]) {
            extent[3] = coordinate[1];
          }
        }
        function extendCoordinates(extent, coordinates) {
          for (var i = 0, ii = coordinates.length; i < ii; ++i) {
            extendCoordinate(extent, coordinates[i]);
          }
          return extent;
        }
        function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
          for (; offset < end; offset += stride) {
            extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
          }
          return extent;
        }
        function extendRings(extent, rings) {
          for (var i = 0, ii = rings.length; i < ii; ++i) {
            extendCoordinates(extent, rings[i]);
          }
          return extent;
        }
        function extendXY(extent, x, y) {
          extent[0] = Math.min(extent[0], x);
          extent[1] = Math.min(extent[1], y);
          extent[2] = Math.max(extent[2], x);
          extent[3] = Math.max(extent[3], y);
        }
        function forEachCorner(extent, callback) {
          var val;
          val = callback(getBottomLeft(extent));
          if (val) {
            return val;
          }
          val = callback(getBottomRight(extent));
          if (val) {
            return val;
          }
          val = callback(getTopRight(extent));
          if (val) {
            return val;
          }
          val = callback(getTopLeft(extent));
          if (val) {
            return val;
          }
          return false;
        }
        function getArea(extent) {
          var area = 0;
          if (!extent_isEmpty(extent)) {
            area = getWidth(extent) * getHeight(extent);
          }
          return area;
        }
        function getBottomLeft(extent) {
          return [extent[0], extent[1]];
        }
        function getBottomRight(extent) {
          return [extent[2], extent[1]];
        }
        function extent_getCenter(extent) {
          return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
        }
        function getCorner(extent, corner) {
          var coordinate;
          if (corner === Corner.BOTTOM_LEFT) {
            coordinate = getBottomLeft(extent);
          } else if (corner === Corner.BOTTOM_RIGHT) {
            coordinate = getBottomRight(extent);
          } else if (corner === Corner.TOP_LEFT) {
            coordinate = getTopLeft(extent);
          } else if (corner === Corner.TOP_RIGHT) {
            coordinate = getTopRight(extent);
          } else {
            assert2(false, 13);
          }
          return coordinate;
        }
        function getEnlargedArea(extent1, extent2) {
          var minX = Math.min(extent1[0], extent2[0]);
          var minY = Math.min(extent1[1], extent2[1]);
          var maxX = Math.max(extent1[2], extent2[2]);
          var maxY = Math.max(extent1[3], extent2[3]);
          return (maxX - minX) * (maxY - minY);
        }
        function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
          var dx = resolution * size[0] / 2;
          var dy = resolution * size[1] / 2;
          var cosRotation = Math.cos(rotation);
          var sinRotation = Math.sin(rotation);
          var xCos = dx * cosRotation;
          var xSin = dx * sinRotation;
          var yCos = dy * cosRotation;
          var ySin = dy * sinRotation;
          var x = center[0];
          var y = center[1];
          var x0 = x - xCos + ySin;
          var x1 = x - xCos - ySin;
          var x2 = x + xCos - ySin;
          var x3 = x + xCos + ySin;
          var y0 = y - xSin - yCos;
          var y1 = y - xSin + yCos;
          var y2 = y + xSin + yCos;
          var y3 = y + xSin - yCos;
          return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
        }
        function getHeight(extent) {
          return extent[3] - extent[1];
        }
        function getIntersectionArea(extent1, extent2) {
          var intersection = getIntersection(extent1, extent2);
          return getArea(intersection);
        }
        function getIntersection(extent1, extent2, opt_extent) {
          var intersection = opt_extent ? opt_extent : createEmpty();
          if (extent_intersects(extent1, extent2)) {
            if (extent1[0] > extent2[0]) {
              intersection[0] = extent1[0];
            } else {
              intersection[0] = extent2[0];
            }
            if (extent1[1] > extent2[1]) {
              intersection[1] = extent1[1];
            } else {
              intersection[1] = extent2[1];
            }
            if (extent1[2] < extent2[2]) {
              intersection[2] = extent1[2];
            } else {
              intersection[2] = extent2[2];
            }
            if (extent1[3] < extent2[3]) {
              intersection[3] = extent1[3];
            } else {
              intersection[3] = extent2[3];
            }
          } else {
            createOrUpdateEmpty(intersection);
          }
          return intersection;
        }
        function getMargin(extent) {
          return getWidth(extent) + getHeight(extent);
        }
        function getSize(extent) {
          return [extent[2] - extent[0], extent[3] - extent[1]];
        }
        function getTopLeft(extent) {
          return [extent[0], extent[3]];
        }
        function getTopRight(extent) {
          return [extent[2], extent[3]];
        }
        function getWidth(extent) {
          return extent[2] - extent[0];
        }
        function extent_intersects(extent1, extent2) {
          return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
        }
        function extent_isEmpty(extent) {
          return extent[2] < extent[0] || extent[3] < extent[1];
        }
        function returnOrUpdate(extent, opt_extent) {
          if (opt_extent) {
            opt_extent[0] = extent[0];
            opt_extent[1] = extent[1];
            opt_extent[2] = extent[2];
            opt_extent[3] = extent[3];
            return opt_extent;
          } else {
            return extent;
          }
        }
        function scaleFromCenter(extent, value) {
          var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
          var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
          extent[0] -= deltaX;
          extent[2] += deltaX;
          extent[1] -= deltaY;
          extent[3] += deltaY;
        }
        function intersectsSegment(extent, start, end) {
          var intersects = false;
          var startRel = coordinateRelationship(extent, start);
          var endRel = coordinateRelationship(extent, end);
          if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {
            intersects = true;
          } else {
            var minX = extent[0];
            var minY = extent[1];
            var maxX = extent[2];
            var maxY = extent[3];
            var startX = start[0];
            var startY = start[1];
            var endX = end[0];
            var endY = end[1];
            var slope = (endY - startY) / (endX - startX);
            var x = void 0, y = void 0;
            if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
              x = endX - (endY - maxY) / slope;
              intersects = x >= minX && x <= maxX;
            }
            if (!intersects && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {
              y = endY - (endX - maxX) * slope;
              intersects = y >= minY && y <= maxY;
            }
            if (!intersects && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {
              x = endX - (endY - minY) / slope;
              intersects = x >= minX && x <= maxX;
            }
            if (!intersects && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {
              y = endY - (endX - minX) * slope;
              intersects = y >= minY && y <= maxY;
            }
          }
          return intersects;
        }
        function applyTransform(extent, transformFn, opt_extent, opt_stops) {
          var coordinates = [];
          if (opt_stops > 1) {
            var width = extent[2] - extent[0];
            var height = extent[3] - extent[1];
            for (var i = 0; i < opt_stops; ++i) {
              coordinates.push(extent[0] + width * i / opt_stops, extent[1], extent[2], extent[1] + height * i / opt_stops, extent[2] - width * i / opt_stops, extent[3], extent[0], extent[3] - height * i / opt_stops);
            }
          } else {
            coordinates = [
              extent[0],
              extent[1],
              extent[2],
              extent[1],
              extent[2],
              extent[3],
              extent[0],
              extent[3]
            ];
          }
          transformFn(coordinates, coordinates, 2);
          var xs = [];
          var ys = [];
          for (var i = 0, l = coordinates.length; i < l; i += 2) {
            xs.push(coordinates[i]);
            ys.push(coordinates[i + 1]);
          }
          return _boundingExtentXYs(xs, ys, opt_extent);
        }
        function extent_wrapX(extent, projection) {
          var projectionExtent = projection.getExtent();
          var center = extent_getCenter(extent);
          if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
            var worldWidth = getWidth(projectionExtent);
            var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
            var offset = worldsAway * worldWidth;
            extent[0] -= offset;
            extent[2] -= offset;
          }
          return extent;
        }
        function clamp(value, min, max) {
          return Math.min(Math.max(value, min), max);
        }
        var cosh = function() {
          var cosh2;
          if ("cosh" in Math) {
            cosh2 = Math.cosh;
          } else {
            cosh2 = function(x) {
              var y = Math.exp(x);
              return (y + 1 / y) / 2;
            };
          }
          return cosh2;
        }();
        var log2 = function() {
          var log22;
          if ("log2" in Math) {
            log22 = Math.log2;
          } else {
            log22 = function(x) {
              return Math.log(x) * Math.LOG2E;
            };
          }
          return log22;
        }();
        function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
          var dx = x2 - x1;
          var dy = y2 - y1;
          if (dx !== 0 || dy !== 0) {
            var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
            if (t > 1) {
              x1 = x2;
              y1 = y2;
            } else if (t > 0) {
              x1 += dx * t;
              y1 += dy * t;
            }
          }
          return math_squaredDistance(x, y, x1, y1);
        }
        function math_squaredDistance(x1, y1, x2, y2) {
          var dx = x2 - x1;
          var dy = y2 - y1;
          return dx * dx + dy * dy;
        }
        function solveLinearSystem(mat) {
          var n = mat.length;
          for (var i = 0; i < n; i++) {
            var maxRow = i;
            var maxEl = Math.abs(mat[i][i]);
            for (var r = i + 1; r < n; r++) {
              var absValue = Math.abs(mat[r][i]);
              if (absValue > maxEl) {
                maxEl = absValue;
                maxRow = r;
              }
            }
            if (maxEl === 0) {
              return null;
            }
            var tmp = mat[maxRow];
            mat[maxRow] = mat[i];
            mat[i] = tmp;
            for (var j = i + 1; j < n; j++) {
              var coef = -mat[j][i] / mat[i][i];
              for (var k = i; k < n + 1; k++) {
                if (i == k) {
                  mat[j][k] = 0;
                } else {
                  mat[j][k] += coef * mat[i][k];
                }
              }
            }
          }
          var x = new Array(n);
          for (var l = n - 1; l >= 0; l--) {
            x[l] = mat[l][n] / mat[l][l];
            for (var m = l - 1; m >= 0; m--) {
              mat[m][n] -= mat[m][l] * x[l];
            }
          }
          return x;
        }
        function toDegrees(angleInRadians) {
          return angleInRadians * 180 / Math.PI;
        }
        function toRadians(angleInDegrees) {
          return angleInDegrees * Math.PI / 180;
        }
        function modulo(a, b) {
          var r = a % b;
          return r * b < 0 ? r + b : r;
        }
        function lerp(a, b, x) {
          return a + x * (b - a);
        }
        function toFixed(n, decimals) {
          var factor = Math.pow(10, decimals);
          return Math.round(n * factor) / factor;
        }
        function round(n, decimals) {
          return Math.round(toFixed(n, decimals));
        }
        function floor(n, decimals) {
          return Math.floor(toFixed(n, decimals));
        }
        function ceil(n, decimals) {
          return Math.ceil(toFixed(n, decimals));
        }
        var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
        var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
        function asString(color) {
          if (typeof color === "string") {
            return color;
          } else {
            return color_toString(color);
          }
        }
        function fromNamed(color) {
          var el = document.createElement("div");
          el.style.color = color;
          if (el.style.color !== "") {
            document.body.appendChild(el);
            var rgb = getComputedStyle(el).color;
            document.body.removeChild(el);
            return rgb;
          } else {
            return "";
          }
        }
        var fromString = function() {
          var MAX_CACHE_SIZE = 1024;
          var cache = {};
          var cacheSize = 0;
          return function(s) {
            var color;
            if (cache.hasOwnProperty(s)) {
              color = cache[s];
            } else {
              if (cacheSize >= MAX_CACHE_SIZE) {
                var i = 0;
                for (var key in cache) {
                  if ((i++ & 3) === 0) {
                    delete cache[key];
                    --cacheSize;
                  }
                }
              }
              color = fromStringInternal_(s);
              cache[s] = color;
              ++cacheSize;
            }
            return color;
          };
        }();
        function asArray(color) {
          if (Array.isArray(color)) {
            return color;
          } else {
            return fromString(color);
          }
        }
        function fromStringInternal_(s) {
          var r, g, b, a, color;
          if (NAMED_COLOR_RE_.exec(s)) {
            s = fromNamed(s);
          }
          if (HEX_COLOR_RE_.exec(s)) {
            var n = s.length - 1;
            var d = void 0;
            if (n <= 4) {
              d = 1;
            } else {
              d = 2;
            }
            var hasAlpha = n === 4 || n === 8;
            r = parseInt(s.substr(1 + 0 * d, d), 16);
            g = parseInt(s.substr(1 + 1 * d, d), 16);
            b = parseInt(s.substr(1 + 2 * d, d), 16);
            if (hasAlpha) {
              a = parseInt(s.substr(1 + 3 * d, d), 16);
            } else {
              a = 255;
            }
            if (d == 1) {
              r = (r << 4) + r;
              g = (g << 4) + g;
              b = (b << 4) + b;
              if (hasAlpha) {
                a = (a << 4) + a;
              }
            }
            color = [r, g, b, a / 255];
          } else if (s.indexOf("rgba(") == 0) {
            color = s.slice(5, -1).split(",").map(Number);
            normalize(color);
          } else if (s.indexOf("rgb(") == 0) {
            color = s.slice(4, -1).split(",").map(Number);
            color.push(1);
            normalize(color);
          } else {
            assert2(false, 14);
          }
          return color;
        }
        function normalize(color) {
          color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
          color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
          color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
          color[3] = clamp(color[3], 0, 1);
          return color;
        }
        function color_toString(color) {
          var r = color[0];
          if (r != (r | 0)) {
            r = r + 0.5 | 0;
          }
          var g = color[1];
          if (g != (g | 0)) {
            g = g + 0.5 | 0;
          }
          var b = color[2];
          if (b != (b | 0)) {
            b = b + 0.5 | 0;
          }
          var a = color[3] === void 0 ? 1 : Math.round(color[3] * 100) / 100;
          return "rgba(" + r + "," + g + "," + b + "," + a + ")";
        }
        function isStringColor(s) {
          if (NAMED_COLOR_RE_.test(s)) {
            s = fromNamed(s);
          }
          return HEX_COLOR_RE_.test(s) || s.indexOf("rgba(") === 0 || s.indexOf("rgb(") === 0;
        }
        var IconImageCache = function() {
          function IconImageCache2() {
            this.cache_ = {};
            this.cacheSize_ = 0;
            this.maxCacheSize_ = 32;
          }
          IconImageCache2.prototype.clear = function() {
            this.cache_ = {};
            this.cacheSize_ = 0;
          };
          IconImageCache2.prototype.canExpireCache = function() {
            return this.cacheSize_ > this.maxCacheSize_;
          };
          IconImageCache2.prototype.expire = function() {
            if (this.canExpireCache()) {
              var i = 0;
              for (var key in this.cache_) {
                var iconImage = this.cache_[key];
                if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                  delete this.cache_[key];
                  --this.cacheSize_;
                }
              }
            }
          };
          IconImageCache2.prototype.get = function(src, crossOrigin, color) {
            var key = getKey(src, crossOrigin, color);
            return key in this.cache_ ? this.cache_[key] : null;
          };
          IconImageCache2.prototype.set = function(src, crossOrigin, color, iconImage) {
            var key = getKey(src, crossOrigin, color);
            this.cache_[key] = iconImage;
            ++this.cacheSize_;
          };
          IconImageCache2.prototype.setSize = function(maxCacheSize) {
            this.maxCacheSize_ = maxCacheSize;
            this.expire();
          };
          return IconImageCache2;
        }();
        function getKey(src, crossOrigin, color) {
          var colorString = color ? asString(color) : "null";
          return crossOrigin + ":" + src + ":" + colorString;
        }
        var style_IconImageCache = IconImageCache;
        var shared = new IconImageCache();
        var ol_Object = __webpack_require__("e269");
        var Property = {
          OPACITY: "opacity",
          VISIBLE: "visible",
          EXTENT: "extent",
          Z_INDEX: "zIndex",
          MAX_RESOLUTION: "maxResolution",
          MIN_RESOLUTION: "minResolution",
          MAX_ZOOM: "maxZoom",
          MIN_ZOOM: "minZoom",
          SOURCE: "source",
          MAP: "map"
        };
        var ol_obj = __webpack_require__("38f3");
        var Base_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Base_BaseLayer = function(_super) {
          Base_extends(BaseLayer, _super);
          function BaseLayer(options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.background_ = options.background;
            var properties = Object(ol_obj["a"])({}, options);
            if (typeof options.properties === "object") {
              delete properties.properties;
              Object(ol_obj["a"])(properties, options.properties);
            }
            properties[Property.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
            assert2(typeof properties[Property.OPACITY] === "number", 64);
            properties[Property.VISIBLE] = options.visible !== void 0 ? options.visible : true;
            properties[Property.Z_INDEX] = options.zIndex;
            properties[Property.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
            properties[Property.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
            properties[Property.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
            properties[Property.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
            _this.className_ = properties.className !== void 0 ? options.className : "ol-layer";
            delete properties.className;
            _this.setProperties(properties);
            _this.state_ = null;
            return _this;
          }
          BaseLayer.prototype.getBackground = function() {
            return this.background_;
          };
          BaseLayer.prototype.getClassName = function() {
            return this.className_;
          };
          BaseLayer.prototype.getLayerState = function(opt_managed) {
            var state = this.state_ || {
              layer: this,
              managed: opt_managed === void 0 ? true : opt_managed
            };
            var zIndex = this.getZIndex();
            state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
            state.sourceState = this.getSourceState();
            state.visible = this.getVisible();
            state.extent = this.getExtent();
            state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
            state.maxResolution = this.getMaxResolution();
            state.minResolution = Math.max(this.getMinResolution(), 0);
            state.minZoom = this.getMinZoom();
            state.maxZoom = this.getMaxZoom();
            this.state_ = state;
            return state;
          };
          BaseLayer.prototype.getLayersArray = function(opt_array) {
            return Object(util["b"])();
          };
          BaseLayer.prototype.getLayerStatesArray = function(opt_states) {
            return Object(util["b"])();
          };
          BaseLayer.prototype.getExtent = function() {
            return this.get(Property.EXTENT);
          };
          BaseLayer.prototype.getMaxResolution = function() {
            return this.get(Property.MAX_RESOLUTION);
          };
          BaseLayer.prototype.getMinResolution = function() {
            return this.get(Property.MIN_RESOLUTION);
          };
          BaseLayer.prototype.getMinZoom = function() {
            return this.get(Property.MIN_ZOOM);
          };
          BaseLayer.prototype.getMaxZoom = function() {
            return this.get(Property.MAX_ZOOM);
          };
          BaseLayer.prototype.getOpacity = function() {
            return this.get(Property.OPACITY);
          };
          BaseLayer.prototype.getSourceState = function() {
            return Object(util["b"])();
          };
          BaseLayer.prototype.getVisible = function() {
            return this.get(Property.VISIBLE);
          };
          BaseLayer.prototype.getZIndex = function() {
            return this.get(Property.Z_INDEX);
          };
          BaseLayer.prototype.setBackground = function(opt_background) {
            this.background_ = opt_background;
            this.changed();
          };
          BaseLayer.prototype.setExtent = function(extent) {
            this.set(Property.EXTENT, extent);
          };
          BaseLayer.prototype.setMaxResolution = function(maxResolution) {
            this.set(Property.MAX_RESOLUTION, maxResolution);
          };
          BaseLayer.prototype.setMinResolution = function(minResolution) {
            this.set(Property.MIN_RESOLUTION, minResolution);
          };
          BaseLayer.prototype.setMaxZoom = function(maxZoom) {
            this.set(Property.MAX_ZOOM, maxZoom);
          };
          BaseLayer.prototype.setMinZoom = function(minZoom) {
            this.set(Property.MIN_ZOOM, minZoom);
          };
          BaseLayer.prototype.setOpacity = function(opacity) {
            assert2(typeof opacity === "number", 64);
            this.set(Property.OPACITY, opacity);
          };
          BaseLayer.prototype.setVisible = function(visible) {
            this.set(Property.VISIBLE, visible);
          };
          BaseLayer.prototype.setZIndex = function(zindex) {
            this.set(Property.Z_INDEX, zindex);
          };
          BaseLayer.prototype.disposeInternal = function() {
            if (this.state_) {
              this.state_.layer = null;
              this.state_ = null;
            }
            _super.prototype.disposeInternal.call(this);
          };
          return BaseLayer;
        }(ol_Object["a"]);
        var Base = Base_BaseLayer;
        var EventType = __webpack_require__("01d4");
        var render_EventType = {
          PRERENDER: "prerender",
          POSTRENDER: "postrender",
          PRECOMPOSE: "precompose",
          POSTCOMPOSE: "postcompose",
          RENDERCOMPLETE: "rendercomplete"
        };
        var State = {
          UNDEFINED: "undefined",
          LOADING: "loading",
          READY: "ready",
          ERROR: "error"
        };
        var events = __webpack_require__("1e8d");
        var Layer_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Layer_Layer = function(_super) {
          Layer_extends(Layer, _super);
          function Layer(options) {
            var _this = this;
            var baseOptions = Object(ol_obj["a"])({}, options);
            delete baseOptions.source;
            _this = _super.call(this, baseOptions) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.mapPrecomposeKey_ = null;
            _this.mapRenderKey_ = null;
            _this.sourceChangeKey_ = null;
            _this.renderer_ = null;
            if (options.render) {
              _this.render = options.render;
            }
            if (options.map) {
              _this.setMap(options.map);
            }
            _this.addChangeListener(Property.SOURCE, _this.handleSourcePropertyChange_);
            var source = options.source ? options.source : null;
            _this.setSource(source);
            return _this;
          }
          Layer.prototype.getLayersArray = function(opt_array) {
            var array = opt_array ? opt_array : [];
            array.push(this);
            return array;
          };
          Layer.prototype.getLayerStatesArray = function(opt_states) {
            var states = opt_states ? opt_states : [];
            states.push(this.getLayerState());
            return states;
          };
          Layer.prototype.getSource = function() {
            return this.get(Property.SOURCE) || null;
          };
          Layer.prototype.getSourceState = function() {
            var source = this.getSource();
            return !source ? State.UNDEFINED : source.getState();
          };
          Layer.prototype.handleSourceChange_ = function() {
            this.changed();
          };
          Layer.prototype.handleSourcePropertyChange_ = function() {
            if (this.sourceChangeKey_) {
              Object(events["c"])(this.sourceChangeKey_);
              this.sourceChangeKey_ = null;
            }
            var source = this.getSource();
            if (source) {
              this.sourceChangeKey_ = Object(events["a"])(source, EventType["a"].CHANGE, this.handleSourceChange_, this);
            }
            this.changed();
          };
          Layer.prototype.getFeatures = function(pixel) {
            if (!this.renderer_) {
              return new Promise(function(resolve) {
                return resolve([]);
              });
            }
            return this.renderer_.getFeatures(pixel);
          };
          Layer.prototype.render = function(frameState, target) {
            var layerRenderer = this.getRenderer();
            if (layerRenderer.prepareFrame(frameState)) {
              return layerRenderer.renderFrame(frameState, target);
            }
          };
          Layer.prototype.setMapInternal = function(map) {
            this.set(Property.MAP, map);
          };
          Layer.prototype.getMapInternal = function() {
            return this.get(Property.MAP);
          };
          Layer.prototype.setMap = function(map) {
            if (this.mapPrecomposeKey_) {
              Object(events["c"])(this.mapPrecomposeKey_);
              this.mapPrecomposeKey_ = null;
            }
            if (!map) {
              this.changed();
            }
            if (this.mapRenderKey_) {
              Object(events["c"])(this.mapRenderKey_);
              this.mapRenderKey_ = null;
            }
            if (map) {
              this.mapPrecomposeKey_ = Object(events["a"])(map, render_EventType.PRECOMPOSE, function(evt) {
                var renderEvent = evt;
                var layerStatesArray = renderEvent.frameState.layerStatesArray;
                var layerState = this.getLayerState(false);
                assert2(!layerStatesArray.some(function(arrayLayerState) {
                  return arrayLayerState.layer === layerState.layer;
                }), 67);
                layerStatesArray.push(layerState);
              }, this);
              this.mapRenderKey_ = Object(events["a"])(this, EventType["a"].CHANGE, map.render, map);
              this.changed();
            }
          };
          Layer.prototype.setSource = function(source) {
            this.set(Property.SOURCE, source);
          };
          Layer.prototype.getRenderer = function() {
            if (!this.renderer_) {
              this.renderer_ = this.createRenderer();
            }
            return this.renderer_;
          };
          Layer.prototype.hasRenderer = function() {
            return !!this.renderer_;
          };
          Layer.prototype.createRenderer = function() {
            return null;
          };
          Layer.prototype.disposeInternal = function() {
            if (this.renderer_) {
              this.renderer_.dispose();
              delete this.renderer_;
            }
            this.setSource(null);
            _super.prototype.disposeInternal.call(this);
          };
          return Layer;
        }(Base);
        function inView(layerState, viewState) {
          if (!layerState.visible) {
            return false;
          }
          var resolution = viewState.resolution;
          if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
            return false;
          }
          var zoom = viewState.zoom;
          return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
        }
        var layer_Layer = Layer_Layer;
        function padNumber(number, width, opt_precision) {
          var numberString = opt_precision !== void 0 ? number.toFixed(opt_precision) : "" + number;
          var decimal = numberString.indexOf(".");
          decimal = decimal === -1 ? numberString.length : decimal;
          return decimal > width ? numberString : new Array(1 + width - decimal).join("0") + numberString;
        }
        function compareVersions(v1, v2) {
          var s1 = ("" + v1).split(".");
          var s2 = ("" + v2).split(".");
          for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
            var n1 = parseInt(s1[i] || "0", 10);
            var n2 = parseInt(s2[i] || "0", 10);
            if (n1 > n2) {
              return 1;
            }
            if (n2 > n1) {
              return -1;
            }
          }
          return 0;
        }
        function coordinate_add(coordinate, delta) {
          coordinate[0] += +delta[0];
          coordinate[1] += +delta[1];
          return coordinate;
        }
        function closestOnCircle(coordinate, circle) {
          var r = circle.getRadius();
          var center = circle.getCenter();
          var x0 = center[0];
          var y0 = center[1];
          var x1 = coordinate[0];
          var y1 = coordinate[1];
          var dx = x1 - x0;
          var dy = y1 - y0;
          if (dx === 0 && dy === 0) {
            dx = 1;
          }
          var d = Math.sqrt(dx * dx + dy * dy);
          var x = x0 + r * dx / d;
          var y = y0 + r * dy / d;
          return [x, y];
        }
        function closestOnSegment(coordinate, segment) {
          var x0 = coordinate[0];
          var y0 = coordinate[1];
          var start = segment[0];
          var end = segment[1];
          var x1 = start[0];
          var y1 = start[1];
          var x2 = end[0];
          var y2 = end[1];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
          var x, y;
          if (along <= 0) {
            x = x1;
            y = y1;
          } else if (along >= 1) {
            x = x2;
            y = y2;
          } else {
            x = x1 + along * dx;
            y = y1 + along * dy;
          }
          return [x, y];
        }
        function createStringXY(opt_fractionDigits) {
          return function(coordinate) {
            return toStringXY(coordinate, opt_fractionDigits);
          };
        }
        function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
          var normalizedDegrees = modulo(degrees + 180, 360) - 180;
          var x = Math.abs(3600 * normalizedDegrees);
          var dflPrecision = opt_fractionDigits || 0;
          var precision = Math.pow(10, dflPrecision);
          var deg = Math.floor(x / 3600);
          var min = Math.floor((x - deg * 3600) / 60);
          var sec = x - deg * 3600 - min * 60;
          sec = Math.ceil(sec * precision) / precision;
          if (sec >= 60) {
            sec = 0;
            min += 1;
          }
          if (min >= 60) {
            min = 0;
            deg += 1;
          }
          return deg + "\xB0 " + padNumber(min, 2) + "\u2032 " + padNumber(sec, 2, dflPrecision) + "\u2033" + (normalizedDegrees == 0 ? "" : " " + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
        }
        function coordinate_format(coordinate, template, opt_fractionDigits) {
          if (coordinate) {
            return template.replace("{x}", coordinate[0].toFixed(opt_fractionDigits)).replace("{y}", coordinate[1].toFixed(opt_fractionDigits));
          } else {
            return "";
          }
        }
        function coordinate_equals(coordinate1, coordinate2) {
          var equals2 = true;
          for (var i = coordinate1.length - 1; i >= 0; --i) {
            if (coordinate1[i] != coordinate2[i]) {
              equals2 = false;
              break;
            }
          }
          return equals2;
        }
        function coordinate_rotate(coordinate, angle) {
          var cosAngle = Math.cos(angle);
          var sinAngle = Math.sin(angle);
          var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
          var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
          coordinate[0] = x;
          coordinate[1] = y;
          return coordinate;
        }
        function coordinate_scale(coordinate, scale) {
          coordinate[0] *= scale;
          coordinate[1] *= scale;
          return coordinate;
        }
        function coordinate_squaredDistance(coord1, coord2) {
          var dx = coord1[0] - coord2[0];
          var dy = coord1[1] - coord2[1];
          return dx * dx + dy * dy;
        }
        function coordinate_distance(coord1, coord2) {
          return Math.sqrt(coordinate_squaredDistance(coord1, coord2));
        }
        function squaredDistanceToSegment(coordinate, segment) {
          return coordinate_squaredDistance(coordinate, closestOnSegment(coordinate, segment));
        }
        function toStringHDMS(coordinate, opt_fractionDigits) {
          if (coordinate) {
            return degreesToStringHDMS("NS", coordinate[1], opt_fractionDigits) + " " + degreesToStringHDMS("EW", coordinate[0], opt_fractionDigits);
          } else {
            return "";
          }
        }
        function toStringXY(coordinate, opt_fractionDigits) {
          return coordinate_format(coordinate, "{x}, {y}", opt_fractionDigits);
        }
        function coordinate_wrapX(coordinate, projection) {
          if (projection.canWrapX()) {
            var worldWidth = getWidth(projection.getExtent());
            var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
            if (worldsAway) {
              coordinate[0] -= worldsAway * worldWidth;
            }
          }
          return coordinate;
        }
        function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
          var projectionExtent = projection.getExtent();
          var worldsAway = 0;
          if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
            var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);
            worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
          }
          return worldsAway;
        }
        var Map_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Map_MapRenderer = function(_super) {
          Map_extends(MapRenderer, _super);
          function MapRenderer(map) {
            var _this = _super.call(this) || this;
            _this.map_ = map;
            return _this;
          }
          MapRenderer.prototype.dispatchRenderEvent = function(type, frameState) {
            Object(util["b"])();
          };
          MapRenderer.prototype.calculateMatrices2D = function(frameState) {
            var viewState = frameState.viewState;
            var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
            var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
            compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
            makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
          };
          MapRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
            var result;
            var viewState = frameState.viewState;
            function forEachFeatureAtCoordinate(managed, feature, layer2, geometry) {
              return callback.call(thisArg, feature, managed ? layer2 : null, geometry);
            }
            var projection = viewState.projection;
            var translatedCoordinate = coordinate_wrapX(coordinate.slice(), projection);
            var offsets = [[0, 0]];
            if (projection.canWrapX() && checkWrapped) {
              var projectionExtent = projection.getExtent();
              var worldWidth = getWidth(projectionExtent);
              offsets.push([-worldWidth, 0], [worldWidth, 0]);
            }
            var layerStates = frameState.layerStatesArray;
            var numLayers = layerStates.length;
            var matches = [];
            var tmpCoord = [];
            for (var i = 0; i < offsets.length; i++) {
              for (var j = numLayers - 1; j >= 0; --j) {
                var layerState = layerStates[j];
                var layer = layerState.layer;
                if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
                  var layerRenderer = layer.getRenderer();
                  var source = layer.getSource();
                  if (layerRenderer && source) {
                    var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
                    var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                    tmpCoord[0] = coordinates[0] + offsets[i][0];
                    tmpCoord[1] = coordinates[1] + offsets[i][1];
                    result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);
                  }
                  if (result) {
                    return result;
                  }
                }
              }
            }
            if (matches.length === 0) {
              return void 0;
            }
            var order = 1 / matches.length;
            matches.forEach(function(m, i2) {
              return m.distanceSq += i2 * order;
            });
            matches.sort(function(a, b) {
              return a.distanceSq - b.distanceSq;
            });
            matches.some(function(m) {
              return result = m.callback(m.feature, m.layer, m.geometry);
            });
            return result;
          };
          MapRenderer.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {
            return Object(util["b"])();
          };
          MapRenderer.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
            var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, functions["b"], this, layerFilter, thisArg);
            return hasFeature !== void 0;
          };
          MapRenderer.prototype.getMap = function() {
            return this.map_;
          };
          MapRenderer.prototype.renderFrame = function(frameState) {
            Object(util["b"])();
          };
          MapRenderer.prototype.scheduleExpireIconCache = function(frameState) {
            if (shared.canExpireCache()) {
              frameState.postRenderFunctions.push(expireIconCache);
            }
          };
          return MapRenderer;
        }(Disposable["a"]);
        function expireIconCache(map, frameState) {
          shared.expire();
        }
        var renderer_Map = Map_MapRenderer;
        var ObjectEventType = __webpack_require__("7b4f");
        var events_Event = __webpack_require__("cef7");
        var Event_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var RenderEvent = function(_super) {
          Event_extends(RenderEvent2, _super);
          function RenderEvent2(type, opt_inversePixelTransform, opt_frameState, opt_context) {
            var _this = _super.call(this, type) || this;
            _this.inversePixelTransform = opt_inversePixelTransform;
            _this.frameState = opt_frameState;
            _this.context = opt_context;
            return _this;
          }
          return RenderEvent2;
        }(events_Event["a"]);
        var render_Event = RenderEvent;
        var CLASS_HIDDEN = "ol-hidden";
        var CLASS_SELECTABLE = "ol-selectable";
        var CLASS_UNSELECTABLE = "ol-unselectable";
        var CLASS_UNSUPPORTED = "ol-unsupported";
        var CLASS_CONTROL = "ol-control";
        var CLASS_COLLAPSED = "ol-collapsed";
        var fontRegEx = new RegExp([
          "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
          "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
          "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
          "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
          "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
          "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
          `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
        ].join(""), "i");
        var fontRegExMatchIndex = [
          "style",
          "variant",
          "weight",
          "size",
          "lineHeight",
          "family"
        ];
        var getFontParameters = function(fontSpec) {
          var match = fontSpec.match(fontRegEx);
          if (!match) {
            return null;
          }
          var style = {
            lineHeight: "normal",
            size: "1.2em",
            style: "normal",
            weight: "normal",
            variant: "normal"
          };
          for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
            var value = match[i + 1];
            if (value !== void 0) {
              style[fontRegExMatchIndex[i]] = value;
            }
          }
          style.families = style.family.split(/,\s?/);
          return style;
        };
        function cssOpacity(opacity) {
          return opacity === 1 ? "" : String(Math.round(opacity * 100) / 100);
        }
        var Target = __webpack_require__("0ec0");
        var dom = __webpack_require__("0999");
        var defaultFont = "10px sans-serif";
        var defaultFillStyle = "#000";
        var defaultLineCap = "round";
        var defaultLineDash = [];
        var defaultLineDashOffset = 0;
        var defaultLineJoin = "round";
        var defaultMiterLimit = 10;
        var defaultStrokeStyle = "#000";
        var defaultTextAlign = "center";
        var defaultTextBaseline = "middle";
        var defaultPadding = [0, 0, 0, 0];
        var defaultLineWidth = 1;
        var checkedFonts = new ol_Object["a"]();
        var labelCache = new Target["a"]();
        labelCache.setSize = function() {
          console.warn("labelCache is deprecated.");
        };
        var measureContext = null;
        var measureFont;
        var textHeights = {};
        var registerFont = function() {
          var retries = 100;
          var size = "32px ";
          var referenceFonts = ["monospace", "serif"];
          var len = referenceFonts.length;
          var text = "wmytzilWMYTZIL@#/&?$%10\uF013";
          var interval, referenceWidth;
          function isAvailable(fontStyle, fontWeight, fontFamily) {
            var available = true;
            for (var i = 0; i < len; ++i) {
              var referenceFont = referenceFonts[i];
              referenceWidth = measureTextWidth(fontStyle + " " + fontWeight + " " + size + referenceFont, text);
              if (fontFamily != referenceFont) {
                var width = measureTextWidth(fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont, text);
                available = available && width != referenceWidth;
              }
            }
            if (available) {
              return true;
            }
            return false;
          }
          function check() {
            var done = true;
            var fonts = checkedFonts.getKeys();
            for (var i = 0, ii = fonts.length; i < ii; ++i) {
              var font = fonts[i];
              if (checkedFonts.get(font) < retries) {
                if (isAvailable.apply(this, font.split("\n"))) {
                  Object(ol_obj["b"])(textHeights);
                  measureContext = null;
                  measureFont = void 0;
                  checkedFonts.set(font, retries);
                } else {
                  checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                  done = false;
                }
              }
            }
            if (done) {
              clearInterval(interval);
              interval = void 0;
            }
          }
          return function(fontSpec) {
            var font = getFontParameters(fontSpec);
            if (!font) {
              return;
            }
            var families = font.families;
            for (var i = 0, ii = families.length; i < ii; ++i) {
              var family = families[i];
              var key = font.style + "\n" + font.weight + "\n" + family;
              if (checkedFonts.get(key) === void 0) {
                checkedFonts.set(key, retries, true);
                if (!isAvailable(font.style, font.weight, family)) {
                  checkedFonts.set(key, 0, true);
                  if (interval === void 0) {
                    interval = setInterval(check, 32);
                  }
                }
              }
            }
          };
        }();
        var measureTextHeight = function() {
          var measureElement;
          return function(fontSpec) {
            var height = textHeights[fontSpec];
            if (height == void 0) {
              if (has["g"]) {
                var font = getFontParameters(fontSpec);
                var metrics = measureText(fontSpec, "\u017Dg");
                var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
                height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
              } else {
                if (!measureElement) {
                  measureElement = document.createElement("div");
                  measureElement.innerHTML = "M";
                  measureElement.style.minHeight = "0";
                  measureElement.style.maxHeight = "none";
                  measureElement.style.height = "auto";
                  measureElement.style.padding = "0";
                  measureElement.style.border = "none";
                  measureElement.style.position = "absolute";
                  measureElement.style.display = "block";
                  measureElement.style.left = "-99999px";
                }
                measureElement.style.font = fontSpec;
                document.body.appendChild(measureElement);
                height = measureElement.offsetHeight;
                document.body.removeChild(measureElement);
              }
              textHeights[fontSpec] = height;
            }
            return height;
          };
        }();
        function measureText(font, text) {
          if (!measureContext) {
            measureContext = Object(dom["a"])(1, 1);
          }
          if (font != measureFont) {
            measureContext.font = font;
            measureFont = measureContext.font;
          }
          return measureContext.measureText(text);
        }
        function measureTextWidth(font, text) {
          return measureText(font, text).width;
        }
        function canvas_measureAndCacheTextWidth(font, text, cache) {
          if (text in cache) {
            return cache[text];
          }
          var width = measureTextWidth(font, text);
          cache[text] = width;
          return width;
        }
        function measureTextWidths(font, lines, widths) {
          var numLines = lines.length;
          var width = 0;
          for (var i = 0; i < numLines; ++i) {
            var currentWidth = measureTextWidth(font, lines[i]);
            width = Math.max(width, currentWidth);
            widths.push(currentWidth);
          }
          return width;
        }
        function rotateAtOffset(context, rotation, offsetX, offsetY) {
          if (rotation !== 0) {
            context.translate(offsetX, offsetY);
            context.rotate(rotation);
            context.translate(-offsetX, -offsetY);
          }
        }
        function drawImageOrLabel(context, transform2, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
          context.save();
          if (opacity !== 1) {
            context.globalAlpha *= opacity;
          }
          if (transform2) {
            context.setTransform.apply(context, transform2);
          }
          if (labelOrImage.contextInstructions) {
            context.translate(x, y);
            context.scale(scale[0], scale[1]);
            executeLabelInstructions(labelOrImage, context);
          } else if (scale[0] < 0 || scale[1] < 0) {
            context.translate(x, y);
            context.scale(scale[0], scale[1]);
            context.drawImage(labelOrImage, originX, originY, w, h, 0, 0, w, h);
          } else {
            context.drawImage(labelOrImage, originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
          }
          context.restore();
        }
        function executeLabelInstructions(label, context) {
          var contextInstructions = label.contextInstructions;
          for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
            if (Array.isArray(contextInstructions[i + 1])) {
              context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
            } else {
              context[contextInstructions[i]] = contextInstructions[i + 1];
            }
          }
        }
        var Composite_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Composite_CompositeMapRenderer = function(_super) {
          Composite_extends(CompositeMapRenderer, _super);
          function CompositeMapRenderer(map) {
            var _this = _super.call(this, map) || this;
            _this.fontChangeListenerKey_ = Object(events["a"])(checkedFonts, ObjectEventType["a"].PROPERTYCHANGE, map.redrawText.bind(map));
            _this.element_ = document.createElement("div");
            var style = _this.element_.style;
            style.position = "absolute";
            style.width = "100%";
            style.height = "100%";
            style.zIndex = "0";
            _this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
            var container = map.getViewport();
            container.insertBefore(_this.element_, container.firstChild || null);
            _this.children_ = [];
            _this.renderedVisible_ = true;
            return _this;
          }
          CompositeMapRenderer.prototype.dispatchRenderEvent = function(type, frameState) {
            var map = this.getMap();
            if (map.hasListener(type)) {
              var event_1 = new render_Event(type, void 0, frameState);
              map.dispatchEvent(event_1);
            }
          };
          CompositeMapRenderer.prototype.disposeInternal = function() {
            Object(events["c"])(this.fontChangeListenerKey_);
            this.element_.parentNode.removeChild(this.element_);
            _super.prototype.disposeInternal.call(this);
          };
          CompositeMapRenderer.prototype.renderFrame = function(frameState) {
            if (!frameState) {
              if (this.renderedVisible_) {
                this.element_.style.display = "none";
                this.renderedVisible_ = false;
              }
              return;
            }
            this.calculateMatrices2D(frameState);
            this.dispatchRenderEvent(render_EventType.PRECOMPOSE, frameState);
            var layerStatesArray = frameState.layerStatesArray.sort(function(a, b) {
              return a.zIndex - b.zIndex;
            });
            var viewState = frameState.viewState;
            this.children_.length = 0;
            var declutterLayers = [];
            var previousElement = null;
            for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layerState = layerStatesArray[i];
              frameState.layerIndex = i;
              if (!inView(layerState, viewState) || layerState.sourceState != State.READY && layerState.sourceState != State.UNDEFINED) {
                continue;
              }
              var layer = layerState.layer;
              var element = layer.render(frameState, previousElement);
              if (!element) {
                continue;
              }
              if (element !== previousElement) {
                this.children_.push(element);
                previousElement = element;
              }
              if ("getDeclutter" in layer) {
                declutterLayers.push(layer);
              }
            }
            for (var i = declutterLayers.length - 1; i >= 0; --i) {
              declutterLayers[i].renderDeclutter(frameState);
            }
            Object(dom["f"])(this.element_, this.children_);
            this.dispatchRenderEvent(render_EventType.POSTCOMPOSE, frameState);
            if (!this.renderedVisible_) {
              this.element_.style.display = "";
              this.renderedVisible_ = true;
            }
            this.scheduleExpireIconCache(frameState);
          };
          CompositeMapRenderer.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {
            var viewState = frameState.viewState;
            var layerStates = frameState.layerStatesArray;
            var numLayers = layerStates.length;
            for (var i = numLayers - 1; i >= 0; --i) {
              var layerState = layerStates[i];
              var layer = layerState.layer;
              if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter(layer)) {
                var layerRenderer = layer.getRenderer();
                var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);
                if (data) {
                  var result = callback(layer, data);
                  if (result) {
                    return result;
                  }
                }
              }
            }
            return void 0;
          };
          return CompositeMapRenderer;
        }(renderer_Map);
        var Composite = Composite_CompositeMapRenderer;
        var CollectionEventType = {
          ADD: "add",
          REMOVE: "remove"
        };
        var Collection_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Collection_Property = {
          LENGTH: "length"
        };
        var CollectionEvent = function(_super) {
          Collection_extends(CollectionEvent2, _super);
          function CollectionEvent2(type, opt_element, opt_index) {
            var _this = _super.call(this, type) || this;
            _this.element = opt_element;
            _this.index = opt_index;
            return _this;
          }
          return CollectionEvent2;
        }(events_Event["a"]);
        var Collection_Collection = function(_super) {
          Collection_extends(Collection, _super);
          function Collection(opt_array, opt_options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            var options = opt_options || {};
            _this.unique_ = !!options.unique;
            _this.array_ = opt_array ? opt_array : [];
            if (_this.unique_) {
              for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
                _this.assertUnique_(_this.array_[i], i);
              }
            }
            _this.updateLength_();
            return _this;
          }
          Collection.prototype.clear = function() {
            while (this.getLength() > 0) {
              this.pop();
            }
          };
          Collection.prototype.extend = function(arr) {
            for (var i = 0, ii = arr.length; i < ii; ++i) {
              this.push(arr[i]);
            }
            return this;
          };
          Collection.prototype.forEach = function(f) {
            var array = this.array_;
            for (var i = 0, ii = array.length; i < ii; ++i) {
              f(array[i], i, array);
            }
          };
          Collection.prototype.getArray = function() {
            return this.array_;
          };
          Collection.prototype.item = function(index) {
            return this.array_[index];
          };
          Collection.prototype.getLength = function() {
            return this.get(Collection_Property.LENGTH);
          };
          Collection.prototype.insertAt = function(index, elem) {
            if (this.unique_) {
              this.assertUnique_(elem);
            }
            this.array_.splice(index, 0, elem);
            this.updateLength_();
            this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
          };
          Collection.prototype.pop = function() {
            return this.removeAt(this.getLength() - 1);
          };
          Collection.prototype.push = function(elem) {
            if (this.unique_) {
              this.assertUnique_(elem);
            }
            var n = this.getLength();
            this.insertAt(n, elem);
            return this.getLength();
          };
          Collection.prototype.remove = function(elem) {
            var arr = this.array_;
            for (var i = 0, ii = arr.length; i < ii; ++i) {
              if (arr[i] === elem) {
                return this.removeAt(i);
              }
            }
            return void 0;
          };
          Collection.prototype.removeAt = function(index) {
            var prev = this.array_[index];
            this.array_.splice(index, 1);
            this.updateLength_();
            this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
            return prev;
          };
          Collection.prototype.setAt = function(index, elem) {
            var n = this.getLength();
            if (index < n) {
              if (this.unique_) {
                this.assertUnique_(elem, index);
              }
              var prev = this.array_[index];
              this.array_[index] = elem;
              this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
              this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
            } else {
              for (var j = n; j < index; ++j) {
                this.insertAt(j, void 0);
              }
              this.insertAt(index, elem);
            }
          };
          Collection.prototype.updateLength_ = function() {
            this.set(Collection_Property.LENGTH, this.array_.length);
          };
          Collection.prototype.assertUnique_ = function(elem, opt_except) {
            for (var i = 0, ii = this.array_.length; i < ii; ++i) {
              if (this.array_[i] === elem && i !== opt_except) {
                throw new ol_AssertionError(58);
              }
            }
          };
          return Collection;
        }(ol_Object["a"]);
        var ol_Collection = Collection_Collection;
        var Group_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GroupEvent = function(_super) {
          Group_extends(GroupEvent2, _super);
          function GroupEvent2(type, layer) {
            var _this = _super.call(this, type) || this;
            _this.layer = layer;
            return _this;
          }
          return GroupEvent2;
        }(events_Event["a"]);
        var Group_Property = {
          LAYERS: "layers"
        };
        var Group_LayerGroup = function(_super) {
          Group_extends(LayerGroup, _super);
          function LayerGroup(opt_options) {
            var _this = this;
            var options = opt_options || {};
            var baseOptions = Object(ol_obj["a"])({}, options);
            delete baseOptions.layers;
            var layers = options.layers;
            _this = _super.call(this, baseOptions) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.layersListenerKeys_ = [];
            _this.listenerKeys_ = {};
            _this.addChangeListener(Group_Property.LAYERS, _this.handleLayersChanged_);
            if (layers) {
              if (Array.isArray(layers)) {
                layers = new ol_Collection(layers.slice(), { unique: true });
              } else {
                assert2(typeof layers.getArray === "function", 43);
              }
            } else {
              layers = new ol_Collection(void 0, { unique: true });
            }
            _this.setLayers(layers);
            return _this;
          }
          LayerGroup.prototype.handleLayerChange_ = function() {
            this.changed();
          };
          LayerGroup.prototype.handleLayersChanged_ = function() {
            this.layersListenerKeys_.forEach(events["c"]);
            this.layersListenerKeys_.length = 0;
            var layers = this.getLayers();
            this.layersListenerKeys_.push(Object(events["a"])(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), Object(events["a"])(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));
            for (var id in this.listenerKeys_) {
              this.listenerKeys_[id].forEach(events["c"]);
            }
            Object(ol_obj["b"])(this.listenerKeys_);
            var layersArray = layers.getArray();
            for (var i = 0, ii = layersArray.length; i < ii; i++) {
              var layer = layersArray[i];
              this.registerLayerListeners_(layer);
              this.dispatchEvent(new GroupEvent("addlayer", layer));
            }
            this.changed();
          };
          LayerGroup.prototype.registerLayerListeners_ = function(layer) {
            var listenerKeys = [
              Object(events["a"])(layer, ObjectEventType["a"].PROPERTYCHANGE, this.handleLayerChange_, this),
              Object(events["a"])(layer, EventType["a"].CHANGE, this.handleLayerChange_, this)
            ];
            if (layer instanceof LayerGroup) {
              listenerKeys.push(Object(events["a"])(layer, "addlayer", this.handleLayerGroupAdd_, this), Object(events["a"])(layer, "removelayer", this.handleLayerGroupRemove_, this));
            }
            this.listenerKeys_[Object(util["c"])(layer)] = listenerKeys;
          };
          LayerGroup.prototype.handleLayerGroupAdd_ = function(event) {
            this.dispatchEvent(new GroupEvent("addlayer", event.layer));
          };
          LayerGroup.prototype.handleLayerGroupRemove_ = function(event) {
            this.dispatchEvent(new GroupEvent("removelayer", event.layer));
          };
          LayerGroup.prototype.handleLayersAdd_ = function(collectionEvent) {
            var layer = collectionEvent.element;
            this.registerLayerListeners_(layer);
            this.dispatchEvent(new GroupEvent("addlayer", layer));
            this.changed();
          };
          LayerGroup.prototype.handleLayersRemove_ = function(collectionEvent) {
            var layer = collectionEvent.element;
            var key = Object(util["c"])(layer);
            this.listenerKeys_[key].forEach(events["c"]);
            delete this.listenerKeys_[key];
            this.dispatchEvent(new GroupEvent("removelayer", layer));
            this.changed();
          };
          LayerGroup.prototype.getLayers = function() {
            return this.get(Group_Property.LAYERS);
          };
          LayerGroup.prototype.setLayers = function(layers) {
            var collection = this.getLayers();
            if (collection) {
              var currentLayers = collection.getArray();
              for (var i = 0, ii = currentLayers.length; i < ii; ++i) {
                this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
              }
            }
            this.set(Group_Property.LAYERS, layers);
          };
          LayerGroup.prototype.getLayersArray = function(opt_array) {
            var array = opt_array !== void 0 ? opt_array : [];
            this.getLayers().forEach(function(layer) {
              layer.getLayersArray(array);
            });
            return array;
          };
          LayerGroup.prototype.getLayerStatesArray = function(opt_states) {
            var states = opt_states !== void 0 ? opt_states : [];
            var pos = states.length;
            this.getLayers().forEach(function(layer) {
              layer.getLayerStatesArray(states);
            });
            var ownLayerState = this.getLayerState();
            var defaultZIndex = ownLayerState.zIndex;
            if (!opt_states && ownLayerState.zIndex === void 0) {
              defaultZIndex = 0;
            }
            for (var i = pos, ii = states.length; i < ii; i++) {
              var layerState = states[i];
              layerState.opacity *= ownLayerState.opacity;
              layerState.visible = layerState.visible && ownLayerState.visible;
              layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
              layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
              layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
              layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
              if (ownLayerState.extent !== void 0) {
                if (layerState.extent !== void 0) {
                  layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
                } else {
                  layerState.extent = ownLayerState.extent;
                }
              }
              if (layerState.zIndex === void 0) {
                layerState.zIndex = defaultZIndex;
              }
            }
            return states;
          };
          LayerGroup.prototype.getSourceState = function() {
            return State.READY;
          };
          return LayerGroup;
        }(Base);
        var Group = Group_LayerGroup;
        var MapEvent_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var MapEvent = function(_super) {
          MapEvent_extends(MapEvent2, _super);
          function MapEvent2(type, map, opt_frameState) {
            var _this = _super.call(this, type) || this;
            _this.map = map;
            _this.frameState = opt_frameState !== void 0 ? opt_frameState : null;
            return _this;
          }
          return MapEvent2;
        }(events_Event["a"]);
        var ol_MapEvent = MapEvent;
        var MapBrowserEvent_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var MapBrowserEvent = function(_super) {
          MapBrowserEvent_extends(MapBrowserEvent2, _super);
          function MapBrowserEvent2(type, map, originalEvent, opt_dragging, opt_frameState) {
            var _this = _super.call(this, type, map, opt_frameState) || this;
            _this.originalEvent = originalEvent;
            _this.pixel_ = null;
            _this.coordinate_ = null;
            _this.dragging = opt_dragging !== void 0 ? opt_dragging : false;
            return _this;
          }
          Object.defineProperty(MapBrowserEvent2.prototype, "pixel", {
            get: function() {
              if (!this.pixel_) {
                this.pixel_ = this.map.getEventPixel(this.originalEvent);
              }
              return this.pixel_;
            },
            set: function(pixel) {
              this.pixel_ = pixel;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(MapBrowserEvent2.prototype, "coordinate", {
            get: function() {
              if (!this.coordinate_) {
                this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
              }
              return this.coordinate_;
            },
            set: function(coordinate) {
              this.coordinate_ = coordinate;
            },
            enumerable: false,
            configurable: true
          });
          MapBrowserEvent2.prototype.preventDefault = function() {
            _super.prototype.preventDefault.call(this);
            if ("preventDefault" in this.originalEvent) {
              this.originalEvent.preventDefault();
            }
          };
          MapBrowserEvent2.prototype.stopPropagation = function() {
            _super.prototype.stopPropagation.call(this);
            if ("stopPropagation" in this.originalEvent) {
              this.originalEvent.stopPropagation();
            }
          };
          return MapBrowserEvent2;
        }(ol_MapEvent);
        var ol_MapBrowserEvent = MapBrowserEvent;
        var MapBrowserEventType = {
          SINGLECLICK: "singleclick",
          CLICK: EventType["a"].CLICK,
          DBLCLICK: EventType["a"].DBLCLICK,
          POINTERDRAG: "pointerdrag",
          POINTERMOVE: "pointermove",
          POINTERDOWN: "pointerdown",
          POINTERUP: "pointerup",
          POINTEROVER: "pointerover",
          POINTEROUT: "pointerout",
          POINTERENTER: "pointerenter",
          POINTERLEAVE: "pointerleave",
          POINTERCANCEL: "pointercancel"
        };
        var pointer_EventType = {
          POINTERMOVE: "pointermove",
          POINTERDOWN: "pointerdown",
          POINTERUP: "pointerup",
          POINTEROVER: "pointerover",
          POINTEROUT: "pointerout",
          POINTERENTER: "pointerenter",
          POINTERLEAVE: "pointerleave",
          POINTERCANCEL: "pointercancel"
        };
        var MapBrowserEventHandler_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var MapBrowserEventHandler_MapBrowserEventHandler = function(_super) {
          MapBrowserEventHandler_extends(MapBrowserEventHandler, _super);
          function MapBrowserEventHandler(map, moveTolerance) {
            var _this = _super.call(this, map) || this;
            _this.map_ = map;
            _this.clickTimeoutId_;
            _this.emulateClicks_ = false;
            _this.dragging_ = false;
            _this.dragListenerKeys_ = [];
            _this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
            _this.down_ = null;
            var element = _this.map_.getViewport();
            _this.activePointers_ = 0;
            _this.trackedTouches_ = {};
            _this.element_ = element;
            _this.pointerdownListenerKey_ = Object(events["a"])(element, pointer_EventType.POINTERDOWN, _this.handlePointerDown_, _this);
            _this.originalPointerMoveEvent_;
            _this.relayedListenerKey_ = Object(events["a"])(element, pointer_EventType.POINTERMOVE, _this.relayEvent_, _this);
            _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);
            _this.element_.addEventListener(EventType["a"].TOUCHMOVE, _this.boundHandleTouchMove_, has["e"] ? { passive: false } : false);
            return _this;
          }
          MapBrowserEventHandler.prototype.emulateClick_ = function(pointerEvent) {
            var newEvent = new ol_MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
            if (this.clickTimeoutId_ !== void 0) {
              clearTimeout(this.clickTimeoutId_);
              this.clickTimeoutId_ = void 0;
              newEvent = new ol_MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
              this.dispatchEvent(newEvent);
            } else {
              this.clickTimeoutId_ = setTimeout(function() {
                this.clickTimeoutId_ = void 0;
                var newEvent2 = new ol_MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
                this.dispatchEvent(newEvent2);
              }.bind(this), 250);
            }
          };
          MapBrowserEventHandler.prototype.updateActivePointers_ = function(pointerEvent) {
            var event = pointerEvent;
            if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {
              delete this.trackedTouches_[event.pointerId];
            } else if (event.type == MapBrowserEventType.POINTERDOWN) {
              this.trackedTouches_[event.pointerId] = true;
            }
            this.activePointers_ = Object.keys(this.trackedTouches_).length;
          };
          MapBrowserEventHandler.prototype.handlePointerUp_ = function(pointerEvent) {
            this.updateActivePointers_(pointerEvent);
            var newEvent = new ol_MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
            if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
              this.emulateClick_(this.down_);
            }
            if (this.activePointers_ === 0) {
              this.dragListenerKeys_.forEach(events["c"]);
              this.dragListenerKeys_.length = 0;
              this.dragging_ = false;
              this.down_ = null;
            }
          };
          MapBrowserEventHandler.prototype.isMouseActionButton_ = function(pointerEvent) {
            return pointerEvent.button === 0;
          };
          MapBrowserEventHandler.prototype.handlePointerDown_ = function(pointerEvent) {
            this.emulateClicks_ = this.activePointers_ === 0;
            this.updateActivePointers_(pointerEvent);
            var newEvent = new ol_MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
            this.down_ = {};
            for (var property in pointerEvent) {
              var value = pointerEvent[property];
              this.down_[property] = typeof value === "function" ? functions["c"] : value;
            }
            if (this.dragListenerKeys_.length === 0) {
              var doc = this.map_.getOwnerDocument();
              this.dragListenerKeys_.push(Object(events["a"])(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), Object(events["a"])(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), Object(events["a"])(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));
              if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
                this.dragListenerKeys_.push(Object(events["a"])(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));
              }
            }
          };
          MapBrowserEventHandler.prototype.handlePointerMove_ = function(pointerEvent) {
            if (this.isMoving_(pointerEvent)) {
              this.dragging_ = true;
              var newEvent = new ol_MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
              this.dispatchEvent(newEvent);
            }
          };
          MapBrowserEventHandler.prototype.relayEvent_ = function(pointerEvent) {
            this.originalPointerMoveEvent_ = pointerEvent;
            var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
            this.dispatchEvent(new ol_MapBrowserEvent(pointerEvent.type, this.map_, pointerEvent, dragging));
          };
          MapBrowserEventHandler.prototype.handleTouchMove_ = function(event) {
            var originalEvent = this.originalPointerMoveEvent_;
            if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
              event.preventDefault();
            }
          };
          MapBrowserEventHandler.prototype.isMoving_ = function(pointerEvent) {
            return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
          };
          MapBrowserEventHandler.prototype.disposeInternal = function() {
            if (this.relayedListenerKey_) {
              Object(events["c"])(this.relayedListenerKey_);
              this.relayedListenerKey_ = null;
            }
            this.element_.removeEventListener(EventType["a"].TOUCHMOVE, this.boundHandleTouchMove_);
            if (this.pointerdownListenerKey_) {
              Object(events["c"])(this.pointerdownListenerKey_);
              this.pointerdownListenerKey_ = null;
            }
            this.dragListenerKeys_.forEach(events["c"]);
            this.dragListenerKeys_.length = 0;
            this.element_ = null;
            _super.prototype.disposeInternal.call(this);
          };
          return MapBrowserEventHandler;
        }(Target["a"]);
        var ol_MapBrowserEventHandler = MapBrowserEventHandler_MapBrowserEventHandler;
        var MapEventType = __webpack_require__("592d");
        var MapProperty = {
          LAYERGROUP: "layergroup",
          SIZE: "size",
          TARGET: "target",
          VIEW: "view"
        };
        var DROP = Infinity;
        var PriorityQueue_PriorityQueue = function() {
          function PriorityQueue(priorityFunction, keyFunction) {
            this.priorityFunction_ = priorityFunction;
            this.keyFunction_ = keyFunction;
            this.elements_ = [];
            this.priorities_ = [];
            this.queuedElements_ = {};
          }
          PriorityQueue.prototype.clear = function() {
            this.elements_.length = 0;
            this.priorities_.length = 0;
            Object(ol_obj["b"])(this.queuedElements_);
          };
          PriorityQueue.prototype.dequeue = function() {
            var elements = this.elements_;
            var priorities = this.priorities_;
            var element = elements[0];
            if (elements.length == 1) {
              elements.length = 0;
              priorities.length = 0;
            } else {
              elements[0] = elements.pop();
              priorities[0] = priorities.pop();
              this.siftUp_(0);
            }
            var elementKey = this.keyFunction_(element);
            delete this.queuedElements_[elementKey];
            return element;
          };
          PriorityQueue.prototype.enqueue = function(element) {
            assert2(!(this.keyFunction_(element) in this.queuedElements_), 31);
            var priority = this.priorityFunction_(element);
            if (priority != DROP) {
              this.elements_.push(element);
              this.priorities_.push(priority);
              this.queuedElements_[this.keyFunction_(element)] = true;
              this.siftDown_(0, this.elements_.length - 1);
              return true;
            }
            return false;
          };
          PriorityQueue.prototype.getCount = function() {
            return this.elements_.length;
          };
          PriorityQueue.prototype.getLeftChildIndex_ = function(index) {
            return index * 2 + 1;
          };
          PriorityQueue.prototype.getRightChildIndex_ = function(index) {
            return index * 2 + 2;
          };
          PriorityQueue.prototype.getParentIndex_ = function(index) {
            return index - 1 >> 1;
          };
          PriorityQueue.prototype.heapify_ = function() {
            var i;
            for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
              this.siftUp_(i);
            }
          };
          PriorityQueue.prototype.isEmpty = function() {
            return this.elements_.length === 0;
          };
          PriorityQueue.prototype.isKeyQueued = function(key) {
            return key in this.queuedElements_;
          };
          PriorityQueue.prototype.isQueued = function(element) {
            return this.isKeyQueued(this.keyFunction_(element));
          };
          PriorityQueue.prototype.siftUp_ = function(index) {
            var elements = this.elements_;
            var priorities = this.priorities_;
            var count = elements.length;
            var element = elements[index];
            var priority = priorities[index];
            var startIndex = index;
            while (index < count >> 1) {
              var lIndex = this.getLeftChildIndex_(index);
              var rIndex = this.getRightChildIndex_(index);
              var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
              elements[index] = elements[smallerChildIndex];
              priorities[index] = priorities[smallerChildIndex];
              index = smallerChildIndex;
            }
            elements[index] = element;
            priorities[index] = priority;
            this.siftDown_(startIndex, index);
          };
          PriorityQueue.prototype.siftDown_ = function(startIndex, index) {
            var elements = this.elements_;
            var priorities = this.priorities_;
            var element = elements[index];
            var priority = priorities[index];
            while (index > startIndex) {
              var parentIndex = this.getParentIndex_(index);
              if (priorities[parentIndex] > priority) {
                elements[index] = elements[parentIndex];
                priorities[index] = priorities[parentIndex];
                index = parentIndex;
              } else {
                break;
              }
            }
            elements[index] = element;
            priorities[index] = priority;
          };
          PriorityQueue.prototype.reprioritize = function() {
            var priorityFunction = this.priorityFunction_;
            var elements = this.elements_;
            var priorities = this.priorities_;
            var index = 0;
            var n = elements.length;
            var element, i, priority;
            for (i = 0; i < n; ++i) {
              element = elements[i];
              priority = priorityFunction(element);
              if (priority == DROP) {
                delete this.queuedElements_[this.keyFunction_(element)];
              } else {
                priorities[index] = priority;
                elements[index++] = element;
              }
            }
            elements.length = index;
            priorities.length = index;
            this.heapify_();
          };
          return PriorityQueue;
        }();
        var structs_PriorityQueue = PriorityQueue_PriorityQueue;
        var TileState = {
          IDLE: 0,
          LOADING: 1,
          LOADED: 2,
          ERROR: 3,
          EMPTY: 4
        };
        var TileQueue_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var TileQueue_TileQueue = function(_super) {
          TileQueue_extends(TileQueue, _super);
          function TileQueue(tilePriorityFunction, tileChangeCallback) {
            var _this = _super.call(this, function(element) {
              return tilePriorityFunction.apply(null, element);
            }, function(element) {
              return element[0].getKey();
            }) || this;
            _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
            _this.tileChangeCallback_ = tileChangeCallback;
            _this.tilesLoading_ = 0;
            _this.tilesLoadingKeys_ = {};
            return _this;
          }
          TileQueue.prototype.enqueue = function(element) {
            var added = _super.prototype.enqueue.call(this, element);
            if (added) {
              var tile = element[0];
              tile.addEventListener(EventType["a"].CHANGE, this.boundHandleTileChange_);
            }
            return added;
          };
          TileQueue.prototype.getTilesLoading = function() {
            return this.tilesLoading_;
          };
          TileQueue.prototype.handleTileChange = function(event) {
            var tile = event.target;
            var state = tile.getState();
            if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {
              tile.removeEventListener(EventType["a"].CHANGE, this.boundHandleTileChange_);
              var tileKey = tile.getKey();
              if (tileKey in this.tilesLoadingKeys_) {
                delete this.tilesLoadingKeys_[tileKey];
                --this.tilesLoading_;
              }
              this.tileChangeCallback_();
            }
          };
          TileQueue.prototype.loadMoreTiles = function(maxTotalLoading, maxNewLoads) {
            var newLoads = 0;
            var state, tile, tileKey;
            while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
              tile = this.dequeue()[0];
              tileKey = tile.getKey();
              state = tile.getState();
              if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                this.tilesLoadingKeys_[tileKey] = true;
                ++this.tilesLoading_;
                ++newLoads;
                tile.load();
              }
            }
          };
          return TileQueue;
        }(structs_PriorityQueue);
        var ol_TileQueue = TileQueue_TileQueue;
        function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
          if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
            return DROP;
          }
          if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
            return DROP;
          }
          var center = frameState.viewState.center;
          var deltaX = tileCenter[0] - center[0];
          var deltaY = tileCenter[1] - center[1];
          return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
        }
        var geom_GeometryType = {
          POINT: "Point",
          LINE_STRING: "LineString",
          LINEAR_RING: "LinearRing",
          POLYGON: "Polygon",
          MULTI_POINT: "MultiPoint",
          MULTI_LINE_STRING: "MultiLineString",
          MULTI_POLYGON: "MultiPolygon",
          GEOMETRY_COLLECTION: "GeometryCollection",
          CIRCLE: "Circle"
        };
        var Units = {
          RADIANS: "radians",
          DEGREES: "degrees",
          FEET: "ft",
          METERS: "m",
          PIXELS: "pixels",
          TILE_PIXELS: "tile-pixels",
          USFEET: "us-ft"
        };
        var unitByCode = {
          "9001": Units.METERS,
          "9002": Units.FEET,
          "9003": Units.USFEET,
          "9101": Units.RADIANS,
          "9102": Units.DEGREES
        };
        function fromCode(code) {
          return unitByCode[code];
        }
        var METERS_PER_UNIT = {};
        METERS_PER_UNIT[Units.RADIANS] = 6370997 / (2 * Math.PI);
        METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
        METERS_PER_UNIT[Units.FEET] = 0.3048;
        METERS_PER_UNIT[Units.METERS] = 1;
        METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;
        var proj_Units = Units;
        var ViewHint = {
          ANIMATING: 0,
          INTERACTING: 1
        };
        var ViewProperty = {
          CENTER: "center",
          RESOLUTION: "resolution",
          ROTATION: "rotation"
        };
        var DEFAULT_MAX_ZOOM = 42;
        var DEFAULT_TILE_SIZE = 256;
        var Projection_Projection = function() {
          function Projection(options) {
            this.code_ = options.code;
            this.units_ = options.units;
            this.extent_ = options.extent !== void 0 ? options.extent : null;
            this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
            this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
            this.global_ = options.global !== void 0 ? options.global : false;
            this.canWrapX_ = !!(this.global_ && this.extent_);
            this.getPointResolutionFunc_ = options.getPointResolution;
            this.defaultTileGrid_ = null;
            this.metersPerUnit_ = options.metersPerUnit;
          }
          Projection.prototype.canWrapX = function() {
            return this.canWrapX_;
          };
          Projection.prototype.getCode = function() {
            return this.code_;
          };
          Projection.prototype.getExtent = function() {
            return this.extent_;
          };
          Projection.prototype.getUnits = function() {
            return this.units_;
          };
          Projection.prototype.getMetersPerUnit = function() {
            return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
          };
          Projection.prototype.getWorldExtent = function() {
            return this.worldExtent_;
          };
          Projection.prototype.getAxisOrientation = function() {
            return this.axisOrientation_;
          };
          Projection.prototype.isGlobal = function() {
            return this.global_;
          };
          Projection.prototype.setGlobal = function(global2) {
            this.global_ = global2;
            this.canWrapX_ = !!(global2 && this.extent_);
          };
          Projection.prototype.getDefaultTileGrid = function() {
            return this.defaultTileGrid_;
          };
          Projection.prototype.setDefaultTileGrid = function(tileGrid) {
            this.defaultTileGrid_ = tileGrid;
          };
          Projection.prototype.setExtent = function(extent) {
            this.extent_ = extent;
            this.canWrapX_ = !!(this.global_ && extent);
          };
          Projection.prototype.setWorldExtent = function(worldExtent) {
            this.worldExtent_ = worldExtent;
          };
          Projection.prototype.setGetPointResolution = function(func) {
            this.getPointResolutionFunc_ = func;
          };
          Projection.prototype.getPointResolutionFunc = function() {
            return this.getPointResolutionFunc_;
          };
          return Projection;
        }();
        var proj_Projection = Projection_Projection;
        var epsg3857_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var RADIUS = 6378137;
        var HALF_SIZE = Math.PI * RADIUS;
        var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
        var WORLD_EXTENT = [-180, -85, 180, 85];
        var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
        var epsg3857_EPSG3857Projection = function(_super) {
          epsg3857_extends(EPSG3857Projection, _super);
          function EPSG3857Projection(code) {
            return _super.call(this, {
              code,
              units: proj_Units.METERS,
              extent: EXTENT,
              global: true,
              worldExtent: WORLD_EXTENT,
              getPointResolution: function(resolution, point) {
                return resolution / cosh(point[1] / RADIUS);
              }
            }) || this;
          }
          return EPSG3857Projection;
        }(proj_Projection);
        var PROJECTIONS = [
          new epsg3857_EPSG3857Projection("EPSG:3857"),
          new epsg3857_EPSG3857Projection("EPSG:102100"),
          new epsg3857_EPSG3857Projection("EPSG:102113"),
          new epsg3857_EPSG3857Projection("EPSG:900913"),
          new epsg3857_EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
          new epsg3857_EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
        ];
        function fromEPSG4326(input, opt_output, opt_dimension) {
          var length = input.length;
          var dimension = opt_dimension > 1 ? opt_dimension : 2;
          var output = opt_output;
          if (output === void 0) {
            if (dimension > 2) {
              output = input.slice();
            } else {
              output = new Array(length);
            }
          }
          for (var i = 0; i < length; i += dimension) {
            output[i] = HALF_SIZE * input[i] / 180;
            var y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
            if (y > MAX_SAFE_Y) {
              y = MAX_SAFE_Y;
            } else if (y < -MAX_SAFE_Y) {
              y = -MAX_SAFE_Y;
            }
            output[i + 1] = y;
          }
          return output;
        }
        function toEPSG4326(input, opt_output, opt_dimension) {
          var length = input.length;
          var dimension = opt_dimension > 1 ? opt_dimension : 2;
          var output = opt_output;
          if (output === void 0) {
            if (dimension > 2) {
              output = input.slice();
            } else {
              output = new Array(length);
            }
          }
          for (var i = 0; i < length; i += dimension) {
            output[i] = 180 * input[i] / HALF_SIZE;
            output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
          }
          return output;
        }
        var epsg4326_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var epsg4326_RADIUS = 6378137;
        var epsg4326_EXTENT = [-180, -90, 180, 90];
        var epsg4326_METERS_PER_UNIT = Math.PI * epsg4326_RADIUS / 180;
        var epsg4326_EPSG4326Projection = function(_super) {
          epsg4326_extends(EPSG4326Projection, _super);
          function EPSG4326Projection(code, opt_axisOrientation) {
            return _super.call(this, {
              code,
              units: proj_Units.DEGREES,
              extent: epsg4326_EXTENT,
              axisOrientation: opt_axisOrientation,
              global: true,
              metersPerUnit: epsg4326_METERS_PER_UNIT,
              worldExtent: epsg4326_EXTENT
            }) || this;
          }
          return EPSG4326Projection;
        }(proj_Projection);
        var epsg4326_PROJECTIONS = [
          new epsg4326_EPSG4326Projection("CRS:84"),
          new epsg4326_EPSG4326Projection("EPSG:4326", "neu"),
          new epsg4326_EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
          new epsg4326_EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
          new epsg4326_EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
          new epsg4326_EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
          new epsg4326_EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
        ];
        var projections_cache = {};
        function clear() {
          projections_cache = {};
        }
        function projections_get(code) {
          return projections_cache[code] || projections_cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
        }
        function projections_add(code, projection) {
          projections_cache[code] = projection;
        }
        var transforms_transforms = {};
        function transforms_clear() {
          transforms_transforms = {};
        }
        function transforms_add(source, destination, transformFn) {
          var sourceCode = source.getCode();
          var destinationCode = destination.getCode();
          if (!(sourceCode in transforms_transforms)) {
            transforms_transforms[sourceCode] = {};
          }
          transforms_transforms[sourceCode][destinationCode] = transformFn;
        }
        function transforms_remove(source, destination) {
          var sourceCode = source.getCode();
          var destinationCode = destination.getCode();
          var transform2 = transforms_transforms[sourceCode][destinationCode];
          delete transforms_transforms[sourceCode][destinationCode];
          if (Object(ol_obj["d"])(transforms_transforms[sourceCode])) {
            delete transforms_transforms[sourceCode];
          }
          return transform2;
        }
        function transforms_get(sourceCode, destinationCode) {
          var transform2;
          if (sourceCode in transforms_transforms && destinationCode in transforms_transforms[sourceCode]) {
            transform2 = transforms_transforms[sourceCode][destinationCode];
          }
          return transform2;
        }
        var DEFAULT_RADIUS = 63710088e-1;
        function getDistance(c1, c2, opt_radius) {
          var radius = opt_radius || DEFAULT_RADIUS;
          var lat1 = toRadians(c1[1]);
          var lat2 = toRadians(c2[1]);
          var deltaLatBy2 = (lat2 - lat1) / 2;
          var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
          var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
          return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }
        function getLengthInternal(coordinates, radius) {
          var length = 0;
          for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
            length += getDistance(coordinates[i], coordinates[i + 1], radius);
          }
          return length;
        }
        function getLength(geometry, opt_options) {
          var options = opt_options || {};
          var radius = options.radius || DEFAULT_RADIUS;
          var projection = options.projection || "EPSG:3857";
          var type = geometry.getType();
          if (type !== geom_GeometryType.GEOMETRY_COLLECTION) {
            geometry = geometry.clone().transform(projection, "EPSG:4326");
          }
          var length = 0;
          var coordinates, coords, i, ii, j, jj;
          switch (type) {
            case geom_GeometryType.POINT:
            case geom_GeometryType.MULTI_POINT: {
              break;
            }
            case geom_GeometryType.LINE_STRING:
            case geom_GeometryType.LINEAR_RING: {
              coordinates = geometry.getCoordinates();
              length = getLengthInternal(coordinates, radius);
              break;
            }
            case geom_GeometryType.MULTI_LINE_STRING:
            case geom_GeometryType.POLYGON: {
              coordinates = geometry.getCoordinates();
              for (i = 0, ii = coordinates.length; i < ii; ++i) {
                length += getLengthInternal(coordinates[i], radius);
              }
              break;
            }
            case geom_GeometryType.MULTI_POLYGON: {
              coordinates = geometry.getCoordinates();
              for (i = 0, ii = coordinates.length; i < ii; ++i) {
                coords = coordinates[i];
                for (j = 0, jj = coords.length; j < jj; ++j) {
                  length += getLengthInternal(coords[j], radius);
                }
              }
              break;
            }
            case geom_GeometryType.GEOMETRY_COLLECTION: {
              var geometries = geometry.getGeometries();
              for (i = 0, ii = geometries.length; i < ii; ++i) {
                length += getLength(geometries[i], opt_options);
              }
              break;
            }
            default: {
              throw new Error("Unsupported geometry type: " + type);
            }
          }
          return length;
        }
        function getAreaInternal(coordinates, radius) {
          var area = 0;
          var len = coordinates.length;
          var x1 = coordinates[len - 1][0];
          var y1 = coordinates[len - 1][1];
          for (var i = 0; i < len; i++) {
            var x2 = coordinates[i][0];
            var y2 = coordinates[i][1];
            area += toRadians(x2 - x1) * (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));
            x1 = x2;
            y1 = y2;
          }
          return area * radius * radius / 2;
        }
        function sphere_getArea(geometry, opt_options) {
          var options = opt_options || {};
          var radius = options.radius || DEFAULT_RADIUS;
          var projection = options.projection || "EPSG:3857";
          var type = geometry.getType();
          if (type !== geom_GeometryType.GEOMETRY_COLLECTION) {
            geometry = geometry.clone().transform(projection, "EPSG:4326");
          }
          var area = 0;
          var coordinates, coords, i, ii, j, jj;
          switch (type) {
            case geom_GeometryType.POINT:
            case geom_GeometryType.MULTI_POINT:
            case geom_GeometryType.LINE_STRING:
            case geom_GeometryType.MULTI_LINE_STRING:
            case geom_GeometryType.LINEAR_RING: {
              break;
            }
            case geom_GeometryType.POLYGON: {
              coordinates = geometry.getCoordinates();
              area = Math.abs(getAreaInternal(coordinates[0], radius));
              for (i = 1, ii = coordinates.length; i < ii; ++i) {
                area -= Math.abs(getAreaInternal(coordinates[i], radius));
              }
              break;
            }
            case geom_GeometryType.MULTI_POLYGON: {
              coordinates = geometry.getCoordinates();
              for (i = 0, ii = coordinates.length; i < ii; ++i) {
                coords = coordinates[i];
                area += Math.abs(getAreaInternal(coords[0], radius));
                for (j = 1, jj = coords.length; j < jj; ++j) {
                  area -= Math.abs(getAreaInternal(coords[j], radius));
                }
              }
              break;
            }
            case geom_GeometryType.GEOMETRY_COLLECTION: {
              var geometries = geometry.getGeometries();
              for (i = 0, ii = geometries.length; i < ii; ++i) {
                area += sphere_getArea(geometries[i], opt_options);
              }
              break;
            }
            default: {
              throw new Error("Unsupported geometry type: " + type);
            }
          }
          return area;
        }
        function sphere_offset(c1, distance, bearing, opt_radius) {
          var radius = opt_radius || DEFAULT_RADIUS;
          var lat1 = toRadians(c1[1]);
          var lon1 = toRadians(c1[0]);
          var dByR = distance / radius;
          var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
          var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
          return [toDegrees(lon), toDegrees(lat)];
        }
        function cloneTransform(input, opt_output, opt_dimension) {
          var output;
          if (opt_output !== void 0) {
            for (var i = 0, ii = input.length; i < ii; ++i) {
              opt_output[i] = input[i];
            }
            output = opt_output;
          } else {
            output = input.slice();
          }
          return output;
        }
        function identityTransform(input, opt_output, opt_dimension) {
          if (opt_output !== void 0 && input !== opt_output) {
            for (var i = 0, ii = input.length; i < ii; ++i) {
              opt_output[i] = input[i];
            }
            input = opt_output;
          }
          return input;
        }
        function addProjection(projection) {
          projections_add(projection.getCode(), projection);
          transforms_add(projection, projection, cloneTransform);
        }
        function addProjections(projections) {
          projections.forEach(addProjection);
        }
        function proj_get(projectionLike) {
          return typeof projectionLike === "string" ? projections_get(projectionLike) : projectionLike || null;
        }
        function getPointResolution(projection, resolution, point, opt_units) {
          projection = proj_get(projection);
          var pointResolution;
          var getter = projection.getPointResolutionFunc();
          if (getter) {
            pointResolution = getter(resolution, point);
            if (opt_units && opt_units !== projection.getUnits()) {
              var metersPerUnit = projection.getMetersPerUnit();
              if (metersPerUnit) {
                pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[opt_units];
              }
            }
          } else {
            var units = projection.getUnits();
            if (units == proj_Units.DEGREES && !opt_units || opt_units == proj_Units.DEGREES) {
              pointResolution = resolution;
            } else {
              var toEPSG4326_1 = getTransformFromProjections(projection, proj_get("EPSG:4326"));
              if (toEPSG4326_1 === identityTransform && units !== proj_Units.DEGREES) {
                pointResolution = resolution * projection.getMetersPerUnit();
              } else {
                var vertices = [
                  point[0] - resolution / 2,
                  point[1],
                  point[0] + resolution / 2,
                  point[1],
                  point[0],
                  point[1] - resolution / 2,
                  point[0],
                  point[1] + resolution / 2
                ];
                vertices = toEPSG4326_1(vertices, vertices, 2);
                var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
                var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
                pointResolution = (width + height) / 2;
              }
              var metersPerUnit = opt_units ? METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();
              if (metersPerUnit !== void 0) {
                pointResolution /= metersPerUnit;
              }
            }
          }
          return pointResolution;
        }
        function addEquivalentProjections(projections) {
          addProjections(projections);
          projections.forEach(function(source) {
            projections.forEach(function(destination) {
              if (source !== destination) {
                transforms_add(source, destination, cloneTransform);
              }
            });
          });
        }
        function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
          projections1.forEach(function(projection1) {
            projections2.forEach(function(projection2) {
              transforms_add(projection1, projection2, forwardTransform);
              transforms_add(projection2, projection1, inverseTransform);
            });
          });
        }
        function clearAllProjections() {
          clear();
          transforms_clear();
        }
        function createProjection(projection, defaultCode) {
          if (!projection) {
            return proj_get(defaultCode);
          } else if (typeof projection === "string") {
            return proj_get(projection);
          } else {
            return projection;
          }
        }
        function createTransformFromCoordinateTransform(coordTransform) {
          return function(input, opt_output, opt_dimension) {
            var length = input.length;
            var dimension = opt_dimension !== void 0 ? opt_dimension : 2;
            var output = opt_output !== void 0 ? opt_output : new Array(length);
            for (var i = 0; i < length; i += dimension) {
              var point = coordTransform([input[i], input[i + 1]]);
              output[i] = point[0];
              output[i + 1] = point[1];
              for (var j = dimension - 1; j >= 2; --j) {
                output[i + j] = input[i + j];
              }
            }
            return output;
          };
        }
        function addCoordinateTransforms(source, destination, forward, inverse) {
          var sourceProj = proj_get(source);
          var destProj = proj_get(destination);
          transforms_add(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
          transforms_add(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
        }
        function fromLonLat(coordinate, opt_projection) {
          return proj_transform(coordinate, "EPSG:4326", opt_projection !== void 0 ? opt_projection : "EPSG:3857");
        }
        function toLonLat(coordinate, opt_projection) {
          var lonLat = proj_transform(coordinate, opt_projection !== void 0 ? opt_projection : "EPSG:3857", "EPSG:4326");
          var lon = lonLat[0];
          if (lon < -180 || lon > 180) {
            lonLat[0] = modulo(lon + 180, 360) - 180;
          }
          return lonLat;
        }
        function equivalent(projection1, projection2) {
          if (projection1 === projection2) {
            return true;
          }
          var equalUnits = projection1.getUnits() === projection2.getUnits();
          if (projection1.getCode() === projection2.getCode()) {
            return equalUnits;
          } else {
            var transformFunc = getTransformFromProjections(projection1, projection2);
            return transformFunc === cloneTransform && equalUnits;
          }
        }
        function getTransformFromProjections(sourceProjection, destinationProjection) {
          var sourceCode = sourceProjection.getCode();
          var destinationCode = destinationProjection.getCode();
          var transformFunc = transforms_get(sourceCode, destinationCode);
          if (!transformFunc) {
            transformFunc = identityTransform;
          }
          return transformFunc;
        }
        function getTransform(source, destination) {
          var sourceProjection = proj_get(source);
          var destinationProjection = proj_get(destination);
          return getTransformFromProjections(sourceProjection, destinationProjection);
        }
        function proj_transform(coordinate, source, destination) {
          var transformFunc = getTransform(source, destination);
          return transformFunc(coordinate, void 0, coordinate.length);
        }
        function transformExtent(extent, source, destination, opt_stops) {
          var transformFunc = getTransform(source, destination);
          return applyTransform(extent, transformFunc, void 0, opt_stops);
        }
        function transformWithProjections(point, sourceProjection, destinationProjection) {
          var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
          return transformFunc(point);
        }
        var proj_userProjection = null;
        function setUserProjection(projection) {
          proj_userProjection = proj_get(projection);
        }
        function clearUserProjection() {
          proj_userProjection = null;
        }
        function getUserProjection() {
          return proj_userProjection;
        }
        function useGeographic() {
          setUserProjection("EPSG:4326");
        }
        function toUserCoordinate(coordinate, sourceProjection) {
          if (!proj_userProjection) {
            return coordinate;
          }
          return proj_transform(coordinate, sourceProjection, proj_userProjection);
        }
        function fromUserCoordinate(coordinate, destProjection) {
          if (!proj_userProjection) {
            return coordinate;
          }
          return proj_transform(coordinate, proj_userProjection, destProjection);
        }
        function toUserExtent(extent, sourceProjection) {
          if (!proj_userProjection) {
            return extent;
          }
          return transformExtent(extent, sourceProjection, proj_userProjection);
        }
        function fromUserExtent(extent, destProjection) {
          if (!proj_userProjection) {
            return extent;
          }
          return transformExtent(extent, proj_userProjection, destProjection);
        }
        function toUserResolution(resolution, sourceProjection) {
          if (!proj_userProjection) {
            return resolution;
          }
          var sourceUnits = proj_get(sourceProjection).getUnits();
          var userUnits = proj_userProjection.getUnits();
          return sourceUnits && userUnits ? resolution * METERS_PER_UNIT[sourceUnits] / METERS_PER_UNIT[userUnits] : resolution;
        }
        function fromUserResolution(resolution, destProjection) {
          if (!proj_userProjection) {
            return resolution;
          }
          var sourceUnits = proj_get(destProjection).getUnits();
          var userUnits = proj_userProjection.getUnits();
          return sourceUnits && userUnits ? resolution * METERS_PER_UNIT[userUnits] / METERS_PER_UNIT[sourceUnits] : resolution;
        }
        function createSafeCoordinateTransform(sourceProj, destProj, transform2) {
          return function(coord) {
            var sourceX = coord[0];
            var sourceY = coord[1];
            var transformed, worldsAway;
            if (sourceProj.canWrapX()) {
              var sourceExtent = sourceProj.getExtent();
              var sourceExtentWidth = getWidth(sourceExtent);
              worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
              if (worldsAway) {
                sourceX = sourceX - worldsAway * sourceExtentWidth;
              }
              sourceX = clamp(sourceX, sourceExtent[0], sourceExtent[2]);
              sourceY = clamp(sourceY, sourceExtent[1], sourceExtent[3]);
              transformed = transform2([sourceX, sourceY]);
            } else {
              transformed = transform2(coord);
            }
            if (worldsAway && destProj.canWrapX()) {
              transformed[0] += worldsAway * getWidth(destProj.getExtent());
            }
            return transformed;
          };
        }
        function addCommon() {
          addEquivalentProjections(PROJECTIONS);
          addEquivalentProjections(epsg4326_PROJECTIONS);
          addEquivalentTransforms(epsg4326_PROJECTIONS, PROJECTIONS, fromEPSG4326, toEPSG4326);
        }
        addCommon();
        function createExtent(extent, onlyCenter, smooth) {
          return function(center, resolution, size, opt_isMoving, opt_centerShift) {
            if (center) {
              var viewWidth = onlyCenter ? 0 : size[0] * resolution;
              var viewHeight = onlyCenter ? 0 : size[1] * resolution;
              var shiftX = opt_centerShift ? opt_centerShift[0] : 0;
              var shiftY = opt_centerShift ? opt_centerShift[1] : 0;
              var minX = extent[0] + viewWidth / 2 + shiftX;
              var maxX = extent[2] - viewWidth / 2 + shiftX;
              var minY = extent[1] + viewHeight / 2 + shiftY;
              var maxY = extent[3] - viewHeight / 2 + shiftY;
              if (minX > maxX) {
                minX = (maxX + minX) / 2;
                maxX = minX;
              }
              if (minY > maxY) {
                minY = (maxY + minY) / 2;
                maxY = minY;
              }
              var x = clamp(center[0], minX, maxX);
              var y = clamp(center[1], minY, maxY);
              var ratio = 30 * resolution;
              if (opt_isMoving && smooth) {
                x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
                y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
              }
              return [x, y];
            } else {
              return void 0;
            }
          };
        }
        function none(center) {
          return center;
        }
        var ol_array = __webpack_require__("9f5e");
        function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
          var xResolution = getWidth(maxExtent) / viewportSize[0];
          var yResolution = getHeight(maxExtent) / viewportSize[1];
          if (showFullExtent) {
            return Math.min(resolution, Math.max(xResolution, yResolution));
          }
          return Math.min(resolution, Math.min(xResolution, yResolution));
        }
        function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
          var result = Math.min(resolution, maxResolution);
          var ratio = 50;
          result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
          if (minResolution) {
            result = Math.max(result, minResolution);
            result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
          }
          return clamp(result, minResolution / 2, maxResolution * 2);
        }
        function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
          return function(resolution, direction, size, opt_isMoving) {
            if (resolution !== void 0) {
              var maxResolution = resolutions[0];
              var minResolution = resolutions[resolutions.length - 1];
              var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
              if (opt_isMoving) {
                var smooth = opt_smooth !== void 0 ? opt_smooth : true;
                if (!smooth) {
                  return clamp(resolution, minResolution, cappedMaxRes);
                }
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
              }
              var capped = Math.min(cappedMaxRes, resolution);
              var z = Math.floor(Object(ol_array["h"])(resolutions, capped, direction));
              if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
                return resolutions[z + 1];
              }
              return resolutions[z];
            } else {
              return void 0;
            }
          };
        }
        function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
          return function(resolution, direction, size, opt_isMoving) {
            if (resolution !== void 0) {
              var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
              var minResolution = opt_minResolution !== void 0 ? opt_minResolution : 0;
              if (opt_isMoving) {
                var smooth = opt_smooth !== void 0 ? opt_smooth : true;
                if (!smooth) {
                  return clamp(resolution, minResolution, cappedMaxRes);
                }
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
              }
              var tolerance = 1e-9;
              var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
              var offset = -direction * (0.5 - tolerance) + 0.5;
              var capped = Math.min(cappedMaxRes, resolution);
              var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
              var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
              var newResolution = maxResolution / Math.pow(power, zoomLevel);
              return clamp(newResolution, minResolution, cappedMaxRes);
            } else {
              return void 0;
            }
          };
        }
        function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
          return function(resolution, direction, size, opt_isMoving) {
            if (resolution !== void 0) {
              var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
              var smooth = opt_smooth !== void 0 ? opt_smooth : true;
              if (!smooth || !opt_isMoving) {
                return clamp(resolution, minResolution, cappedMaxRes);
              }
              return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            } else {
              return void 0;
            }
          };
        }
        function disable(rotation) {
          if (rotation !== void 0) {
            return 0;
          } else {
            return void 0;
          }
        }
        function rotationconstraint_none(rotation) {
          if (rotation !== void 0) {
            return rotation;
          } else {
            return void 0;
          }
        }
        function createSnapToN(n) {
          var theta = 2 * Math.PI / n;
          return function(rotation, opt_isMoving) {
            if (opt_isMoving) {
              return rotation;
            }
            if (rotation !== void 0) {
              rotation = Math.floor(rotation / theta + 0.5) * theta;
              return rotation;
            } else {
              return void 0;
            }
          };
        }
        function createSnapToZero(opt_tolerance) {
          var tolerance = opt_tolerance || toRadians(5);
          return function(rotation, opt_isMoving) {
            if (opt_isMoving) {
              return rotation;
            }
            if (rotation !== void 0) {
              if (Math.abs(rotation) <= tolerance) {
                return 0;
              } else {
                return rotation;
              }
            } else {
              return void 0;
            }
          };
        }
        function easeIn(t) {
          return Math.pow(t, 3);
        }
        function easeOut(t) {
          return 1 - easeIn(1 - t);
        }
        function inAndOut(t) {
          return 3 * t * t - 2 * t * t * t;
        }
        function linear(t) {
          return t;
        }
        function upAndDown(t) {
          if (t < 0.5) {
            return inAndOut(2 * t);
          } else {
            return 1 - inAndOut(2 * (t - 0.5));
          }
        }
        var GeometryLayout = {
          XY: "XY",
          XYZ: "XYZ",
          XYM: "XYM",
          XYZM: "XYZM"
        };
        function transform2D(flatCoordinates, offset, end, stride, transform2, opt_dest) {
          var dest = opt_dest ? opt_dest : [];
          var i = 0;
          for (var j = offset; j < end; j += stride) {
            var x = flatCoordinates[j];
            var y = flatCoordinates[j + 1];
            dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
            dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
          }
          if (opt_dest && dest.length != i) {
            dest.length = i;
          }
          return dest;
        }
        function transform_rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
          var dest = opt_dest ? opt_dest : [];
          var cos = Math.cos(angle);
          var sin = Math.sin(angle);
          var anchorX = anchor[0];
          var anchorY = anchor[1];
          var i = 0;
          for (var j = offset; j < end; j += stride) {
            var deltaX = flatCoordinates[j] - anchorX;
            var deltaY = flatCoordinates[j + 1] - anchorY;
            dest[i++] = anchorX + deltaX * cos - deltaY * sin;
            dest[i++] = anchorY + deltaX * sin + deltaY * cos;
            for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
            }
          }
          if (opt_dest && dest.length != i) {
            dest.length = i;
          }
          return dest;
        }
        function flat_transform_scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
          var dest = opt_dest ? opt_dest : [];
          var anchorX = anchor[0];
          var anchorY = anchor[1];
          var i = 0;
          for (var j = offset; j < end; j += stride) {
            var deltaX = flatCoordinates[j] - anchorX;
            var deltaY = flatCoordinates[j + 1] - anchorY;
            dest[i++] = anchorX + sx * deltaX;
            dest[i++] = anchorY + sy * deltaY;
            for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
            }
          }
          if (opt_dest && dest.length != i) {
            dest.length = i;
          }
          return dest;
        }
        function flat_transform_translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
          var dest = opt_dest ? opt_dest : [];
          var i = 0;
          for (var j = offset; j < end; j += stride) {
            dest[i++] = flatCoordinates[j] + deltaX;
            dest[i++] = flatCoordinates[j + 1] + deltaY;
            for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
            }
          }
          if (opt_dest && dest.length != i) {
            dest.length = i;
          }
          return dest;
        }
        var Geometry_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var tmpTransform = create();
        var Geometry_Geometry = function(_super) {
          Geometry_extends(Geometry, _super);
          function Geometry() {
            var _this = _super.call(this) || this;
            _this.extent_ = createEmpty();
            _this.extentRevision_ = -1;
            _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            _this.simplifiedGeometryRevision = 0;
            _this.simplifyTransformedInternal = Object(functions["d"])(function(revision, squaredTolerance, opt_transform) {
              if (!opt_transform) {
                return this.getSimplifiedGeometry(squaredTolerance);
              }
              var clone2 = this.clone();
              clone2.applyTransform(opt_transform);
              return clone2.getSimplifiedGeometry(squaredTolerance);
            });
            return _this;
          }
          Geometry.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {
            return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
          };
          Geometry.prototype.clone = function() {
            return Object(util["b"])();
          };
          Geometry.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            return Object(util["b"])();
          };
          Geometry.prototype.containsXY = function(x, y) {
            var coord = this.getClosestPoint([x, y]);
            return coord[0] === x && coord[1] === y;
          };
          Geometry.prototype.getClosestPoint = function(point, opt_closestPoint) {
            var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
            this.closestPointXY(point[0], point[1], closestPoint, Infinity);
            return closestPoint;
          };
          Geometry.prototype.intersectsCoordinate = function(coordinate) {
            return this.containsXY(coordinate[0], coordinate[1]);
          };
          Geometry.prototype.computeExtent = function(extent) {
            return Object(util["b"])();
          };
          Geometry.prototype.getExtent = function(opt_extent) {
            if (this.extentRevision_ != this.getRevision()) {
              var extent = this.computeExtent(this.extent_);
              if (isNaN(extent[0]) || isNaN(extent[1])) {
                createOrUpdateEmpty(extent);
              }
              this.extentRevision_ = this.getRevision();
            }
            return returnOrUpdate(this.extent_, opt_extent);
          };
          Geometry.prototype.rotate = function(angle, anchor) {
            Object(util["b"])();
          };
          Geometry.prototype.scale = function(sx, opt_sy, opt_anchor) {
            Object(util["b"])();
          };
          Geometry.prototype.simplify = function(tolerance) {
            return this.getSimplifiedGeometry(tolerance * tolerance);
          };
          Geometry.prototype.getSimplifiedGeometry = function(squaredTolerance) {
            return Object(util["b"])();
          };
          Geometry.prototype.getType = function() {
            return Object(util["b"])();
          };
          Geometry.prototype.applyTransform = function(transformFn) {
            Object(util["b"])();
          };
          Geometry.prototype.intersectsExtent = function(extent) {
            return Object(util["b"])();
          };
          Geometry.prototype.translate = function(deltaX, deltaY) {
            Object(util["b"])();
          };
          Geometry.prototype.transform = function(source, destination) {
            var sourceProj = proj_get(source);
            var transformFn = sourceProj.getUnits() == proj_Units.TILE_PIXELS ? function(inCoordinates, outCoordinates, stride) {
              var pixelExtent = sourceProj.getExtent();
              var projectedExtent = sourceProj.getWorldExtent();
              var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
              compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
              transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
              return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
            } : getTransform(sourceProj, destination);
            this.applyTransform(transformFn);
            return this;
          };
          return Geometry;
        }(ol_Object["a"]);
        var geom_Geometry = Geometry_Geometry;
        var SimpleGeometry_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var SimpleGeometry_SimpleGeometry = function(_super) {
          SimpleGeometry_extends(SimpleGeometry, _super);
          function SimpleGeometry() {
            var _this = _super.call(this) || this;
            _this.layout = GeometryLayout.XY;
            _this.stride = 2;
            _this.flatCoordinates = null;
            return _this;
          }
          SimpleGeometry.prototype.computeExtent = function(extent) {
            return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
          };
          SimpleGeometry.prototype.getCoordinates = function() {
            return Object(util["b"])();
          };
          SimpleGeometry.prototype.getFirstCoordinate = function() {
            return this.flatCoordinates.slice(0, this.stride);
          };
          SimpleGeometry.prototype.getFlatCoordinates = function() {
            return this.flatCoordinates;
          };
          SimpleGeometry.prototype.getLastCoordinate = function() {
            return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
          };
          SimpleGeometry.prototype.getLayout = function() {
            return this.layout;
          };
          SimpleGeometry.prototype.getSimplifiedGeometry = function(squaredTolerance) {
            if (this.simplifiedGeometryRevision !== this.getRevision()) {
              this.simplifiedGeometryMaxMinSquaredTolerance = 0;
              this.simplifiedGeometryRevision = this.getRevision();
            }
            if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
              return this;
            }
            var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
            var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
            if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
              return simplifiedGeometry;
            } else {
              this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
              return this;
            }
          };
          SimpleGeometry.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
            return this;
          };
          SimpleGeometry.prototype.getStride = function() {
            return this.stride;
          };
          SimpleGeometry.prototype.setFlatCoordinates = function(layout, flatCoordinates) {
            this.stride = getStrideForLayout(layout);
            this.layout = layout;
            this.flatCoordinates = flatCoordinates;
          };
          SimpleGeometry.prototype.setCoordinates = function(coordinates, opt_layout) {
            Object(util["b"])();
          };
          SimpleGeometry.prototype.setLayout = function(layout, coordinates, nesting) {
            var stride;
            if (layout) {
              stride = getStrideForLayout(layout);
            } else {
              for (var i = 0; i < nesting; ++i) {
                if (coordinates.length === 0) {
                  this.layout = GeometryLayout.XY;
                  this.stride = 2;
                  return;
                } else {
                  coordinates = coordinates[0];
                }
              }
              stride = coordinates.length;
              layout = getLayoutForStride(stride);
            }
            this.layout = layout;
            this.stride = stride;
          };
          SimpleGeometry.prototype.applyTransform = function(transformFn) {
            if (this.flatCoordinates) {
              transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
              this.changed();
            }
          };
          SimpleGeometry.prototype.rotate = function(angle, anchor) {
            var flatCoordinates = this.getFlatCoordinates();
            if (flatCoordinates) {
              var stride = this.getStride();
              transform_rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
              this.changed();
            }
          };
          SimpleGeometry.prototype.scale = function(sx, opt_sy, opt_anchor) {
            var sy = opt_sy;
            if (sy === void 0) {
              sy = sx;
            }
            var anchor = opt_anchor;
            if (!anchor) {
              anchor = extent_getCenter(this.getExtent());
            }
            var flatCoordinates = this.getFlatCoordinates();
            if (flatCoordinates) {
              var stride = this.getStride();
              flat_transform_scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
              this.changed();
            }
          };
          SimpleGeometry.prototype.translate = function(deltaX, deltaY) {
            var flatCoordinates = this.getFlatCoordinates();
            if (flatCoordinates) {
              var stride = this.getStride();
              flat_transform_translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
              this.changed();
            }
          };
          return SimpleGeometry;
        }(geom_Geometry);
        function getLayoutForStride(stride) {
          var layout;
          if (stride == 2) {
            layout = GeometryLayout.XY;
          } else if (stride == 3) {
            layout = GeometryLayout.XYZ;
          } else if (stride == 4) {
            layout = GeometryLayout.XYZM;
          }
          return layout;
        }
        function getStrideForLayout(layout) {
          var stride;
          if (layout == GeometryLayout.XY) {
            stride = 2;
          } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {
            stride = 3;
          } else if (layout == GeometryLayout.XYZM) {
            stride = 4;
          }
          return stride;
        }
        function transformGeom2D(simpleGeometry, transform2, opt_dest) {
          var flatCoordinates = simpleGeometry.getFlatCoordinates();
          if (!flatCoordinates) {
            return null;
          } else {
            var stride = simpleGeometry.getStride();
            return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform2, opt_dest);
          }
        }
        var geom_SimpleGeometry = SimpleGeometry_SimpleGeometry;
        function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
          var x1 = flatCoordinates[offset1];
          var y1 = flatCoordinates[offset1 + 1];
          var dx = flatCoordinates[offset2] - x1;
          var dy = flatCoordinates[offset2 + 1] - y1;
          var offset;
          if (dx === 0 && dy === 0) {
            offset = offset1;
          } else {
            var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
            if (t > 1) {
              offset = offset2;
            } else if (t > 0) {
              for (var i = 0; i < stride; ++i) {
                closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
              }
              closestPoint.length = stride;
              return;
            } else {
              offset = offset1;
            }
          }
          for (var i = 0; i < stride; ++i) {
            closestPoint[i] = flatCoordinates[offset + i];
          }
          closestPoint.length = stride;
        }
        function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
          var x1 = flatCoordinates[offset];
          var y1 = flatCoordinates[offset + 1];
          for (offset += stride; offset < end; offset += stride) {
            var x2 = flatCoordinates[offset];
            var y2 = flatCoordinates[offset + 1];
            var squaredDelta = math_squaredDistance(x1, y1, x2, y2);
            if (squaredDelta > max) {
              max = squaredDelta;
            }
            x1 = x2;
            y1 = y2;
          }
          return max;
        }
        function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
            offset = end;
          }
          return max;
        }
        function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
            offset = ends[ends.length - 1];
          }
          return max;
        }
        function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
          if (offset == end) {
            return minSquaredDistance;
          }
          var i, squaredDistance;
          if (maxDelta === 0) {
            squaredDistance = math_squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
            if (squaredDistance < minSquaredDistance) {
              for (i = 0; i < stride; ++i) {
                closestPoint[i] = flatCoordinates[offset + i];
              }
              closestPoint.length = stride;
              return squaredDistance;
            } else {
              return minSquaredDistance;
            }
          }
          var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
          var index = offset + stride;
          while (index < end) {
            assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
            squaredDistance = math_squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
            if (squaredDistance < minSquaredDistance) {
              minSquaredDistance = squaredDistance;
              for (i = 0; i < stride; ++i) {
                closestPoint[i] = tmpPoint[i];
              }
              closestPoint.length = stride;
              index += stride;
            } else {
              index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
            }
          }
          if (isRing) {
            assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
            squaredDistance = math_squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
            if (squaredDistance < minSquaredDistance) {
              minSquaredDistance = squaredDistance;
              for (i = 0; i < stride; ++i) {
                closestPoint[i] = tmpPoint[i];
              }
              closestPoint.length = stride;
            }
          }
          return minSquaredDistance;
        }
        function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
          var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
            offset = end;
          }
          return minSquaredDistance;
        }
        function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
          var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
            offset = ends[ends.length - 1];
          }
          return minSquaredDistance;
        }
        function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
          for (var i = 0, ii = coordinate.length; i < ii; ++i) {
            flatCoordinates[offset++] = coordinate[i];
          }
          return offset;
        }
        function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
          for (var i = 0, ii = coordinates.length; i < ii; ++i) {
            var coordinate = coordinates[i];
            for (var j = 0; j < stride; ++j) {
              flatCoordinates[offset++] = coordinate[j];
            }
          }
          return offset;
        }
        function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
          var ends = opt_ends ? opt_ends : [];
          var i = 0;
          for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
            var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
            ends[i++] = end;
            offset = end;
          }
          ends.length = i;
          return ends;
        }
        function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
          var endss = opt_endss ? opt_endss : [];
          var i = 0;
          for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
            var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
            endss[i++] = ends;
            offset = ends[ends.length - 1];
          }
          endss.length = i;
          return endss;
        }
        function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
          var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== void 0 ? opt_simplifiedFlatCoordinates : [];
          if (!highQuality) {
            end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
            flatCoordinates = simplifiedFlatCoordinates;
            offset = 0;
            stride = 2;
          }
          simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
          return simplifiedFlatCoordinates;
        }
        function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
          var n = (end - offset) / stride;
          if (n < 3) {
            for (; offset < end; offset += stride) {
              simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
              simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
            }
            return simplifiedOffset;
          }
          var markers = new Array(n);
          markers[0] = 1;
          markers[n - 1] = 1;
          var stack = [offset, end - stride];
          var index = 0;
          while (stack.length > 0) {
            var last2 = stack.pop();
            var first = stack.pop();
            var maxSquaredDistance = 0;
            var x1 = flatCoordinates[first];
            var y1 = flatCoordinates[first + 1];
            var x2 = flatCoordinates[last2];
            var y2 = flatCoordinates[last2 + 1];
            for (var i = first + stride; i < last2; i += stride) {
              var x = flatCoordinates[i];
              var y = flatCoordinates[i + 1];
              var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
              if (squaredDistance_1 > maxSquaredDistance) {
                index = i;
                maxSquaredDistance = squaredDistance_1;
              }
            }
            if (maxSquaredDistance > squaredTolerance) {
              markers[(index - offset) / stride] = 1;
              if (first + stride < index) {
                stack.push(first, index);
              }
              if (index + stride < last2) {
                stack.push(index, last2);
              }
            }
          }
          for (var i = 0; i < n; ++i) {
            if (markers[i]) {
              simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
              simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
            }
          }
          return simplifiedOffset;
        }
        function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
            simplifiedEnds.push(simplifiedOffset);
            offset = end;
          }
          return simplifiedOffset;
        }
        function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            var simplifiedEnds = [];
            simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
            simplifiedEndss.push(simplifiedEnds);
            offset = ends[ends.length - 1];
          }
          return simplifiedOffset;
        }
        function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
          if (end <= offset + stride) {
            for (; offset < end; offset += stride) {
              simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
              simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
            }
            return simplifiedOffset;
          }
          var x1 = flatCoordinates[offset];
          var y1 = flatCoordinates[offset + 1];
          simplifiedFlatCoordinates[simplifiedOffset++] = x1;
          simplifiedFlatCoordinates[simplifiedOffset++] = y1;
          var x2 = x1;
          var y2 = y1;
          for (offset += stride; offset < end; offset += stride) {
            x2 = flatCoordinates[offset];
            y2 = flatCoordinates[offset + 1];
            if (math_squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
              simplifiedFlatCoordinates[simplifiedOffset++] = x2;
              simplifiedFlatCoordinates[simplifiedOffset++] = y2;
              x1 = x2;
              y1 = y2;
            }
          }
          if (x2 != x1 || y2 != y1) {
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
          }
          return simplifiedOffset;
        }
        function simplify_snap(value, tolerance) {
          return tolerance * Math.round(value / tolerance);
        }
        function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
          if (offset == end) {
            return simplifiedOffset;
          }
          var x1 = simplify_snap(flatCoordinates[offset], tolerance);
          var y1 = simplify_snap(flatCoordinates[offset + 1], tolerance);
          offset += stride;
          simplifiedFlatCoordinates[simplifiedOffset++] = x1;
          simplifiedFlatCoordinates[simplifiedOffset++] = y1;
          var x2, y2;
          do {
            x2 = simplify_snap(flatCoordinates[offset], tolerance);
            y2 = simplify_snap(flatCoordinates[offset + 1], tolerance);
            offset += stride;
            if (offset == end) {
              simplifiedFlatCoordinates[simplifiedOffset++] = x2;
              simplifiedFlatCoordinates[simplifiedOffset++] = y2;
              return simplifiedOffset;
            }
          } while (x2 == x1 && y2 == y1);
          while (offset < end) {
            var x3 = simplify_snap(flatCoordinates[offset], tolerance);
            var y3 = simplify_snap(flatCoordinates[offset + 1], tolerance);
            offset += stride;
            if (x3 == x2 && y3 == y2) {
              continue;
            }
            var dx1 = x2 - x1;
            var dy1 = y2 - y1;
            var dx2 = x3 - x1;
            var dy2 = y3 - y1;
            if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
              x2 = x3;
              y2 = y3;
              continue;
            }
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            x1 = x2;
            y1 = y2;
            x2 = x3;
            y2 = y3;
          }
          simplifiedFlatCoordinates[simplifiedOffset++] = x2;
          simplifiedFlatCoordinates[simplifiedOffset++] = y2;
          return simplifiedOffset;
        }
        function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
            simplifiedEnds.push(simplifiedOffset);
            offset = end;
          }
          return simplifiedOffset;
        }
        function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            var simplifiedEnds = [];
            simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
            simplifiedEndss.push(simplifiedEnds);
            offset = ends[ends.length - 1];
          }
          return simplifiedOffset;
        }
        function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
          var coordinates = opt_coordinates !== void 0 ? opt_coordinates : [];
          var i = 0;
          for (var j = offset; j < end; j += stride) {
            coordinates[i++] = flatCoordinates.slice(j, j + stride);
          }
          coordinates.length = i;
          return coordinates;
        }
        function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
          var coordinatess = opt_coordinatess !== void 0 ? opt_coordinatess : [];
          var i = 0;
          for (var j = 0, jj = ends.length; j < jj; ++j) {
            var end = ends[j];
            coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
            offset = end;
          }
          coordinatess.length = i;
          return coordinatess;
        }
        function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
          var coordinatesss = opt_coordinatesss !== void 0 ? opt_coordinatesss : [];
          var i = 0;
          for (var j = 0, jj = endss.length; j < jj; ++j) {
            var ends = endss[j];
            coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
            offset = ends[ends.length - 1];
          }
          coordinatesss.length = i;
          return coordinatesss;
        }
        function area_linearRing(flatCoordinates, offset, end, stride) {
          var twiceArea = 0;
          var x1 = flatCoordinates[end - stride];
          var y1 = flatCoordinates[end - stride + 1];
          for (; offset < end; offset += stride) {
            var x2 = flatCoordinates[offset];
            var y2 = flatCoordinates[offset + 1];
            twiceArea += y1 * x2 - x1 * y2;
            x1 = x2;
            y1 = y2;
          }
          return twiceArea / 2;
        }
        function area_linearRings(flatCoordinates, offset, ends, stride) {
          var area = 0;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            area += area_linearRing(flatCoordinates, offset, end, stride);
            offset = end;
          }
          return area;
        }
        function linearRingss(flatCoordinates, offset, endss, stride) {
          var area = 0;
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            area += area_linearRings(flatCoordinates, offset, ends, stride);
            offset = ends[ends.length - 1];
          }
          return area;
        }
        var LinearRing_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var LinearRing_LinearRing = function(_super) {
          LinearRing_extends(LinearRing, _super);
          function LinearRing(coordinates, opt_layout) {
            var _this = _super.call(this) || this;
            _this.maxDelta_ = -1;
            _this.maxDeltaRevision_ = -1;
            if (opt_layout !== void 0 && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, coordinates);
            } else {
              _this.setCoordinates(coordinates, opt_layout);
            }
            return _this;
          }
          LinearRing.prototype.clone = function() {
            return new LinearRing(this.flatCoordinates.slice(), this.layout);
          };
          LinearRing.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
            }
            if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
            }
            return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
          };
          LinearRing.prototype.getArea = function() {
            return area_linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
          };
          LinearRing.prototype.getCoordinates = function() {
            return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
          };
          LinearRing.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
            var simplifiedFlatCoordinates = [];
            simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
            return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);
          };
          LinearRing.prototype.getType = function() {
            return geom_GeometryType.LINEAR_RING;
          };
          LinearRing.prototype.intersectsExtent = function(extent) {
            return false;
          };
          LinearRing.prototype.setCoordinates = function(coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 1);
            if (!this.flatCoordinates) {
              this.flatCoordinates = [];
            }
            this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
            this.changed();
          };
          return LinearRing;
        }(geom_SimpleGeometry);
        var geom_LinearRing = LinearRing_LinearRing;
        var Point_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Point_Point = function(_super) {
          Point_extends(Point, _super);
          function Point(coordinates, opt_layout) {
            var _this = _super.call(this) || this;
            _this.setCoordinates(coordinates, opt_layout);
            return _this;
          }
          Point.prototype.clone = function() {
            var point = new Point(this.flatCoordinates.slice(), this.layout);
            point.applyProperties(this);
            return point;
          };
          Point.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            var flatCoordinates = this.flatCoordinates;
            var squaredDistance = math_squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
            if (squaredDistance < minSquaredDistance) {
              var stride = this.stride;
              for (var i = 0; i < stride; ++i) {
                closestPoint[i] = flatCoordinates[i];
              }
              closestPoint.length = stride;
              return squaredDistance;
            } else {
              return minSquaredDistance;
            }
          };
          Point.prototype.getCoordinates = function() {
            return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
          };
          Point.prototype.computeExtent = function(extent) {
            return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
          };
          Point.prototype.getType = function() {
            return geom_GeometryType.POINT;
          };
          Point.prototype.intersectsExtent = function(extent) {
            return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
          };
          Point.prototype.setCoordinates = function(coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 0);
            if (!this.flatCoordinates) {
              this.flatCoordinates = [];
            }
            this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);
            this.changed();
          };
          return Point;
        }(geom_SimpleGeometry);
        var geom_Point = Point_Point;
        function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
          var outside = forEachCorner(extent, function(coordinate) {
            return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
          });
          return !outside;
        }
        function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
          var wn = 0;
          var x1 = flatCoordinates[end - stride];
          var y1 = flatCoordinates[end - stride + 1];
          for (; offset < end; offset += stride) {
            var x2 = flatCoordinates[offset];
            var y2 = flatCoordinates[offset + 1];
            if (y1 <= y) {
              if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
                wn++;
              }
            } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
              wn--;
            }
            x1 = x2;
            y1 = y2;
          }
          return wn !== 0;
        }
        function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
          if (ends.length === 0) {
            return false;
          }
          if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
            return false;
          }
          for (var i = 1, ii = ends.length; i < ii; ++i) {
            if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
              return false;
            }
          }
          return true;
        }
        function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
          if (endss.length === 0) {
            return false;
          }
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
              return true;
            }
            offset = ends[ends.length - 1];
          }
          return false;
        }
        function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
          var i, ii, x, x1, x2, y1, y2;
          var y = flatCenters[flatCentersOffset + 1];
          var intersections = [];
          for (var r = 0, rr = ends.length; r < rr; ++r) {
            var end = ends[r];
            x1 = flatCoordinates[end - stride];
            y1 = flatCoordinates[end - stride + 1];
            for (i = offset; i < end; i += stride) {
              x2 = flatCoordinates[i];
              y2 = flatCoordinates[i + 1];
              if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
                x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
                intersections.push(x);
              }
              x1 = x2;
              y1 = y2;
            }
          }
          var pointX = NaN;
          var maxSegmentLength = -Infinity;
          intersections.sort(ol_array["i"]);
          x1 = intersections[0];
          for (i = 1, ii = intersections.length; i < ii; ++i) {
            x2 = intersections[i];
            var segmentLength = Math.abs(x2 - x1);
            if (segmentLength > maxSegmentLength) {
              x = (x1 + x2) / 2;
              if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
                pointX = x;
                maxSegmentLength = segmentLength;
              }
            }
            x1 = x2;
          }
          if (isNaN(pointX)) {
            pointX = flatCenters[flatCentersOffset];
          }
          if (opt_dest) {
            opt_dest.push(pointX, y, maxSegmentLength);
            return opt_dest;
          } else {
            return [pointX, y, maxSegmentLength];
          }
        }
        function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
          var interiorPoints = [];
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
            offset = ends[ends.length - 1];
          }
          return interiorPoints;
        }
        function forEach(flatCoordinates, offset, end, stride, callback) {
          var ret;
          offset += stride;
          for (; offset < end; offset += stride) {
            ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));
            if (ret) {
              return ret;
            }
          }
          return false;
        }
        function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
          var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
          if (!extent_intersects(extent, coordinatesExtent)) {
            return false;
          }
          if (containsExtent(extent, coordinatesExtent)) {
            return true;
          }
          if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
            return true;
          }
          if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
            return true;
          }
          return forEach(flatCoordinates, offset, end, stride, function(point1, point2) {
            return intersectsSegment(extent, point1, point2);
          });
        }
        function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
              return true;
            }
            offset = ends[i];
          }
          return false;
        }
        function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
          if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
            return true;
          }
          if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
            return true;
          }
          if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
            return true;
          }
          if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
            return true;
          }
          if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
            return true;
          }
          return false;
        }
        function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
          if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
            return false;
          }
          if (ends.length === 1) {
            return true;
          }
          for (var i = 1, ii = ends.length; i < ii; ++i) {
            if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
              if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
                return false;
              }
            }
          }
          return true;
        }
        function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
              return true;
            }
            offset = ends[ends.length - 1];
          }
          return false;
        }
        function reverse_coordinates(flatCoordinates, offset, end, stride) {
          while (offset < end - stride) {
            for (var i = 0; i < stride; ++i) {
              var tmp = flatCoordinates[offset + i];
              flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
              flatCoordinates[end - stride + i] = tmp;
            }
            offset += stride;
            end -= stride;
          }
        }
        function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
          var edge = 0;
          var x1 = flatCoordinates[end - stride];
          var y1 = flatCoordinates[end - stride + 1];
          for (; offset < end; offset += stride) {
            var x2 = flatCoordinates[offset];
            var y2 = flatCoordinates[offset + 1];
            edge += (x2 - x1) * (y2 + y1);
            x1 = x2;
            y1 = y2;
          }
          return edge === 0 ? void 0 : edge > 0;
        }
        function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
          var right = opt_right !== void 0 ? opt_right : false;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
            if (i === 0) {
              if (right && isClockwise || !right && !isClockwise) {
                return false;
              }
            } else {
              if (right && !isClockwise || !right && isClockwise) {
                return false;
              }
            }
            offset = end;
          }
          return true;
        }
        function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {
              return false;
            }
            if (ends.length) {
              offset = ends[ends.length - 1];
            }
          }
          return true;
        }
        function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
          var right = opt_right !== void 0 ? opt_right : false;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
            var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
            if (reverse) {
              reverse_coordinates(flatCoordinates, offset, end, stride);
            }
            offset = end;
          }
          return offset;
        }
        function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
          }
          return offset;
        }
        var Polygon_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Polygon_Polygon = function(_super) {
          Polygon_extends(Polygon, _super);
          function Polygon(coordinates, opt_layout, opt_ends) {
            var _this = _super.call(this) || this;
            _this.ends_ = [];
            _this.flatInteriorPointRevision_ = -1;
            _this.flatInteriorPoint_ = null;
            _this.maxDelta_ = -1;
            _this.maxDeltaRevision_ = -1;
            _this.orientedRevision_ = -1;
            _this.orientedFlatCoordinates_ = null;
            if (opt_layout !== void 0 && opt_ends) {
              _this.setFlatCoordinates(opt_layout, coordinates);
              _this.ends_ = opt_ends;
            } else {
              _this.setCoordinates(coordinates, opt_layout);
            }
            return _this;
          }
          Polygon.prototype.appendLinearRing = function(linearRing) {
            if (!this.flatCoordinates) {
              this.flatCoordinates = linearRing.getFlatCoordinates().slice();
            } else {
              Object(ol_array["c"])(this.flatCoordinates, linearRing.getFlatCoordinates());
            }
            this.ends_.push(this.flatCoordinates.length);
            this.changed();
          };
          Polygon.prototype.clone = function() {
            var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
            polygon.applyProperties(this);
            return polygon;
          };
          Polygon.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
            }
            if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
            }
            return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
          };
          Polygon.prototype.containsXY = function(x, y) {
            return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
          };
          Polygon.prototype.getArea = function() {
            return area_linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
          };
          Polygon.prototype.getCoordinates = function(opt_right) {
            var flatCoordinates;
            if (opt_right !== void 0) {
              flatCoordinates = this.getOrientedFlatCoordinates().slice();
              orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
            } else {
              flatCoordinates = this.flatCoordinates;
            }
            return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
          };
          Polygon.prototype.getEnds = function() {
            return this.ends_;
          };
          Polygon.prototype.getFlatInteriorPoint = function() {
            if (this.flatInteriorPointRevision_ != this.getRevision()) {
              var flatCenter = extent_getCenter(this.getExtent());
              this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
              this.flatInteriorPointRevision_ = this.getRevision();
            }
            return this.flatInteriorPoint_;
          };
          Polygon.prototype.getInteriorPoint = function() {
            return new geom_Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);
          };
          Polygon.prototype.getLinearRingCount = function() {
            return this.ends_.length;
          };
          Polygon.prototype.getLinearRing = function(index) {
            if (index < 0 || this.ends_.length <= index) {
              return null;
            }
            return new geom_LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
          };
          Polygon.prototype.getLinearRings = function() {
            var layout = this.layout;
            var flatCoordinates = this.flatCoordinates;
            var ends = this.ends_;
            var linearRings = [];
            var offset = 0;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var linearRing = new geom_LinearRing(flatCoordinates.slice(offset, end), layout);
              linearRings.push(linearRing);
              offset = end;
            }
            return linearRings;
          };
          Polygon.prototype.getOrientedFlatCoordinates = function() {
            if (this.orientedRevision_ != this.getRevision()) {
              var flatCoordinates = this.flatCoordinates;
              if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
                this.orientedFlatCoordinates_ = flatCoordinates;
              } else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
              }
              this.orientedRevision_ = this.getRevision();
            }
            return this.orientedFlatCoordinates_;
          };
          Polygon.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
            var simplifiedFlatCoordinates = [];
            var simplifiedEnds = [];
            simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
            return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
          };
          Polygon.prototype.getType = function() {
            return geom_GeometryType.POLYGON;
          };
          Polygon.prototype.intersectsExtent = function(extent) {
            return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
          };
          Polygon.prototype.setCoordinates = function(coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 2);
            if (!this.flatCoordinates) {
              this.flatCoordinates = [];
            }
            var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
            this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
            this.changed();
          };
          return Polygon;
        }(geom_SimpleGeometry);
        var geom_Polygon = Polygon_Polygon;
        function circular(center, radius, opt_n, opt_sphereRadius) {
          var n = opt_n ? opt_n : 32;
          var flatCoordinates = [];
          for (var i = 0; i < n; ++i) {
            Object(ol_array["c"])(flatCoordinates, sphere_offset(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));
          }
          flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
          return new Polygon_Polygon(flatCoordinates, GeometryLayout.XY, [
            flatCoordinates.length
          ]);
        }
        function fromExtent(extent) {
          var minX = extent[0];
          var minY = extent[1];
          var maxX = extent[2];
          var maxY = extent[3];
          var flatCoordinates = [
            minX,
            minY,
            minX,
            maxY,
            maxX,
            maxY,
            maxX,
            minY,
            minX,
            minY
          ];
          return new Polygon_Polygon(flatCoordinates, GeometryLayout.XY, [
            flatCoordinates.length
          ]);
        }
        function fromCircle(circle, opt_sides, opt_angle) {
          var sides = opt_sides ? opt_sides : 32;
          var stride = circle.getStride();
          var layout = circle.getLayout();
          var center = circle.getCenter();
          var arrayLength = stride * (sides + 1);
          var flatCoordinates = new Array(arrayLength);
          for (var i = 0; i < arrayLength; i += stride) {
            flatCoordinates[i] = 0;
            flatCoordinates[i + 1] = 0;
            for (var j = 2; j < stride; j++) {
              flatCoordinates[i + j] = center[j];
            }
          }
          var ends = [flatCoordinates.length];
          var polygon = new Polygon_Polygon(flatCoordinates, layout, ends);
          makeRegular(polygon, center, circle.getRadius(), opt_angle);
          return polygon;
        }
        function makeRegular(polygon, center, radius, opt_angle) {
          var flatCoordinates = polygon.getFlatCoordinates();
          var stride = polygon.getStride();
          var sides = flatCoordinates.length / stride - 1;
          var startAngle = opt_angle ? opt_angle : 0;
          for (var i = 0; i <= sides; ++i) {
            var offset = i * stride;
            var angle = startAngle + modulo(i, sides) * 2 * Math.PI / sides;
            flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
            flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
          }
          polygon.changed();
        }
        var View_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var DEFAULT_MIN_ZOOM = 0;
        var View_View = function(_super) {
          View_extends(View, _super);
          function View(opt_options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            var options = Object(ol_obj["a"])({}, opt_options);
            _this.hints_ = [0, 0];
            _this.animations_ = [];
            _this.updateAnimationKey_;
            _this.projection_ = createProjection(options.projection, "EPSG:3857");
            _this.viewportSize_ = [100, 100];
            _this.targetCenter_ = null;
            _this.targetResolution_;
            _this.targetRotation_;
            _this.nextCenter_ = null;
            _this.nextResolution_;
            _this.nextRotation_;
            _this.cancelAnchor_ = void 0;
            if (options.center) {
              options.center = fromUserCoordinate(options.center, _this.projection_);
            }
            if (options.extent) {
              options.extent = fromUserExtent(options.extent, _this.projection_);
            }
            _this.applyOptions_(options);
            return _this;
          }
          View.prototype.applyOptions_ = function(options) {
            var properties = Object(ol_obj["a"])({}, options);
            for (var key in ViewProperty) {
              delete properties[key];
            }
            this.setProperties(properties, true);
            var resolutionConstraintInfo = createResolutionConstraint(options);
            this.maxResolution_ = resolutionConstraintInfo.maxResolution;
            this.minResolution_ = resolutionConstraintInfo.minResolution;
            this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
            this.resolutions_ = options.resolutions;
            this.padding_ = options.padding;
            this.minZoom_ = resolutionConstraintInfo.minZoom;
            var centerConstraint = createCenterConstraint(options);
            var resolutionConstraint = resolutionConstraintInfo.constraint;
            var rotationConstraint = createRotationConstraint(options);
            this.constraints_ = {
              center: centerConstraint,
              resolution: resolutionConstraint,
              rotation: rotationConstraint
            };
            this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
            this.setCenterInternal(options.center !== void 0 ? options.center : null);
            if (options.resolution !== void 0) {
              this.setResolution(options.resolution);
            } else if (options.zoom !== void 0) {
              this.setZoom(options.zoom);
            }
          };
          Object.defineProperty(View.prototype, "padding", {
            get: function() {
              return this.padding_;
            },
            set: function(padding) {
              var oldPadding = this.padding_;
              this.padding_ = padding;
              var center = this.getCenter();
              if (center) {
                var newPadding = padding || [0, 0, 0, 0];
                oldPadding = oldPadding || [0, 0, 0, 0];
                var resolution = this.getResolution();
                var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
                var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
                this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
              }
            },
            enumerable: false,
            configurable: true
          });
          View.prototype.getUpdatedOptions_ = function(newOptions) {
            var options = this.getProperties();
            if (options.resolution !== void 0) {
              options.resolution = this.getResolution();
            } else {
              options.zoom = this.getZoom();
            }
            options.center = this.getCenterInternal();
            options.rotation = this.getRotation();
            return Object(ol_obj["a"])({}, options, newOptions);
          };
          View.prototype.animate = function(var_args) {
            if (this.isDef() && !this.getAnimating()) {
              this.resolveConstraints(0);
            }
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; ++i) {
              var options = arguments[i];
              if (options.center) {
                options = Object(ol_obj["a"])({}, options);
                options.center = fromUserCoordinate(options.center, this.getProjection());
              }
              if (options.anchor) {
                options = Object(ol_obj["a"])({}, options);
                options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
              }
              args[i] = options;
            }
            this.animateInternal.apply(this, args);
          };
          View.prototype.animateInternal = function(var_args) {
            var animationCount = arguments.length;
            var callback;
            if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
              callback = arguments[animationCount - 1];
              --animationCount;
            }
            var i = 0;
            for (; i < animationCount && !this.isDef(); ++i) {
              var state = arguments[i];
              if (state.center) {
                this.setCenterInternal(state.center);
              }
              if (state.zoom !== void 0) {
                this.setZoom(state.zoom);
              } else if (state.resolution) {
                this.setResolution(state.resolution);
              }
              if (state.rotation !== void 0) {
                this.setRotation(state.rotation);
              }
            }
            if (i === animationCount) {
              if (callback) {
                animationCallback(callback, true);
              }
              return;
            }
            var start = Date.now();
            var center = this.targetCenter_.slice();
            var resolution = this.targetResolution_;
            var rotation = this.targetRotation_;
            var series = [];
            for (; i < animationCount; ++i) {
              var options = arguments[i];
              var animation = {
                start,
                complete: false,
                anchor: options.anchor,
                duration: options.duration !== void 0 ? options.duration : 1e3,
                easing: options.easing || inAndOut,
                callback
              };
              if (options.center) {
                animation.sourceCenter = center;
                animation.targetCenter = options.center.slice();
                center = animation.targetCenter;
              }
              if (options.zoom !== void 0) {
                animation.sourceResolution = resolution;
                animation.targetResolution = this.getResolutionForZoom(options.zoom);
                resolution = animation.targetResolution;
              } else if (options.resolution) {
                animation.sourceResolution = resolution;
                animation.targetResolution = options.resolution;
                resolution = animation.targetResolution;
              }
              if (options.rotation !== void 0) {
                animation.sourceRotation = rotation;
                var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                animation.targetRotation = rotation + delta;
                rotation = animation.targetRotation;
              }
              if (isNoopAnimation(animation)) {
                animation.complete = true;
              } else {
                start += animation.duration;
              }
              series.push(animation);
            }
            this.animations_.push(series);
            this.setHint(ViewHint.ANIMATING, 1);
            this.updateAnimations_();
          };
          View.prototype.getAnimating = function() {
            return this.hints_[ViewHint.ANIMATING] > 0;
          };
          View.prototype.getInteracting = function() {
            return this.hints_[ViewHint.INTERACTING] > 0;
          };
          View.prototype.cancelAnimations = function() {
            this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
            var anchor;
            for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
              var series = this.animations_[i];
              if (series[0].callback) {
                animationCallback(series[0].callback, false);
              }
              if (!anchor) {
                for (var j = 0, jj = series.length; j < jj; ++j) {
                  var animation = series[j];
                  if (!animation.complete) {
                    anchor = animation.anchor;
                    break;
                  }
                }
              }
            }
            this.animations_.length = 0;
            this.cancelAnchor_ = anchor;
            this.nextCenter_ = null;
            this.nextResolution_ = NaN;
            this.nextRotation_ = NaN;
          };
          View.prototype.updateAnimations_ = function() {
            if (this.updateAnimationKey_ !== void 0) {
              cancelAnimationFrame(this.updateAnimationKey_);
              this.updateAnimationKey_ = void 0;
            }
            if (!this.getAnimating()) {
              return;
            }
            var now = Date.now();
            var more = false;
            for (var i = this.animations_.length - 1; i >= 0; --i) {
              var series = this.animations_[i];
              var seriesComplete = true;
              for (var j = 0, jj = series.length; j < jj; ++j) {
                var animation = series[j];
                if (animation.complete) {
                  continue;
                }
                var elapsed = now - animation.start;
                var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                if (fraction >= 1) {
                  animation.complete = true;
                  fraction = 1;
                } else {
                  seriesComplete = false;
                }
                var progress = animation.easing(fraction);
                if (animation.sourceCenter) {
                  var x0 = animation.sourceCenter[0];
                  var y0 = animation.sourceCenter[1];
                  var x1 = animation.targetCenter[0];
                  var y1 = animation.targetCenter[1];
                  this.nextCenter_ = animation.targetCenter;
                  var x = x0 + progress * (x1 - x0);
                  var y = y0 + progress * (y1 - y0);
                  this.targetCenter_ = [x, y];
                }
                if (animation.sourceResolution && animation.targetResolution) {
                  var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
                  if (animation.anchor) {
                    var size = this.getViewportSize_(this.getRotation());
                    var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                    this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                  }
                  this.nextResolution_ = animation.targetResolution;
                  this.targetResolution_ = resolution;
                  this.applyTargetState_(true);
                }
                if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
                  var rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
                  if (animation.anchor) {
                    var constrainedRotation = this.constraints_.rotation(rotation, true);
                    this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                  }
                  this.nextRotation_ = animation.targetRotation;
                  this.targetRotation_ = rotation;
                }
                this.applyTargetState_(true);
                more = true;
                if (!animation.complete) {
                  break;
                }
              }
              if (seriesComplete) {
                this.animations_[i] = null;
                this.setHint(ViewHint.ANIMATING, -1);
                this.nextCenter_ = null;
                this.nextResolution_ = NaN;
                this.nextRotation_ = NaN;
                var callback = series[0].callback;
                if (callback) {
                  animationCallback(callback, true);
                }
              }
            }
            this.animations_ = this.animations_.filter(Boolean);
            if (more && this.updateAnimationKey_ === void 0) {
              this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
            }
          };
          View.prototype.calculateCenterRotate = function(rotation, anchor) {
            var center;
            var currentCenter = this.getCenterInternal();
            if (currentCenter !== void 0) {
              center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
              coordinate_rotate(center, rotation - this.getRotation());
              coordinate_add(center, anchor);
            }
            return center;
          };
          View.prototype.calculateCenterZoom = function(resolution, anchor) {
            var center;
            var currentCenter = this.getCenterInternal();
            var currentResolution = this.getResolution();
            if (currentCenter !== void 0 && currentResolution !== void 0) {
              var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
              var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
              center = [x, y];
            }
            return center;
          };
          View.prototype.getViewportSize_ = function(opt_rotation) {
            var size = this.viewportSize_;
            if (opt_rotation) {
              var w = size[0];
              var h = size[1];
              return [
                Math.abs(w * Math.cos(opt_rotation)) + Math.abs(h * Math.sin(opt_rotation)),
                Math.abs(w * Math.sin(opt_rotation)) + Math.abs(h * Math.cos(opt_rotation))
              ];
            } else {
              return size;
            }
          };
          View.prototype.setViewportSize = function(opt_size) {
            this.viewportSize_ = Array.isArray(opt_size) ? opt_size.slice() : [100, 100];
            if (!this.getAnimating()) {
              this.resolveConstraints(0);
            }
          };
          View.prototype.getCenter = function() {
            var center = this.getCenterInternal();
            if (!center) {
              return center;
            }
            return toUserCoordinate(center, this.getProjection());
          };
          View.prototype.getCenterInternal = function() {
            return this.get(ViewProperty.CENTER);
          };
          View.prototype.getConstraints = function() {
            return this.constraints_;
          };
          View.prototype.getConstrainResolution = function() {
            return this.get("constrainResolution");
          };
          View.prototype.getHints = function(opt_hints) {
            if (opt_hints !== void 0) {
              opt_hints[0] = this.hints_[0];
              opt_hints[1] = this.hints_[1];
              return opt_hints;
            } else {
              return this.hints_.slice();
            }
          };
          View.prototype.calculateExtent = function(opt_size) {
            var extent = this.calculateExtentInternal(opt_size);
            return toUserExtent(extent, this.getProjection());
          };
          View.prototype.calculateExtentInternal = function(opt_size) {
            var size = opt_size || this.getViewportSizeMinusPadding_();
            var center = this.getCenterInternal();
            assert2(center, 1);
            var resolution = this.getResolution();
            assert2(resolution !== void 0, 2);
            var rotation = this.getRotation();
            assert2(rotation !== void 0, 3);
            return getForViewAndSize(center, resolution, rotation, size);
          };
          View.prototype.getMaxResolution = function() {
            return this.maxResolution_;
          };
          View.prototype.getMinResolution = function() {
            return this.minResolution_;
          };
          View.prototype.getMaxZoom = function() {
            return this.getZoomForResolution(this.minResolution_);
          };
          View.prototype.setMaxZoom = function(zoom) {
            this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
          };
          View.prototype.getMinZoom = function() {
            return this.getZoomForResolution(this.maxResolution_);
          };
          View.prototype.setMinZoom = function(zoom) {
            this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
          };
          View.prototype.setConstrainResolution = function(enabled) {
            this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
          };
          View.prototype.getProjection = function() {
            return this.projection_;
          };
          View.prototype.getResolution = function() {
            return this.get(ViewProperty.RESOLUTION);
          };
          View.prototype.getResolutions = function() {
            return this.resolutions_;
          };
          View.prototype.getResolutionForExtent = function(extent, opt_size) {
            return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), opt_size);
          };
          View.prototype.getResolutionForExtentInternal = function(extent, opt_size) {
            var size = opt_size || this.getViewportSizeMinusPadding_();
            var xResolution = getWidth(extent) / size[0];
            var yResolution = getHeight(extent) / size[1];
            return Math.max(xResolution, yResolution);
          };
          View.prototype.getResolutionForValueFunction = function(opt_power) {
            var power = opt_power || 2;
            var maxResolution = this.getConstrainedResolution(this.maxResolution_);
            var minResolution = this.minResolution_;
            var max = Math.log(maxResolution / minResolution) / Math.log(power);
            return function(value) {
              var resolution = maxResolution / Math.pow(power, value * max);
              return resolution;
            };
          };
          View.prototype.getRotation = function() {
            return this.get(ViewProperty.ROTATION);
          };
          View.prototype.getValueForResolutionFunction = function(opt_power) {
            var logPower = Math.log(opt_power || 2);
            var maxResolution = this.getConstrainedResolution(this.maxResolution_);
            var minResolution = this.minResolution_;
            var max = Math.log(maxResolution / minResolution) / logPower;
            return function(resolution) {
              var value = Math.log(maxResolution / resolution) / logPower / max;
              return value;
            };
          };
          View.prototype.getViewportSizeMinusPadding_ = function(opt_rotation) {
            var size = this.getViewportSize_(opt_rotation);
            var padding = this.padding_;
            if (padding) {
              size = [
                size[0] - padding[1] - padding[3],
                size[1] - padding[0] - padding[2]
              ];
            }
            return size;
          };
          View.prototype.getState = function() {
            var projection = this.getProjection();
            var resolution = this.getResolution();
            var rotation = this.getRotation();
            var center = this.getCenterInternal();
            var padding = this.padding_;
            if (padding) {
              var reducedSize = this.getViewportSizeMinusPadding_();
              center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
            }
            return {
              center: center.slice(0),
              projection: projection !== void 0 ? projection : null,
              resolution,
              nextCenter: this.nextCenter_,
              nextResolution: this.nextResolution_,
              nextRotation: this.nextRotation_,
              rotation,
              zoom: this.getZoom()
            };
          };
          View.prototype.getZoom = function() {
            var zoom;
            var resolution = this.getResolution();
            if (resolution !== void 0) {
              zoom = this.getZoomForResolution(resolution);
            }
            return zoom;
          };
          View.prototype.getZoomForResolution = function(resolution) {
            var offset = this.minZoom_ || 0;
            var max, zoomFactor;
            if (this.resolutions_) {
              var nearest = Object(ol_array["h"])(this.resolutions_, resolution, 1);
              offset = nearest;
              max = this.resolutions_[nearest];
              if (nearest == this.resolutions_.length - 1) {
                zoomFactor = 2;
              } else {
                zoomFactor = max / this.resolutions_[nearest + 1];
              }
            } else {
              max = this.maxResolution_;
              zoomFactor = this.zoomFactor_;
            }
            return offset + Math.log(max / resolution) / Math.log(zoomFactor);
          };
          View.prototype.getResolutionForZoom = function(zoom) {
            if (this.resolutions_) {
              if (this.resolutions_.length <= 1) {
                return 0;
              }
              var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
              var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
              return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
            } else {
              return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
            }
          };
          View.prototype.fit = function(geometryOrExtent, opt_options) {
            var geometry;
            assert2(Array.isArray(geometryOrExtent) || typeof geometryOrExtent.getSimplifiedGeometry === "function", 24);
            if (Array.isArray(geometryOrExtent)) {
              assert2(!extent_isEmpty(geometryOrExtent), 25);
              var extent = fromUserExtent(geometryOrExtent, this.getProjection());
              geometry = fromExtent(extent);
            } else if (geometryOrExtent.getType() === geom_GeometryType.CIRCLE) {
              var extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
              geometry = fromExtent(extent);
              geometry.rotate(this.getRotation(), extent_getCenter(extent));
            } else {
              var userProjection = getUserProjection();
              if (userProjection) {
                geometry = geometryOrExtent.clone().transform(userProjection, this.getProjection());
              } else {
                geometry = geometryOrExtent;
              }
            }
            this.fitInternal(geometry, opt_options);
          };
          View.prototype.rotatedExtentForGeometry = function(geometry) {
            var rotation = this.getRotation();
            var cosAngle = Math.cos(rotation);
            var sinAngle = Math.sin(-rotation);
            var coords = geometry.getFlatCoordinates();
            var stride = geometry.getStride();
            var minRotX = Infinity;
            var minRotY = Infinity;
            var maxRotX = -Infinity;
            var maxRotY = -Infinity;
            for (var i = 0, ii = coords.length; i < ii; i += stride) {
              var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
              var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
              minRotX = Math.min(minRotX, rotX);
              minRotY = Math.min(minRotY, rotY);
              maxRotX = Math.max(maxRotX, rotX);
              maxRotY = Math.max(maxRotY, rotY);
            }
            return [minRotX, minRotY, maxRotX, maxRotY];
          };
          View.prototype.fitInternal = function(geometry, opt_options) {
            var options = opt_options || {};
            var size = options.size;
            if (!size) {
              size = this.getViewportSizeMinusPadding_();
            }
            var padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
            var nearest = options.nearest !== void 0 ? options.nearest : false;
            var minResolution;
            if (options.minResolution !== void 0) {
              minResolution = options.minResolution;
            } else if (options.maxZoom !== void 0) {
              minResolution = this.getResolutionForZoom(options.maxZoom);
            } else {
              minResolution = 0;
            }
            var rotatedExtent = this.rotatedExtentForGeometry(geometry);
            var resolution = this.getResolutionForExtentInternal(rotatedExtent, [
              size[0] - padding[1] - padding[3],
              size[1] - padding[0] - padding[2]
            ]);
            resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
            resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
            var rotation = this.getRotation();
            var sinAngle = Math.sin(rotation);
            var cosAngle = Math.cos(rotation);
            var centerRot = extent_getCenter(rotatedExtent);
            centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
            centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
            var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
            var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
            var center = this.getConstrainedCenter([centerX, centerY], resolution);
            var callback = options.callback ? options.callback : functions["c"];
            if (options.duration !== void 0) {
              this.animateInternal({
                resolution,
                center,
                duration: options.duration,
                easing: options.easing
              }, callback);
            } else {
              this.targetResolution_ = resolution;
              this.targetCenter_ = center;
              this.applyTargetState_(false, true);
              animationCallback(callback, true);
            }
          };
          View.prototype.centerOn = function(coordinate, size, position) {
            this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);
          };
          View.prototype.centerOnInternal = function(coordinate, size, position) {
            this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
          };
          View.prototype.calculateCenterShift = function(center, resolution, rotation, size) {
            var centerShift;
            var padding = this.padding_;
            if (padding && center) {
              var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
              var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
              centerShift = [
                center[0] - shiftedCenter[0],
                center[1] - shiftedCenter[1]
              ];
            }
            return centerShift;
          };
          View.prototype.isDef = function() {
            return !!this.getCenterInternal() && this.getResolution() !== void 0;
          };
          View.prototype.adjustCenter = function(deltaCoordinates) {
            var center = toUserCoordinate(this.targetCenter_, this.getProjection());
            this.setCenter([
              center[0] + deltaCoordinates[0],
              center[1] + deltaCoordinates[1]
            ]);
          };
          View.prototype.adjustCenterInternal = function(deltaCoordinates) {
            var center = this.targetCenter_;
            this.setCenterInternal([
              center[0] + deltaCoordinates[0],
              center[1] + deltaCoordinates[1]
            ]);
          };
          View.prototype.adjustResolution = function(ratio, opt_anchor) {
            var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
            this.adjustResolutionInternal(ratio, anchor);
          };
          View.prototype.adjustResolutionInternal = function(ratio, opt_anchor) {
            var isMoving = this.getAnimating() || this.getInteracting();
            var size = this.getViewportSize_(this.getRotation());
            var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
            if (opt_anchor) {
              this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
            }
            this.targetResolution_ *= ratio;
            this.applyTargetState_();
          };
          View.prototype.adjustZoom = function(delta, opt_anchor) {
            this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
          };
          View.prototype.adjustRotation = function(delta, opt_anchor) {
            if (opt_anchor) {
              opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());
            }
            this.adjustRotationInternal(delta, opt_anchor);
          };
          View.prototype.adjustRotationInternal = function(delta, opt_anchor) {
            var isMoving = this.getAnimating() || this.getInteracting();
            var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
            if (opt_anchor) {
              this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
            }
            this.targetRotation_ += delta;
            this.applyTargetState_();
          };
          View.prototype.setCenter = function(center) {
            this.setCenterInternal(fromUserCoordinate(center, this.getProjection()));
          };
          View.prototype.setCenterInternal = function(center) {
            this.targetCenter_ = center;
            this.applyTargetState_();
          };
          View.prototype.setHint = function(hint, delta) {
            this.hints_[hint] += delta;
            this.changed();
            return this.hints_[hint];
          };
          View.prototype.setResolution = function(resolution) {
            this.targetResolution_ = resolution;
            this.applyTargetState_();
          };
          View.prototype.setRotation = function(rotation) {
            this.targetRotation_ = rotation;
            this.applyTargetState_();
          };
          View.prototype.setZoom = function(zoom) {
            this.setResolution(this.getResolutionForZoom(zoom));
          };
          View.prototype.applyTargetState_ = function(opt_doNotCancelAnims, opt_forceMoving) {
            var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
            var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
            var size = this.getViewportSize_(newRotation);
            var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
            var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
            if (this.get(ViewProperty.ROTATION) !== newRotation) {
              this.set(ViewProperty.ROTATION, newRotation);
            }
            if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
              this.set(ViewProperty.RESOLUTION, newResolution);
              this.set("zoom", this.getZoom(), true);
            }
            if (!newCenter || !this.get(ViewProperty.CENTER) || !coordinate_equals(this.get(ViewProperty.CENTER), newCenter)) {
              this.set(ViewProperty.CENTER, newCenter);
            }
            if (this.getAnimating() && !opt_doNotCancelAnims) {
              this.cancelAnimations();
            }
            this.cancelAnchor_ = void 0;
          };
          View.prototype.resolveConstraints = function(opt_duration, opt_resolutionDirection, opt_anchor) {
            var duration = opt_duration !== void 0 ? opt_duration : 200;
            var direction = opt_resolutionDirection || 0;
            var newRotation = this.constraints_.rotation(this.targetRotation_);
            var size = this.getViewportSize_(newRotation);
            var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
            var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
            if (duration === 0 && !this.cancelAnchor_) {
              this.targetResolution_ = newResolution;
              this.targetRotation_ = newRotation;
              this.targetCenter_ = newCenter;
              this.applyTargetState_();
              return;
            }
            var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
            this.cancelAnchor_ = void 0;
            if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !coordinate_equals(this.getCenterInternal(), newCenter)) {
              if (this.getAnimating()) {
                this.cancelAnimations();
              }
              this.animateInternal({
                rotation: newRotation,
                center: newCenter,
                resolution: newResolution,
                duration,
                easing: easeOut,
                anchor
              });
            }
          };
          View.prototype.beginInteraction = function() {
            this.resolveConstraints(0);
            this.setHint(ViewHint.INTERACTING, 1);
          };
          View.prototype.endInteraction = function(opt_duration, opt_resolutionDirection, opt_anchor) {
            var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
            this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
          };
          View.prototype.endInteractionInternal = function(opt_duration, opt_resolutionDirection, opt_anchor) {
            this.setHint(ViewHint.INTERACTING, -1);
            this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
          };
          View.prototype.getConstrainedCenter = function(targetCenter, opt_targetResolution) {
            var size = this.getViewportSize_(this.getRotation());
            return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
          };
          View.prototype.getConstrainedZoom = function(targetZoom, opt_direction) {
            var targetRes = this.getResolutionForZoom(targetZoom);
            return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
          };
          View.prototype.getConstrainedResolution = function(targetResolution, opt_direction) {
            var direction = opt_direction || 0;
            var size = this.getViewportSize_(this.getRotation());
            return this.constraints_.resolution(targetResolution, direction, size);
          };
          return View;
        }(ol_Object["a"]);
        function animationCallback(callback, returnValue) {
          setTimeout(function() {
            callback(returnValue);
          }, 0);
        }
        function createCenterConstraint(options) {
          if (options.extent !== void 0) {
            var smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
            return createExtent(options.extent, options.constrainOnlyCenter, smooth);
          }
          var projection = createProjection(options.projection, "EPSG:3857");
          if (options.multiWorld !== true && projection.isGlobal()) {
            var extent = projection.getExtent().slice();
            extent[0] = -Infinity;
            extent[2] = Infinity;
            return createExtent(extent, false, false);
          }
          return none;
        }
        function createResolutionConstraint(options) {
          var resolutionConstraint;
          var maxResolution;
          var minResolution;
          var defaultMaxZoom = 28;
          var defaultZoomFactor = 2;
          var minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
          var maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
          var zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
          var multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
          var smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
          var showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
          var projection = createProjection(options.projection, "EPSG:3857");
          var projExtent = projection.getExtent();
          var constrainOnlyCenter = options.constrainOnlyCenter;
          var extent = options.extent;
          if (!multiWorld && !extent && projection.isGlobal()) {
            constrainOnlyCenter = false;
            extent = projExtent;
          }
          if (options.resolutions !== void 0) {
            var resolutions = options.resolutions;
            maxResolution = resolutions[minZoom];
            minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
            if (options.constrainResolution) {
              resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
            } else {
              resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
            }
          } else {
            var size = !projExtent ? 360 * METERS_PER_UNIT[proj_Units.DEGREES] / projection.getMetersPerUnit() : Math.max(getWidth(projExtent), getHeight(projExtent));
            var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
            var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
            maxResolution = options.maxResolution;
            if (maxResolution !== void 0) {
              minZoom = 0;
            } else {
              maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
            }
            minResolution = options.minResolution;
            if (minResolution === void 0) {
              if (options.maxZoom !== void 0) {
                if (options.maxResolution !== void 0) {
                  minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                } else {
                  minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
                }
              } else {
                minResolution = defaultMinResolution;
              }
            }
            maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
            minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
            if (options.constrainResolution) {
              resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
            } else {
              resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
            }
          }
          return {
            constraint: resolutionConstraint,
            maxResolution,
            minResolution,
            minZoom,
            zoomFactor
          };
        }
        function createRotationConstraint(options) {
          var enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
          if (enableRotation) {
            var constrainRotation = options.constrainRotation;
            if (constrainRotation === void 0 || constrainRotation === true) {
              return createSnapToZero();
            } else if (constrainRotation === false) {
              return rotationconstraint_none;
            } else if (typeof constrainRotation === "number") {
              return createSnapToN(constrainRotation);
            } else {
              return rotationconstraint_none;
            }
          } else {
            return disable;
          }
        }
        function isNoopAnimation(animation) {
          if (animation.sourceCenter && animation.targetCenter) {
            if (!coordinate_equals(animation.sourceCenter, animation.targetCenter)) {
              return false;
            }
          }
          if (animation.sourceResolution !== animation.targetResolution) {
            return false;
          }
          if (animation.sourceRotation !== animation.targetRotation) {
            return false;
          }
          return true;
        }
        function calculateCenterOn(coordinate, size, position, resolution, rotation) {
          var cosAngle = Math.cos(-rotation);
          var sinAngle = Math.sin(-rotation);
          var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
          var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
          rotX += (size[0] / 2 - position[0]) * resolution;
          rotY += (position[1] - size[1] / 2) * resolution;
          sinAngle = -sinAngle;
          var centerX = rotX * cosAngle - rotY * sinAngle;
          var centerY = rotY * cosAngle + rotX * sinAngle;
          return [centerX, centerY];
        }
        var ol_View = View_View;
        function size_buffer(size, num, opt_size) {
          if (opt_size === void 0) {
            opt_size = [0, 0];
          }
          opt_size[0] = size[0] + 2 * num;
          opt_size[1] = size[1] + 2 * num;
          return opt_size;
        }
        function hasArea(size) {
          return size[0] > 0 && size[1] > 0;
        }
        function size_scale(size, ratio, opt_size) {
          if (opt_size === void 0) {
            opt_size = [0, 0];
          }
          opt_size[0] = size[0] * ratio + 0.5 | 0;
          opt_size[1] = size[1] * ratio + 0.5 | 0;
          return opt_size;
        }
        function toSize(size, opt_size) {
          if (Array.isArray(size)) {
            return size;
          } else {
            if (opt_size === void 0) {
              opt_size = [size, size];
            } else {
              opt_size[0] = size;
              opt_size[1] = size;
            }
            return opt_size;
          }
        }
        var PluggableMap_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        function removeLayerMapProperty(layer) {
          if (layer instanceof layer_Layer) {
            layer.setMapInternal(null);
            return;
          }
          if (layer instanceof Group) {
            layer.getLayers().forEach(removeLayerMapProperty);
          }
        }
        function setLayerMapProperty(layer, map) {
          if (layer instanceof layer_Layer) {
            layer.setMapInternal(map);
            return;
          }
          if (layer instanceof Group) {
            var layers = layer.getLayers().getArray();
            for (var i = 0, ii = layers.length; i < ii; ++i) {
              setLayerMapProperty(layers[i], map);
            }
          }
        }
        var PluggableMap_PluggableMap = function(_super) {
          PluggableMap_extends(PluggableMap, _super);
          function PluggableMap(options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            var optionsInternal = createOptionsInternal(options);
            _this.renderComplete_;
            _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
            _this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
            _this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : has["a"];
            _this.postRenderTimeoutHandle_;
            _this.animationDelayKey_;
            _this.animationDelay_ = function() {
              this.animationDelayKey_ = void 0;
              this.renderFrame_(Date.now());
            }.bind(_this);
            _this.coordinateToPixelTransform_ = create();
            _this.pixelToCoordinateTransform_ = create();
            _this.frameIndex_ = 0;
            _this.frameState_ = null;
            _this.previousExtent_ = null;
            _this.viewPropertyListenerKey_ = null;
            _this.viewChangeListenerKey_ = null;
            _this.layerGroupPropertyListenerKeys_ = null;
            _this.viewport_ = document.createElement("div");
            _this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
            _this.viewport_.style.position = "relative";
            _this.viewport_.style.overflow = "hidden";
            _this.viewport_.style.width = "100%";
            _this.viewport_.style.height = "100%";
            _this.overlayContainer_ = document.createElement("div");
            _this.overlayContainer_.style.position = "absolute";
            _this.overlayContainer_.style.zIndex = "0";
            _this.overlayContainer_.style.width = "100%";
            _this.overlayContainer_.style.height = "100%";
            _this.overlayContainer_.style.pointerEvents = "none";
            _this.overlayContainer_.className = "ol-overlaycontainer";
            _this.viewport_.appendChild(_this.overlayContainer_);
            _this.overlayContainerStopEvent_ = document.createElement("div");
            _this.overlayContainerStopEvent_.style.position = "absolute";
            _this.overlayContainerStopEvent_.style.zIndex = "0";
            _this.overlayContainerStopEvent_.style.width = "100%";
            _this.overlayContainerStopEvent_.style.height = "100%";
            _this.overlayContainerStopEvent_.style.pointerEvents = "none";
            _this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
            _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
            _this.mapBrowserEventHandler_ = null;
            _this.moveTolerance_ = options.moveTolerance;
            _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
            _this.targetChangeHandlerKeys_ = null;
            _this.controls = optionsInternal.controls || new ol_Collection();
            _this.interactions = optionsInternal.interactions || new ol_Collection();
            _this.overlays_ = optionsInternal.overlays;
            _this.overlayIdIndex_ = {};
            _this.renderer_ = null;
            _this.postRenderFunctions_ = [];
            _this.tileQueue_ = new ol_TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));
            _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);
            _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);
            _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);
            _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_);
            _this.setProperties(optionsInternal.values);
            var map = _this;
            if (options.view && !(options.view instanceof ol_View)) {
              options.view.then(function(viewOptions) {
                map.setView(new ol_View(viewOptions));
              });
            }
            _this.controls.addEventListener(CollectionEventType.ADD, function(event) {
              event.element.setMap(this);
            }.bind(_this));
            _this.controls.addEventListener(CollectionEventType.REMOVE, function(event) {
              event.element.setMap(null);
            }.bind(_this));
            _this.interactions.addEventListener(CollectionEventType.ADD, function(event) {
              event.element.setMap(this);
            }.bind(_this));
            _this.interactions.addEventListener(CollectionEventType.REMOVE, function(event) {
              event.element.setMap(null);
            }.bind(_this));
            _this.overlays_.addEventListener(CollectionEventType.ADD, function(event) {
              this.addOverlayInternal_(event.element);
            }.bind(_this));
            _this.overlays_.addEventListener(CollectionEventType.REMOVE, function(event) {
              var overlay = event.element;
              var id = overlay.getId();
              if (id !== void 0) {
                delete this.overlayIdIndex_[id.toString()];
              }
              event.element.setMap(null);
            }.bind(_this));
            _this.controls.forEach(function(control) {
              control.setMap(this);
            }.bind(_this));
            _this.interactions.forEach(function(interaction) {
              interaction.setMap(this);
            }.bind(_this));
            _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));
            return _this;
          }
          PluggableMap.prototype.createRenderer = function() {
            throw new Error("Use a map type that has a createRenderer method");
          };
          PluggableMap.prototype.addControl = function(control) {
            this.getControls().push(control);
          };
          PluggableMap.prototype.addInteraction = function(interaction) {
            this.getInteractions().push(interaction);
          };
          PluggableMap.prototype.addLayer = function(layer) {
            var layers = this.getLayerGroup().getLayers();
            layers.push(layer);
          };
          PluggableMap.prototype.handleLayerAdd_ = function(event) {
            setLayerMapProperty(event.layer, this);
          };
          PluggableMap.prototype.addOverlay = function(overlay) {
            this.getOverlays().push(overlay);
          };
          PluggableMap.prototype.addOverlayInternal_ = function(overlay) {
            var id = overlay.getId();
            if (id !== void 0) {
              this.overlayIdIndex_[id.toString()] = overlay;
            }
            overlay.setMap(this);
          };
          PluggableMap.prototype.disposeInternal = function() {
            this.setTarget(null);
            _super.prototype.disposeInternal.call(this);
          };
          PluggableMap.prototype.forEachFeatureAtPixel = function(pixel, callback, opt_options) {
            if (!this.frameState_) {
              return;
            }
            var coordinate = this.getCoordinateFromPixelInternal(pixel);
            opt_options = opt_options !== void 0 ? opt_options : {};
            var hitTolerance = opt_options.hitTolerance !== void 0 ? opt_options.hitTolerance : 0;
            var layerFilter = opt_options.layerFilter !== void 0 ? opt_options.layerFilter : functions["b"];
            var checkWrapped = opt_options.checkWrapped !== false;
            return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
          };
          PluggableMap.prototype.getFeaturesAtPixel = function(pixel, opt_options) {
            var features = [];
            this.forEachFeatureAtPixel(pixel, function(feature) {
              features.push(feature);
            }, opt_options);
            return features;
          };
          PluggableMap.prototype.getAllLayers = function() {
            var layers = [];
            function addLayersFrom(layerGroup) {
              layerGroup.forEach(function(layer) {
                if (layer instanceof Group) {
                  addLayersFrom(layer.getLayers());
                } else {
                  layers.push(layer);
                }
              });
            }
            addLayersFrom(this.getLayers());
            return layers;
          };
          PluggableMap.prototype.forEachLayerAtPixel = function(pixel, callback, opt_options) {
            if (!this.frameState_) {
              return;
            }
            var options = opt_options || {};
            var hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
            var layerFilter = options.layerFilter || functions["b"];
            return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
          };
          PluggableMap.prototype.hasFeatureAtPixel = function(pixel, opt_options) {
            if (!this.frameState_) {
              return false;
            }
            var coordinate = this.getCoordinateFromPixelInternal(pixel);
            opt_options = opt_options !== void 0 ? opt_options : {};
            var layerFilter = opt_options.layerFilter !== void 0 ? opt_options.layerFilter : functions["b"];
            var hitTolerance = opt_options.hitTolerance !== void 0 ? opt_options.hitTolerance : 0;
            var checkWrapped = opt_options.checkWrapped !== false;
            return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
          };
          PluggableMap.prototype.getEventCoordinate = function(event) {
            return this.getCoordinateFromPixel(this.getEventPixel(event));
          };
          PluggableMap.prototype.getEventCoordinateInternal = function(event) {
            return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
          };
          PluggableMap.prototype.getEventPixel = function(event) {
            var viewportPosition = this.viewport_.getBoundingClientRect();
            var eventPosition = "changedTouches" in event ? event.changedTouches[0] : event;
            return [
              eventPosition.clientX - viewportPosition.left,
              eventPosition.clientY - viewportPosition.top
            ];
          };
          PluggableMap.prototype.getTarget = function() {
            return this.get(MapProperty.TARGET);
          };
          PluggableMap.prototype.getTargetElement = function() {
            var target = this.getTarget();
            if (target !== void 0) {
              return typeof target === "string" ? document.getElementById(target) : target;
            } else {
              return null;
            }
          };
          PluggableMap.prototype.getCoordinateFromPixel = function(pixel) {
            return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
          };
          PluggableMap.prototype.getCoordinateFromPixelInternal = function(pixel) {
            var frameState = this.frameState_;
            if (!frameState) {
              return null;
            } else {
              return apply(frameState.pixelToCoordinateTransform, pixel.slice());
            }
          };
          PluggableMap.prototype.getControls = function() {
            return this.controls;
          };
          PluggableMap.prototype.getOverlays = function() {
            return this.overlays_;
          };
          PluggableMap.prototype.getOverlayById = function(id) {
            var overlay = this.overlayIdIndex_[id.toString()];
            return overlay !== void 0 ? overlay : null;
          };
          PluggableMap.prototype.getInteractions = function() {
            return this.interactions;
          };
          PluggableMap.prototype.getLayerGroup = function() {
            return this.get(MapProperty.LAYERGROUP);
          };
          PluggableMap.prototype.setLayers = function(layers) {
            var group = this.getLayerGroup();
            if (layers instanceof ol_Collection) {
              group.setLayers(layers);
              return;
            }
            var collection = group.getLayers();
            collection.clear();
            collection.extend(layers);
          };
          PluggableMap.prototype.getLayers = function() {
            var layers = this.getLayerGroup().getLayers();
            return layers;
          };
          PluggableMap.prototype.getLoading = function() {
            var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
            for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layer = layerStatesArray[i].layer;
              var source = layer.getSource();
              if (source && source.loading) {
                return true;
              }
            }
            return false;
          };
          PluggableMap.prototype.getPixelFromCoordinate = function(coordinate) {
            var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
            return this.getPixelFromCoordinateInternal(viewCoordinate);
          };
          PluggableMap.prototype.getPixelFromCoordinateInternal = function(coordinate) {
            var frameState = this.frameState_;
            if (!frameState) {
              return null;
            } else {
              return apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
            }
          };
          PluggableMap.prototype.getRenderer = function() {
            return this.renderer_;
          };
          PluggableMap.prototype.getSize = function() {
            return this.get(MapProperty.SIZE);
          };
          PluggableMap.prototype.getView = function() {
            return this.get(MapProperty.VIEW);
          };
          PluggableMap.prototype.getViewport = function() {
            return this.viewport_;
          };
          PluggableMap.prototype.getOverlayContainer = function() {
            return this.overlayContainer_;
          };
          PluggableMap.prototype.getOverlayContainerStopEvent = function() {
            return this.overlayContainerStopEvent_;
          };
          PluggableMap.prototype.getOwnerDocument = function() {
            var targetElement = this.getTargetElement();
            return targetElement ? targetElement.ownerDocument : document;
          };
          PluggableMap.prototype.getTilePriority = function(tile, tileSourceKey, tileCenter, tileResolution) {
            return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
          };
          PluggableMap.prototype.handleBrowserEvent = function(browserEvent, opt_type) {
            var type = opt_type || browserEvent.type;
            var mapBrowserEvent = new ol_MapBrowserEvent(type, this, browserEvent);
            this.handleMapBrowserEvent(mapBrowserEvent);
          };
          PluggableMap.prototype.handleMapBrowserEvent = function(mapBrowserEvent) {
            if (!this.frameState_) {
              return;
            }
            var originalEvent = mapBrowserEvent.originalEvent;
            var eventType = originalEvent.type;
            if (eventType === pointer_EventType.POINTERDOWN || eventType === EventType["a"].WHEEL || eventType === EventType["a"].KEYDOWN) {
              var doc = this.getOwnerDocument();
              var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
              var target = originalEvent.target;
              if (this.overlayContainerStopEvent_.contains(target) || !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
                return;
              }
            }
            mapBrowserEvent.frameState = this.frameState_;
            if (this.dispatchEvent(mapBrowserEvent) !== false) {
              var interactionsArray = this.getInteractions().getArray().slice();
              for (var i = interactionsArray.length - 1; i >= 0; i--) {
                var interaction = interactionsArray[i];
                if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
                  continue;
                }
                var cont = interaction.handleEvent(mapBrowserEvent);
                if (!cont || mapBrowserEvent.propagationStopped) {
                  break;
                }
              }
            }
          };
          PluggableMap.prototype.handlePostRender = function() {
            var frameState = this.frameState_;
            var tileQueue = this.tileQueue_;
            if (!tileQueue.isEmpty()) {
              var maxTotalLoading = this.maxTilesLoading_;
              var maxNewLoads = maxTotalLoading;
              if (frameState) {
                var hints = frameState.viewHints;
                if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
                  var lowOnFrameBudget = Date.now() - frameState.time > 8;
                  maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                  maxNewLoads = lowOnFrameBudget ? 0 : 2;
                }
              }
              if (tileQueue.getTilesLoading() < maxTotalLoading) {
                tileQueue.reprioritize();
                tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
              }
            }
            if (frameState && this.hasListener(render_EventType.RENDERCOMPLETE) && !frameState.animate && this.renderComplete_) {
              this.renderer_.dispatchRenderEvent(render_EventType.RENDERCOMPLETE, frameState);
            }
            var postRenderFunctions = this.postRenderFunctions_;
            for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
              postRenderFunctions[i](this, frameState);
            }
            postRenderFunctions.length = 0;
          };
          PluggableMap.prototype.handleSizeChanged_ = function() {
            if (this.getView() && !this.getView().getAnimating()) {
              this.getView().resolveConstraints(0);
            }
            this.render();
          };
          PluggableMap.prototype.handleTargetChanged_ = function() {
            if (this.mapBrowserEventHandler_) {
              for (var i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
                Object(events["c"])(this.targetChangeHandlerKeys_[i]);
              }
              this.targetChangeHandlerKeys_ = null;
              this.viewport_.removeEventListener(EventType["a"].CONTEXTMENU, this.boundHandleBrowserEvent_);
              this.viewport_.removeEventListener(EventType["a"].WHEEL, this.boundHandleBrowserEvent_);
              this.mapBrowserEventHandler_.dispose();
              this.mapBrowserEventHandler_ = null;
              Object(dom["e"])(this.viewport_);
            }
            var targetElement = this.getTargetElement();
            if (!targetElement) {
              if (this.renderer_) {
                clearTimeout(this.postRenderTimeoutHandle_);
                this.postRenderTimeoutHandle_ = void 0;
                this.postRenderFunctions_.length = 0;
                this.renderer_.dispose();
                this.renderer_ = null;
              }
              if (this.animationDelayKey_) {
                cancelAnimationFrame(this.animationDelayKey_);
                this.animationDelayKey_ = void 0;
              }
            } else {
              targetElement.appendChild(this.viewport_);
              if (!this.renderer_) {
                this.renderer_ = this.createRenderer();
              }
              this.mapBrowserEventHandler_ = new ol_MapBrowserEventHandler(this, this.moveTolerance_);
              for (var key in MapBrowserEventType) {
                this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));
              }
              this.viewport_.addEventListener(EventType["a"].CONTEXTMENU, this.boundHandleBrowserEvent_, false);
              this.viewport_.addEventListener(EventType["a"].WHEEL, this.boundHandleBrowserEvent_, has["e"] ? { passive: false } : false);
              var defaultView = this.getOwnerDocument().defaultView;
              var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
              this.targetChangeHandlerKeys_ = [
                Object(events["a"])(keyboardEventTarget, EventType["a"].KEYDOWN, this.handleBrowserEvent, this),
                Object(events["a"])(keyboardEventTarget, EventType["a"].KEYPRESS, this.handleBrowserEvent, this),
                Object(events["a"])(defaultView, EventType["a"].RESIZE, this.updateSize, this)
              ];
            }
            this.updateSize();
          };
          PluggableMap.prototype.handleTileChange_ = function() {
            this.render();
          };
          PluggableMap.prototype.handleViewPropertyChanged_ = function() {
            this.render();
          };
          PluggableMap.prototype.handleViewChanged_ = function() {
            if (this.viewPropertyListenerKey_) {
              Object(events["c"])(this.viewPropertyListenerKey_);
              this.viewPropertyListenerKey_ = null;
            }
            if (this.viewChangeListenerKey_) {
              Object(events["c"])(this.viewChangeListenerKey_);
              this.viewChangeListenerKey_ = null;
            }
            var view = this.getView();
            if (view) {
              this.updateViewportSize_();
              this.viewPropertyListenerKey_ = Object(events["a"])(view, ObjectEventType["a"].PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
              this.viewChangeListenerKey_ = Object(events["a"])(view, EventType["a"].CHANGE, this.handleViewPropertyChanged_, this);
              view.resolveConstraints(0);
            }
            this.render();
          };
          PluggableMap.prototype.handleLayerGroupChanged_ = function() {
            if (this.layerGroupPropertyListenerKeys_) {
              this.layerGroupPropertyListenerKeys_.forEach(events["c"]);
              this.layerGroupPropertyListenerKeys_ = null;
            }
            var layerGroup = this.getLayerGroup();
            if (layerGroup) {
              this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
              this.layerGroupPropertyListenerKeys_ = [
                Object(events["a"])(layerGroup, ObjectEventType["a"].PROPERTYCHANGE, this.render, this),
                Object(events["a"])(layerGroup, EventType["a"].CHANGE, this.render, this),
                Object(events["a"])(layerGroup, "addlayer", this.handleLayerAdd_, this),
                Object(events["a"])(layerGroup, "removelayer", this.handleLayerRemove_, this)
              ];
            }
            this.render();
          };
          PluggableMap.prototype.isRendered = function() {
            return !!this.frameState_;
          };
          PluggableMap.prototype.renderSync = function() {
            if (this.animationDelayKey_) {
              cancelAnimationFrame(this.animationDelayKey_);
            }
            this.animationDelay_();
          };
          PluggableMap.prototype.redrawText = function() {
            var layerStates = this.getLayerGroup().getLayerStatesArray();
            for (var i = 0, ii = layerStates.length; i < ii; ++i) {
              var layer = layerStates[i].layer;
              if (layer.hasRenderer()) {
                layer.getRenderer().handleFontsChanged();
              }
            }
          };
          PluggableMap.prototype.render = function() {
            if (this.renderer_ && this.animationDelayKey_ === void 0) {
              this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
            }
          };
          PluggableMap.prototype.removeControl = function(control) {
            return this.getControls().remove(control);
          };
          PluggableMap.prototype.removeInteraction = function(interaction) {
            return this.getInteractions().remove(interaction);
          };
          PluggableMap.prototype.removeLayer = function(layer) {
            var layers = this.getLayerGroup().getLayers();
            return layers.remove(layer);
          };
          PluggableMap.prototype.handleLayerRemove_ = function(event) {
            removeLayerMapProperty(event.layer);
          };
          PluggableMap.prototype.removeOverlay = function(overlay) {
            return this.getOverlays().remove(overlay);
          };
          PluggableMap.prototype.renderFrame_ = function(time) {
            var _this = this;
            var size = this.getSize();
            var view = this.getView();
            var previousFrameState = this.frameState_;
            var frameState = null;
            if (size !== void 0 && hasArea(size) && view && view.isDef()) {
              var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : void 0);
              var viewState = view.getState();
              frameState = {
                animate: false,
                coordinateToPixelTransform: this.coordinateToPixelTransform_,
                declutterTree: null,
                extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
                index: this.frameIndex_++,
                layerIndex: 0,
                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                pixelRatio: this.pixelRatio_,
                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                postRenderFunctions: [],
                size,
                tileQueue: this.tileQueue_,
                time,
                usedTiles: {},
                viewState,
                viewHints,
                wantedTiles: {},
                mapId: Object(util["c"])(this),
                renderTargets: {}
              };
              if (viewState.nextCenter && viewState.nextResolution) {
                var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
                frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);
              }
            }
            this.frameState_ = frameState;
            this.renderer_.renderFrame(frameState);
            if (frameState) {
              if (frameState.animate) {
                this.render();
              }
              Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
              if (previousFrameState) {
                var moveStart = !this.previousExtent_ || !extent_isEmpty(this.previousExtent_) && !equals(frameState.extent, this.previousExtent_);
                if (moveStart) {
                  this.dispatchEvent(new ol_MapEvent(MapEventType["a"].MOVESTART, this, previousFrameState));
                  this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
                }
              }
              var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals(frameState.extent, this.previousExtent_);
              if (idle) {
                this.dispatchEvent(new ol_MapEvent(MapEventType["a"].MOVEEND, this, frameState));
                clone(frameState.extent, this.previousExtent_);
              }
            }
            this.dispatchEvent(new ol_MapEvent(MapEventType["a"].POSTRENDER, this, frameState));
            this.renderComplete_ = !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoading();
            if (!this.postRenderTimeoutHandle_) {
              this.postRenderTimeoutHandle_ = setTimeout(function() {
                _this.postRenderTimeoutHandle_ = void 0;
                _this.handlePostRender();
              }, 0);
            }
          };
          PluggableMap.prototype.setLayerGroup = function(layerGroup) {
            var oldLayerGroup = this.getLayerGroup();
            if (oldLayerGroup) {
              this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
            }
            this.set(MapProperty.LAYERGROUP, layerGroup);
          };
          PluggableMap.prototype.setSize = function(size) {
            this.set(MapProperty.SIZE, size);
          };
          PluggableMap.prototype.setTarget = function(target) {
            this.set(MapProperty.TARGET, target);
          };
          PluggableMap.prototype.setView = function(view) {
            if (!view || view instanceof ol_View) {
              this.set(MapProperty.VIEW, view);
              return;
            }
            this.set(MapProperty.VIEW, new ol_View());
            var map = this;
            view.then(function(viewOptions) {
              map.setView(new ol_View(viewOptions));
            });
          };
          PluggableMap.prototype.updateSize = function() {
            var targetElement = this.getTargetElement();
            var size = void 0;
            if (targetElement) {
              var computedStyle = getComputedStyle(targetElement);
              var width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
              var height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
              if (!isNaN(width) && !isNaN(height)) {
                size = [width, height];
                if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
                  console.warn("No map visible because the map container's width or height are 0.");
                }
              }
            }
            this.setSize(size);
            this.updateViewportSize_();
          };
          PluggableMap.prototype.updateViewportSize_ = function() {
            var view = this.getView();
            if (view) {
              var size = void 0;
              var computedStyle = getComputedStyle(this.viewport_);
              if (computedStyle.width && computedStyle.height) {
                size = [
                  parseInt(computedStyle.width, 10),
                  parseInt(computedStyle.height, 10)
                ];
              }
              view.setViewportSize(size);
            }
          };
          return PluggableMap;
        }(ol_Object["a"]);
        function createOptionsInternal(options) {
          var keyboardEventTarget = null;
          if (options.keyboardEventTarget !== void 0) {
            keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
          }
          var values = {};
          var layerGroup = options.layers && typeof options.layers.getLayers === "function" ? options.layers : new Group({ layers: options.layers });
          values[MapProperty.LAYERGROUP] = layerGroup;
          values[MapProperty.TARGET] = options.target;
          values[MapProperty.VIEW] = options.view instanceof ol_View ? options.view : new ol_View();
          var controls;
          if (options.controls !== void 0) {
            if (Array.isArray(options.controls)) {
              controls = new ol_Collection(options.controls.slice());
            } else {
              assert2(typeof options.controls.getArray === "function", 47);
              controls = options.controls;
            }
          }
          var interactions;
          if (options.interactions !== void 0) {
            if (Array.isArray(options.interactions)) {
              interactions = new ol_Collection(options.interactions.slice());
            } else {
              assert2(typeof options.interactions.getArray === "function", 48);
              interactions = options.interactions;
            }
          }
          var overlays;
          if (options.overlays !== void 0) {
            if (Array.isArray(options.overlays)) {
              overlays = new ol_Collection(options.overlays.slice());
            } else {
              assert2(typeof options.overlays.getArray === "function", 49);
              overlays = options.overlays;
            }
          } else {
            overlays = new ol_Collection();
          }
          return {
            controls,
            interactions,
            keyboardEventTarget,
            overlays,
            values
          };
        }
        var ol_PluggableMap = PluggableMap_PluggableMap;
        var Control = __webpack_require__("3900");
        var Attribution_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Attribution_Attribution = function(_super) {
          Attribution_extends(Attribution, _super);
          function Attribution(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
              element: document.createElement("div"),
              render: options.render,
              target: options.target
            }) || this;
            _this.ulElement_ = document.createElement("ul");
            _this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
            _this.userCollapsed_ = _this.collapsed_;
            _this.overrideCollapsible_ = options.collapsible !== void 0;
            _this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
            if (!_this.collapsible_) {
              _this.collapsed_ = false;
            }
            var className = options.className !== void 0 ? options.className : "ol-attribution";
            var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
            var expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
            var collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
            var collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collpase";
            if (typeof collapseLabel === "string") {
              _this.collapseLabel_ = document.createElement("span");
              _this.collapseLabel_.textContent = collapseLabel;
              _this.collapseLabel_.className = collapseClassName;
            } else {
              _this.collapseLabel_ = collapseLabel;
            }
            var label = options.label !== void 0 ? options.label : "i";
            if (typeof label === "string") {
              _this.label_ = document.createElement("span");
              _this.label_.textContent = label;
              _this.label_.className = expandClassName;
            } else {
              _this.label_ = label;
            }
            var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
            _this.toggleButton_ = document.createElement("button");
            _this.toggleButton_.setAttribute("type", "button");
            _this.toggleButton_.setAttribute("aria-expanded", String(!_this.collapsed_));
            _this.toggleButton_.title = tipLabel;
            _this.toggleButton_.appendChild(activeLabel);
            _this.toggleButton_.addEventListener(EventType["a"].CLICK, _this.handleClick_.bind(_this), false);
            var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (_this.collapsible_ ? "" : " ol-uncollapsible");
            var element = _this.element;
            element.className = cssClasses;
            element.appendChild(_this.toggleButton_);
            element.appendChild(_this.ulElement_);
            _this.renderedAttributions_ = [];
            _this.renderedVisible_ = true;
            return _this;
          }
          Attribution.prototype.collectSourceAttributions_ = function(frameState) {
            var lookup = {};
            var visibleAttributions = [];
            var collapsible = true;
            var layerStatesArray = frameState.layerStatesArray;
            for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layerState = layerStatesArray[i];
              if (!inView(layerState, frameState.viewState)) {
                continue;
              }
              var source = layerState.layer.getSource();
              if (!source) {
                continue;
              }
              var attributionGetter = source.getAttributions();
              if (!attributionGetter) {
                continue;
              }
              var attributions = attributionGetter(frameState);
              if (!attributions) {
                continue;
              }
              collapsible = collapsible && source.getAttributionsCollapsible() !== false;
              if (Array.isArray(attributions)) {
                for (var j = 0, jj = attributions.length; j < jj; ++j) {
                  if (!(attributions[j] in lookup)) {
                    visibleAttributions.push(attributions[j]);
                    lookup[attributions[j]] = true;
                  }
                }
              } else {
                if (!(attributions in lookup)) {
                  visibleAttributions.push(attributions);
                  lookup[attributions] = true;
                }
              }
            }
            if (!this.overrideCollapsible_) {
              this.setCollapsible(collapsible);
            }
            return visibleAttributions;
          };
          Attribution.prototype.updateElement_ = function(frameState) {
            if (!frameState) {
              if (this.renderedVisible_) {
                this.element.style.display = "none";
                this.renderedVisible_ = false;
              }
              return;
            }
            var attributions = this.collectSourceAttributions_(frameState);
            var visible = attributions.length > 0;
            if (this.renderedVisible_ != visible) {
              this.element.style.display = visible ? "" : "none";
              this.renderedVisible_ = visible;
            }
            if (Object(ol_array["b"])(attributions, this.renderedAttributions_)) {
              return;
            }
            Object(dom["d"])(this.ulElement_);
            for (var i = 0, ii = attributions.length; i < ii; ++i) {
              var element = document.createElement("li");
              element.innerHTML = attributions[i];
              this.ulElement_.appendChild(element);
            }
            this.renderedAttributions_ = attributions;
          };
          Attribution.prototype.handleClick_ = function(event) {
            event.preventDefault();
            this.handleToggle_();
            this.userCollapsed_ = this.collapsed_;
          };
          Attribution.prototype.handleToggle_ = function() {
            this.element.classList.toggle(CLASS_COLLAPSED);
            if (this.collapsed_) {
              Object(dom["g"])(this.collapseLabel_, this.label_);
            } else {
              Object(dom["g"])(this.label_, this.collapseLabel_);
            }
            this.collapsed_ = !this.collapsed_;
            this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
          };
          Attribution.prototype.getCollapsible = function() {
            return this.collapsible_;
          };
          Attribution.prototype.setCollapsible = function(collapsible) {
            if (this.collapsible_ === collapsible) {
              return;
            }
            this.collapsible_ = collapsible;
            this.element.classList.toggle("ol-uncollapsible");
            if (this.userCollapsed_) {
              this.handleToggle_();
            }
          };
          Attribution.prototype.setCollapsed = function(collapsed) {
            this.userCollapsed_ = collapsed;
            if (!this.collapsible_ || this.collapsed_ === collapsed) {
              return;
            }
            this.handleToggle_();
          };
          Attribution.prototype.getCollapsed = function() {
            return this.collapsed_;
          };
          Attribution.prototype.render = function(mapEvent) {
            this.updateElement_(mapEvent.frameState);
          };
          return Attribution;
        }(Control["default"]);
        var control_Attribution = Attribution_Attribution;
        var Rotate_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Rotate_Rotate = function(_super) {
          Rotate_extends(Rotate, _super);
          function Rotate(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
              element: document.createElement("div"),
              render: options.render,
              target: options.target
            }) || this;
            var className = options.className !== void 0 ? options.className : "ol-rotate";
            var label = options.label !== void 0 ? options.label : "\u21E7";
            var compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
            _this.label_ = null;
            if (typeof label === "string") {
              _this.label_ = document.createElement("span");
              _this.label_.className = compassClassName;
              _this.label_.textContent = label;
            } else {
              _this.label_ = label;
              _this.label_.classList.add(compassClassName);
            }
            var tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
            var button = document.createElement("button");
            button.className = className + "-reset";
            button.setAttribute("type", "button");
            button.title = tipLabel;
            button.appendChild(_this.label_);
            button.addEventListener(EventType["a"].CLICK, _this.handleClick_.bind(_this), false);
            var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
            var element = _this.element;
            element.className = cssClasses;
            element.appendChild(button);
            _this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
            _this.duration_ = options.duration !== void 0 ? options.duration : 250;
            _this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
            _this.rotation_ = void 0;
            if (_this.autoHide_) {
              _this.element.classList.add(CLASS_HIDDEN);
            }
            return _this;
          }
          Rotate.prototype.handleClick_ = function(event) {
            event.preventDefault();
            if (this.callResetNorth_ !== void 0) {
              this.callResetNorth_();
            } else {
              this.resetNorth_();
            }
          };
          Rotate.prototype.resetNorth_ = function() {
            var map = this.getMap();
            var view = map.getView();
            if (!view) {
              return;
            }
            var rotation = view.getRotation();
            if (rotation !== void 0) {
              if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
                view.animate({
                  rotation: 0,
                  duration: this.duration_,
                  easing: easeOut
                });
              } else {
                view.setRotation(0);
              }
            }
          };
          Rotate.prototype.render = function(mapEvent) {
            var frameState = mapEvent.frameState;
            if (!frameState) {
              return;
            }
            var rotation = frameState.viewState.rotation;
            if (rotation != this.rotation_) {
              var transform2 = "rotate(" + rotation + "rad)";
              if (this.autoHide_) {
                var contains = this.element.classList.contains(CLASS_HIDDEN);
                if (!contains && rotation === 0) {
                  this.element.classList.add(CLASS_HIDDEN);
                } else if (contains && rotation !== 0) {
                  this.element.classList.remove(CLASS_HIDDEN);
                }
              }
              this.label_.style.transform = transform2;
            }
            this.rotation_ = rotation;
          };
          return Rotate;
        }(Control["default"]);
        var control_Rotate = Rotate_Rotate;
        var Zoom_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Zoom_Zoom = function(_super) {
          Zoom_extends(Zoom, _super);
          function Zoom(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
              element: document.createElement("div"),
              target: options.target
            }) || this;
            var className = options.className !== void 0 ? options.className : "ol-zoom";
            var delta = options.delta !== void 0 ? options.delta : 1;
            var zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
            var zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
            var zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
            var zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
            var zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
            var zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
            var inElement = document.createElement("button");
            inElement.className = zoomInClassName;
            inElement.setAttribute("type", "button");
            inElement.title = zoomInTipLabel;
            inElement.appendChild(typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel);
            inElement.addEventListener(EventType["a"].CLICK, _this.handleClick_.bind(_this, delta), false);
            var outElement = document.createElement("button");
            outElement.className = zoomOutClassName;
            outElement.setAttribute("type", "button");
            outElement.title = zoomOutTipLabel;
            outElement.appendChild(typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
            outElement.addEventListener(EventType["a"].CLICK, _this.handleClick_.bind(_this, -delta), false);
            var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
            var element = _this.element;
            element.className = cssClasses;
            element.appendChild(inElement);
            element.appendChild(outElement);
            _this.duration_ = options.duration !== void 0 ? options.duration : 250;
            return _this;
          }
          Zoom.prototype.handleClick_ = function(delta, event) {
            event.preventDefault();
            this.zoomByDelta_(delta);
          };
          Zoom.prototype.zoomByDelta_ = function(delta) {
            var map = this.getMap();
            var view = map.getView();
            if (!view) {
              return;
            }
            var currentZoom = view.getZoom();
            if (currentZoom !== void 0) {
              var newZoom = view.getConstrainedZoom(currentZoom + delta);
              if (this.duration_ > 0) {
                if (view.getAnimating()) {
                  view.cancelAnimations();
                }
                view.animate({
                  zoom: newZoom,
                  duration: this.duration_,
                  easing: easeOut
                });
              } else {
                view.setZoom(newZoom);
              }
            }
          };
          return Zoom;
        }(Control["default"]);
        var control_Zoom = Zoom_Zoom;
        function defaults(opt_options) {
          var options = opt_options ? opt_options : {};
          var controls = new ol_Collection();
          var zoomControl = options.zoom !== void 0 ? options.zoom : true;
          if (zoomControl) {
            controls.push(new control_Zoom(options.zoomOptions));
          }
          var rotateControl = options.rotate !== void 0 ? options.rotate : true;
          if (rotateControl) {
            controls.push(new control_Rotate(options.rotateOptions));
          }
          var attributionControl = options.attribution !== void 0 ? options.attribution : true;
          if (attributionControl) {
            controls.push(new control_Attribution(options.attributionOptions));
          }
          return controls;
        }
        var interaction_Property = {
          ACTIVE: "active"
        };
        var Interaction_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Interaction_Interaction = function(_super) {
          Interaction_extends(Interaction, _super);
          function Interaction(opt_options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            if (opt_options && opt_options.handleEvent) {
              _this.handleEvent = opt_options.handleEvent;
            }
            _this.map_ = null;
            _this.setActive(true);
            return _this;
          }
          Interaction.prototype.getActive = function() {
            return this.get(interaction_Property.ACTIVE);
          };
          Interaction.prototype.getMap = function() {
            return this.map_;
          };
          Interaction.prototype.handleEvent = function(mapBrowserEvent) {
            return true;
          };
          Interaction.prototype.setActive = function(active) {
            this.set(interaction_Property.ACTIVE, active);
          };
          Interaction.prototype.setMap = function(map) {
            this.map_ = map;
          };
          return Interaction;
        }(ol_Object["a"]);
        function pan(view, delta, opt_duration) {
          var currentCenter = view.getCenterInternal();
          if (currentCenter) {
            var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
            view.animateInternal({
              duration: opt_duration !== void 0 ? opt_duration : 250,
              easing: linear,
              center: view.getConstrainedCenter(center)
            });
          }
        }
        function zoomByDelta(view, delta, opt_anchor, opt_duration) {
          var currentZoom = view.getZoom();
          if (currentZoom === void 0) {
            return;
          }
          var newZoom = view.getConstrainedZoom(currentZoom + delta);
          var newResolution = view.getResolutionForZoom(newZoom);
          if (view.getAnimating()) {
            view.cancelAnimations();
          }
          view.animate({
            resolution: newResolution,
            anchor: opt_anchor,
            duration: opt_duration !== void 0 ? opt_duration : 250,
            easing: easeOut
          });
        }
        var interaction_Interaction = Interaction_Interaction;
        var DoubleClickZoom_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var DoubleClickZoom_DoubleClickZoom = function(_super) {
          DoubleClickZoom_extends(DoubleClickZoom, _super);
          function DoubleClickZoom(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.delta_ = options.delta ? options.delta : 1;
            _this.duration_ = options.duration !== void 0 ? options.duration : 250;
            return _this;
          }
          DoubleClickZoom.prototype.handleEvent = function(mapBrowserEvent) {
            var stopEvent = false;
            if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
              var browserEvent = mapBrowserEvent.originalEvent;
              var map = mapBrowserEvent.map;
              var anchor = mapBrowserEvent.coordinate;
              var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
              var view = map.getView();
              zoomByDelta(view, delta, anchor, this.duration_);
              browserEvent.preventDefault();
              stopEvent = true;
            }
            return !stopEvent;
          };
          return DoubleClickZoom;
        }(interaction_Interaction);
        var interaction_DoubleClickZoom = DoubleClickZoom_DoubleClickZoom;
        var Pointer_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Pointer_PointerInteraction = function(_super) {
          Pointer_extends(PointerInteraction, _super);
          function PointerInteraction(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, options) || this;
            if (options.handleDownEvent) {
              _this.handleDownEvent = options.handleDownEvent;
            }
            if (options.handleDragEvent) {
              _this.handleDragEvent = options.handleDragEvent;
            }
            if (options.handleMoveEvent) {
              _this.handleMoveEvent = options.handleMoveEvent;
            }
            if (options.handleUpEvent) {
              _this.handleUpEvent = options.handleUpEvent;
            }
            if (options.stopDown) {
              _this.stopDown = options.stopDown;
            }
            _this.handlingDownUpSequence = false;
            _this.trackedPointers_ = {};
            _this.targetPointers = [];
            return _this;
          }
          PointerInteraction.prototype.getPointerCount = function() {
            return this.targetPointers.length;
          };
          PointerInteraction.prototype.handleDownEvent = function(mapBrowserEvent) {
            return false;
          };
          PointerInteraction.prototype.handleDragEvent = function(mapBrowserEvent) {
          };
          PointerInteraction.prototype.handleEvent = function(mapBrowserEvent) {
            if (!mapBrowserEvent.originalEvent) {
              return true;
            }
            var stopEvent = false;
            this.updateTrackedPointers_(mapBrowserEvent);
            if (this.handlingDownUpSequence) {
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
                this.handleDragEvent(mapBrowserEvent);
                mapBrowserEvent.originalEvent.preventDefault();
              } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                var handledUp = this.handleUpEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
              }
            } else {
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                var handled = this.handleDownEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handled;
                stopEvent = this.stopDown(handled);
              } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
                this.handleMoveEvent(mapBrowserEvent);
              }
            }
            return !stopEvent;
          };
          PointerInteraction.prototype.handleMoveEvent = function(mapBrowserEvent) {
          };
          PointerInteraction.prototype.handleUpEvent = function(mapBrowserEvent) {
            return false;
          };
          PointerInteraction.prototype.stopDown = function(handled) {
            return handled;
          };
          PointerInteraction.prototype.updateTrackedPointers_ = function(mapBrowserEvent) {
            if (isPointerDraggingEvent(mapBrowserEvent)) {
              var event_1 = mapBrowserEvent.originalEvent;
              var id = event_1.pointerId.toString();
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                delete this.trackedPointers_[id];
              } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                this.trackedPointers_[id] = event_1;
              } else if (id in this.trackedPointers_) {
                this.trackedPointers_[id] = event_1;
              }
              this.targetPointers = Object(ol_obj["c"])(this.trackedPointers_);
            }
          };
          return PointerInteraction;
        }(interaction_Interaction);
        function Pointer_centroid(pointerEvents) {
          var length = pointerEvents.length;
          var clientX = 0;
          var clientY = 0;
          for (var i = 0; i < length; i++) {
            clientX += pointerEvents[i].clientX;
            clientY += pointerEvents[i].clientY;
          }
          return [clientX / length, clientY / length];
        }
        function isPointerDraggingEvent(mapBrowserEvent) {
          var type = mapBrowserEvent.type;
          return type === MapBrowserEventType.POINTERDOWN || type === MapBrowserEventType.POINTERDRAG || type === MapBrowserEventType.POINTERUP;
        }
        var Pointer = Pointer_PointerInteraction;
        function condition_all(var_args) {
          var conditions = arguments;
          return function(event) {
            var pass = true;
            for (var i = 0, ii = conditions.length; i < ii; ++i) {
              pass = pass && conditions[i](event);
              if (!pass) {
                break;
              }
            }
            return pass;
          };
        }
        var altKeyOnly = function(mapBrowserEvent) {
          var originalEvent = mapBrowserEvent.originalEvent;
          return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
        };
        var altShiftKeysOnly = function(mapBrowserEvent) {
          var originalEvent = mapBrowserEvent.originalEvent;
          return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
        };
        var condition_focus = function(event) {
          var targetElement = event.map.getTargetElement();
          var activeElement = event.map.getOwnerDocument().activeElement;
          return targetElement.contains(activeElement);
        };
        var focusWithTabindex = function(event) {
          return event.map.getTargetElement().hasAttribute("tabindex") ? condition_focus(event) : true;
        };
        var always = functions["b"];
        var click = function(mapBrowserEvent) {
          return mapBrowserEvent.type == MapBrowserEventType.CLICK;
        };
        var mouseActionButton = function(mapBrowserEvent) {
          var originalEvent = mapBrowserEvent.originalEvent;
          return originalEvent.button == 0 && !(has["f"] && has["d"] && originalEvent.ctrlKey);
        };
        var never = functions["a"];
        var pointerMove = function(mapBrowserEvent) {
          return mapBrowserEvent.type == "pointermove";
        };
        var singleClick = function(mapBrowserEvent) {
          return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;
        };
        var doubleClick = function(mapBrowserEvent) {
          return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;
        };
        var noModifierKeys = function(mapBrowserEvent) {
          var originalEvent = mapBrowserEvent.originalEvent;
          return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
        };
        var platformModifierKeyOnly = function(mapBrowserEvent) {
          var originalEvent = mapBrowserEvent.originalEvent;
          return !originalEvent.altKey && (has["d"] ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
        };
        var shiftKeyOnly = function(mapBrowserEvent) {
          var originalEvent = mapBrowserEvent.originalEvent;
          return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
        };
        var targetNotEditable = function(mapBrowserEvent) {
          var originalEvent = mapBrowserEvent.originalEvent;
          var tagName = originalEvent.target.tagName;
          return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA";
        };
        var mouseOnly = function(mapBrowserEvent) {
          var pointerEvent = mapBrowserEvent.originalEvent;
          assert2(pointerEvent !== void 0, 56);
          return pointerEvent.pointerType == "mouse";
        };
        var touchOnly = function(mapBrowserEvent) {
          var pointerEvt = mapBrowserEvent.originalEvent;
          assert2(pointerEvt !== void 0, 56);
          return pointerEvt.pointerType === "touch";
        };
        var penOnly = function(mapBrowserEvent) {
          var pointerEvt = mapBrowserEvent.originalEvent;
          assert2(pointerEvt !== void 0, 56);
          return pointerEvt.pointerType === "pen";
        };
        var primaryAction = function(mapBrowserEvent) {
          var pointerEvent = mapBrowserEvent.originalEvent;
          assert2(pointerEvent !== void 0, 56);
          return pointerEvent.isPrimary && pointerEvent.button === 0;
        };
        var DragPan_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var DragPan_DragPan = function(_super) {
          DragPan_extends(DragPan, _super);
          function DragPan(opt_options) {
            var _this = _super.call(this, {
              stopDown: functions["a"]
            }) || this;
            var options = opt_options ? opt_options : {};
            _this.kinetic_ = options.kinetic;
            _this.lastCentroid = null;
            _this.lastPointersCount_;
            _this.panning_ = false;
            var condition = options.condition ? options.condition : condition_all(noModifierKeys, primaryAction);
            _this.condition_ = options.onFocusOnly ? condition_all(focusWithTabindex, condition) : condition;
            _this.noKinetic_ = false;
            return _this;
          }
          DragPan.prototype.handleDragEvent = function(mapBrowserEvent) {
            if (!this.panning_) {
              this.panning_ = true;
              this.getMap().getView().beginInteraction();
            }
            var targetPointers = this.targetPointers;
            var centroid = Pointer_centroid(targetPointers);
            if (targetPointers.length == this.lastPointersCount_) {
              if (this.kinetic_) {
                this.kinetic_.update(centroid[0], centroid[1]);
              }
              if (this.lastCentroid) {
                var delta = [
                  this.lastCentroid[0] - centroid[0],
                  centroid[1] - this.lastCentroid[1]
                ];
                var map = mapBrowserEvent.map;
                var view = map.getView();
                coordinate_scale(delta, view.getResolution());
                coordinate_rotate(delta, view.getRotation());
                view.adjustCenterInternal(delta);
              }
            } else if (this.kinetic_) {
              this.kinetic_.begin();
            }
            this.lastCentroid = centroid;
            this.lastPointersCount_ = targetPointers.length;
            mapBrowserEvent.originalEvent.preventDefault();
          };
          DragPan.prototype.handleUpEvent = function(mapBrowserEvent) {
            var map = mapBrowserEvent.map;
            var view = map.getView();
            if (this.targetPointers.length === 0) {
              if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                var distance = this.kinetic_.getDistance();
                var angle = this.kinetic_.getAngle();
                var center = view.getCenterInternal();
                var centerpx = map.getPixelFromCoordinateInternal(center);
                var dest = map.getCoordinateFromPixelInternal([
                  centerpx[0] - distance * Math.cos(angle),
                  centerpx[1] - distance * Math.sin(angle)
                ]);
                view.animateInternal({
                  center: view.getConstrainedCenter(dest),
                  duration: 500,
                  easing: easeOut
                });
              }
              if (this.panning_) {
                this.panning_ = false;
                view.endInteraction();
              }
              return false;
            } else {
              if (this.kinetic_) {
                this.kinetic_.begin();
              }
              this.lastCentroid = null;
              return true;
            }
          };
          DragPan.prototype.handleDownEvent = function(mapBrowserEvent) {
            if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              this.lastCentroid = null;
              if (view.getAnimating()) {
                view.cancelAnimations();
              }
              if (this.kinetic_) {
                this.kinetic_.begin();
              }
              this.noKinetic_ = this.targetPointers.length > 1;
              return true;
            } else {
              return false;
            }
          };
          return DragPan;
        }(Pointer);
        var interaction_DragPan = DragPan_DragPan;
        var DragRotate_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var DragRotate_DragRotate = function(_super) {
          DragRotate_extends(DragRotate, _super);
          function DragRotate(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
              stopDown: functions["a"]
            }) || this;
            _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
            _this.lastAngle_ = void 0;
            _this.duration_ = options.duration !== void 0 ? options.duration : 250;
            return _this;
          }
          DragRotate.prototype.handleDragEvent = function(mapBrowserEvent) {
            if (!mouseOnly(mapBrowserEvent)) {
              return;
            }
            var map = mapBrowserEvent.map;
            var view = map.getView();
            if (view.getConstraints().rotation === disable) {
              return;
            }
            var size = map.getSize();
            var offset = mapBrowserEvent.pixel;
            var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
            if (this.lastAngle_ !== void 0) {
              var delta = theta - this.lastAngle_;
              view.adjustRotationInternal(-delta);
            }
            this.lastAngle_ = theta;
          };
          DragRotate.prototype.handleUpEvent = function(mapBrowserEvent) {
            if (!mouseOnly(mapBrowserEvent)) {
              return true;
            }
            var map = mapBrowserEvent.map;
            var view = map.getView();
            view.endInteraction(this.duration_);
            return false;
          };
          DragRotate.prototype.handleDownEvent = function(mapBrowserEvent) {
            if (!mouseOnly(mapBrowserEvent)) {
              return false;
            }
            if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
              var map = mapBrowserEvent.map;
              map.getView().beginInteraction();
              this.lastAngle_ = void 0;
              return true;
            } else {
              return false;
            }
          };
          return DragRotate;
        }(Pointer);
        var interaction_DragRotate = DragRotate_DragRotate;
        var Box_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Box_RenderBox = function(_super) {
          Box_extends(RenderBox, _super);
          function RenderBox(className) {
            var _this = _super.call(this) || this;
            _this.geometry_ = null;
            _this.element_ = document.createElement("div");
            _this.element_.style.position = "absolute";
            _this.element_.style.pointerEvents = "auto";
            _this.element_.className = "ol-box " + className;
            _this.map_ = null;
            _this.startPixel_ = null;
            _this.endPixel_ = null;
            return _this;
          }
          RenderBox.prototype.disposeInternal = function() {
            this.setMap(null);
          };
          RenderBox.prototype.render_ = function() {
            var startPixel = this.startPixel_;
            var endPixel = this.endPixel_;
            var px = "px";
            var style = this.element_.style;
            style.left = Math.min(startPixel[0], endPixel[0]) + px;
            style.top = Math.min(startPixel[1], endPixel[1]) + px;
            style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
            style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
          };
          RenderBox.prototype.setMap = function(map) {
            if (this.map_) {
              this.map_.getOverlayContainer().removeChild(this.element_);
              var style = this.element_.style;
              style.left = "inherit";
              style.top = "inherit";
              style.width = "inherit";
              style.height = "inherit";
            }
            this.map_ = map;
            if (this.map_) {
              this.map_.getOverlayContainer().appendChild(this.element_);
            }
          };
          RenderBox.prototype.setPixels = function(startPixel, endPixel) {
            this.startPixel_ = startPixel;
            this.endPixel_ = endPixel;
            this.createOrUpdateGeometry();
            this.render_();
          };
          RenderBox.prototype.createOrUpdateGeometry = function() {
            var startPixel = this.startPixel_;
            var endPixel = this.endPixel_;
            var pixels = [
              startPixel,
              [startPixel[0], endPixel[1]],
              endPixel,
              [endPixel[0], startPixel[1]]
            ];
            var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
            coordinates[4] = coordinates[0].slice();
            if (!this.geometry_) {
              this.geometry_ = new geom_Polygon([coordinates]);
            } else {
              this.geometry_.setCoordinates([coordinates]);
            }
          };
          RenderBox.prototype.getGeometry = function() {
            return this.geometry_;
          };
          return RenderBox;
        }(Disposable["a"]);
        var Box = Box_RenderBox;
        var DragBox_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var DragBoxEventType = {
          BOXSTART: "boxstart",
          BOXDRAG: "boxdrag",
          BOXEND: "boxend",
          BOXCANCEL: "boxcancel"
        };
        var DragBoxEvent = function(_super) {
          DragBox_extends(DragBoxEvent2, _super);
          function DragBoxEvent2(type, coordinate, mapBrowserEvent) {
            var _this = _super.call(this, type) || this;
            _this.coordinate = coordinate;
            _this.mapBrowserEvent = mapBrowserEvent;
            return _this;
          }
          return DragBoxEvent2;
        }(events_Event["a"]);
        var DragBox_DragBox = function(_super) {
          DragBox_extends(DragBox, _super);
          function DragBox(opt_options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            var options = opt_options ? opt_options : {};
            _this.box_ = new Box(options.className || "ol-dragbox");
            _this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;
            if (options.onBoxEnd) {
              _this.onBoxEnd = options.onBoxEnd;
            }
            _this.startPixel_ = null;
            _this.condition_ = options.condition ? options.condition : mouseActionButton;
            _this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this.defaultBoxEndCondition;
            return _this;
          }
          DragBox.prototype.defaultBoxEndCondition = function(mapBrowserEvent, startPixel, endPixel) {
            var width = endPixel[0] - startPixel[0];
            var height = endPixel[1] - startPixel[1];
            return width * width + height * height >= this.minArea_;
          };
          DragBox.prototype.getGeometry = function() {
            return this.box_.getGeometry();
          };
          DragBox.prototype.handleDragEvent = function(mapBrowserEvent) {
            this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
            this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
          };
          DragBox.prototype.handleUpEvent = function(mapBrowserEvent) {
            this.box_.setMap(null);
            var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
            if (completeBox) {
              this.onBoxEnd(mapBrowserEvent);
            }
            this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
            return false;
          };
          DragBox.prototype.handleDownEvent = function(mapBrowserEvent) {
            if (this.condition_(mapBrowserEvent)) {
              this.startPixel_ = mapBrowserEvent.pixel;
              this.box_.setMap(mapBrowserEvent.map);
              this.box_.setPixels(this.startPixel_, this.startPixel_);
              this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
              return true;
            } else {
              return false;
            }
          };
          DragBox.prototype.onBoxEnd = function(event) {
          };
          return DragBox;
        }(Pointer);
        var interaction_DragBox = DragBox_DragBox;
        var DragZoom_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var DragZoom_DragZoom = function(_super) {
          DragZoom_extends(DragZoom, _super);
          function DragZoom(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var condition = options.condition ? options.condition : shiftKeyOnly;
            _this = _super.call(this, {
              condition,
              className: options.className || "ol-dragzoom",
              minArea: options.minArea
            }) || this;
            _this.duration_ = options.duration !== void 0 ? options.duration : 200;
            _this.out_ = options.out !== void 0 ? options.out : false;
            return _this;
          }
          DragZoom.prototype.onBoxEnd = function(event) {
            var map = this.getMap();
            var view = map.getView();
            var geometry = this.getGeometry();
            if (this.out_) {
              var rotatedExtent = view.rotatedExtentForGeometry(geometry);
              var resolution = view.getResolutionForExtentInternal(rotatedExtent);
              var factor = view.getResolution() / resolution;
              geometry = geometry.clone();
              geometry.scale(factor * factor);
            }
            view.fitInternal(geometry, {
              duration: this.duration_,
              easing: easeOut
            });
          };
          return DragZoom;
        }(interaction_DragBox);
        var interaction_DragZoom = DragZoom_DragZoom;
        var KeyCode = {
          LEFT: 37,
          UP: 38,
          RIGHT: 39,
          DOWN: 40
        };
        var KeyboardPan_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var KeyboardPan_KeyboardPan = function(_super) {
          KeyboardPan_extends(KeyboardPan, _super);
          function KeyboardPan(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options || {};
            _this.defaultCondition_ = function(mapBrowserEvent) {
              return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
            };
            _this.condition_ = options.condition !== void 0 ? options.condition : _this.defaultCondition_;
            _this.duration_ = options.duration !== void 0 ? options.duration : 100;
            _this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
            return _this;
          }
          KeyboardPan.prototype.handleEvent = function(mapBrowserEvent) {
            var stopEvent = false;
            if (mapBrowserEvent.type == EventType["a"].KEYDOWN) {
              var keyEvent = mapBrowserEvent.originalEvent;
              var keyCode = keyEvent.keyCode;
              if (this.condition_(mapBrowserEvent) && (keyCode == KeyCode.DOWN || keyCode == KeyCode.LEFT || keyCode == KeyCode.RIGHT || keyCode == KeyCode.UP)) {
                var map = mapBrowserEvent.map;
                var view = map.getView();
                var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                var deltaX = 0, deltaY = 0;
                if (keyCode == KeyCode.DOWN) {
                  deltaY = -mapUnitsDelta;
                } else if (keyCode == KeyCode.LEFT) {
                  deltaX = -mapUnitsDelta;
                } else if (keyCode == KeyCode.RIGHT) {
                  deltaX = mapUnitsDelta;
                } else {
                  deltaY = mapUnitsDelta;
                }
                var delta = [deltaX, deltaY];
                coordinate_rotate(delta, view.getRotation());
                pan(view, delta, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
              }
            }
            return !stopEvent;
          };
          return KeyboardPan;
        }(interaction_Interaction);
        var interaction_KeyboardPan = KeyboardPan_KeyboardPan;
        var KeyboardZoom_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var KeyboardZoom_KeyboardZoom = function(_super) {
          KeyboardZoom_extends(KeyboardZoom, _super);
          function KeyboardZoom(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.condition_ = options.condition ? options.condition : targetNotEditable;
            _this.delta_ = options.delta ? options.delta : 1;
            _this.duration_ = options.duration !== void 0 ? options.duration : 100;
            return _this;
          }
          KeyboardZoom.prototype.handleEvent = function(mapBrowserEvent) {
            var stopEvent = false;
            if (mapBrowserEvent.type == EventType["a"].KEYDOWN || mapBrowserEvent.type == EventType["a"].KEYPRESS) {
              var keyEvent = mapBrowserEvent.originalEvent;
              var charCode = keyEvent.charCode;
              if (this.condition_(mapBrowserEvent) && (charCode == "+".charCodeAt(0) || charCode == "-".charCodeAt(0))) {
                var map = mapBrowserEvent.map;
                var delta = charCode == "+".charCodeAt(0) ? this.delta_ : -this.delta_;
                var view = map.getView();
                zoomByDelta(view, delta, void 0, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
              }
            }
            return !stopEvent;
          };
          return KeyboardZoom;
        }(interaction_Interaction);
        var interaction_KeyboardZoom = KeyboardZoom_KeyboardZoom;
        var Kinetic = function() {
          function Kinetic2(decay, minVelocity, delay) {
            this.decay_ = decay;
            this.minVelocity_ = minVelocity;
            this.delay_ = delay;
            this.points_ = [];
            this.angle_ = 0;
            this.initialVelocity_ = 0;
          }
          Kinetic2.prototype.begin = function() {
            this.points_.length = 0;
            this.angle_ = 0;
            this.initialVelocity_ = 0;
          };
          Kinetic2.prototype.update = function(x, y) {
            this.points_.push(x, y, Date.now());
          };
          Kinetic2.prototype.end = function() {
            if (this.points_.length < 6) {
              return false;
            }
            var delay = Date.now() - this.delay_;
            var lastIndex = this.points_.length - 3;
            if (this.points_[lastIndex + 2] < delay) {
              return false;
            }
            var firstIndex = lastIndex - 3;
            while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
              firstIndex -= 3;
            }
            var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
            if (duration < 1e3 / 60) {
              return false;
            }
            var dx = this.points_[lastIndex] - this.points_[firstIndex];
            var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
            this.angle_ = Math.atan2(dy, dx);
            this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
            return this.initialVelocity_ > this.minVelocity_;
          };
          Kinetic2.prototype.getDistance = function() {
            return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
          };
          Kinetic2.prototype.getAngle = function() {
            return this.angle_;
          };
          return Kinetic2;
        }();
        var ol_Kinetic = Kinetic;
        var MouseWheelZoom_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Mode = {
          TRACKPAD: "trackpad",
          WHEEL: "wheel"
        };
        var MouseWheelZoom_MouseWheelZoom = function(_super) {
          MouseWheelZoom_extends(MouseWheelZoom, _super);
          function MouseWheelZoom(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, options) || this;
            _this.totalDelta_ = 0;
            _this.lastDelta_ = 0;
            _this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
            _this.duration_ = options.duration !== void 0 ? options.duration : 250;
            _this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
            _this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
            _this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
            var condition = options.condition ? options.condition : always;
            _this.condition_ = options.onFocusOnly ? condition_all(focusWithTabindex, condition) : condition;
            _this.lastAnchor_ = null;
            _this.startTime_ = void 0;
            _this.timeoutId_;
            _this.mode_ = void 0;
            _this.trackpadEventGap_ = 400;
            _this.trackpadTimeoutId_;
            _this.deltaPerZoom_ = 300;
            return _this;
          }
          MouseWheelZoom.prototype.endInteraction_ = function() {
            this.trackpadTimeoutId_ = void 0;
            var view = this.getMap().getView();
            view.endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
          };
          MouseWheelZoom.prototype.handleEvent = function(mapBrowserEvent) {
            if (!this.condition_(mapBrowserEvent)) {
              return true;
            }
            var type = mapBrowserEvent.type;
            if (type !== EventType["a"].WHEEL) {
              return true;
            }
            var map = mapBrowserEvent.map;
            var wheelEvent = mapBrowserEvent.originalEvent;
            wheelEvent.preventDefault();
            if (this.useAnchor_) {
              this.lastAnchor_ = mapBrowserEvent.coordinate;
            }
            var delta;
            if (mapBrowserEvent.type == EventType["a"].WHEEL) {
              delta = wheelEvent.deltaY;
              if (has["b"] && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
                delta /= has["a"];
              }
              if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
                delta *= 40;
              }
            }
            if (delta === 0) {
              return false;
            } else {
              this.lastDelta_ = delta;
            }
            var now = Date.now();
            if (this.startTime_ === void 0) {
              this.startTime_ = now;
            }
            if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
              this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
            }
            var view = map.getView();
            if (this.mode_ === Mode.TRACKPAD && !(view.getConstrainResolution() || this.constrainResolution_)) {
              if (this.trackpadTimeoutId_) {
                clearTimeout(this.trackpadTimeoutId_);
              } else {
                if (view.getAnimating()) {
                  view.cancelAnimations();
                }
                view.beginInteraction();
              }
              this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
              view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
              this.startTime_ = now;
              return false;
            }
            this.totalDelta_ += delta;
            var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
            clearTimeout(this.timeoutId_);
            this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
            return false;
          };
          MouseWheelZoom.prototype.handleWheelZoom_ = function(map) {
            var view = map.getView();
            if (view.getAnimating()) {
              view.cancelAnimations();
            }
            var delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
            if (view.getConstrainResolution() || this.constrainResolution_) {
              delta = delta ? delta > 0 ? 1 : -1 : 0;
            }
            zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
            this.mode_ = void 0;
            this.totalDelta_ = 0;
            this.lastAnchor_ = null;
            this.startTime_ = void 0;
            this.timeoutId_ = void 0;
          };
          MouseWheelZoom.prototype.setMouseAnchor = function(useAnchor) {
            this.useAnchor_ = useAnchor;
            if (!useAnchor) {
              this.lastAnchor_ = null;
            }
          };
          return MouseWheelZoom;
        }(interaction_Interaction);
        var interaction_MouseWheelZoom = MouseWheelZoom_MouseWheelZoom;
        var PinchRotate_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var PinchRotate_PinchRotate = function(_super) {
          PinchRotate_extends(PinchRotate, _super);
          function PinchRotate(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var pointerOptions = options;
            if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = functions["a"];
            }
            _this = _super.call(this, pointerOptions) || this;
            _this.anchor_ = null;
            _this.lastAngle_ = void 0;
            _this.rotating_ = false;
            _this.rotationDelta_ = 0;
            _this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
            _this.duration_ = options.duration !== void 0 ? options.duration : 250;
            return _this;
          }
          PinchRotate.prototype.handleDragEvent = function(mapBrowserEvent) {
            var rotationDelta = 0;
            var touch0 = this.targetPointers[0];
            var touch1 = this.targetPointers[1];
            var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
            if (this.lastAngle_ !== void 0) {
              var delta = angle - this.lastAngle_;
              this.rotationDelta_ += delta;
              if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
                this.rotating_ = true;
              }
              rotationDelta = delta;
            }
            this.lastAngle_ = angle;
            var map = mapBrowserEvent.map;
            var view = map.getView();
            if (view.getConstraints().rotation === disable) {
              return;
            }
            var viewportPosition = map.getViewport().getBoundingClientRect();
            var centroid = Pointer_centroid(this.targetPointers);
            centroid[0] -= viewportPosition.left;
            centroid[1] -= viewportPosition.top;
            this.anchor_ = map.getCoordinateFromPixelInternal(centroid);
            if (this.rotating_) {
              map.render();
              view.adjustRotationInternal(rotationDelta, this.anchor_);
            }
          };
          PinchRotate.prototype.handleUpEvent = function(mapBrowserEvent) {
            if (this.targetPointers.length < 2) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              view.endInteraction(this.duration_);
              return false;
            } else {
              return true;
            }
          };
          PinchRotate.prototype.handleDownEvent = function(mapBrowserEvent) {
            if (this.targetPointers.length >= 2) {
              var map = mapBrowserEvent.map;
              this.anchor_ = null;
              this.lastAngle_ = void 0;
              this.rotating_ = false;
              this.rotationDelta_ = 0;
              if (!this.handlingDownUpSequence) {
                map.getView().beginInteraction();
              }
              return true;
            } else {
              return false;
            }
          };
          return PinchRotate;
        }(Pointer);
        var interaction_PinchRotate = PinchRotate_PinchRotate;
        var PinchZoom_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var PinchZoom_PinchZoom = function(_super) {
          PinchZoom_extends(PinchZoom, _super);
          function PinchZoom(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var pointerOptions = options;
            if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = functions["a"];
            }
            _this = _super.call(this, pointerOptions) || this;
            _this.anchor_ = null;
            _this.duration_ = options.duration !== void 0 ? options.duration : 400;
            _this.lastDistance_ = void 0;
            _this.lastScaleDelta_ = 1;
            return _this;
          }
          PinchZoom.prototype.handleDragEvent = function(mapBrowserEvent) {
            var scaleDelta = 1;
            var touch0 = this.targetPointers[0];
            var touch1 = this.targetPointers[1];
            var dx = touch0.clientX - touch1.clientX;
            var dy = touch0.clientY - touch1.clientY;
            var distance = Math.sqrt(dx * dx + dy * dy);
            if (this.lastDistance_ !== void 0) {
              scaleDelta = this.lastDistance_ / distance;
            }
            this.lastDistance_ = distance;
            var map = mapBrowserEvent.map;
            var view = map.getView();
            if (scaleDelta != 1) {
              this.lastScaleDelta_ = scaleDelta;
            }
            var viewportPosition = map.getViewport().getBoundingClientRect();
            var centroid = Pointer_centroid(this.targetPointers);
            centroid[0] -= viewportPosition.left;
            centroid[1] -= viewportPosition.top;
            this.anchor_ = map.getCoordinateFromPixelInternal(centroid);
            map.render();
            view.adjustResolutionInternal(scaleDelta, this.anchor_);
          };
          PinchZoom.prototype.handleUpEvent = function(mapBrowserEvent) {
            if (this.targetPointers.length < 2) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
              view.endInteraction(this.duration_, direction);
              return false;
            } else {
              return true;
            }
          };
          PinchZoom.prototype.handleDownEvent = function(mapBrowserEvent) {
            if (this.targetPointers.length >= 2) {
              var map = mapBrowserEvent.map;
              this.anchor_ = null;
              this.lastDistance_ = void 0;
              this.lastScaleDelta_ = 1;
              if (!this.handlingDownUpSequence) {
                map.getView().beginInteraction();
              }
              return true;
            } else {
              return false;
            }
          };
          return PinchZoom;
        }(Pointer);
        var interaction_PinchZoom = PinchZoom_PinchZoom;
        function interaction_defaults(opt_options) {
          var options = opt_options ? opt_options : {};
          var interactions = new ol_Collection();
          var kinetic = new ol_Kinetic(-5e-3, 0.05, 100);
          var altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
          if (altShiftDragRotate) {
            interactions.push(new interaction_DragRotate());
          }
          var doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
          if (doubleClickZoom) {
            interactions.push(new interaction_DoubleClickZoom({
              delta: options.zoomDelta,
              duration: options.zoomDuration
            }));
          }
          var dragPan = options.dragPan !== void 0 ? options.dragPan : true;
          if (dragPan) {
            interactions.push(new interaction_DragPan({
              onFocusOnly: options.onFocusOnly,
              kinetic
            }));
          }
          var pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
          if (pinchRotate) {
            interactions.push(new interaction_PinchRotate());
          }
          var pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
          if (pinchZoom) {
            interactions.push(new interaction_PinchZoom({
              duration: options.zoomDuration
            }));
          }
          var keyboard = options.keyboard !== void 0 ? options.keyboard : true;
          if (keyboard) {
            interactions.push(new interaction_KeyboardPan());
            interactions.push(new interaction_KeyboardZoom({
              delta: options.zoomDelta,
              duration: options.zoomDuration
            }));
          }
          var mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
          if (mouseWheelZoom) {
            interactions.push(new interaction_MouseWheelZoom({
              onFocusOnly: options.onFocusOnly,
              duration: options.zoomDuration
            }));
          }
          var shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
          if (shiftDragZoom) {
            interactions.push(new interaction_DragZoom({
              duration: options.zoomDuration
            }));
          }
          return interactions;
        }
        var ol_Map_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Map_Map = function(_super) {
          ol_Map_extends(Map2, _super);
          function Map2(options) {
            var _this = this;
            options = Object(ol_obj["a"])({}, options);
            if (!options.controls) {
              options.controls = defaults();
            }
            if (!options.interactions) {
              options.interactions = interaction_defaults({
                onFocusOnly: true
              });
            }
            _this = _super.call(this, options) || this;
            return _this;
          }
          Map2.prototype.createRenderer = function() {
            return new Composite(this);
          };
          return Map2;
        }(ol_PluggableMap);
        var ol_Map = Map_Map;
        var es_object_keys = __webpack_require__("b64b");
        var es_symbol = __webpack_require__("a4d3");
        var es_array_filter = __webpack_require__("4de4");
        var es_object_to_string = __webpack_require__("d3b7");
        var es_object_get_own_property_descriptor = __webpack_require__("e439");
        var web_dom_collections_for_each = __webpack_require__("159b");
        var es_object_get_own_property_descriptors = __webpack_require__("dbb4");
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread2(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        var es_array_includes = __webpack_require__("caad");
        var es_string_includes = __webpack_require__("2532");
        function usePropsAsObjectProperties(props) {
          var ignoredKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var options = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props);
          Object.keys(options).forEach(function(key) {
            options[key] = options[key].value;
          });
          var properties = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])(_objectSpread2({}, options));
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(props, function() {
            options = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props);
            Object.keys(options).forEach(function(key) {
              if (properties[key] != options[key].value && !ignoredKeys.includes(key)) {
                properties[key] = options[key].value;
              }
            });
          });
          return {
            properties
          };
        }
        var Mapvue_type_script_lang_js = {
          name: "ol-map",
          setup: function setup(props, _ref) {
            var emit = _ref.emit;
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var mapRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
            var map = new ol_Map(properties);
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              map.setProperties(properties);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.setTarget(mapRef.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.setTarget(null);
              map = null;
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("map", map);
            var focus = function focus2() {
              return map.focus();
            };
            var forEachFeatureAtPixel = function forEachFeatureAtPixel2(pixel, callback) {
              var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return map.forEachFeatureAtPixel(pixel, callback, options);
            };
            var forEachLayerAtPixel = function forEachLayerAtPixel2(pixel, callback, layerFilter) {
              return map.forEachLayerAtPixel(pixel, callback, layerFilter);
            };
            var getCoordinateFromPixel = function getCoordinateFromPixel2(pixel) {
              return map.getCoordinateFromPixel(pixel);
            };
            var refresh = function refresh2() {
              return map.refresh();
            };
            var render = function render2() {
              return map.render();
            };
            var updateSize = function updateSize2() {
              return map.updateSize();
            };
            map.on("click", function(event) {
              return emit("click", event);
            });
            map.on("dblclick", function(event) {
              return emit("dblclick", event);
            });
            map.on("singleclick", function(event) {
              return emit("singleclick", event);
            });
            map.on("pointerdrag", function(event) {
              return emit("pointerdrag", event);
            });
            map.on("pointermove", function(event) {
              return emit("pointermove", event);
            });
            map.on("movestart", function(event) {
              return emit("movestart", event);
            });
            map.on("moveend", function(event) {
              return emit("moveend", event);
            });
            map.on("postrender", function(event) {
              return emit("postrender", event);
            });
            map.on("precompose", function(event) {
              return emit("precompose", event);
            });
            map.on("postcompose", function(event) {
              return emit("postcompose", event);
            });
            return {
              map,
              mapRef,
              focus,
              forEachFeatureAtPixel,
              forEachLayerAtPixel,
              getCoordinateFromPixel,
              refresh,
              render,
              updateSize
            };
          },
          props: {
            loadTilesWhileAnimating: {
              type: Boolean,
              default: false
            },
            loadTilesWhileInteracting: {
              type: Boolean,
              default: false
            },
            moveTolerance: {
              type: Number,
              default: 1
            },
            pixelRatio: {
              type: Number,
              default: 1
            },
            controls: {
              type: Array,
              default: function _default() {
                return [];
              }
            }
          }
        };
        var exportHelper = __webpack_require__("6b0d");
        var exportHelper_default = __webpack_require__.n(exportHelper);
        const __exports__ = exportHelper_default()(Mapvue_type_script_lang_js, [["render", Mapvue_type_template_id_39e43851_lang_true_render]]);
        var map_Map = __exports__;
        var _hoisted_1 = {
          key: 0
        };
        function Viewvue_type_template_id_1a31c3c4_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        function useView(props, emit) {
          var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
          var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
          var createProp = function createProp2() {
            return _objectSpread2(_objectSpread2({}, properties), {}, {
              projection: typeof properties.projection == "string" ? properties.projection : new proj_Projection(_objectSpread2({}, properties.projection))
            });
          };
          var view = new ol_View(createProp());
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
            map.setView(view);
          });
          view.on("change:center", function() {
            emit("centerChanged", getCenter());
            emit("zoomChanged", getZoom());
          });
          view.on("change:resolution", function() {
            return emit("resolutionChanged", getResolution());
          });
          view.on("change:rotation", function() {
            return emit("rotationChanged", getRotation());
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
            var pr = createProp();
            view.setProperties(pr);
            view.applyOptions_(pr);
          });
          var adjustCenter = function adjustCenter2(deltaCoordinates) {
            return view.adjustCenter(deltaCoordinates);
          };
          var adjustResolution = function adjustResolution2(ratio, opt_anchor) {
            return view.adjustResolution(ratio, opt_anchor);
          };
          var adjustRotation = function adjustRotation2(delta, opt_anchor) {
            return view.adjustRotation(delta, opt_anchor);
          };
          var adjustZoom = function adjustZoom2(delta, opt_anchor) {
            return view.adjustZoom(delta, opt_anchor);
          };
          var animate = function animate2(var_args) {
            return view.animate(var_args);
          };
          var beginInteraction = function beginInteraction2() {
            return view.beginInteraction();
          };
          var calculateExtent = function calculateExtent2(opt_size) {
            return view.calculateExtent(opt_size);
          };
          var cancelAnimations = function cancelAnimations2() {
            return view.cancelAnimations();
          };
          var centerOn = function centerOn2(coordinate, size, position) {
            return view.centerOn(coordinate, size, position);
          };
          var changed = function changed2() {
            return view.changed();
          };
          var dispatchEvent = function dispatchEvent2(event) {
            return view.dispatchEvent(event);
          };
          var endInteraction = function endInteraction2(opt_duration, opt_resolutionDirection, opt_anchor) {
            return view.endInteraction(opt_duration, opt_resolutionDirection, opt_anchor);
          };
          var fit = function fit2(geometryOrExtent, opt_options) {
            return view.fit(geometryOrExtent, opt_options);
          };
          var get = function get2(key) {
            return view.get(key);
          };
          var getAnimating = function getAnimating2() {
            return view.getAnimating();
          };
          var getCenter = function getCenter2() {
            return view.getCenter();
          };
          var getInteracting = function getInteracting2() {
            return view.getInteracting();
          };
          var getKeys = function getKeys2() {
            return view.getKeys();
          };
          var getMaxResolution = function getMaxResolution2() {
            return view.getMaxResolution();
          };
          var getMaxZoom = function getMaxZoom2() {
            return view.getMaxZoom();
          };
          var getMinResolution = function getMinResolution2() {
            return view.getMinResolution();
          };
          var getMinZoom = function getMinZoom2() {
            return view.getMinZoom();
          };
          var getProjection = function getProjection2() {
            return view.getProjection();
          };
          var getProperties = function getProperties2() {
            return view.getProperties();
          };
          var getResolution = function getResolution2() {
            return view.getResolution();
          };
          var getResolutionForExtent = function getResolutionForExtent2(extent, opt_size) {
            return view.getResolutionForExtent(extent, opt_size);
          };
          var getResolutionForZoom = function getResolutionForZoom2(zoom) {
            return view.getResolutionForZoom(zoom);
          };
          var getResolutions = function getResolutions2() {
            return view.getResolutions();
          };
          var getRevision = function getRevision2() {
            return view.getRevision();
          };
          var getRotation = function getRotation2() {
            return view.getRotation();
          };
          var getZoom = function getZoom2() {
            return view.getZoom();
          };
          var getZoomForResolution = function getZoomForResolution2(resolution) {
            return view.getZoomForResolution(resolution);
          };
          var setCenter = function setCenter2(center) {
            return view.setCenter(center);
          };
          var setConstrainResolution = function setConstrainResolution2(enabled) {
            return view.setConstrainResolution(enabled);
          };
          var setMaxZoom = function setMaxZoom2(zoom) {
            return view.setMaxZoom(zoom);
          };
          var setMinZoom = function setMinZoom2(zoom) {
            return view.setMinZoom(zoom);
          };
          var setResolution = function setResolution2(resolution) {
            return view.setResolution(resolution);
          };
          var setRotation = function setRotation2(rotation) {
            return view.setRotation(rotation);
          };
          var setZoom = function setZoom2(zoom) {
            return view.setZoom(zoom);
          };
          return {
            view,
            adjustCenter,
            adjustResolution,
            adjustRotation,
            adjustZoom,
            animate,
            beginInteraction,
            calculateExtent,
            cancelAnimations,
            centerOn,
            changed,
            dispatchEvent,
            endInteraction,
            fit,
            get,
            getAnimating,
            getCenter,
            getInteracting,
            getKeys,
            getMaxResolution,
            getMaxZoom,
            getMinResolution,
            getMinZoom,
            getProjection,
            getProperties,
            getResolution,
            getResolutionForExtent,
            getResolutionForZoom,
            getResolutions,
            getRevision,
            getRotation,
            getZoom,
            getZoomForResolution,
            setCenter,
            setConstrainResolution,
            setMaxZoom,
            setMinZoom,
            setResolution,
            setRotation,
            setZoom
          };
        }
        var Viewvue_type_script_lang_js = {
          name: "ol-view",
          setup: function setup(props, _ref) {
            var emit = _ref.emit;
            var view = useView(props, emit);
            return _objectSpread2({}, view);
          },
          props: {
            center: {
              type: Array,
              default: function _default() {
                return [0, 0];
              }
            },
            constrainRotation: {
              type: Boolean,
              default: true
            },
            enableRotation: {
              type: Boolean,
              default: true
            },
            extent: {
              type: Array
            },
            constrainOnlyCenter: {
              type: Boolean,
              default: false
            },
            smoothExtentConstraint: {
              type: Boolean,
              default: true
            },
            maxResolution: {
              type: Number
            },
            minResolution: {
              type: Number
            },
            maxZoom: {
              type: Number,
              default: 28
            },
            minZoom: {
              type: Number,
              default: 0
            },
            multiWorld: {
              type: Boolean,
              default: false
            },
            constrainResolution: {
              type: Boolean,
              default: false
            },
            smoothResolutionConstraint: {
              type: Boolean,
              default: true
            },
            showFullExtent: {
              type: Boolean,
              default: false
            },
            projection: {
              type: [String, Object],
              default: "EPSG:3857"
            },
            resolution: {
              type: Number
            },
            resolutions: {
              type: Array
            },
            rotation: {
              type: Number
            },
            zoom: {
              type: Number,
              default: 0
            },
            zoomFactor: {
              type: Number,
              default: 2
            },
            padding: {
              type: Array,
              default: function _default() {
                return [0, 0, 0, 0];
              }
            }
          }
        };
        const View_exports_ = exportHelper_default()(Viewvue_type_script_lang_js, [["render", Viewvue_type_template_id_1a31c3c4_lang_true_render]]);
        var map_View = View_exports_;
        function Featurevue_type_template_id_2a92e3d7_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var Feature_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Feature_Feature = function(_super) {
          Feature_extends(Feature, _super);
          function Feature(opt_geometryOrProperties) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.id_ = void 0;
            _this.geometryName_ = "geometry";
            _this.style_ = null;
            _this.styleFunction_ = void 0;
            _this.geometryChangeKey_ = null;
            _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);
            if (opt_geometryOrProperties) {
              if (typeof opt_geometryOrProperties.getSimplifiedGeometry === "function") {
                var geometry = opt_geometryOrProperties;
                _this.setGeometry(geometry);
              } else {
                var properties = opt_geometryOrProperties;
                _this.setProperties(properties);
              }
            }
            return _this;
          }
          Feature.prototype.clone = function() {
            var clone2 = new Feature(this.hasProperties() ? this.getProperties() : null);
            clone2.setGeometryName(this.getGeometryName());
            var geometry = this.getGeometry();
            if (geometry) {
              clone2.setGeometry(geometry.clone());
            }
            var style = this.getStyle();
            if (style) {
              clone2.setStyle(style);
            }
            return clone2;
          };
          Feature.prototype.getGeometry = function() {
            return this.get(this.geometryName_);
          };
          Feature.prototype.getId = function() {
            return this.id_;
          };
          Feature.prototype.getGeometryName = function() {
            return this.geometryName_;
          };
          Feature.prototype.getStyle = function() {
            return this.style_;
          };
          Feature.prototype.getStyleFunction = function() {
            return this.styleFunction_;
          };
          Feature.prototype.handleGeometryChange_ = function() {
            this.changed();
          };
          Feature.prototype.handleGeometryChanged_ = function() {
            if (this.geometryChangeKey_) {
              Object(events["c"])(this.geometryChangeKey_);
              this.geometryChangeKey_ = null;
            }
            var geometry = this.getGeometry();
            if (geometry) {
              this.geometryChangeKey_ = Object(events["a"])(geometry, EventType["a"].CHANGE, this.handleGeometryChange_, this);
            }
            this.changed();
          };
          Feature.prototype.setGeometry = function(geometry) {
            this.set(this.geometryName_, geometry);
          };
          Feature.prototype.setStyle = function(opt_style) {
            this.style_ = opt_style;
            this.styleFunction_ = !opt_style ? void 0 : createStyleFunction(opt_style);
            this.changed();
          };
          Feature.prototype.setId = function(id) {
            this.id_ = id;
            this.changed();
          };
          Feature.prototype.setGeometryName = function(name) {
            this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
            this.geometryName_ = name;
            this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
            this.handleGeometryChanged_();
          };
          return Feature;
        }(ol_Object["a"]);
        function createStyleFunction(obj) {
          if (typeof obj === "function") {
            return obj;
          } else {
            var styles_1;
            if (Array.isArray(obj)) {
              styles_1 = obj;
            } else {
              assert2(typeof obj.getZIndex === "function", 41);
              var style = obj;
              styles_1 = [style];
            }
            return function() {
              return styles_1;
            };
          }
        }
        var ol_Feature = Feature_Feature;
        var Featurevue_type_script_lang_js = {
          name: "ol-feature",
          setup: function setup(props) {
            var vectorSource = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorSource");
            var vectorLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorLayer");
            var animation = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("animation", null);
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var feature = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var f = new ol_Feature(_objectSpread2({}, properties.properties));
              return f;
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(feature, function(newVal, oldVal) {
              vectorSource.value.removeFeature(oldVal);
              vectorSource.value.addFeature(newVal);
              vectorSource.value.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(vectorSource, function(newVal, oldVal) {
              oldVal.removeFeature(feature.value);
              newVal.addFeature(feature.value);
              newVal.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              vectorSource.value.addFeature(feature.value);
              if (animation != null) {
                vectorLayer.value.animateFeature(feature.value, animation.value);
              }
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              vectorSource.value.removeFeature(feature.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("feature", feature);
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", feature);
            return {
              feature
            };
          },
          props: {
            properties: {
              type: [geom_Geometry, Object, Array]
            }
          }
        };
        const Feature_exports_ = exportHelper_default()(Featurevue_type_script_lang_js, [["render", Featurevue_type_template_id_2a92e3d7_lang_true_render]]);
        var map_Feature = Feature_exports_;
        var Overlayvue_type_template_id_fdec3864_lang_true_hoisted_1 = {
          ref: "htmlContent"
        };
        function Overlayvue_type_template_id_fdec3864_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", Overlayvue_type_template_id_fdec3864_lang_true_hoisted_1, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default", {
            position: $props.position
          })], 512);
        }
        var OverlayPositioning = {
          BOTTOM_LEFT: "bottom-left",
          BOTTOM_CENTER: "bottom-center",
          BOTTOM_RIGHT: "bottom-right",
          CENTER_LEFT: "center-left",
          CENTER_CENTER: "center-center",
          CENTER_RIGHT: "center-right",
          TOP_LEFT: "top-left",
          TOP_CENTER: "top-center",
          TOP_RIGHT: "top-right"
        };
        var Overlay_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Overlay_Property = {
          ELEMENT: "element",
          MAP: "map",
          OFFSET: "offset",
          POSITION: "position",
          POSITIONING: "positioning"
        };
        var Overlay_Overlay = function(_super) {
          Overlay_extends(Overlay, _super);
          function Overlay(options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.options = options;
            _this.id = options.id;
            _this.insertFirst = options.insertFirst !== void 0 ? options.insertFirst : true;
            _this.stopEvent = options.stopEvent !== void 0 ? options.stopEvent : true;
            _this.element = document.createElement("div");
            _this.element.className = options.className !== void 0 ? options.className : "ol-overlay-container " + CLASS_SELECTABLE;
            _this.element.style.position = "absolute";
            _this.element.style.pointerEvents = "auto";
            var autoPan = options.autoPan;
            if (autoPan && typeof autoPan !== "object") {
              autoPan = {
                animation: options.autoPanAnimation,
                margin: options.autoPanMargin
              };
            }
            _this.autoPan = autoPan || false;
            _this.rendered = {
              transform_: "",
              visible: true
            };
            _this.mapPostrenderListenerKey = null;
            _this.addChangeListener(Overlay_Property.ELEMENT, _this.handleElementChanged);
            _this.addChangeListener(Overlay_Property.MAP, _this.handleMapChanged);
            _this.addChangeListener(Overlay_Property.OFFSET, _this.handleOffsetChanged);
            _this.addChangeListener(Overlay_Property.POSITION, _this.handlePositionChanged);
            _this.addChangeListener(Overlay_Property.POSITIONING, _this.handlePositioningChanged);
            if (options.element !== void 0) {
              _this.setElement(options.element);
            }
            _this.setOffset(options.offset !== void 0 ? options.offset : [0, 0]);
            _this.setPositioning(options.positioning !== void 0 ? options.positioning : OverlayPositioning.TOP_LEFT);
            if (options.position !== void 0) {
              _this.setPosition(options.position);
            }
            return _this;
          }
          Overlay.prototype.getElement = function() {
            return this.get(Overlay_Property.ELEMENT);
          };
          Overlay.prototype.getId = function() {
            return this.id;
          };
          Overlay.prototype.getMap = function() {
            return this.get(Overlay_Property.MAP);
          };
          Overlay.prototype.getOffset = function() {
            return this.get(Overlay_Property.OFFSET);
          };
          Overlay.prototype.getPosition = function() {
            return this.get(Overlay_Property.POSITION);
          };
          Overlay.prototype.getPositioning = function() {
            return this.get(Overlay_Property.POSITIONING);
          };
          Overlay.prototype.handleElementChanged = function() {
            Object(dom["d"])(this.element);
            var element = this.getElement();
            if (element) {
              this.element.appendChild(element);
            }
          };
          Overlay.prototype.handleMapChanged = function() {
            if (this.mapPostrenderListenerKey) {
              Object(dom["e"])(this.element);
              Object(events["c"])(this.mapPostrenderListenerKey);
              this.mapPostrenderListenerKey = null;
            }
            var map = this.getMap();
            if (map) {
              this.mapPostrenderListenerKey = Object(events["a"])(map, MapEventType["a"].POSTRENDER, this.render, this);
              this.updatePixelPosition();
              var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
              if (this.insertFirst) {
                container.insertBefore(this.element, container.childNodes[0] || null);
              } else {
                container.appendChild(this.element);
              }
              this.performAutoPan();
            }
          };
          Overlay.prototype.render = function() {
            this.updatePixelPosition();
          };
          Overlay.prototype.handleOffsetChanged = function() {
            this.updatePixelPosition();
          };
          Overlay.prototype.handlePositionChanged = function() {
            this.updatePixelPosition();
            this.performAutoPan();
          };
          Overlay.prototype.handlePositioningChanged = function() {
            this.updatePixelPosition();
          };
          Overlay.prototype.setElement = function(element) {
            this.set(Overlay_Property.ELEMENT, element);
          };
          Overlay.prototype.setMap = function(map) {
            this.set(Overlay_Property.MAP, map);
          };
          Overlay.prototype.setOffset = function(offset) {
            this.set(Overlay_Property.OFFSET, offset);
          };
          Overlay.prototype.setPosition = function(position) {
            this.set(Overlay_Property.POSITION, position);
          };
          Overlay.prototype.performAutoPan = function() {
            if (this.autoPan) {
              this.panIntoView(this.autoPan);
            }
          };
          Overlay.prototype.panIntoView = function(opt_panIntoViewOptions) {
            var map = this.getMap();
            if (!map || !map.getTargetElement() || !this.get(Overlay_Property.POSITION)) {
              return;
            }
            var mapRect = this.getRect(map.getTargetElement(), map.getSize());
            var element = this.getElement();
            var overlayRect = this.getRect(element, [
              Object(dom["c"])(element),
              Object(dom["b"])(element)
            ]);
            var panIntoViewOptions = opt_panIntoViewOptions || {};
            var myMargin = panIntoViewOptions.margin === void 0 ? 20 : panIntoViewOptions.margin;
            if (!containsExtent(mapRect, overlayRect)) {
              var offsetLeft = overlayRect[0] - mapRect[0];
              var offsetRight = mapRect[2] - overlayRect[2];
              var offsetTop = overlayRect[1] - mapRect[1];
              var offsetBottom = mapRect[3] - overlayRect[3];
              var delta = [0, 0];
              if (offsetLeft < 0) {
                delta[0] = offsetLeft - myMargin;
              } else if (offsetRight < 0) {
                delta[0] = Math.abs(offsetRight) + myMargin;
              }
              if (offsetTop < 0) {
                delta[1] = offsetTop - myMargin;
              } else if (offsetBottom < 0) {
                delta[1] = Math.abs(offsetBottom) + myMargin;
              }
              if (delta[0] !== 0 || delta[1] !== 0) {
                var center = map.getView().getCenterInternal();
                var centerPx = map.getPixelFromCoordinateInternal(center);
                if (!centerPx) {
                  return;
                }
                var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
                var panOptions = panIntoViewOptions.animation || {};
                map.getView().animateInternal({
                  center: map.getCoordinateFromPixelInternal(newCenterPx),
                  duration: panOptions.duration,
                  easing: panOptions.easing
                });
              }
            }
          };
          Overlay.prototype.getRect = function(element, size) {
            var box = element.getBoundingClientRect();
            var offsetX = box.left + window.pageXOffset;
            var offsetY = box.top + window.pageYOffset;
            return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
          };
          Overlay.prototype.setPositioning = function(positioning) {
            this.set(Overlay_Property.POSITIONING, positioning);
          };
          Overlay.prototype.setVisible = function(visible) {
            if (this.rendered.visible !== visible) {
              this.element.style.display = visible ? "" : "none";
              this.rendered.visible = visible;
            }
          };
          Overlay.prototype.updatePixelPosition = function() {
            var map = this.getMap();
            var position = this.getPosition();
            if (!map || !map.isRendered() || !position) {
              this.setVisible(false);
              return;
            }
            var pixel = map.getPixelFromCoordinate(position);
            var mapSize = map.getSize();
            this.updateRenderedPosition(pixel, mapSize);
          };
          Overlay.prototype.updateRenderedPosition = function(pixel, mapSize) {
            var style = this.element.style;
            var offset = this.getOffset();
            var positioning = this.getPositioning();
            this.setVisible(true);
            var x = Math.round(pixel[0] + offset[0]) + "px";
            var y = Math.round(pixel[1] + offset[1]) + "px";
            var posX = "0%";
            var posY = "0%";
            if (positioning == OverlayPositioning.BOTTOM_RIGHT || positioning == OverlayPositioning.CENTER_RIGHT || positioning == OverlayPositioning.TOP_RIGHT) {
              posX = "-100%";
            } else if (positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.TOP_CENTER) {
              posX = "-50%";
            }
            if (positioning == OverlayPositioning.BOTTOM_LEFT || positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.BOTTOM_RIGHT) {
              posY = "-100%";
            } else if (positioning == OverlayPositioning.CENTER_LEFT || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.CENTER_RIGHT) {
              posY = "-50%";
            }
            var transform2 = "translate(" + posX + ", " + posY + ") translate(" + x + ", " + y + ")";
            if (this.rendered.transform_ != transform2) {
              this.rendered.transform_ = transform2;
              style.transform = transform2;
              style.msTransform = transform2;
            }
          };
          Overlay.prototype.getOptions = function() {
            return this.options;
          };
          return Overlay;
        }(ol_Object["a"]);
        var ol_Overlay = Overlay_Overlay;
        function useOverlay(props, emit) {
          var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
          var htmlContent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
          var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
          var overlay = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
            return new ol_Overlay(properties);
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
            map.addOverlay(overlay.value);
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
            map.removeOverlay(overlay.value);
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(overlay, function(newVal, oldVal) {
            map.removeOverlay(oldVal);
            map.addOverlay(newVal);
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watchEffect"])(function() {
            setElement(htmlContent.value);
          }, {
            flush: "post"
          });
          overlay.value.on("change:element", function() {
            return emit("elementChanged", getElement());
          });
          overlay.value.on("change:offset", function() {
            return emit("offsetChanged", getOffset());
          });
          overlay.value.on("change:position", function() {
            return emit("positionChanged", getPosition());
          });
          overlay.value.on("change:positioning", function() {
            return emit("positioningChanged", getPositioning());
          });
          var getElement = function getElement2() {
            return overlay.value.getElement();
          };
          var getOffset = function getOffset2() {
            return overlay.value.getOffset();
          };
          var getPosition = function getPosition2() {
            return overlay.value.getPosition();
          };
          var getPositioning = function getPositioning2() {
            return overlay.value.getPositioning();
          };
          var panIntoView = function panIntoView2(opt_panIntoViewOptions) {
            return overlay.value.panIntoView(opt_panIntoViewOptions);
          };
          var setElement = function setElement2(element) {
            return overlay.value.setElement(element);
          };
          var setOffset = function setOffset2(offset) {
            return overlay.value.setOffset(offset);
          };
          var setPosition = function setPosition2(position) {
            return overlay.value.setPosition(position);
          };
          var setPositioning = function setPositioning2(positioning) {
            return overlay.value.setPositioning(positioning);
          };
          return {
            overlay,
            htmlContent,
            getOffset,
            getPosition,
            getPositioning,
            panIntoView,
            setElement,
            setOffset,
            setPosition,
            setPositioning
          };
        }
        var Overlayvue_type_script_lang_js = {
          name: "ol-overlay",
          setup: function setup(props, _ref) {
            var emit = _ref.emit;
            var overlay = new useOverlay(props, emit);
            return _objectSpread2({}, overlay);
          },
          props: {
            position: {
              type: Array
            },
            offset: {
              type: Array
            },
            positioning: {
              type: Array
            },
            stopEvent: {
              type: Boolean,
              default: true
            },
            insertFirst: {
              type: Boolean,
              default: true
            },
            autoPan: {
              type: Boolean,
              default: false
            },
            autoPanMargin: {
              type: Number,
              default: 20
            },
            autoPanAnimation: {
              type: Object,
              default: void 0
            }
          }
        };
        const Overlay_exports_ = exportHelper_default()(Overlayvue_type_script_lang_js, [["render", Overlayvue_type_template_id_fdec3864_lang_true_render]]);
        var map_Overlay = Overlay_exports_;
        function GeoLocationvue_type_template_id_4348a5ab_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default", {
            position: $setup.position,
            speed: $setup.speed,
            heading: $setup.heading,
            accuracy: $setup.accuracy,
            altitude: $setup.altitude,
            altitudeAccuracy: $setup.altitudeAccuracy,
            accuracyGeometry: $setup.accuracyGeometry
          });
        }
        var Geolocation_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Geolocation_Property = {
          ACCURACY: "accuracy",
          ACCURACY_GEOMETRY: "accuracyGeometry",
          ALTITUDE: "altitude",
          ALTITUDE_ACCURACY: "altitudeAccuracy",
          HEADING: "heading",
          POSITION: "position",
          PROJECTION: "projection",
          SPEED: "speed",
          TRACKING: "tracking",
          TRACKING_OPTIONS: "trackingOptions"
        };
        var Geolocation_GeolocationError = function(_super) {
          Geolocation_extends(GeolocationError, _super);
          function GeolocationError(error) {
            var _this = _super.call(this, EventType["a"].ERROR) || this;
            _this.code = error.code;
            _this.message = error.message;
            return _this;
          }
          return GeolocationError;
        }(events_Event["a"]);
        var Geolocation_Geolocation = function(_super) {
          Geolocation_extends(Geolocation, _super);
          function Geolocation(opt_options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            var options = opt_options || {};
            _this.position_ = null;
            _this.transform_ = identityTransform;
            _this.watchId_ = void 0;
            _this.addChangeListener(Geolocation_Property.PROJECTION, _this.handleProjectionChanged_);
            _this.addChangeListener(Geolocation_Property.TRACKING, _this.handleTrackingChanged_);
            if (options.projection !== void 0) {
              _this.setProjection(options.projection);
            }
            if (options.trackingOptions !== void 0) {
              _this.setTrackingOptions(options.trackingOptions);
            }
            _this.setTracking(options.tracking !== void 0 ? options.tracking : false);
            return _this;
          }
          Geolocation.prototype.disposeInternal = function() {
            this.setTracking(false);
            _super.prototype.disposeInternal.call(this);
          };
          Geolocation.prototype.handleProjectionChanged_ = function() {
            var projection = this.getProjection();
            if (projection) {
              this.transform_ = getTransformFromProjections(proj_get("EPSG:4326"), projection);
              if (this.position_) {
                this.set(Geolocation_Property.POSITION, this.transform_(this.position_));
              }
            }
          };
          Geolocation.prototype.handleTrackingChanged_ = function() {
            if ("geolocation" in navigator) {
              var tracking = this.getTracking();
              if (tracking && this.watchId_ === void 0) {
                this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());
              } else if (!tracking && this.watchId_ !== void 0) {
                navigator.geolocation.clearWatch(this.watchId_);
                this.watchId_ = void 0;
              }
            }
          };
          Geolocation.prototype.positionChange_ = function(position) {
            var coords = position.coords;
            this.set(Geolocation_Property.ACCURACY, coords.accuracy);
            this.set(Geolocation_Property.ALTITUDE, coords.altitude === null ? void 0 : coords.altitude);
            this.set(Geolocation_Property.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? void 0 : coords.altitudeAccuracy);
            this.set(Geolocation_Property.HEADING, coords.heading === null ? void 0 : toRadians(coords.heading));
            if (!this.position_) {
              this.position_ = [coords.longitude, coords.latitude];
            } else {
              this.position_[0] = coords.longitude;
              this.position_[1] = coords.latitude;
            }
            var projectedPosition = this.transform_(this.position_);
            this.set(Geolocation_Property.POSITION, projectedPosition);
            this.set(Geolocation_Property.SPEED, coords.speed === null ? void 0 : coords.speed);
            var geometry = circular(this.position_, coords.accuracy);
            geometry.applyTransform(this.transform_);
            this.set(Geolocation_Property.ACCURACY_GEOMETRY, geometry);
            this.changed();
          };
          Geolocation.prototype.positionError_ = function(error) {
            this.dispatchEvent(new Geolocation_GeolocationError(error));
          };
          Geolocation.prototype.getAccuracy = function() {
            return this.get(Geolocation_Property.ACCURACY);
          };
          Geolocation.prototype.getAccuracyGeometry = function() {
            return this.get(Geolocation_Property.ACCURACY_GEOMETRY) || null;
          };
          Geolocation.prototype.getAltitude = function() {
            return this.get(Geolocation_Property.ALTITUDE);
          };
          Geolocation.prototype.getAltitudeAccuracy = function() {
            return this.get(Geolocation_Property.ALTITUDE_ACCURACY);
          };
          Geolocation.prototype.getHeading = function() {
            return this.get(Geolocation_Property.HEADING);
          };
          Geolocation.prototype.getPosition = function() {
            return this.get(Geolocation_Property.POSITION);
          };
          Geolocation.prototype.getProjection = function() {
            return this.get(Geolocation_Property.PROJECTION);
          };
          Geolocation.prototype.getSpeed = function() {
            return this.get(Geolocation_Property.SPEED);
          };
          Geolocation.prototype.getTracking = function() {
            return this.get(Geolocation_Property.TRACKING);
          };
          Geolocation.prototype.getTrackingOptions = function() {
            return this.get(Geolocation_Property.TRACKING_OPTIONS);
          };
          Geolocation.prototype.setProjection = function(projection) {
            this.set(Geolocation_Property.PROJECTION, proj_get(projection));
          };
          Geolocation.prototype.setTracking = function(tracking) {
            this.set(Geolocation_Property.TRACKING, tracking);
          };
          Geolocation.prototype.setTrackingOptions = function(options) {
            this.set(Geolocation_Property.TRACKING_OPTIONS, options);
          };
          return Geolocation;
        }(ol_Object["a"]);
        var ol_Geolocation = Geolocation_Geolocation;
        var GeoLocationvue_type_script_lang_js = {
          name: "ol-geolocation",
          emits: ["positionChanged", "speedChanged", "headingChanged", "altitudeChanged", "altitudeAccuracyChanged", "accuracyGeometryChanged"],
          setup: function setup(props, _ref) {
            var emit = _ref.emit;
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var geoLoc = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var g = new ol_Geolocation(properties);
              g.on("change", changeEvt);
              return g;
            });
            var position = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
            var accuracy = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
            var altitude = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
            var altitudeAccuracy = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
            var speed = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
            var heading = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
            var accuracyGeometry = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({});
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(position, function() {
              emit("positionChanged", position.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(speed, function() {
              emit("speedChanged", speed.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(heading, function() {
              emit("headingChanged", heading.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(altitude, function() {
              emit("altitudeChanged", altitude.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(altitudeAccuracy, function() {
              emit("altitudeAccuracyChanged", altitudeAccuracy.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(accuracyGeometry, function() {
              emit("accuracyGeometryChanged", accuracyGeometry.value);
            });
            var changeEvt = function changeEvt2() {
              position.value = geoLoc.value.getPosition();
              speed.value = geoLoc.value.getSpeed();
              heading.value = geoLoc.value.getHeading();
              accuracy.value = geoLoc.value.getAccuracy();
              altitude.value = geoLoc.value.getAltitude();
              altitudeAccuracy.value = geoLoc.value.getAltitudeAccuracy();
              accuracyGeometry.value = geoLoc.value.getAccuracyGeometry();
            };
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(geoLoc, function(newVal, oldVal) {
              oldVal.un("change", changeEvt);
              newVal.on("change", changeEvt);
            });
            return {
              geoLoc,
              position,
              accuracy,
              altitude,
              altitudeAccuracy,
              speed,
              heading,
              accuracyGeometry
            };
          },
          props: {
            projection: {
              type: [String, Object],
              default: "EPSG:3857"
            },
            tracking: {
              type: Boolean,
              default: true
            },
            trackingOptions: {
              type: Object,
              default: function _default() {
                return {
                  enableHighAccuracy: true
                };
              }
            }
          }
        };
        const GeoLocation_exports_ = exportHelper_default()(GeoLocationvue_type_script_lang_js, [["render", GeoLocationvue_type_template_id_4348a5ab_lang_true_render]]);
        var GeoLocation = GeoLocation_exports_;
        var Projectionvue_type_template_id_07dd68fa_lang_true_hoisted_1 = {
          key: 0
        };
        function Projectionvue_type_template_id_07dd68fa_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var global = function(defs2) {
          defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
          defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
          defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
          defs2.WGS84 = defs2["EPSG:4326"];
          defs2["EPSG:3785"] = defs2["EPSG:3857"];
          defs2.GOOGLE = defs2["EPSG:3857"];
          defs2["EPSG:900913"] = defs2["EPSG:3857"];
          defs2["EPSG:102113"] = defs2["EPSG:3857"];
        };
        var PJD_3PARAM = 1;
        var PJD_7PARAM = 2;
        var PJD_GRIDSHIFT = 3;
        var PJD_WGS84 = 4;
        var PJD_NODATUM = 5;
        var SRS_WGS84_SEMIMAJOR = 6378137;
        var SRS_WGS84_SEMIMINOR = 6356752314e-3;
        var SRS_WGS84_ESQUARED = 0.0066943799901413165;
        var SEC_TO_RAD = 484813681109536e-20;
        var HALF_PI = Math.PI / 2;
        var SIXTH = 0.16666666666666666;
        var RA4 = 0.04722222222222222;
        var RA6 = 0.022156084656084655;
        var EPSLN = 1e-10;
        var D2R = 0.017453292519943295;
        var R2D = 57.29577951308232;
        var FORTPI = Math.PI / 4;
        var TWO_PI = Math.PI * 2;
        var SPI = 3.14159265359;
        var PrimeMeridian_exports = {};
        PrimeMeridian_exports.greenwich = 0;
        PrimeMeridian_exports.lisbon = -9.131906111111;
        PrimeMeridian_exports.paris = 2.337229166667;
        PrimeMeridian_exports.bogota = -74.080916666667;
        PrimeMeridian_exports.madrid = -3.687938888889;
        PrimeMeridian_exports.rome = 12.452333333333;
        PrimeMeridian_exports.bern = 7.439583333333;
        PrimeMeridian_exports.jakarta = 106.807719444444;
        PrimeMeridian_exports.ferro = -17.666666666667;
        PrimeMeridian_exports.brussels = 4.367975;
        PrimeMeridian_exports.stockholm = 18.058277777778;
        PrimeMeridian_exports.athens = 23.7163375;
        PrimeMeridian_exports.oslo = 10.722916666667;
        var constants_units = {
          ft: { to_meter: 0.3048 },
          "us-ft": { to_meter: 1200 / 3937 }
        };
        var ignoredChar = /[\s_\-\/\(\)]/g;
        function match_match(obj, key) {
          if (obj[key]) {
            return obj[key];
          }
          var keys = Object.keys(obj);
          var lkey = key.toLowerCase().replace(ignoredChar, "");
          var i = -1;
          var testkey, processedKey;
          while (++i < keys.length) {
            testkey = keys[i];
            processedKey = testkey.toLowerCase().replace(ignoredChar, "");
            if (processedKey === lkey) {
              return obj[testkey];
            }
          }
        }
        var projString = function(defData) {
          var self2 = {};
          var paramObj = defData.split("+").map(function(v) {
            return v.trim();
          }).filter(function(a) {
            return a;
          }).reduce(function(p, a) {
            var split = a.split("=");
            split.push(true);
            p[split[0].toLowerCase()] = split[1];
            return p;
          }, {});
          var paramName, paramVal, paramOutname;
          var params = {
            proj: "projName",
            datum: "datumCode",
            rf: function(v) {
              self2.rf = parseFloat(v);
            },
            lat_0: function(v) {
              self2.lat0 = v * D2R;
            },
            lat_1: function(v) {
              self2.lat1 = v * D2R;
            },
            lat_2: function(v) {
              self2.lat2 = v * D2R;
            },
            lat_ts: function(v) {
              self2.lat_ts = v * D2R;
            },
            lon_0: function(v) {
              self2.long0 = v * D2R;
            },
            lon_1: function(v) {
              self2.long1 = v * D2R;
            },
            lon_2: function(v) {
              self2.long2 = v * D2R;
            },
            alpha: function(v) {
              self2.alpha = parseFloat(v) * D2R;
            },
            gamma: function(v) {
              self2.rectified_grid_angle = parseFloat(v);
            },
            lonc: function(v) {
              self2.longc = v * D2R;
            },
            x_0: function(v) {
              self2.x0 = parseFloat(v);
            },
            y_0: function(v) {
              self2.y0 = parseFloat(v);
            },
            k_0: function(v) {
              self2.k0 = parseFloat(v);
            },
            k: function(v) {
              self2.k0 = parseFloat(v);
            },
            a: function(v) {
              self2.a = parseFloat(v);
            },
            b: function(v) {
              self2.b = parseFloat(v);
            },
            r_a: function() {
              self2.R_A = true;
            },
            zone: function(v) {
              self2.zone = parseInt(v, 10);
            },
            south: function() {
              self2.utmSouth = true;
            },
            towgs84: function(v) {
              self2.datum_params = v.split(",").map(function(a) {
                return parseFloat(a);
              });
            },
            to_meter: function(v) {
              self2.to_meter = parseFloat(v);
            },
            units: function(v) {
              self2.units = v;
              var unit = match_match(constants_units, v);
              if (unit) {
                self2.to_meter = unit.to_meter;
              }
            },
            from_greenwich: function(v) {
              self2.from_greenwich = v * D2R;
            },
            pm: function(v) {
              var pm = match_match(PrimeMeridian_exports, v);
              self2.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
            },
            nadgrids: function(v) {
              if (v === "@null") {
                self2.datumCode = "none";
              } else {
                self2.nadgrids = v;
              }
            },
            axis: function(v) {
              var legalAxis = "ewnsud";
              if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
                self2.axis = v;
              }
            },
            approx: function() {
              self2.approx = true;
            }
          };
          for (paramName in paramObj) {
            paramVal = paramObj[paramName];
            if (paramName in params) {
              paramOutname = params[paramName];
              if (typeof paramOutname === "function") {
                paramOutname(paramVal);
              } else {
                self2[paramOutname] = paramVal;
              }
            } else {
              self2[paramName] = paramVal;
            }
          }
          if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
            self2.datumCode = self2.datumCode.toLowerCase();
          }
          return self2;
        };
        var parser = parseString;
        var NEUTRAL = 1;
        var KEYWORD = 2;
        var NUMBER = 3;
        var QUOTED = 4;
        var AFTERQUOTE = 5;
        var ENDED = -1;
        var whitespace = /\s/;
        var latin = /[A-Za-z]/;
        var keyword = /[A-Za-z84_]/;
        var endThings = /[,\]]/;
        var digets = /[\d\.E\-\+]/;
        function parser_Parser(text) {
          if (typeof text !== "string") {
            throw new Error("not a string");
          }
          this.text = text.trim();
          this.level = 0;
          this.place = 0;
          this.root = null;
          this.stack = [];
          this.currentObject = null;
          this.state = NEUTRAL;
        }
        parser_Parser.prototype.readCharicter = function() {
          var char = this.text[this.place++];
          if (this.state !== QUOTED) {
            while (whitespace.test(char)) {
              if (this.place >= this.text.length) {
                return;
              }
              char = this.text[this.place++];
            }
          }
          switch (this.state) {
            case NEUTRAL:
              return this.neutral(char);
            case KEYWORD:
              return this.keyword(char);
            case QUOTED:
              return this.quoted(char);
            case AFTERQUOTE:
              return this.afterquote(char);
            case NUMBER:
              return this.number(char);
            case ENDED:
              return;
          }
        };
        parser_Parser.prototype.afterquote = function(char) {
          if (char === '"') {
            this.word += '"';
            this.state = QUOTED;
            return;
          }
          if (endThings.test(char)) {
            this.word = this.word.trim();
            this.afterItem(char);
            return;
          }
          throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
        };
        parser_Parser.prototype.afterItem = function(char) {
          if (char === ",") {
            if (this.word !== null) {
              this.currentObject.push(this.word);
            }
            this.word = null;
            this.state = NEUTRAL;
            return;
          }
          if (char === "]") {
            this.level--;
            if (this.word !== null) {
              this.currentObject.push(this.word);
              this.word = null;
            }
            this.state = NEUTRAL;
            this.currentObject = this.stack.pop();
            if (!this.currentObject) {
              this.state = ENDED;
            }
            return;
          }
        };
        parser_Parser.prototype.number = function(char) {
          if (digets.test(char)) {
            this.word += char;
            return;
          }
          if (endThings.test(char)) {
            this.word = parseFloat(this.word);
            this.afterItem(char);
            return;
          }
          throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
        };
        parser_Parser.prototype.quoted = function(char) {
          if (char === '"') {
            this.state = AFTERQUOTE;
            return;
          }
          this.word += char;
          return;
        };
        parser_Parser.prototype.keyword = function(char) {
          if (keyword.test(char)) {
            this.word += char;
            return;
          }
          if (char === "[") {
            var newObjects = [];
            newObjects.push(this.word);
            this.level++;
            if (this.root === null) {
              this.root = newObjects;
            } else {
              this.currentObject.push(newObjects);
            }
            this.stack.push(this.currentObject);
            this.currentObject = newObjects;
            this.state = NEUTRAL;
            return;
          }
          if (endThings.test(char)) {
            this.afterItem(char);
            return;
          }
          throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
        };
        parser_Parser.prototype.neutral = function(char) {
          if (latin.test(char)) {
            this.word = char;
            this.state = KEYWORD;
            return;
          }
          if (char === '"') {
            this.word = "";
            this.state = QUOTED;
            return;
          }
          if (digets.test(char)) {
            this.word = char;
            this.state = NUMBER;
            return;
          }
          if (endThings.test(char)) {
            this.afterItem(char);
            return;
          }
          throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
        };
        parser_Parser.prototype.output = function() {
          while (this.place < this.text.length) {
            this.readCharicter();
          }
          if (this.state === ENDED) {
            return this.root;
          }
          throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
        };
        function parseString(txt) {
          var parser2 = new parser_Parser(txt);
          return parser2.output();
        }
        function mapit(obj, key, value) {
          if (Array.isArray(key)) {
            value.unshift(key);
            key = null;
          }
          var thing = key ? {} : obj;
          var out = value.reduce(function(newObj, item) {
            sExpr(item, newObj);
            return newObj;
          }, thing);
          if (key) {
            obj[key] = out;
          }
        }
        function sExpr(v, obj) {
          if (!Array.isArray(v)) {
            obj[v] = true;
            return;
          }
          var key = v.shift();
          if (key === "PARAMETER") {
            key = v.shift();
          }
          if (v.length === 1) {
            if (Array.isArray(v[0])) {
              obj[key] = {};
              sExpr(v[0], obj[key]);
              return;
            }
            obj[key] = v[0];
            return;
          }
          if (!v.length) {
            obj[key] = true;
            return;
          }
          if (key === "TOWGS84") {
            obj[key] = v;
            return;
          }
          if (key === "AXIS") {
            if (!(key in obj)) {
              obj[key] = [];
            }
            obj[key].push(v);
            return;
          }
          if (!Array.isArray(key)) {
            obj[key] = {};
          }
          var i;
          switch (key) {
            case "UNIT":
            case "PRIMEM":
            case "VERT_DATUM":
              obj[key] = {
                name: v[0].toLowerCase(),
                convert: v[1]
              };
              if (v.length === 3) {
                sExpr(v[2], obj[key]);
              }
              return;
            case "SPHEROID":
            case "ELLIPSOID":
              obj[key] = {
                name: v[0],
                a: v[1],
                rf: v[2]
              };
              if (v.length === 4) {
                sExpr(v[3], obj[key]);
              }
              return;
            case "PROJECTEDCRS":
            case "PROJCRS":
            case "GEOGCS":
            case "GEOCCS":
            case "PROJCS":
            case "LOCAL_CS":
            case "GEODCRS":
            case "GEODETICCRS":
            case "GEODETICDATUM":
            case "EDATUM":
            case "ENGINEERINGDATUM":
            case "VERT_CS":
            case "VERTCRS":
            case "VERTICALCRS":
            case "COMPD_CS":
            case "COMPOUNDCRS":
            case "ENGINEERINGCRS":
            case "ENGCRS":
            case "FITTED_CS":
            case "LOCAL_DATUM":
            case "DATUM":
              v[0] = ["name", v[0]];
              mapit(obj, key, v);
              return;
            default:
              i = -1;
              while (++i < v.length) {
                if (!Array.isArray(v[i])) {
                  return sExpr(v, obj[key]);
                }
              }
              return mapit(obj, key, v);
          }
        }
        var wkt_parser_D2R = 0.017453292519943295;
        function rename(obj, params) {
          var outName = params[0];
          var inName = params[1];
          if (!(outName in obj) && inName in obj) {
            obj[outName] = obj[inName];
            if (params.length === 3) {
              obj[outName] = params[2](obj[outName]);
            }
          }
        }
        function d2r(input) {
          return input * wkt_parser_D2R;
        }
        function cleanWKT(wkt) {
          if (wkt.type === "GEOGCS") {
            wkt.projName = "longlat";
          } else if (wkt.type === "LOCAL_CS") {
            wkt.projName = "identity";
            wkt.local = true;
          } else {
            if (typeof wkt.PROJECTION === "object") {
              wkt.projName = Object.keys(wkt.PROJECTION)[0];
            } else {
              wkt.projName = wkt.PROJECTION;
            }
          }
          if (wkt.AXIS) {
            var axisOrder = "";
            for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
              var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
              if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
                axisOrder += "n";
              } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
                axisOrder += "s";
              } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
                axisOrder += "e";
              } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
                axisOrder += "w";
              }
            }
            if (axisOrder.length === 2) {
              axisOrder += "u";
            }
            if (axisOrder.length === 3) {
              wkt.axis = axisOrder;
            }
          }
          if (wkt.UNIT) {
            wkt.units = wkt.UNIT.name.toLowerCase();
            if (wkt.units === "metre") {
              wkt.units = "meter";
            }
            if (wkt.UNIT.convert) {
              if (wkt.type === "GEOGCS") {
                if (wkt.DATUM && wkt.DATUM.SPHEROID) {
                  wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
                }
              } else {
                wkt.to_meter = wkt.UNIT.convert;
              }
            }
          }
          var geogcs = wkt.GEOGCS;
          if (wkt.type === "GEOGCS") {
            geogcs = wkt;
          }
          if (geogcs) {
            if (geogcs.DATUM) {
              wkt.datumCode = geogcs.DATUM.name.toLowerCase();
            } else {
              wkt.datumCode = geogcs.name.toLowerCase();
            }
            if (wkt.datumCode.slice(0, 2) === "d_") {
              wkt.datumCode = wkt.datumCode.slice(2);
            }
            if (wkt.datumCode === "new_zealand_geodetic_datum_1949" || wkt.datumCode === "new_zealand_1949") {
              wkt.datumCode = "nzgd49";
            }
            if (wkt.datumCode === "wgs_1984" || wkt.datumCode === "world_geodetic_system_1984") {
              if (wkt.PROJECTION === "Mercator_Auxiliary_Sphere") {
                wkt.sphere = true;
              }
              wkt.datumCode = "wgs84";
            }
            if (wkt.datumCode.slice(-6) === "_ferro") {
              wkt.datumCode = wkt.datumCode.slice(0, -6);
            }
            if (wkt.datumCode.slice(-8) === "_jakarta") {
              wkt.datumCode = wkt.datumCode.slice(0, -8);
            }
            if (~wkt.datumCode.indexOf("belge")) {
              wkt.datumCode = "rnb72";
            }
            if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
              wkt.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
              if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
                wkt.ellps = "intl";
              }
              wkt.a = geogcs.DATUM.SPHEROID.a;
              wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
            }
            if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
              wkt.datum_params = geogcs.DATUM.TOWGS84;
            }
            if (~wkt.datumCode.indexOf("osgb_1936")) {
              wkt.datumCode = "osgb36";
            }
            if (~wkt.datumCode.indexOf("osni_1952")) {
              wkt.datumCode = "osni52";
            }
            if (~wkt.datumCode.indexOf("tm65") || ~wkt.datumCode.indexOf("geodetic_datum_of_1965")) {
              wkt.datumCode = "ire65";
            }
            if (wkt.datumCode === "ch1903+") {
              wkt.datumCode = "ch1903";
            }
            if (~wkt.datumCode.indexOf("israel")) {
              wkt.datumCode = "isr93";
            }
          }
          if (wkt.b && !isFinite(wkt.b)) {
            wkt.b = wkt.a;
          }
          function toMeter(input) {
            var ratio = wkt.to_meter || 1;
            return input * ratio;
          }
          var renamer = function(a) {
            return rename(wkt, a);
          };
          var list = [
            ["standard_parallel_1", "Standard_Parallel_1"],
            ["standard_parallel_1", "Latitude of 1st standard parallel"],
            ["standard_parallel_2", "Standard_Parallel_2"],
            ["standard_parallel_2", "Latitude of 2nd standard parallel"],
            ["false_easting", "False_Easting"],
            ["false_easting", "False easting"],
            ["false-easting", "Easting at false origin"],
            ["false_northing", "False_Northing"],
            ["false_northing", "False northing"],
            ["false_northing", "Northing at false origin"],
            ["central_meridian", "Central_Meridian"],
            ["central_meridian", "Longitude of natural origin"],
            ["central_meridian", "Longitude of false origin"],
            ["latitude_of_origin", "Latitude_Of_Origin"],
            ["latitude_of_origin", "Central_Parallel"],
            ["latitude_of_origin", "Latitude of natural origin"],
            ["latitude_of_origin", "Latitude of false origin"],
            ["scale_factor", "Scale_Factor"],
            ["k0", "scale_factor"],
            ["latitude_of_center", "Latitude_Of_Center"],
            ["latitude_of_center", "Latitude_of_center"],
            ["lat0", "latitude_of_center", d2r],
            ["longitude_of_center", "Longitude_Of_Center"],
            ["longitude_of_center", "Longitude_of_center"],
            ["longc", "longitude_of_center", d2r],
            ["x0", "false_easting", toMeter],
            ["y0", "false_northing", toMeter],
            ["long0", "central_meridian", d2r],
            ["lat0", "latitude_of_origin", d2r],
            ["lat0", "standard_parallel_1", d2r],
            ["lat1", "standard_parallel_1", d2r],
            ["lat2", "standard_parallel_2", d2r],
            ["azimuth", "Azimuth"],
            ["alpha", "azimuth", d2r],
            ["srsCode", "name"]
          ];
          list.forEach(renamer);
          if (!wkt.long0 && wkt.longc && (wkt.projName === "Albers_Conic_Equal_Area" || wkt.projName === "Lambert_Azimuthal_Equal_Area")) {
            wkt.long0 = wkt.longc;
          }
          if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === "Stereographic_South_Pole" || wkt.projName === "Polar Stereographic (variant B)")) {
            wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
            wkt.lat_ts = wkt.lat1;
          }
        }
        var wkt_parser = function(wkt) {
          var lisp = parser(wkt);
          var type = lisp.shift();
          var name = lisp.shift();
          lisp.unshift(["name", name]);
          lisp.unshift(["type", type]);
          var obj = {};
          sExpr(lisp, obj);
          cleanWKT(obj);
          return obj;
        };
        function defs(name) {
          var that = this;
          if (arguments.length === 2) {
            var def = arguments[1];
            if (typeof def === "string") {
              if (def.charAt(0) === "+") {
                defs[name] = projString(arguments[1]);
              } else {
                defs[name] = wkt_parser(arguments[1]);
              }
            } else {
              defs[name] = def;
            }
          } else if (arguments.length === 1) {
            if (Array.isArray(name)) {
              return name.map(function(v) {
                if (Array.isArray(v)) {
                  defs.apply(that, v);
                } else {
                  defs(v);
                }
              });
            } else if (typeof name === "string") {
              if (name in defs) {
                return defs[name];
              }
            } else if ("EPSG" in name) {
              defs["EPSG:" + name.EPSG] = name;
            } else if ("ESRI" in name) {
              defs["ESRI:" + name.ESRI] = name;
            } else if ("IAU2000" in name) {
              defs["IAU2000:" + name.IAU2000] = name;
            } else {
              console.log(name);
            }
            return;
          }
        }
        global(defs);
        var lib_defs = defs;
        function testObj(code) {
          return typeof code === "string";
        }
        function testDef(code) {
          return code in lib_defs;
        }
        var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
        function testWKT(code) {
          return codeWords.some(function(word) {
            return code.indexOf(word) > -1;
          });
        }
        var codes = ["3857", "900913", "3785", "102113"];
        function checkMercator(item) {
          var auth = match_match(item, "authority");
          if (!auth) {
            return;
          }
          var code = match_match(auth, "epsg");
          return code && codes.indexOf(code) > -1;
        }
        function checkProjStr(item) {
          var ext = match_match(item, "extension");
          if (!ext) {
            return;
          }
          return match_match(ext, "proj4");
        }
        function testProj(code) {
          return code[0] === "+";
        }
        function parse2(code) {
          if (testObj(code)) {
            if (testDef(code)) {
              return lib_defs[code];
            }
            if (testWKT(code)) {
              var out = wkt_parser(code);
              if (checkMercator(out)) {
                return lib_defs["EPSG:3857"];
              }
              var maybeProjStr = checkProjStr(out);
              if (maybeProjStr) {
                return projString(maybeProjStr);
              }
              return out;
            }
            if (testProj(code)) {
              return projString(code);
            }
          } else {
            return code;
          }
        }
        var parseCode = parse2;
        var lib_extend = function(destination, source) {
          destination = destination || {};
          var value, property;
          if (!source) {
            return destination;
          }
          for (property in source) {
            value = source[property];
            if (value !== void 0) {
              destination[property] = value;
            }
          }
          return destination;
        };
        var msfnz = function(eccent, sinphi, cosphi) {
          var con = eccent * sinphi;
          return cosphi / Math.sqrt(1 - con * con);
        };
        var sign = function(x) {
          return x < 0 ? -1 : 1;
        };
        var adjust_lon = function(x) {
          return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
        };
        var tsfnz = function(eccent, phi, sinphi) {
          var con = eccent * sinphi;
          var com = 0.5 * eccent;
          con = Math.pow((1 - con) / (1 + con), com);
          return Math.tan(0.5 * (HALF_PI - phi)) / con;
        };
        var phi2z = function(eccent, ts) {
          var eccnth = 0.5 * eccent;
          var con, dphi;
          var phi = HALF_PI - 2 * Math.atan(ts);
          for (var i = 0; i <= 15; i++) {
            con = eccent * Math.sin(phi);
            dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
            phi += dphi;
            if (Math.abs(dphi) <= 1e-10) {
              return phi;
            }
          }
          return -9999;
        };
        function init() {
          var con = this.b / this.a;
          this.es = 1 - con * con;
          if (!("x0" in this)) {
            this.x0 = 0;
          }
          if (!("y0" in this)) {
            this.y0 = 0;
          }
          this.e = Math.sqrt(this.es);
          if (this.lat_ts) {
            if (this.sphere) {
              this.k0 = Math.cos(this.lat_ts);
            } else {
              this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
            }
          } else {
            if (!this.k0) {
              if (this.k) {
                this.k0 = this.k;
              } else {
                this.k0 = 1;
              }
            }
          }
        }
        function merc_forward(p) {
          var lon = p.x;
          var lat = p.y;
          if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
            return null;
          }
          var x, y;
          if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
            return null;
          } else {
            if (this.sphere) {
              x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
              y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
            } else {
              var sinphi = Math.sin(lat);
              var ts = tsfnz(this.e, lat, sinphi);
              x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
              y = this.y0 - this.a * this.k0 * Math.log(ts);
            }
            p.x = x;
            p.y = y;
            return p;
          }
        }
        function merc_inverse(p) {
          var x = p.x - this.x0;
          var y = p.y - this.y0;
          var lon, lat;
          if (this.sphere) {
            lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
          } else {
            var ts = Math.exp(-y / (this.a * this.k0));
            lat = phi2z(this.e, ts);
            if (lat === -9999) {
              return null;
            }
          }
          lon = adjust_lon(this.long0 + x / (this.a * this.k0));
          p.x = lon;
          p.y = lat;
          return p;
        }
        var merc_names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
        var merc = {
          init,
          forward: merc_forward,
          inverse: merc_inverse,
          names: merc_names
        };
        function longlat_init() {
        }
        function identity(pt) {
          return pt;
        }
        var longlat_names = ["longlat", "identity"];
        var longlat = {
          init: longlat_init,
          forward: identity,
          inverse: identity,
          names: longlat_names
        };
        var projs = [merc, longlat];
        var projections_names = {};
        var projStore = [];
        function lib_projections_add(proj, i) {
          var len = projStore.length;
          if (!proj.names) {
            console.log(i);
            return true;
          }
          projStore[len] = proj;
          proj.names.forEach(function(n) {
            projections_names[n.toLowerCase()] = len;
          });
          return this;
        }
        function lib_projections_get(name) {
          if (!name) {
            return false;
          }
          var n = name.toLowerCase();
          if (typeof projections_names[n] !== "undefined" && projStore[projections_names[n]]) {
            return projStore[projections_names[n]];
          }
        }
        function projections_start() {
          projs.forEach(lib_projections_add);
        }
        var lib_projections = {
          start: projections_start,
          add: lib_projections_add,
          get: lib_projections_get
        };
        var Ellipsoid_exports = {};
        Ellipsoid_exports.MERIT = {
          a: 6378137,
          rf: 298.257,
          ellipseName: "MERIT 1983"
        };
        Ellipsoid_exports.SGS85 = {
          a: 6378136,
          rf: 298.257,
          ellipseName: "Soviet Geodetic System 85"
        };
        Ellipsoid_exports.GRS80 = {
          a: 6378137,
          rf: 298.257222101,
          ellipseName: "GRS 1980(IUGG, 1980)"
        };
        Ellipsoid_exports.IAU76 = {
          a: 6378140,
          rf: 298.257,
          ellipseName: "IAU 1976"
        };
        Ellipsoid_exports.airy = {
          a: 6377563396e-3,
          b: 635625691e-2,
          ellipseName: "Airy 1830"
        };
        Ellipsoid_exports.APL4 = {
          a: 6378137,
          rf: 298.25,
          ellipseName: "Appl. Physics. 1965"
        };
        Ellipsoid_exports.NWL9D = {
          a: 6378145,
          rf: 298.25,
          ellipseName: "Naval Weapons Lab., 1965"
        };
        Ellipsoid_exports.mod_airy = {
          a: 6377340189e-3,
          b: 6356034446e-3,
          ellipseName: "Modified Airy"
        };
        Ellipsoid_exports.andrae = {
          a: 637710443e-2,
          rf: 300,
          ellipseName: "Andrae 1876 (Den., Iclnd.)"
        };
        Ellipsoid_exports.aust_SA = {
          a: 6378160,
          rf: 298.25,
          ellipseName: "Australian Natl & S. Amer. 1969"
        };
        Ellipsoid_exports.GRS67 = {
          a: 6378160,
          rf: 298.247167427,
          ellipseName: "GRS 67(IUGG 1967)"
        };
        Ellipsoid_exports.bessel = {
          a: 6377397155e-3,
          rf: 299.1528128,
          ellipseName: "Bessel 1841"
        };
        Ellipsoid_exports.bess_nam = {
          a: 6377483865e-3,
          rf: 299.1528128,
          ellipseName: "Bessel 1841 (Namibia)"
        };
        Ellipsoid_exports.clrk66 = {
          a: 63782064e-1,
          b: 63565838e-1,
          ellipseName: "Clarke 1866"
        };
        Ellipsoid_exports.clrk80 = {
          a: 6378249145e-3,
          rf: 293.4663,
          ellipseName: "Clarke 1880 mod."
        };
        Ellipsoid_exports.clrk58 = {
          a: 6378293645208759e-9,
          rf: 294.2606763692654,
          ellipseName: "Clarke 1858"
        };
        Ellipsoid_exports.CPM = {
          a: 63757387e-1,
          rf: 334.29,
          ellipseName: "Comm. des Poids et Mesures 1799"
        };
        Ellipsoid_exports.delmbr = {
          a: 6376428,
          rf: 311.5,
          ellipseName: "Delambre 1810 (Belgium)"
        };
        Ellipsoid_exports.engelis = {
          a: 637813605e-2,
          rf: 298.2566,
          ellipseName: "Engelis 1985"
        };
        Ellipsoid_exports.evrst30 = {
          a: 6377276345e-3,
          rf: 300.8017,
          ellipseName: "Everest 1830"
        };
        Ellipsoid_exports.evrst48 = {
          a: 6377304063e-3,
          rf: 300.8017,
          ellipseName: "Everest 1948"
        };
        Ellipsoid_exports.evrst56 = {
          a: 6377301243e-3,
          rf: 300.8017,
          ellipseName: "Everest 1956"
        };
        Ellipsoid_exports.evrst69 = {
          a: 6377295664e-3,
          rf: 300.8017,
          ellipseName: "Everest 1969"
        };
        Ellipsoid_exports.evrstSS = {
          a: 6377298556e-3,
          rf: 300.8017,
          ellipseName: "Everest (Sabah & Sarawak)"
        };
        Ellipsoid_exports.fschr60 = {
          a: 6378166,
          rf: 298.3,
          ellipseName: "Fischer (Mercury Datum) 1960"
        };
        Ellipsoid_exports.fschr60m = {
          a: 6378155,
          rf: 298.3,
          ellipseName: "Fischer 1960"
        };
        Ellipsoid_exports.fschr68 = {
          a: 6378150,
          rf: 298.3,
          ellipseName: "Fischer 1968"
        };
        Ellipsoid_exports.helmert = {
          a: 6378200,
          rf: 298.3,
          ellipseName: "Helmert 1906"
        };
        Ellipsoid_exports.hough = {
          a: 6378270,
          rf: 297,
          ellipseName: "Hough"
        };
        Ellipsoid_exports.intl = {
          a: 6378388,
          rf: 297,
          ellipseName: "International 1909 (Hayford)"
        };
        Ellipsoid_exports.kaula = {
          a: 6378163,
          rf: 298.24,
          ellipseName: "Kaula 1961"
        };
        Ellipsoid_exports.lerch = {
          a: 6378139,
          rf: 298.257,
          ellipseName: "Lerch 1979"
        };
        Ellipsoid_exports.mprts = {
          a: 6397300,
          rf: 191,
          ellipseName: "Maupertius 1738"
        };
        Ellipsoid_exports.new_intl = {
          a: 63781575e-1,
          b: 63567722e-1,
          ellipseName: "New International 1967"
        };
        Ellipsoid_exports.plessis = {
          a: 6376523,
          rf: 6355863,
          ellipseName: "Plessis 1817 (France)"
        };
        Ellipsoid_exports.krass = {
          a: 6378245,
          rf: 298.3,
          ellipseName: "Krassovsky, 1942"
        };
        Ellipsoid_exports.SEasia = {
          a: 6378155,
          b: 63567733205e-4,
          ellipseName: "Southeast Asia"
        };
        Ellipsoid_exports.walbeck = {
          a: 6376896,
          b: 63558348467e-4,
          ellipseName: "Walbeck"
        };
        Ellipsoid_exports.WGS60 = {
          a: 6378165,
          rf: 298.3,
          ellipseName: "WGS 60"
        };
        Ellipsoid_exports.WGS66 = {
          a: 6378145,
          rf: 298.25,
          ellipseName: "WGS 66"
        };
        Ellipsoid_exports.WGS7 = {
          a: 6378135,
          rf: 298.26,
          ellipseName: "WGS 72"
        };
        var WGS84 = Ellipsoid_exports.WGS84 = {
          a: 6378137,
          rf: 298.257223563,
          ellipseName: "WGS 84"
        };
        Ellipsoid_exports.sphere = {
          a: 6370997,
          b: 6370997,
          ellipseName: "Normal Sphere (r=6370997)"
        };
        function eccentricity(a, b, rf, R_A) {
          var a2 = a * a;
          var b2 = b * b;
          var es = (a2 - b2) / a2;
          var e = 0;
          if (R_A) {
            a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
            a2 = a * a;
            es = 0;
          } else {
            e = Math.sqrt(es);
          }
          var ep2 = (a2 - b2) / b2;
          return {
            es,
            e,
            ep2
          };
        }
        function deriveConstants_sphere(a, b, rf, ellps, sphere) {
          if (!a) {
            var ellipse = match_match(Ellipsoid_exports, ellps);
            if (!ellipse) {
              ellipse = WGS84;
            }
            a = ellipse.a;
            b = ellipse.b;
            rf = ellipse.rf;
          }
          if (rf && !b) {
            b = (1 - 1 / rf) * a;
          }
          if (rf === 0 || Math.abs(a - b) < EPSLN) {
            sphere = true;
            b = a;
          }
          return {
            a,
            b,
            rf,
            sphere
          };
        }
        var Datum_exports = {};
        Datum_exports.wgs84 = {
          towgs84: "0,0,0",
          ellipse: "WGS84",
          datumName: "WGS84"
        };
        Datum_exports.ch1903 = {
          towgs84: "674.374,15.056,405.346",
          ellipse: "bessel",
          datumName: "swiss"
        };
        Datum_exports.ggrs87 = {
          towgs84: "-199.87,74.79,246.62",
          ellipse: "GRS80",
          datumName: "Greek_Geodetic_Reference_System_1987"
        };
        Datum_exports.nad83 = {
          towgs84: "0,0,0",
          ellipse: "GRS80",
          datumName: "North_American_Datum_1983"
        };
        Datum_exports.nad27 = {
          nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
          ellipse: "clrk66",
          datumName: "North_American_Datum_1927"
        };
        Datum_exports.potsdam = {
          towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
          ellipse: "bessel",
          datumName: "Potsdam Rauenberg 1950 DHDN"
        };
        Datum_exports.carthage = {
          towgs84: "-263.0,6.0,431.0",
          ellipse: "clark80",
          datumName: "Carthage 1934 Tunisia"
        };
        Datum_exports.hermannskogel = {
          towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
          ellipse: "bessel",
          datumName: "Hermannskogel"
        };
        Datum_exports.osni52 = {
          towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
          ellipse: "airy",
          datumName: "Irish National"
        };
        Datum_exports.ire65 = {
          towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
          ellipse: "mod_airy",
          datumName: "Ireland 1965"
        };
        Datum_exports.rassadiran = {
          towgs84: "-133.63,-157.5,-158.62",
          ellipse: "intl",
          datumName: "Rassadiran"
        };
        Datum_exports.nzgd49 = {
          towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
          ellipse: "intl",
          datumName: "New Zealand Geodetic Datum 1949"
        };
        Datum_exports.osgb36 = {
          towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
          ellipse: "airy",
          datumName: "Airy 1830"
        };
        Datum_exports.s_jtsk = {
          towgs84: "589,76,480",
          ellipse: "bessel",
          datumName: "S-JTSK (Ferro)"
        };
        Datum_exports.beduaram = {
          towgs84: "-106,-87,188",
          ellipse: "clrk80",
          datumName: "Beduaram"
        };
        Datum_exports.gunung_segara = {
          towgs84: "-403,684,41",
          ellipse: "bessel",
          datumName: "Gunung Segara Jakarta"
        };
        Datum_exports.rnb72 = {
          towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
          ellipse: "intl",
          datumName: "Reseau National Belge 1972"
        };
        function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
          var out = {};
          if (datumCode === void 0 || datumCode === "none") {
            out.datum_type = PJD_NODATUM;
          } else {
            out.datum_type = PJD_WGS84;
          }
          if (datum_params) {
            out.datum_params = datum_params.map(parseFloat);
            if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
              out.datum_type = PJD_3PARAM;
            }
            if (out.datum_params.length > 3) {
              if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
                out.datum_type = PJD_7PARAM;
                out.datum_params[3] *= SEC_TO_RAD;
                out.datum_params[4] *= SEC_TO_RAD;
                out.datum_params[5] *= SEC_TO_RAD;
                out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
              }
            }
          }
          if (nadgrids) {
            out.datum_type = PJD_GRIDSHIFT;
            out.grids = nadgrids;
          }
          out.a = a;
          out.b = b;
          out.es = es;
          out.ep2 = ep2;
          return out;
        }
        var lib_datum = datum;
        var loadedNadgrids = {};
        function nadgrid(key, data) {
          var view = new DataView(data);
          var isLittleEndian = detectLittleEndian(view);
          var header = readHeader(view, isLittleEndian);
          if (header.nSubgrids > 1) {
            console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
          }
          var subgrids = readSubgrids(view, header, isLittleEndian);
          var nadgrid2 = { header, subgrids };
          loadedNadgrids[key] = nadgrid2;
          return nadgrid2;
        }
        function getNadgrids(nadgrids) {
          if (nadgrids === void 0) {
            return null;
          }
          var grids = nadgrids.split(",");
          return grids.map(parseNadgridString);
        }
        function parseNadgridString(value) {
          if (value.length === 0) {
            return null;
          }
          var optional = value[0] === "@";
          if (optional) {
            value = value.slice(1);
          }
          if (value === "null") {
            return { name: "null", mandatory: !optional, grid: null, isNull: true };
          }
          return {
            name: value,
            mandatory: !optional,
            grid: loadedNadgrids[value] || null,
            isNull: false
          };
        }
        function secondsToRadians(seconds) {
          return seconds / 3600 * Math.PI / 180;
        }
        function detectLittleEndian(view) {
          var nFields = view.getInt32(8, false);
          if (nFields === 11) {
            return false;
          }
          nFields = view.getInt32(8, true);
          if (nFields !== 11) {
            console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
          }
          return true;
        }
        function readHeader(view, isLittleEndian) {
          return {
            nFields: view.getInt32(8, isLittleEndian),
            nSubgridFields: view.getInt32(24, isLittleEndian),
            nSubgrids: view.getInt32(40, isLittleEndian),
            shiftType: decodeString(view, 56, 56 + 8).trim(),
            fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
            fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
            toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
            toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
          };
        }
        function decodeString(view, start, end) {
          return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
        }
        function readSubgrids(view, header, isLittleEndian) {
          var gridOffset = 176;
          var grids = [];
          for (var i = 0; i < header.nSubgrids; i++) {
            var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
            var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
            var lngColumnCount = Math.round(1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
            var latColumnCount = Math.round(1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
            grids.push({
              ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
              del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
              lim: [lngColumnCount, latColumnCount],
              count: subHeader.gridNodeCount,
              cvs: mapNodes(nodes)
            });
          }
          return grids;
        }
        function mapNodes(nodes) {
          return nodes.map(function(r) {
            return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
          });
        }
        function readGridHeader(view, offset, isLittleEndian) {
          return {
            name: decodeString(view, offset + 8, offset + 16).trim(),
            parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
            lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
            upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
            lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
            upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
            latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
            longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
            gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
          };
        }
        function readGridNodes(view, offset, gridHeader, isLittleEndian) {
          var nodesOffset = offset + 176;
          var gridRecordLength = 16;
          var gridShiftRecords = [];
          for (var i = 0; i < gridHeader.gridNodeCount; i++) {
            var record = {
              latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
              longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
              latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
              longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian)
            };
            gridShiftRecords.push(record);
          }
          return gridShiftRecords;
        }
        function Proj_Projection(srsCode, callback) {
          if (!(this instanceof Proj_Projection)) {
            return new Proj_Projection(srsCode);
          }
          callback = callback || function(error) {
            if (error) {
              throw error;
            }
          };
          var json = parseCode(srsCode);
          if (typeof json !== "object") {
            callback(srsCode);
            return;
          }
          var ourProj = Proj_Projection.projections.get(json.projName);
          if (!ourProj) {
            callback(srsCode);
            return;
          }
          if (json.datumCode && json.datumCode !== "none") {
            var datumDef = match_match(Datum_exports, json.datumCode);
            if (datumDef) {
              json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
              json.ellps = datumDef.ellipse;
              json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
            }
          }
          json.k0 = json.k0 || 1;
          json.axis = json.axis || "enu";
          json.ellps = json.ellps || "wgs84";
          json.lat1 = json.lat1 || json.lat0;
          var sphere_ = deriveConstants_sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
          var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
          var nadgrids = getNadgrids(json.nadgrids);
          var datumObj = json.datum || lib_datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2, nadgrids);
          lib_extend(this, json);
          lib_extend(this, ourProj);
          this.a = sphere_.a;
          this.b = sphere_.b;
          this.rf = sphere_.rf;
          this.sphere = sphere_.sphere;
          this.es = ecc.es;
          this.e = ecc.e;
          this.ep2 = ecc.ep2;
          this.datum = datumObj;
          this.init();
          callback(null, this);
        }
        Proj_Projection.projections = lib_projections;
        Proj_Projection.projections.start();
        var Proj = Proj_Projection;
        function compareDatums(source, dest) {
          if (source.datum_type !== dest.datum_type) {
            return false;
          } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
            return false;
          } else if (source.datum_type === PJD_3PARAM) {
            return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
          } else if (source.datum_type === PJD_7PARAM) {
            return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
          } else {
            return true;
          }
        }
        function geodeticToGeocentric(p, es, a) {
          var Longitude = p.x;
          var Latitude = p.y;
          var Height = p.z ? p.z : 0;
          var Rn;
          var Sin_Lat;
          var Sin2_Lat;
          var Cos_Lat;
          if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
            Latitude = -HALF_PI;
          } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
            Latitude = HALF_PI;
          } else if (Latitude < -HALF_PI) {
            return { x: -Infinity, y: -Infinity, z: p.z };
          } else if (Latitude > HALF_PI) {
            return { x: Infinity, y: Infinity, z: p.z };
          }
          if (Longitude > Math.PI) {
            Longitude -= 2 * Math.PI;
          }
          Sin_Lat = Math.sin(Latitude);
          Cos_Lat = Math.cos(Latitude);
          Sin2_Lat = Sin_Lat * Sin_Lat;
          Rn = a / Math.sqrt(1 - es * Sin2_Lat);
          return {
            x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
            y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
            z: (Rn * (1 - es) + Height) * Sin_Lat
          };
        }
        function geocentricToGeodetic(p, es, a, b) {
          var genau = 1e-12;
          var genau2 = genau * genau;
          var maxiter = 30;
          var P;
          var RR;
          var CT;
          var ST;
          var RX;
          var RK;
          var RN;
          var CPHI0;
          var SPHI0;
          var CPHI;
          var SPHI;
          var SDPHI;
          var iter;
          var X = p.x;
          var Y = p.y;
          var Z = p.z ? p.z : 0;
          var Longitude;
          var Latitude;
          var Height;
          P = Math.sqrt(X * X + Y * Y);
          RR = Math.sqrt(X * X + Y * Y + Z * Z);
          if (P / a < genau) {
            Longitude = 0;
            if (RR / a < genau) {
              Latitude = HALF_PI;
              Height = -b;
              return {
                x: p.x,
                y: p.y,
                z: p.z
              };
            }
          } else {
            Longitude = Math.atan2(Y, X);
          }
          CT = Z / RR;
          ST = P / RR;
          RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
          CPHI0 = ST * (1 - es) * RX;
          SPHI0 = CT * RX;
          iter = 0;
          do {
            iter++;
            RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0);
            Height = P * CPHI0 + Z * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
            RK = es * RN / (RN + Height);
            RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
            CPHI = ST * (1 - RK) * RX;
            SPHI = CT * RX;
            SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
            CPHI0 = CPHI;
            SPHI0 = SPHI;
          } while (SDPHI * SDPHI > genau2 && iter < maxiter);
          Latitude = Math.atan(SPHI / Math.abs(CPHI));
          return {
            x: Longitude,
            y: Latitude,
            z: Height
          };
        }
        function geocentricToWgs84(p, datum_type, datum_params) {
          if (datum_type === PJD_3PARAM) {
            return {
              x: p.x + datum_params[0],
              y: p.y + datum_params[1],
              z: p.z + datum_params[2]
            };
          } else if (datum_type === PJD_7PARAM) {
            var Dx_BF = datum_params[0];
            var Dy_BF = datum_params[1];
            var Dz_BF = datum_params[2];
            var Rx_BF = datum_params[3];
            var Ry_BF = datum_params[4];
            var Rz_BF = datum_params[5];
            var M_BF = datum_params[6];
            return {
              x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
              y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
              z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
            };
          }
        }
        function geocentricFromWgs84(p, datum_type, datum_params) {
          if (datum_type === PJD_3PARAM) {
            return {
              x: p.x - datum_params[0],
              y: p.y - datum_params[1],
              z: p.z - datum_params[2]
            };
          } else if (datum_type === PJD_7PARAM) {
            var Dx_BF = datum_params[0];
            var Dy_BF = datum_params[1];
            var Dz_BF = datum_params[2];
            var Rx_BF = datum_params[3];
            var Ry_BF = datum_params[4];
            var Rz_BF = datum_params[5];
            var M_BF = datum_params[6];
            var x_tmp = (p.x - Dx_BF) / M_BF;
            var y_tmp = (p.y - Dy_BF) / M_BF;
            var z_tmp = (p.z - Dz_BF) / M_BF;
            return {
              x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
              y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
              z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
            };
          }
        }
        function checkParams(type) {
          return type === PJD_3PARAM || type === PJD_7PARAM;
        }
        var datum_transform = function(source, dest, point) {
          if (compareDatums(source, dest)) {
            return point;
          }
          if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
            return point;
          }
          var source_a = source.a;
          var source_es = source.es;
          if (source.datum_type === PJD_GRIDSHIFT) {
            var gridShiftCode = applyGridShift(source, false, point);
            if (gridShiftCode !== 0) {
              return void 0;
            }
            source_a = SRS_WGS84_SEMIMAJOR;
            source_es = SRS_WGS84_ESQUARED;
          }
          var dest_a = dest.a;
          var dest_b = dest.b;
          var dest_es = dest.es;
          if (dest.datum_type === PJD_GRIDSHIFT) {
            dest_a = SRS_WGS84_SEMIMAJOR;
            dest_b = SRS_WGS84_SEMIMINOR;
            dest_es = SRS_WGS84_ESQUARED;
          }
          if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
            return point;
          }
          point = geodeticToGeocentric(point, source_es, source_a);
          if (checkParams(source.datum_type)) {
            point = geocentricToWgs84(point, source.datum_type, source.datum_params);
          }
          if (checkParams(dest.datum_type)) {
            point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
          }
          point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);
          if (dest.datum_type === PJD_GRIDSHIFT) {
            var destGridShiftResult = applyGridShift(dest, true, point);
            if (destGridShiftResult !== 0) {
              return void 0;
            }
          }
          return point;
        };
        function applyGridShift(source, inverse, point) {
          if (source.grids === null || source.grids.length === 0) {
            console.log("Grid shift grids not found");
            return -1;
          }
          var input = { x: -point.x, y: point.y };
          var output = { x: Number.NaN, y: Number.NaN };
          var onlyMandatoryGrids = false;
          var attemptedGrids = [];
          for (var i = 0; i < source.grids.length; i++) {
            var grid = source.grids[i];
            attemptedGrids.push(grid.name);
            if (grid.isNull) {
              output = input;
              break;
            }
            onlyMandatoryGrids = grid.mandatory;
            if (grid.grid === null) {
              if (grid.mandatory) {
                console.log("Unable to find mandatory grid '" + grid.name + "'");
                return -1;
              }
              continue;
            }
            var subgrid = grid.grid.subgrids[0];
            var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
            var minX = subgrid.ll[0] - epsilon;
            var minY = subgrid.ll[1] - epsilon;
            var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
            var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
            if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
              continue;
            }
            output = applySubgridShift(input, inverse, subgrid);
            if (!isNaN(output.x)) {
              break;
            }
          }
          if (isNaN(output.x)) {
            console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
            return -1;
          }
          point.x = -output.x;
          point.y = output.y;
          return 0;
        }
        function applySubgridShift(pin, inverse, ct) {
          var val = { x: Number.NaN, y: Number.NaN };
          if (isNaN(pin.x)) {
            return val;
          }
          var tb = { x: pin.x, y: pin.y };
          tb.x -= ct.ll[0];
          tb.y -= ct.ll[1];
          tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
          var t = nadInterpolate(tb, ct);
          if (inverse) {
            if (isNaN(t.x)) {
              return val;
            }
            t.x = tb.x - t.x;
            t.y = tb.y - t.y;
            var i = 9, tol = 1e-12;
            var dif, del;
            do {
              del = nadInterpolate(t, ct);
              if (isNaN(del.x)) {
                console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
                break;
              }
              dif = { x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y) };
              t.x += dif.x;
              t.y += dif.y;
            } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
            if (i < 0) {
              console.log("Inverse grid shift iterator failed to converge.");
              return val;
            }
            val.x = adjust_lon(t.x + ct.ll[0]);
            val.y = t.y + ct.ll[1];
          } else {
            if (!isNaN(t.x)) {
              val.x = pin.x + t.x;
              val.y = pin.y + t.y;
            }
          }
          return val;
        }
        function nadInterpolate(pin, ct) {
          var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
          var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
          var frct = { x: t.x - 1 * indx.x, y: t.y - 1 * indx.y };
          var val = { x: Number.NaN, y: Number.NaN };
          var inx;
          if (indx.x < 0 || indx.x >= ct.lim[0]) {
            return val;
          }
          if (indx.y < 0 || indx.y >= ct.lim[1]) {
            return val;
          }
          inx = indx.y * ct.lim[0] + indx.x;
          var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
          inx++;
          var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
          inx += ct.lim[0];
          var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
          inx--;
          var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
          var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
          val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
          val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
          return val;
        }
        var adjust_axis = function(crs, denorm, point) {
          var xin = point.x, yin = point.y, zin = point.z || 0;
          var v, t, i;
          var out = {};
          for (i = 0; i < 3; i++) {
            if (denorm && i === 2 && point.z === void 0) {
              continue;
            }
            if (i === 0) {
              v = xin;
              if ("ew".indexOf(crs.axis[i]) !== -1) {
                t = "x";
              } else {
                t = "y";
              }
            } else if (i === 1) {
              v = yin;
              if ("ns".indexOf(crs.axis[i]) !== -1) {
                t = "y";
              } else {
                t = "x";
              }
            } else {
              v = zin;
              t = "z";
            }
            switch (crs.axis[i]) {
              case "e":
                out[t] = v;
                break;
              case "w":
                out[t] = -v;
                break;
              case "n":
                out[t] = v;
                break;
              case "s":
                out[t] = -v;
                break;
              case "u":
                if (point[t] !== void 0) {
                  out.z = v;
                }
                break;
              case "d":
                if (point[t] !== void 0) {
                  out.z = -v;
                }
                break;
              default:
                return null;
            }
          }
          return out;
        };
        var toPoint = function(array) {
          var out = {
            x: array[0],
            y: array[1]
          };
          if (array.length > 2) {
            out.z = array[2];
          }
          if (array.length > 3) {
            out.m = array[3];
          }
          return out;
        };
        var checkSanity = function(point) {
          checkCoord(point.x);
          checkCoord(point.y);
        };
        function checkCoord(num) {
          if (typeof Number.isFinite === "function") {
            if (Number.isFinite(num)) {
              return;
            }
            throw new TypeError("coordinates must be finite numbers");
          }
          if (typeof num !== "number" || num !== num || !isFinite(num)) {
            throw new TypeError("coordinates must be finite numbers");
          }
        }
        function checkNotWGS(source, dest) {
          return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== "WGS84";
        }
        function transform_transform(source, dest, point, enforceAxis) {
          var wgs84;
          if (Array.isArray(point)) {
            point = toPoint(point);
          }
          checkSanity(point);
          if (source.datum && dest.datum && checkNotWGS(source, dest)) {
            wgs84 = new Proj("WGS84");
            point = transform_transform(source, wgs84, point, enforceAxis);
            source = wgs84;
          }
          if (enforceAxis && source.axis !== "enu") {
            point = adjust_axis(source, false, point);
          }
          if (source.projName === "longlat") {
            point = {
              x: point.x * D2R,
              y: point.y * D2R,
              z: point.z || 0
            };
          } else {
            if (source.to_meter) {
              point = {
                x: point.x * source.to_meter,
                y: point.y * source.to_meter,
                z: point.z || 0
              };
            }
            point = source.inverse(point);
            if (!point) {
              return;
            }
          }
          if (source.from_greenwich) {
            point.x += source.from_greenwich;
          }
          point = datum_transform(source.datum, dest.datum, point);
          if (!point) {
            return;
          }
          if (dest.from_greenwich) {
            point = {
              x: point.x - dest.from_greenwich,
              y: point.y,
              z: point.z || 0
            };
          }
          if (dest.projName === "longlat") {
            point = {
              x: point.x * R2D,
              y: point.y * R2D,
              z: point.z || 0
            };
          } else {
            point = dest.forward(point);
            if (dest.to_meter) {
              point = {
                x: point.x / dest.to_meter,
                y: point.y / dest.to_meter,
                z: point.z || 0
              };
            }
          }
          if (enforceAxis && dest.axis !== "enu") {
            return adjust_axis(dest, true, point);
          }
          return point;
        }
        var core_wgs84 = Proj("WGS84");
        function transformer(from, to, coords, enforceAxis) {
          var transformedArray, out, keys;
          if (Array.isArray(coords)) {
            transformedArray = transform_transform(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
            if (coords.length > 2) {
              if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
                if (typeof transformedArray.z === "number") {
                  return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
                } else {
                  return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
                }
              } else {
                return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
              }
            } else {
              return [transformedArray.x, transformedArray.y];
            }
          } else {
            out = transform_transform(from, to, coords, enforceAxis);
            keys = Object.keys(coords);
            if (keys.length === 2) {
              return out;
            }
            keys.forEach(function(key) {
              if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
                if (key === "x" || key === "y" || key === "z") {
                  return;
                }
              } else {
                if (key === "x" || key === "y") {
                  return;
                }
              }
              out[key] = coords[key];
            });
            return out;
          }
        }
        function checkProj(item) {
          if (item instanceof Proj) {
            return item;
          }
          if (item.oProj) {
            return item.oProj;
          }
          return Proj(item);
        }
        function core_proj4(fromProj, toProj, coord) {
          fromProj = checkProj(fromProj);
          var single = false;
          var obj;
          if (typeof toProj === "undefined") {
            toProj = fromProj;
            fromProj = core_wgs84;
            single = true;
          } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
            coord = toProj;
            toProj = fromProj;
            fromProj = core_wgs84;
            single = true;
          }
          toProj = checkProj(toProj);
          if (coord) {
            return transformer(fromProj, toProj, coord);
          } else {
            obj = {
              forward: function(coords, enforceAxis) {
                return transformer(fromProj, toProj, coords, enforceAxis);
              },
              inverse: function(coords, enforceAxis) {
                return transformer(toProj, fromProj, coords, enforceAxis);
              }
            };
            if (single) {
              obj.oProj = toProj;
            }
            return obj;
          }
        }
        var core = core_proj4;
        var NUM_100K_SETS = 6;
        var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
        var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
        var mgrs_A = 65;
        var I = 73;
        var O = 79;
        var mgrs_V = 86;
        var mgrs_Z = 90;
        var mgrs = {
          forward: mgrs_forward,
          inverse: mgrs_inverse,
          toPoint: mgrs_toPoint
        };
        function mgrs_forward(ll, accuracy) {
          accuracy = accuracy || 5;
          return encode(LLtoUTM({
            lat: ll[1],
            lon: ll[0]
          }), accuracy);
        }
        ;
        function mgrs_inverse(mgrs2) {
          var bbox = UTMtoLL(decode(mgrs2.toUpperCase()));
          if (bbox.lat && bbox.lon) {
            return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
          }
          return [bbox.left, bbox.bottom, bbox.right, bbox.top];
        }
        ;
        function mgrs_toPoint(mgrs2) {
          var bbox = UTMtoLL(decode(mgrs2.toUpperCase()));
          if (bbox.lat && bbox.lon) {
            return [bbox.lon, bbox.lat];
          }
          return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
        }
        ;
        function degToRad(deg) {
          return deg * (Math.PI / 180);
        }
        function radToDeg(rad) {
          return 180 * (rad / Math.PI);
        }
        function LLtoUTM(ll) {
          var Lat = ll.lat;
          var Long = ll.lon;
          var a = 6378137;
          var eccSquared = 669438e-8;
          var k0 = 0.9996;
          var LongOrigin;
          var eccPrimeSquared;
          var N, T, C, A, M;
          var LatRad = degToRad(Lat);
          var LongRad = degToRad(Long);
          var LongOriginRad;
          var ZoneNumber;
          ZoneNumber = Math.floor((Long + 180) / 6) + 1;
          if (Long === 180) {
            ZoneNumber = 60;
          }
          if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
            ZoneNumber = 32;
          }
          if (Lat >= 72 && Lat < 84) {
            if (Long >= 0 && Long < 9) {
              ZoneNumber = 31;
            } else if (Long >= 9 && Long < 21) {
              ZoneNumber = 33;
            } else if (Long >= 21 && Long < 33) {
              ZoneNumber = 35;
            } else if (Long >= 33 && Long < 42) {
              ZoneNumber = 37;
            }
          }
          LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
          LongOriginRad = degToRad(LongOrigin);
          eccPrimeSquared = eccSquared / (1 - eccSquared);
          N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
          T = Math.tan(LatRad) * Math.tan(LatRad);
          C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
          A = Math.cos(LatRad) * (LongRad - LongOriginRad);
          M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
          var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120) + 5e5;
          var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720));
          if (Lat < 0) {
            UTMNorthing += 1e7;
          }
          return {
            northing: Math.round(UTMNorthing),
            easting: Math.round(UTMEasting),
            zoneNumber: ZoneNumber,
            zoneLetter: getLetterDesignator(Lat)
          };
        }
        function UTMtoLL(utm2) {
          var UTMNorthing = utm2.northing;
          var UTMEasting = utm2.easting;
          var zoneLetter = utm2.zoneLetter;
          var zoneNumber = utm2.zoneNumber;
          if (zoneNumber < 0 || zoneNumber > 60) {
            return null;
          }
          var k0 = 0.9996;
          var a = 6378137;
          var eccSquared = 669438e-8;
          var eccPrimeSquared;
          var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
          var N1, T1, C12, R1, D, M;
          var LongOrigin;
          var mu, phi1Rad;
          var x = UTMEasting - 5e5;
          var y = UTMNorthing;
          if (zoneLetter < "N") {
            y -= 1e7;
          }
          LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
          eccPrimeSquared = eccSquared / (1 - eccSquared);
          M = y / k0;
          mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
          phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
          N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
          T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
          C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
          R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
          D = x / (N1 * k0);
          var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D * D * D * D * D * D / 720);
          lat = radToDeg(lat);
          var lon = (D - (1 + 2 * T1 + C12) * D * D * D / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
          lon = LongOrigin + radToDeg(lon);
          var result;
          if (utm2.accuracy) {
            var topRight = UTMtoLL({
              northing: utm2.northing + utm2.accuracy,
              easting: utm2.easting + utm2.accuracy,
              zoneLetter: utm2.zoneLetter,
              zoneNumber: utm2.zoneNumber
            });
            result = {
              top: topRight.lat,
              right: topRight.lon,
              bottom: lat,
              left: lon
            };
          } else {
            result = {
              lat,
              lon
            };
          }
          return result;
        }
        function getLetterDesignator(lat) {
          var LetterDesignator = "Z";
          if (84 >= lat && lat >= 72) {
            LetterDesignator = "X";
          } else if (72 > lat && lat >= 64) {
            LetterDesignator = "W";
          } else if (64 > lat && lat >= 56) {
            LetterDesignator = "V";
          } else if (56 > lat && lat >= 48) {
            LetterDesignator = "U";
          } else if (48 > lat && lat >= 40) {
            LetterDesignator = "T";
          } else if (40 > lat && lat >= 32) {
            LetterDesignator = "S";
          } else if (32 > lat && lat >= 24) {
            LetterDesignator = "R";
          } else if (24 > lat && lat >= 16) {
            LetterDesignator = "Q";
          } else if (16 > lat && lat >= 8) {
            LetterDesignator = "P";
          } else if (8 > lat && lat >= 0) {
            LetterDesignator = "N";
          } else if (0 > lat && lat >= -8) {
            LetterDesignator = "M";
          } else if (-8 > lat && lat >= -16) {
            LetterDesignator = "L";
          } else if (-16 > lat && lat >= -24) {
            LetterDesignator = "K";
          } else if (-24 > lat && lat >= -32) {
            LetterDesignator = "J";
          } else if (-32 > lat && lat >= -40) {
            LetterDesignator = "H";
          } else if (-40 > lat && lat >= -48) {
            LetterDesignator = "G";
          } else if (-48 > lat && lat >= -56) {
            LetterDesignator = "F";
          } else if (-56 > lat && lat >= -64) {
            LetterDesignator = "E";
          } else if (-64 > lat && lat >= -72) {
            LetterDesignator = "D";
          } else if (-72 > lat && lat >= -80) {
            LetterDesignator = "C";
          }
          return LetterDesignator;
        }
        function encode(utm2, accuracy) {
          var seasting = "00000" + utm2.easting, snorthing = "00000" + utm2.northing;
          return utm2.zoneNumber + utm2.zoneLetter + get100kID(utm2.easting, utm2.northing, utm2.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
        }
        function get100kID(easting, northing, zoneNumber) {
          var setParm = get100kSetForZone(zoneNumber);
          var setColumn = Math.floor(easting / 1e5);
          var setRow = Math.floor(northing / 1e5) % 20;
          return getLetter100kID(setColumn, setRow, setParm);
        }
        function get100kSetForZone(i) {
          var setParm = i % NUM_100K_SETS;
          if (setParm === 0) {
            setParm = NUM_100K_SETS;
          }
          return setParm;
        }
        function getLetter100kID(column, row, parm) {
          var index = parm - 1;
          var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
          var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
          var colInt = colOrigin + column - 1;
          var rowInt = rowOrigin + row;
          var rollover = false;
          if (colInt > mgrs_Z) {
            colInt = colInt - mgrs_Z + mgrs_A - 1;
            rollover = true;
          }
          if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
            colInt++;
          }
          if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
            colInt++;
            if (colInt === I) {
              colInt++;
            }
          }
          if (colInt > mgrs_Z) {
            colInt = colInt - mgrs_Z + mgrs_A - 1;
          }
          if (rowInt > mgrs_V) {
            rowInt = rowInt - mgrs_V + mgrs_A - 1;
            rollover = true;
          } else {
            rollover = false;
          }
          if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
            rowInt++;
          }
          if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
            rowInt++;
            if (rowInt === I) {
              rowInt++;
            }
          }
          if (rowInt > mgrs_V) {
            rowInt = rowInt - mgrs_V + mgrs_A - 1;
          }
          var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
          return twoLetter;
        }
        function decode(mgrsString) {
          if (mgrsString && mgrsString.length === 0) {
            throw "MGRSPoint coverting from nothing";
          }
          var length = mgrsString.length;
          var hunK = null;
          var sb = "";
          var testChar;
          var i = 0;
          while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
            if (i >= 2) {
              throw "MGRSPoint bad conversion from: " + mgrsString;
            }
            sb += testChar;
            i++;
          }
          var zoneNumber = parseInt(sb, 10);
          if (i === 0 || i + 3 > length) {
            throw "MGRSPoint bad conversion from: " + mgrsString;
          }
          var zoneLetter = mgrsString.charAt(i++);
          if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
            throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
          }
          hunK = mgrsString.substring(i, i += 2);
          var set = get100kSetForZone(zoneNumber);
          var east100k = getEastingFromChar(hunK.charAt(0), set);
          var north100k = getNorthingFromChar(hunK.charAt(1), set);
          while (north100k < getMinNorthing(zoneLetter)) {
            north100k += 2e6;
          }
          var remainder = length - i;
          if (remainder % 2 !== 0) {
            throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
          }
          var sep = remainder / 2;
          var sepEasting = 0;
          var sepNorthing = 0;
          var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
          if (sep > 0) {
            accuracyBonus = 1e5 / Math.pow(10, sep);
            sepEastingString = mgrsString.substring(i, i + sep);
            sepEasting = parseFloat(sepEastingString) * accuracyBonus;
            sepNorthingString = mgrsString.substring(i + sep);
            sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
          }
          easting = sepEasting + east100k;
          northing = sepNorthing + north100k;
          return {
            easting,
            northing,
            zoneLetter,
            zoneNumber,
            accuracy: accuracyBonus
          };
        }
        function getEastingFromChar(e, set) {
          var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
          var eastingValue = 1e5;
          var rewindMarker = false;
          while (curCol !== e.charCodeAt(0)) {
            curCol++;
            if (curCol === I) {
              curCol++;
            }
            if (curCol === O) {
              curCol++;
            }
            if (curCol > mgrs_Z) {
              if (rewindMarker) {
                throw "Bad character: " + e;
              }
              curCol = mgrs_A;
              rewindMarker = true;
            }
            eastingValue += 1e5;
          }
          return eastingValue;
        }
        function getNorthingFromChar(n, set) {
          if (n > "V") {
            throw "MGRSPoint given invalid Northing " + n;
          }
          var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
          var northingValue = 0;
          var rewindMarker = false;
          while (curRow !== n.charCodeAt(0)) {
            curRow++;
            if (curRow === I) {
              curRow++;
            }
            if (curRow === O) {
              curRow++;
            }
            if (curRow > mgrs_V) {
              if (rewindMarker) {
                throw "Bad character: " + n;
              }
              curRow = mgrs_A;
              rewindMarker = true;
            }
            northingValue += 1e5;
          }
          return northingValue;
        }
        function getMinNorthing(zoneLetter) {
          var northing;
          switch (zoneLetter) {
            case "C":
              northing = 11e5;
              break;
            case "D":
              northing = 2e6;
              break;
            case "E":
              northing = 28e5;
              break;
            case "F":
              northing = 37e5;
              break;
            case "G":
              northing = 46e5;
              break;
            case "H":
              northing = 55e5;
              break;
            case "J":
              northing = 64e5;
              break;
            case "K":
              northing = 73e5;
              break;
            case "L":
              northing = 82e5;
              break;
            case "M":
              northing = 91e5;
              break;
            case "N":
              northing = 0;
              break;
            case "P":
              northing = 8e5;
              break;
            case "Q":
              northing = 17e5;
              break;
            case "R":
              northing = 26e5;
              break;
            case "S":
              northing = 35e5;
              break;
            case "T":
              northing = 44e5;
              break;
            case "U":
              northing = 53e5;
              break;
            case "V":
              northing = 62e5;
              break;
            case "W":
              northing = 7e6;
              break;
            case "X":
              northing = 79e5;
              break;
            default:
              northing = -1;
          }
          if (northing >= 0) {
            return northing;
          } else {
            throw "Invalid zone letter: " + zoneLetter;
          }
        }
        function lib_Point_Point(x, y, z) {
          if (!(this instanceof lib_Point_Point)) {
            return new lib_Point_Point(x, y, z);
          }
          if (Array.isArray(x)) {
            this.x = x[0];
            this.y = x[1];
            this.z = x[2] || 0;
          } else if (typeof x === "object") {
            this.x = x.x;
            this.y = x.y;
            this.z = x.z || 0;
          } else if (typeof x === "string" && typeof y === "undefined") {
            var coords = x.split(",");
            this.x = parseFloat(coords[0], 10);
            this.y = parseFloat(coords[1], 10);
            this.z = parseFloat(coords[2], 10) || 0;
          } else {
            this.x = x;
            this.y = y;
            this.z = z || 0;
          }
          console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
        }
        lib_Point_Point.fromMGRS = function(mgrsStr) {
          return new lib_Point_Point(mgrs_toPoint(mgrsStr));
        };
        lib_Point_Point.prototype.toMGRS = function(accuracy) {
          return mgrs_forward([this.x, this.y], accuracy);
        };
        var lib_Point = lib_Point_Point;
        var C00 = 1;
        var C02 = 0.25;
        var C04 = 0.046875;
        var C06 = 0.01953125;
        var C08 = 0.01068115234375;
        var C22 = 0.75;
        var C44 = 0.46875;
        var C46 = 0.013020833333333334;
        var C48 = 0.007120768229166667;
        var C66 = 0.3645833333333333;
        var C68 = 0.005696614583333333;
        var C88 = 0.3076171875;
        var pj_enfn = function(es) {
          var en = [];
          en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
          en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
          var t = es * es;
          en[2] = t * (C44 - es * (C46 + es * C48));
          t *= es;
          en[3] = t * (C66 - es * C68);
          en[4] = t * es * C88;
          return en;
        };
        var pj_mlfn = function(phi, sphi, cphi, en) {
          cphi *= sphi;
          sphi *= sphi;
          return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
        };
        var MAX_ITER = 20;
        var pj_inv_mlfn = function(arg, es, en) {
          var k = 1 / (1 - es);
          var phi = arg;
          for (var i = MAX_ITER; i; --i) {
            var s = Math.sin(phi);
            var t = 1 - es * s * s;
            t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
            phi -= t;
            if (Math.abs(t) < EPSLN) {
              return phi;
            }
          }
          return phi;
        };
        function tmerc_init() {
          this.x0 = this.x0 !== void 0 ? this.x0 : 0;
          this.y0 = this.y0 !== void 0 ? this.y0 : 0;
          this.long0 = this.long0 !== void 0 ? this.long0 : 0;
          this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
          if (this.es) {
            this.en = pj_enfn(this.es);
            this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
          }
        }
        function tmerc_forward(p) {
          var lon = p.x;
          var lat = p.y;
          var delta_lon = adjust_lon(lon - this.long0);
          var con;
          var x, y;
          var sin_phi = Math.sin(lat);
          var cos_phi = Math.cos(lat);
          if (!this.es) {
            var b = cos_phi * Math.sin(delta_lon);
            if (Math.abs(Math.abs(b) - 1) < EPSLN) {
              return 93;
            } else {
              x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
              y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
              b = Math.abs(y);
              if (b >= 1) {
                if (b - 1 > EPSLN) {
                  return 93;
                } else {
                  y = 0;
                }
              } else {
                y = Math.acos(y);
              }
              if (lat < 0) {
                y = -y;
              }
              y = this.a * this.k0 * (y - this.lat0) + this.y0;
            }
          } else {
            var al = cos_phi * delta_lon;
            var als = Math.pow(al, 2);
            var c = this.ep2 * Math.pow(cos_phi, 2);
            var cs = Math.pow(c, 2);
            var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
            var t = Math.pow(tq, 2);
            var ts = Math.pow(t, 2);
            con = 1 - this.es * Math.pow(sin_phi, 2);
            al = al / Math.sqrt(con);
            var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
            x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
            y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function tmerc_inverse(p) {
          var con, phi;
          var lat, lon;
          var x = (p.x - this.x0) * (1 / this.a);
          var y = (p.y - this.y0) * (1 / this.a);
          if (!this.es) {
            var f = Math.exp(x / this.k0);
            var g = 0.5 * (f - 1 / f);
            var temp = this.lat0 + y / this.k0;
            var h = Math.cos(temp);
            con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
            lat = Math.asin(con);
            if (y < 0) {
              lat = -lat;
            }
            if (g === 0 && h === 0) {
              lon = 0;
            } else {
              lon = adjust_lon(Math.atan2(g, h) + this.long0);
            }
          } else {
            con = this.ml0 + y / this.k0;
            phi = pj_inv_mlfn(con, this.es, this.en);
            if (Math.abs(phi) < HALF_PI) {
              var sin_phi = Math.sin(phi);
              var cos_phi = Math.cos(phi);
              var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
              var c = this.ep2 * Math.pow(cos_phi, 2);
              var cs = Math.pow(c, 2);
              var t = Math.pow(tan_phi, 2);
              var ts = Math.pow(t, 2);
              con = 1 - this.es * Math.pow(sin_phi, 2);
              var d = x * Math.sqrt(con) / this.k0;
              var ds = Math.pow(d, 2);
              con = con * tan_phi;
              lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
              lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
            } else {
              lat = HALF_PI * sign(y);
              lon = 0;
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var tmerc_names = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
        var tmerc = {
          init: tmerc_init,
          forward: tmerc_forward,
          inverse: tmerc_inverse,
          names: tmerc_names
        };
        var sinh = function(x) {
          var r = Math.exp(x);
          r = (r - 1 / r) / 2;
          return r;
        };
        var hypot = function(x, y) {
          x = Math.abs(x);
          y = Math.abs(y);
          var a = Math.max(x, y);
          var b = Math.min(x, y) / (a ? a : 1);
          return a * Math.sqrt(1 + Math.pow(b, 2));
        };
        var log1py = function(x) {
          var y = 1 + x;
          var z = y - 1;
          return z === 0 ? x : x * Math.log(y) / z;
        };
        var asinhy = function(x) {
          var y = Math.abs(x);
          y = log1py(y * (1 + y / (hypot(1, y) + 1)));
          return x < 0 ? -y : y;
        };
        var gatg = function(pp, B) {
          var cos_2B = 2 * Math.cos(2 * B);
          var i = pp.length - 1;
          var h1 = pp[i];
          var h2 = 0;
          var h;
          while (--i >= 0) {
            h = -h2 + cos_2B * h1 + pp[i];
            h2 = h1;
            h1 = h;
          }
          return B + h * Math.sin(2 * B);
        };
        var clens = function(pp, arg_r) {
          var r = 2 * Math.cos(arg_r);
          var i = pp.length - 1;
          var hr1 = pp[i];
          var hr2 = 0;
          var hr;
          while (--i >= 0) {
            hr = -hr2 + r * hr1 + pp[i];
            hr2 = hr1;
            hr1 = hr;
          }
          return Math.sin(arg_r) * hr;
        };
        var common_cosh = function(x) {
          var r = Math.exp(x);
          r = (r + 1 / r) / 2;
          return r;
        };
        var clens_cmplx = function(pp, arg_r, arg_i) {
          var sin_arg_r = Math.sin(arg_r);
          var cos_arg_r = Math.cos(arg_r);
          var sinh_arg_i = sinh(arg_i);
          var cosh_arg_i = common_cosh(arg_i);
          var r = 2 * cos_arg_r * cosh_arg_i;
          var i = -2 * sin_arg_r * sinh_arg_i;
          var j = pp.length - 1;
          var hr = pp[j];
          var hi1 = 0;
          var hr1 = 0;
          var hi = 0;
          var hr2;
          var hi2;
          while (--j >= 0) {
            hr2 = hr1;
            hi2 = hi1;
            hr1 = hr;
            hi1 = hi;
            hr = -hr2 + r * hr1 - i * hi1 + pp[j];
            hi = -hi2 + i * hr1 + r * hi1;
          }
          r = sin_arg_r * cosh_arg_i;
          i = cos_arg_r * sinh_arg_i;
          return [r * hr - i * hi, r * hi + i * hr];
        };
        function etmerc_init() {
          if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
            throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
          }
          if (this.approx) {
            tmerc.init.apply(this);
            this.forward = tmerc.forward;
            this.inverse = tmerc.inverse;
          }
          this.x0 = this.x0 !== void 0 ? this.x0 : 0;
          this.y0 = this.y0 !== void 0 ? this.y0 : 0;
          this.long0 = this.long0 !== void 0 ? this.long0 : 0;
          this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
          this.cgb = [];
          this.cbg = [];
          this.utg = [];
          this.gtu = [];
          var f = this.es / (1 + Math.sqrt(1 - this.es));
          var n = f / (2 - f);
          var np = n;
          this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
          this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
          np = np * n;
          this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
          this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
          np = np * n;
          this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
          this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
          np = np * n;
          this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
          this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
          np = np * n;
          this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
          this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
          np = np * n;
          this.cgb[5] = np * (601676 / 22275);
          this.cbg[5] = np * (444337 / 155925);
          np = Math.pow(n, 2);
          this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
          this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
          this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
          this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
          this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
          np = np * n;
          this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
          this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
          np = np * n;
          this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
          this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
          np = np * n;
          this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
          this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
          np = np * n;
          this.utg[5] = np * (-20648693 / 638668800);
          this.gtu[5] = np * (212378941 / 319334400);
          var Z = gatg(this.cbg, this.lat0);
          this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
        }
        function etmerc_forward(p) {
          var Ce = adjust_lon(p.x - this.long0);
          var Cn = p.y;
          Cn = gatg(this.cbg, Cn);
          var sin_Cn = Math.sin(Cn);
          var cos_Cn = Math.cos(Cn);
          var sin_Ce = Math.sin(Ce);
          var cos_Ce = Math.cos(Ce);
          Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
          Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
          Ce = asinhy(Math.tan(Ce));
          var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
          Cn = Cn + tmp[0];
          Ce = Ce + tmp[1];
          var x;
          var y;
          if (Math.abs(Ce) <= 2.623395162778) {
            x = this.a * (this.Qn * Ce) + this.x0;
            y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
          } else {
            x = Infinity;
            y = Infinity;
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function etmerc_inverse(p) {
          var Ce = (p.x - this.x0) * (1 / this.a);
          var Cn = (p.y - this.y0) * (1 / this.a);
          Cn = (Cn - this.Zb) / this.Qn;
          Ce = Ce / this.Qn;
          var lon;
          var lat;
          if (Math.abs(Ce) <= 2.623395162778) {
            var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
            Cn = Cn + tmp[0];
            Ce = Ce + tmp[1];
            Ce = Math.atan(sinh(Ce));
            var sin_Cn = Math.sin(Cn);
            var cos_Cn = Math.cos(Cn);
            var sin_Ce = Math.sin(Ce);
            var cos_Ce = Math.cos(Ce);
            Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
            Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
            lon = adjust_lon(Ce + this.long0);
            lat = gatg(this.cgb, Cn);
          } else {
            lon = Infinity;
            lat = Infinity;
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var etmerc_names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
        var etmerc = {
          init: etmerc_init,
          forward: etmerc_forward,
          inverse: etmerc_inverse,
          names: etmerc_names
        };
        var adjust_zone = function(zone, lon) {
          if (zone === void 0) {
            zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;
            if (zone < 0) {
              return 0;
            } else if (zone > 60) {
              return 60;
            }
          }
          return zone;
        };
        var dependsOn = "etmerc";
        function utm_init() {
          var zone = adjust_zone(this.zone, this.long0);
          if (zone === void 0) {
            throw new Error("unknown utm zone");
          }
          this.lat0 = 0;
          this.long0 = (6 * Math.abs(zone) - 183) * D2R;
          this.x0 = 5e5;
          this.y0 = this.utmSouth ? 1e7 : 0;
          this.k0 = 0.9996;
          etmerc.init.apply(this);
          this.forward = etmerc.forward;
          this.inverse = etmerc.inverse;
        }
        var utm_names = ["Universal Transverse Mercator System", "utm"];
        var utm = {
          init: utm_init,
          names: utm_names,
          dependsOn
        };
        var srat = function(esinp, exp) {
          return Math.pow((1 - esinp) / (1 + esinp), exp);
        };
        var gauss_MAX_ITER = 20;
        function gauss_init() {
          var sphi = Math.sin(this.lat0);
          var cphi = Math.cos(this.lat0);
          cphi *= cphi;
          this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
          this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
          this.phic0 = Math.asin(sphi / this.C);
          this.ratexp = 0.5 * this.C * this.e;
          this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
        }
        function gauss_forward(p) {
          var lon = p.x;
          var lat = p.y;
          p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
          p.x = this.C * lon;
          return p;
        }
        function gauss_inverse(p) {
          var DEL_TOL = 1e-14;
          var lon = p.x / this.C;
          var lat = p.y;
          var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
          for (var i = gauss_MAX_ITER; i > 0; --i) {
            lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
            if (Math.abs(lat - p.y) < DEL_TOL) {
              break;
            }
            p.y = lat;
          }
          if (!i) {
            return null;
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var gauss_names = ["gauss"];
        var gauss = {
          init: gauss_init,
          forward: gauss_forward,
          inverse: gauss_inverse,
          names: gauss_names
        };
        function sterea_init() {
          gauss.init.apply(this);
          if (!this.rc) {
            return;
          }
          this.sinc0 = Math.sin(this.phic0);
          this.cosc0 = Math.cos(this.phic0);
          this.R2 = 2 * this.rc;
          if (!this.title) {
            this.title = "Oblique Stereographic Alternative";
          }
        }
        function sterea_forward(p) {
          var sinc, cosc, cosl, k;
          p.x = adjust_lon(p.x - this.long0);
          gauss.forward.apply(this, [p]);
          sinc = Math.sin(p.y);
          cosc = Math.cos(p.y);
          cosl = Math.cos(p.x);
          k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
          p.x = k * cosc * Math.sin(p.x);
          p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
          p.x = this.a * p.x + this.x0;
          p.y = this.a * p.y + this.y0;
          return p;
        }
        function sterea_inverse(p) {
          var sinc, cosc, lon, lat, rho;
          p.x = (p.x - this.x0) / this.a;
          p.y = (p.y - this.y0) / this.a;
          p.x /= this.k0;
          p.y /= this.k0;
          if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
            var c = 2 * Math.atan2(rho, this.R2);
            sinc = Math.sin(c);
            cosc = Math.cos(c);
            lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
            lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
          } else {
            lat = this.phic0;
            lon = 0;
          }
          p.x = lon;
          p.y = lat;
          gauss.inverse.apply(this, [p]);
          p.x = adjust_lon(p.x + this.long0);
          return p;
        }
        var sterea_names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
        var sterea = {
          init: sterea_init,
          forward: sterea_forward,
          inverse: sterea_inverse,
          names: sterea_names
        };
        function ssfn_(phit, sinphi, eccen) {
          sinphi *= eccen;
          return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
        }
        function stere_init() {
          this.coslat0 = Math.cos(this.lat0);
          this.sinlat0 = Math.sin(this.lat0);
          if (this.sphere) {
            if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
              this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
            }
          } else {
            if (Math.abs(this.coslat0) <= EPSLN) {
              if (this.lat0 > 0) {
                this.con = 1;
              } else {
                this.con = -1;
              }
            }
            this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
            if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
              this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
            }
            this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
            this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
            this.cosX0 = Math.cos(this.X0);
            this.sinX0 = Math.sin(this.X0);
          }
        }
        function stere_forward(p) {
          var lon = p.x;
          var lat = p.y;
          var sinlat = Math.sin(lat);
          var coslat = Math.cos(lat);
          var A, X, sinX, cosX, ts, rh;
          var dlon = adjust_lon(lon - this.long0);
          if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
            p.x = NaN;
            p.y = NaN;
            return p;
          }
          if (this.sphere) {
            A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
            p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
            p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
            return p;
          } else {
            X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
            cosX = Math.cos(X);
            sinX = Math.sin(X);
            if (Math.abs(this.coslat0) <= EPSLN) {
              ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
              rh = 2 * this.a * this.k0 * ts / this.cons;
              p.x = this.x0 + rh * Math.sin(lon - this.long0);
              p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
              return p;
            } else if (Math.abs(this.sinlat0) < EPSLN) {
              A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
              p.y = A * sinX;
            } else {
              A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
              p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
            }
            p.x = A * cosX * Math.sin(dlon) + this.x0;
          }
          return p;
        }
        function stere_inverse(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var lon, lat, ts, ce, Chi;
          var rh = Math.sqrt(p.x * p.x + p.y * p.y);
          if (this.sphere) {
            var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
            lon = this.long0;
            lat = this.lat0;
            if (rh <= EPSLN) {
              p.x = lon;
              p.y = lat;
              return p;
            }
            lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
            if (Math.abs(this.coslat0) < EPSLN) {
              if (this.lat0 > 0) {
                lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
              } else {
                lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
              }
            } else {
              lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
            }
            p.x = lon;
            p.y = lat;
            return p;
          } else {
            if (Math.abs(this.coslat0) <= EPSLN) {
              if (rh <= EPSLN) {
                lat = this.lat0;
                lon = this.long0;
                p.x = lon;
                p.y = lat;
                return p;
              }
              p.x *= this.con;
              p.y *= this.con;
              ts = rh * this.cons / (2 * this.a * this.k0);
              lat = this.con * phi2z(this.e, ts);
              lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
            } else {
              ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
              lon = this.long0;
              if (rh <= EPSLN) {
                Chi = this.X0;
              } else {
                Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
                lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
              }
              lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var stere_names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
        var stere = {
          init: stere_init,
          forward: stere_forward,
          inverse: stere_inverse,
          names: stere_names,
          ssfn_
        };
        function somerc_init() {
          var phy0 = this.lat0;
          this.lambda0 = this.long0;
          var sinPhy0 = Math.sin(phy0);
          var semiMajorAxis = this.a;
          var invF = this.rf;
          var flattening = 1 / invF;
          var e2 = 2 * flattening - Math.pow(flattening, 2);
          var e = this.e = Math.sqrt(e2);
          this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
          this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
          this.b0 = Math.asin(sinPhy0 / this.alpha);
          var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
          var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
          var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
          this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
        }
        function somerc_forward(p) {
          var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
          var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
          var S = -this.alpha * (Sa1 + Sa2) + this.K;
          var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
          var I2 = this.alpha * (p.x - this.lambda0);
          var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I2)));
          var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I2));
          p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
          p.x = this.R * rotI + this.x0;
          return p;
        }
        function somerc_inverse(p) {
          var Y = p.x - this.x0;
          var X = p.y - this.y0;
          var rotI = Y / this.R;
          var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
          var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
          var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
          var lambda = this.lambda0 + I2 / this.alpha;
          var S = 0;
          var phy = b;
          var prevPhy = -1e3;
          var iteration = 0;
          while (Math.abs(phy - prevPhy) > 1e-7) {
            if (++iteration > 20) {
              return;
            }
            S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
            prevPhy = phy;
            phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
          }
          p.x = lambda;
          p.y = phy;
          return p;
        }
        var somerc_names = ["somerc"];
        var somerc = {
          init: somerc_init,
          forward: somerc_forward,
          inverse: somerc_inverse,
          names: somerc_names
        };
        var TOL = 1e-7;
        function isTypeA(P) {
          var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
          var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
          return "no_uoff" in P || "no_off" in P || typeAProjections.indexOf(projectionName) !== -1;
        }
        function omerc_init() {
          var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0, AB;
          this.no_off = isTypeA(this);
          this.no_rot = "no_rot" in this;
          var alp = false;
          if ("alpha" in this) {
            alp = true;
          }
          var gam = false;
          if ("rectified_grid_angle" in this) {
            gam = true;
          }
          if (alp) {
            alpha_c = this.alpha;
          }
          if (gam) {
            gamma = this.rectified_grid_angle * D2R;
          }
          if (alp || gam) {
            lamc = this.longc;
          } else {
            lam1 = this.long1;
            phi1 = this.lat1;
            lam2 = this.long2;
            phi2 = this.lat2;
            if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
              throw new Error();
            }
          }
          var one_es = 1 - this.es;
          com = Math.sqrt(one_es);
          if (Math.abs(this.lat0) > EPSLN) {
            sinph0 = Math.sin(this.lat0);
            cosph0 = Math.cos(this.lat0);
            con = 1 - this.es * sinph0 * sinph0;
            this.B = cosph0 * cosph0;
            this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
            this.A = this.B * this.k0 * com / con;
            D = this.B * com / (cosph0 * Math.sqrt(con));
            F = D * D - 1;
            if (F <= 0) {
              F = 0;
            } else {
              F = Math.sqrt(F);
              if (this.lat0 < 0) {
                F = -F;
              }
            }
            this.E = F += D;
            this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
          } else {
            this.B = 1 / com;
            this.A = this.k0;
            this.E = D = F = 1;
          }
          if (alp || gam) {
            if (alp) {
              gamma0 = Math.asin(Math.sin(alpha_c) / D);
              if (!gam) {
                gamma = alpha_c;
              }
            } else {
              gamma0 = gamma;
              alpha_c = Math.asin(D * Math.sin(gamma0));
            }
            this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
          } else {
            H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
            L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
            F = this.E / H;
            p = (L - H) / (L + H);
            J = this.E * this.E;
            J = (J - L * H) / (J + L * H);
            con = lam1 - lam2;
            if (con < -Math.pi) {
              lam2 -= TWO_PI;
            } else if (con > Math.pi) {
              lam2 += TWO_PI;
            }
            this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
            gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
            gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
          }
          this.singam = Math.sin(gamma0);
          this.cosgam = Math.cos(gamma0);
          this.sinrot = Math.sin(gamma);
          this.cosrot = Math.cos(gamma);
          this.rB = 1 / this.B;
          this.ArB = this.A * this.rB;
          this.BrA = 1 / this.ArB;
          AB = this.A * this.B;
          if (this.no_off) {
            this.u_0 = 0;
          } else {
            this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
            if (this.lat0 < 0) {
              this.u_0 = -this.u_0;
            }
          }
          F = 0.5 * gamma0;
          this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
          this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
        }
        function omerc_forward(p) {
          var coords = {};
          var S, T, U, V, W, temp, u, v;
          p.x = p.x - this.lam0;
          if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
            W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
            temp = 1 / W;
            S = 0.5 * (W - temp);
            T = 0.5 * (W + temp);
            V = Math.sin(this.B * p.x);
            U = (S * this.singam - V * this.cosgam) / T;
            if (Math.abs(Math.abs(U) - 1) < EPSLN) {
              throw new Error();
            }
            v = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
            temp = Math.cos(this.B * p.x);
            if (Math.abs(temp) < TOL) {
              u = this.A * p.x;
            } else {
              u = this.ArB * Math.atan2(S * this.cosgam + V * this.singam, temp);
            }
          } else {
            v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
            u = this.ArB * p.y;
          }
          if (this.no_rot) {
            coords.x = u;
            coords.y = v;
          } else {
            u -= this.u_0;
            coords.x = v * this.cosrot + u * this.sinrot;
            coords.y = u * this.cosrot - v * this.sinrot;
          }
          coords.x = this.a * coords.x + this.x0;
          coords.y = this.a * coords.y + this.y0;
          return coords;
        }
        function omerc_inverse(p) {
          var u, v, Qp, Sp, Tp, Vp, Up;
          var coords = {};
          p.x = (p.x - this.x0) * (1 / this.a);
          p.y = (p.y - this.y0) * (1 / this.a);
          if (this.no_rot) {
            v = p.y;
            u = p.x;
          } else {
            v = p.x * this.cosrot - p.y * this.sinrot;
            u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
          }
          Qp = Math.exp(-this.BrA * v);
          Sp = 0.5 * (Qp - 1 / Qp);
          Tp = 0.5 * (Qp + 1 / Qp);
          Vp = Math.sin(this.BrA * u);
          Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
          if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
            coords.x = 0;
            coords.y = Up < 0 ? -HALF_PI : HALF_PI;
          } else {
            coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
            coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
            if (coords.y === Infinity) {
              throw new Error();
            }
            coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
          }
          coords.x += this.lam0;
          return coords;
        }
        var omerc_names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
        var omerc = {
          init: omerc_init,
          forward: omerc_forward,
          inverse: omerc_inverse,
          names: omerc_names
        };
        function lcc_init() {
          if (!this.lat2) {
            this.lat2 = this.lat1;
          }
          if (!this.k0) {
            this.k0 = 1;
          }
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
            return;
          }
          var temp = this.b / this.a;
          this.e = Math.sqrt(1 - temp * temp);
          var sin1 = Math.sin(this.lat1);
          var cos1 = Math.cos(this.lat1);
          var ms1 = msfnz(this.e, sin1, cos1);
          var ts1 = tsfnz(this.e, this.lat1, sin1);
          var sin2 = Math.sin(this.lat2);
          var cos2 = Math.cos(this.lat2);
          var ms2 = msfnz(this.e, sin2, cos2);
          var ts2 = tsfnz(this.e, this.lat2, sin2);
          var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
          if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
            this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
          } else {
            this.ns = sin1;
          }
          if (isNaN(this.ns)) {
            this.ns = sin1;
          }
          this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
          this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
          if (!this.title) {
            this.title = "Lambert Conformal Conic";
          }
        }
        function lcc_forward(p) {
          var lon = p.x;
          var lat = p.y;
          if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
            lat = sign(lat) * (HALF_PI - 2 * EPSLN);
          }
          var con = Math.abs(Math.abs(lat) - HALF_PI);
          var ts, rh1;
          if (con > EPSLN) {
            ts = tsfnz(this.e, lat, Math.sin(lat));
            rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
          } else {
            con = lat * this.ns;
            if (con <= 0) {
              return null;
            }
            rh1 = 0;
          }
          var theta = this.ns * adjust_lon(lon - this.long0);
          p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
          p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
          return p;
        }
        function lcc_inverse(p) {
          var rh1, con, ts;
          var lat, lon;
          var x = (p.x - this.x0) / this.k0;
          var y = this.rh - (p.y - this.y0) / this.k0;
          if (this.ns > 0) {
            rh1 = Math.sqrt(x * x + y * y);
            con = 1;
          } else {
            rh1 = -Math.sqrt(x * x + y * y);
            con = -1;
          }
          var theta = 0;
          if (rh1 !== 0) {
            theta = Math.atan2(con * x, con * y);
          }
          if (rh1 !== 0 || this.ns > 0) {
            con = 1 / this.ns;
            ts = Math.pow(rh1 / (this.a * this.f0), con);
            lat = phi2z(this.e, ts);
            if (lat === -9999) {
              return null;
            }
          } else {
            lat = -HALF_PI;
          }
          lon = adjust_lon(theta / this.ns + this.long0);
          p.x = lon;
          p.y = lat;
          return p;
        }
        var lcc_names = [
          "Lambert Tangential Conformal Conic Projection",
          "Lambert_Conformal_Conic",
          "Lambert_Conformal_Conic_1SP",
          "Lambert_Conformal_Conic_2SP",
          "lcc"
        ];
        var lcc = {
          init: lcc_init,
          forward: lcc_forward,
          inverse: lcc_inverse,
          names: lcc_names
        };
        function krovak_init() {
          this.a = 6377397155e-3;
          this.es = 0.006674372230614;
          this.e = Math.sqrt(this.es);
          if (!this.lat0) {
            this.lat0 = 0.863937979737193;
          }
          if (!this.long0) {
            this.long0 = 0.7417649320975901 - 0.308341501185665;
          }
          if (!this.k0) {
            this.k0 = 0.9999;
          }
          this.s45 = 0.785398163397448;
          this.s90 = 2 * this.s45;
          this.fi0 = this.lat0;
          this.e2 = this.es;
          this.e = Math.sqrt(this.e2);
          this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
          this.uq = 1.04216856380474;
          this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
          this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
          this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
          this.k1 = this.k0;
          this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
          this.s0 = 1.37008346281555;
          this.n = Math.sin(this.s0);
          this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
          this.ad = this.s90 - this.uq;
        }
        function krovak_forward(p) {
          var gfi, u, deltav, s, d, eps, ro;
          var lon = p.x;
          var lat = p.y;
          var delta_lon = adjust_lon(lon - this.long0);
          gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
          u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
          deltav = -delta_lon * this.alfa;
          s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
          d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
          eps = this.n * d;
          ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
          p.y = ro * Math.cos(eps) / 1;
          p.x = ro * Math.sin(eps) / 1;
          if (!this.czech) {
            p.y *= -1;
            p.x *= -1;
          }
          return p;
        }
        function krovak_inverse(p) {
          var u, deltav, s, d, eps, ro, fi1;
          var ok;
          var tmp = p.x;
          p.x = p.y;
          p.y = tmp;
          if (!this.czech) {
            p.y *= -1;
            p.x *= -1;
          }
          ro = Math.sqrt(p.x * p.x + p.y * p.y);
          eps = Math.atan2(p.y, p.x);
          d = eps / Math.sin(this.s0);
          s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
          u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
          deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
          p.x = this.long0 - deltav / this.alfa;
          fi1 = u;
          ok = 0;
          var iter = 0;
          do {
            p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
            if (Math.abs(fi1 - p.y) < 1e-10) {
              ok = 1;
            }
            fi1 = p.y;
            iter += 1;
          } while (ok === 0 && iter < 15);
          if (iter >= 15) {
            return null;
          }
          return p;
        }
        var krovak_names = ["Krovak", "krovak"];
        var krovak = {
          init: krovak_init,
          forward: krovak_forward,
          inverse: krovak_inverse,
          names: krovak_names
        };
        var mlfn = function(e0, e1, e2, e3, phi) {
          return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
        };
        var e0fn = function(x) {
          return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
        };
        var e1fn = function(x) {
          return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
        };
        var e2fn = function(x) {
          return 0.05859375 * x * x * (1 + 0.75 * x);
        };
        var e3fn = function(x) {
          return x * x * x * (35 / 3072);
        };
        var gN = function(a, e, sinphi) {
          var temp = e * sinphi;
          return a / Math.sqrt(1 - temp * temp);
        };
        var adjust_lat = function(x) {
          return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
        };
        var imlfn = function(ml, e0, e1, e2, e3) {
          var phi;
          var dphi;
          phi = ml / e0;
          for (var i = 0; i < 15; i++) {
            dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
            phi += dphi;
            if (Math.abs(dphi) <= 1e-10) {
              return phi;
            }
          }
          return NaN;
        };
        function cass_init() {
          if (!this.sphere) {
            this.e0 = e0fn(this.es);
            this.e1 = e1fn(this.es);
            this.e2 = e2fn(this.es);
            this.e3 = e3fn(this.es);
            this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
          }
        }
        function cass_forward(p) {
          var x, y;
          var lam = p.x;
          var phi = p.y;
          lam = adjust_lon(lam - this.long0);
          if (this.sphere) {
            x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
            y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
          } else {
            var sinphi = Math.sin(phi);
            var cosphi = Math.cos(phi);
            var nl = gN(this.a, this.e, sinphi);
            var tl = Math.tan(phi) * Math.tan(phi);
            var al = lam * Math.cos(phi);
            var asq = al * al;
            var cl = this.es * cosphi * cosphi / (1 - this.es);
            var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
            x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
            y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
          }
          p.x = x + this.x0;
          p.y = y + this.y0;
          return p;
        }
        function cass_inverse(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var x = p.x / this.a;
          var y = p.y / this.a;
          var phi, lam;
          if (this.sphere) {
            var dd = y + this.lat0;
            phi = Math.asin(Math.sin(dd) * Math.cos(x));
            lam = Math.atan2(Math.tan(x), Math.cos(dd));
          } else {
            var ml1 = this.ml0 / this.a + y;
            var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
            if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
              p.x = this.long0;
              p.y = HALF_PI;
              if (y < 0) {
                p.y *= -1;
              }
              return p;
            }
            var nl1 = gN(this.a, this.e, Math.sin(phi1));
            var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
            var tl1 = Math.pow(Math.tan(phi1), 2);
            var dl = x * this.a / nl1;
            var dsq = dl * dl;
            phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
            lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
          }
          p.x = adjust_lon(lam + this.long0);
          p.y = adjust_lat(phi);
          return p;
        }
        var cass_names = ["Cassini", "Cassini_Soldner", "cass"];
        var cass = {
          init: cass_init,
          forward: cass_forward,
          inverse: cass_inverse,
          names: cass_names
        };
        var qsfnz = function(eccent, sinphi) {
          var con;
          if (eccent > 1e-7) {
            con = eccent * sinphi;
            return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
          } else {
            return 2 * sinphi;
          }
        };
        var S_POLE = 1;
        var N_POLE = 2;
        var EQUIT = 3;
        var OBLIQ = 4;
        function laea_init() {
          var t = Math.abs(this.lat0);
          if (Math.abs(t - HALF_PI) < EPSLN) {
            this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
          } else if (Math.abs(t) < EPSLN) {
            this.mode = this.EQUIT;
          } else {
            this.mode = this.OBLIQ;
          }
          if (this.es > 0) {
            var sinphi;
            this.qp = qsfnz(this.e, 1);
            this.mmf = 0.5 / (1 - this.es);
            this.apa = authset(this.es);
            switch (this.mode) {
              case this.N_POLE:
                this.dd = 1;
                break;
              case this.S_POLE:
                this.dd = 1;
                break;
              case this.EQUIT:
                this.rq = Math.sqrt(0.5 * this.qp);
                this.dd = 1 / this.rq;
                this.xmf = 1;
                this.ymf = 0.5 * this.qp;
                break;
              case this.OBLIQ:
                this.rq = Math.sqrt(0.5 * this.qp);
                sinphi = Math.sin(this.lat0);
                this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
                this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
                this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
                this.ymf = (this.xmf = this.rq) / this.dd;
                this.xmf *= this.dd;
                break;
            }
          } else {
            if (this.mode === this.OBLIQ) {
              this.sinph0 = Math.sin(this.lat0);
              this.cosph0 = Math.cos(this.lat0);
            }
          }
        }
        function laea_forward(p) {
          var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
          var lam = p.x;
          var phi = p.y;
          lam = adjust_lon(lam - this.long0);
          if (this.sphere) {
            sinphi = Math.sin(phi);
            cosphi = Math.cos(phi);
            coslam = Math.cos(lam);
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
              if (y <= EPSLN) {
                return null;
              }
              y = Math.sqrt(2 / y);
              x = y * cosphi * Math.sin(lam);
              y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
            } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
              if (this.mode === this.N_POLE) {
                coslam = -coslam;
              }
              if (Math.abs(phi + this.lat0) < EPSLN) {
                return null;
              }
              y = FORTPI - phi * 0.5;
              y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
              x = y * Math.sin(lam);
              y *= coslam;
            }
          } else {
            sinb = 0;
            cosb = 0;
            b = 0;
            coslam = Math.cos(lam);
            sinlam = Math.sin(lam);
            sinphi = Math.sin(phi);
            q = qsfnz(this.e, sinphi);
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              sinb = q / this.qp;
              cosb = Math.sqrt(1 - sinb * sinb);
            }
            switch (this.mode) {
              case this.OBLIQ:
                b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
                break;
              case this.EQUIT:
                b = 1 + cosb * coslam;
                break;
              case this.N_POLE:
                b = HALF_PI + phi;
                q = this.qp - q;
                break;
              case this.S_POLE:
                b = phi - HALF_PI;
                q = this.qp + q;
                break;
            }
            if (Math.abs(b) < EPSLN) {
              return null;
            }
            switch (this.mode) {
              case this.OBLIQ:
              case this.EQUIT:
                b = Math.sqrt(2 / b);
                if (this.mode === this.OBLIQ) {
                  y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
                } else {
                  y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
                }
                x = this.xmf * b * cosb * sinlam;
                break;
              case this.N_POLE:
              case this.S_POLE:
                if (q >= 0) {
                  x = (b = Math.sqrt(q)) * sinlam;
                  y = coslam * (this.mode === this.S_POLE ? b : -b);
                } else {
                  x = y = 0;
                }
                break;
            }
          }
          p.x = this.a * x + this.x0;
          p.y = this.a * y + this.y0;
          return p;
        }
        function laea_inverse(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var x = p.x / this.a;
          var y = p.y / this.a;
          var lam, phi, cCe, sCe, q, rho, ab;
          if (this.sphere) {
            var cosz = 0, rh, sinz = 0;
            rh = Math.sqrt(x * x + y * y);
            phi = rh * 0.5;
            if (phi > 1) {
              return null;
            }
            phi = 2 * Math.asin(phi);
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              sinz = Math.sin(phi);
              cosz = Math.cos(phi);
            }
            switch (this.mode) {
              case this.EQUIT:
                phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
                x *= sinz;
                y = cosz * rh;
                break;
              case this.OBLIQ:
                phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
                x *= sinz * this.cosph0;
                y = (cosz - Math.sin(phi) * this.sinph0) * rh;
                break;
              case this.N_POLE:
                y = -y;
                phi = HALF_PI - phi;
                break;
              case this.S_POLE:
                phi -= HALF_PI;
                break;
            }
            lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
          } else {
            ab = 0;
            if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              x /= this.dd;
              y *= this.dd;
              rho = Math.sqrt(x * x + y * y);
              if (rho < EPSLN) {
                p.x = this.long0;
                p.y = this.lat0;
                return p;
              }
              sCe = 2 * Math.asin(0.5 * rho / this.rq);
              cCe = Math.cos(sCe);
              x *= sCe = Math.sin(sCe);
              if (this.mode === this.OBLIQ) {
                ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
                q = this.qp * ab;
                y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
              } else {
                ab = y * sCe / rho;
                q = this.qp * ab;
                y = rho * cCe;
              }
            } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
              if (this.mode === this.N_POLE) {
                y = -y;
              }
              q = x * x + y * y;
              if (!q) {
                p.x = this.long0;
                p.y = this.lat0;
                return p;
              }
              ab = 1 - q / this.qp;
              if (this.mode === this.S_POLE) {
                ab = -ab;
              }
            }
            lam = Math.atan2(x, y);
            phi = authlat(Math.asin(ab), this.apa);
          }
          p.x = adjust_lon(this.long0 + lam);
          p.y = phi;
          return p;
        }
        var P00 = 0.3333333333333333;
        var P01 = 0.17222222222222222;
        var P02 = 0.10257936507936508;
        var P10 = 0.06388888888888888;
        var P11 = 0.0664021164021164;
        var P20 = 0.016415012942191543;
        function authset(es) {
          var t;
          var APA = [];
          APA[0] = es * P00;
          t = es * es;
          APA[0] += t * P01;
          APA[1] = t * P10;
          t *= es;
          APA[0] += t * P02;
          APA[1] += t * P11;
          APA[2] = t * P20;
          return APA;
        }
        function authlat(beta, APA) {
          var t = beta + beta;
          return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
        }
        var laea_names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
        var laea = {
          init: laea_init,
          forward: laea_forward,
          inverse: laea_inverse,
          names: laea_names,
          S_POLE,
          N_POLE,
          EQUIT,
          OBLIQ
        };
        var asinz = function(x) {
          if (Math.abs(x) > 1) {
            x = x > 1 ? 1 : -1;
          }
          return Math.asin(x);
        };
        function aea_init() {
          if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
            return;
          }
          this.temp = this.b / this.a;
          this.es = 1 - Math.pow(this.temp, 2);
          this.e3 = Math.sqrt(this.es);
          this.sin_po = Math.sin(this.lat1);
          this.cos_po = Math.cos(this.lat1);
          this.t1 = this.sin_po;
          this.con = this.sin_po;
          this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
          this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
          this.sin_po = Math.sin(this.lat2);
          this.cos_po = Math.cos(this.lat2);
          this.t2 = this.sin_po;
          this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
          this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
          this.sin_po = Math.sin(this.lat0);
          this.cos_po = Math.cos(this.lat0);
          this.t3 = this.sin_po;
          this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);
          if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
            this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
          } else {
            this.ns0 = this.con;
          }
          this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
          this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
        }
        function aea_forward(p) {
          var lon = p.x;
          var lat = p.y;
          this.sin_phi = Math.sin(lat);
          this.cos_phi = Math.cos(lat);
          var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
          var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
          var theta = this.ns0 * adjust_lon(lon - this.long0);
          var x = rh1 * Math.sin(theta) + this.x0;
          var y = this.rh - rh1 * Math.cos(theta) + this.y0;
          p.x = x;
          p.y = y;
          return p;
        }
        function aea_inverse(p) {
          var rh1, qs, con, theta, lon, lat;
          p.x -= this.x0;
          p.y = this.rh - p.y + this.y0;
          if (this.ns0 >= 0) {
            rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
            con = 1;
          } else {
            rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
            con = -1;
          }
          theta = 0;
          if (rh1 !== 0) {
            theta = Math.atan2(con * p.x, con * p.y);
          }
          con = rh1 * this.ns0 / this.a;
          if (this.sphere) {
            lat = Math.asin((this.c - con * con) / (2 * this.ns0));
          } else {
            qs = (this.c - con * con) / this.ns0;
            lat = this.phi1z(this.e3, qs);
          }
          lon = adjust_lon(theta / this.ns0 + this.long0);
          p.x = lon;
          p.y = lat;
          return p;
        }
        function phi1z(eccent, qs) {
          var sinphi, cosphi, con, com, dphi;
          var phi = asinz(0.5 * qs);
          if (eccent < EPSLN) {
            return phi;
          }
          var eccnts = eccent * eccent;
          for (var i = 1; i <= 25; i++) {
            sinphi = Math.sin(phi);
            cosphi = Math.cos(phi);
            con = eccent * sinphi;
            com = 1 - con * con;
            dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
            phi = phi + dphi;
            if (Math.abs(dphi) <= 1e-7) {
              return phi;
            }
          }
          return null;
        }
        var aea_names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
        var aea = {
          init: aea_init,
          forward: aea_forward,
          inverse: aea_inverse,
          names: aea_names,
          phi1z
        };
        function gnom_init() {
          this.sin_p14 = Math.sin(this.lat0);
          this.cos_p14 = Math.cos(this.lat0);
          this.infinity_dist = 1e3 * this.a;
          this.rc = 1;
        }
        function gnom_forward(p) {
          var sinphi, cosphi;
          var dlon;
          var coslon;
          var ksp;
          var g;
          var x, y;
          var lon = p.x;
          var lat = p.y;
          dlon = adjust_lon(lon - this.long0);
          sinphi = Math.sin(lat);
          cosphi = Math.cos(lat);
          coslon = Math.cos(dlon);
          g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
          ksp = 1;
          if (g > 0 || Math.abs(g) <= EPSLN) {
            x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
            y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
          } else {
            x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
            y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function gnom_inverse(p) {
          var rh;
          var sinc, cosc;
          var c;
          var lon, lat;
          p.x = (p.x - this.x0) / this.a;
          p.y = (p.y - this.y0) / this.a;
          p.x /= this.k0;
          p.y /= this.k0;
          if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
            c = Math.atan2(rh, this.rc);
            sinc = Math.sin(c);
            cosc = Math.cos(c);
            lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
            lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
            lon = adjust_lon(this.long0 + lon);
          } else {
            lat = this.phic0;
            lon = 0;
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var gnom_names = ["gnom"];
        var gnom = {
          init: gnom_init,
          forward: gnom_forward,
          inverse: gnom_inverse,
          names: gnom_names
        };
        var iqsfnz = function(eccent, q) {
          var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
          if (Math.abs(Math.abs(q) - temp) < 1e-6) {
            if (q < 0) {
              return -1 * HALF_PI;
            } else {
              return HALF_PI;
            }
          }
          var phi = Math.asin(0.5 * q);
          var dphi;
          var sin_phi;
          var cos_phi;
          var con;
          for (var i = 0; i < 30; i++) {
            sin_phi = Math.sin(phi);
            cos_phi = Math.cos(phi);
            con = eccent * sin_phi;
            dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
            phi += dphi;
            if (Math.abs(dphi) <= 1e-10) {
              return phi;
            }
          }
          return NaN;
        };
        function cea_init() {
          if (!this.sphere) {
            this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
          }
        }
        function cea_forward(p) {
          var lon = p.x;
          var lat = p.y;
          var x, y;
          var dlon = adjust_lon(lon - this.long0);
          if (this.sphere) {
            x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
            y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
          } else {
            var qs = qsfnz(this.e, Math.sin(lat));
            x = this.x0 + this.a * this.k0 * dlon;
            y = this.y0 + this.a * qs * 0.5 / this.k0;
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function cea_inverse(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var lon, lat;
          if (this.sphere) {
            lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
            lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
          } else {
            lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
            lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var cea_names = ["cea"];
        var cea = {
          init: cea_init,
          forward: cea_forward,
          inverse: cea_inverse,
          names: cea_names
        };
        function eqc_init() {
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          this.lat0 = this.lat0 || 0;
          this.long0 = this.long0 || 0;
          this.lat_ts = this.lat_ts || 0;
          this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
          this.rc = Math.cos(this.lat_ts);
        }
        function eqc_forward(p) {
          var lon = p.x;
          var lat = p.y;
          var dlon = adjust_lon(lon - this.long0);
          var dlat = adjust_lat(lat - this.lat0);
          p.x = this.x0 + this.a * dlon * this.rc;
          p.y = this.y0 + this.a * dlat;
          return p;
        }
        function eqc_inverse(p) {
          var x = p.x;
          var y = p.y;
          p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));
          p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a);
          return p;
        }
        var eqc_names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
        var eqc = {
          init: eqc_init,
          forward: eqc_forward,
          inverse: eqc_inverse,
          names: eqc_names
        };
        var poly_MAX_ITER = 20;
        function poly_init() {
          this.temp = this.b / this.a;
          this.es = 1 - Math.pow(this.temp, 2);
          this.e = Math.sqrt(this.es);
          this.e0 = e0fn(this.es);
          this.e1 = e1fn(this.es);
          this.e2 = e2fn(this.es);
          this.e3 = e3fn(this.es);
          this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
        }
        function poly_forward(p) {
          var lon = p.x;
          var lat = p.y;
          var x, y, el;
          var dlon = adjust_lon(lon - this.long0);
          el = dlon * Math.sin(lat);
          if (this.sphere) {
            if (Math.abs(lat) <= EPSLN) {
              x = this.a * dlon;
              y = -1 * this.a * this.lat0;
            } else {
              x = this.a * Math.sin(el) / Math.tan(lat);
              y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
            }
          } else {
            if (Math.abs(lat) <= EPSLN) {
              x = this.a * dlon;
              y = -1 * this.ml0;
            } else {
              var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
              x = nl * Math.sin(el);
              y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
            }
          }
          p.x = x + this.x0;
          p.y = y + this.y0;
          return p;
        }
        function poly_inverse(p) {
          var lon, lat, x, y, i;
          var al, bl;
          var phi, dphi;
          x = p.x - this.x0;
          y = p.y - this.y0;
          if (this.sphere) {
            if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
              lon = adjust_lon(x / this.a + this.long0);
              lat = 0;
            } else {
              al = this.lat0 + y / this.a;
              bl = x * x / this.a / this.a + al * al;
              phi = al;
              var tanphi;
              for (i = poly_MAX_ITER; i; --i) {
                tanphi = Math.tan(phi);
                dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
                phi += dphi;
                if (Math.abs(dphi) <= EPSLN) {
                  lat = phi;
                  break;
                }
              }
              lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
            }
          } else {
            if (Math.abs(y + this.ml0) <= EPSLN) {
              lat = 0;
              lon = adjust_lon(this.long0 + x / this.a);
            } else {
              al = (this.ml0 + y) / this.a;
              bl = x * x / this.a / this.a + al * al;
              phi = al;
              var cl, mln, mlnp, ma;
              var con;
              for (i = poly_MAX_ITER; i; --i) {
                con = this.e * Math.sin(phi);
                cl = Math.sqrt(1 - con * con) * Math.tan(phi);
                mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
                mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
                ma = mln / this.a;
                dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
                phi -= dphi;
                if (Math.abs(dphi) <= EPSLN) {
                  lat = phi;
                  break;
                }
              }
              cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
              lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var poly_names = ["Polyconic", "poly"];
        var projections_poly = {
          init: poly_init,
          forward: poly_forward,
          inverse: poly_inverse,
          names: poly_names
        };
        var iterations = 1;
        function nzmg_init() {
          this.A = [];
          this.A[1] = 0.6399175073;
          this.A[2] = -0.1358797613;
          this.A[3] = 0.063294409;
          this.A[4] = -0.02526853;
          this.A[5] = 0.0117879;
          this.A[6] = -55161e-7;
          this.A[7] = 26906e-7;
          this.A[8] = -1333e-6;
          this.A[9] = 67e-5;
          this.A[10] = -34e-5;
          this.B_re = [];
          this.B_im = [];
          this.B_re[1] = 0.7557853228;
          this.B_im[1] = 0;
          this.B_re[2] = 0.249204646;
          this.B_im[2] = 3371507e-9;
          this.B_re[3] = -1541739e-9;
          this.B_im[3] = 0.04105856;
          this.B_re[4] = -0.10162907;
          this.B_im[4] = 0.01727609;
          this.B_re[5] = -0.26623489;
          this.B_im[5] = -0.36249218;
          this.B_re[6] = -0.6870983;
          this.B_im[6] = -1.1651967;
          this.C_re = [];
          this.C_im = [];
          this.C_re[1] = 1.3231270439;
          this.C_im[1] = 0;
          this.C_re[2] = -0.577245789;
          this.C_im[2] = -7809598e-9;
          this.C_re[3] = 0.508307513;
          this.C_im[3] = -0.112208952;
          this.C_re[4] = -0.15094762;
          this.C_im[4] = 0.18200602;
          this.C_re[5] = 1.01418179;
          this.C_im[5] = 1.64497696;
          this.C_re[6] = 1.9660549;
          this.C_im[6] = 2.5127645;
          this.D = [];
          this.D[1] = 1.5627014243;
          this.D[2] = 0.5185406398;
          this.D[3] = -0.03333098;
          this.D[4] = -0.1052906;
          this.D[5] = -0.0368594;
          this.D[6] = 7317e-6;
          this.D[7] = 0.0122;
          this.D[8] = 394e-5;
          this.D[9] = -13e-4;
        }
        function nzmg_forward(p) {
          var n;
          var lon = p.x;
          var lat = p.y;
          var delta_lat = lat - this.lat0;
          var delta_lon = lon - this.long0;
          var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
          var d_lambda = delta_lon;
          var d_phi_n = 1;
          var d_psi = 0;
          for (n = 1; n <= 10; n++) {
            d_phi_n = d_phi_n * d_phi;
            d_psi = d_psi + this.A[n] * d_phi_n;
          }
          var th_re = d_psi;
          var th_im = d_lambda;
          var th_n_re = 1;
          var th_n_im = 0;
          var th_n_re1;
          var th_n_im1;
          var z_re = 0;
          var z_im = 0;
          for (n = 1; n <= 6; n++) {
            th_n_re1 = th_n_re * th_re - th_n_im * th_im;
            th_n_im1 = th_n_im * th_re + th_n_re * th_im;
            th_n_re = th_n_re1;
            th_n_im = th_n_im1;
            z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
            z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
          }
          p.x = z_im * this.a + this.x0;
          p.y = z_re * this.a + this.y0;
          return p;
        }
        function nzmg_inverse(p) {
          var n;
          var x = p.x;
          var y = p.y;
          var delta_x = x - this.x0;
          var delta_y = y - this.y0;
          var z_re = delta_y / this.a;
          var z_im = delta_x / this.a;
          var z_n_re = 1;
          var z_n_im = 0;
          var z_n_re1;
          var z_n_im1;
          var th_re = 0;
          var th_im = 0;
          for (n = 1; n <= 6; n++) {
            z_n_re1 = z_n_re * z_re - z_n_im * z_im;
            z_n_im1 = z_n_im * z_re + z_n_re * z_im;
            z_n_re = z_n_re1;
            z_n_im = z_n_im1;
            th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
            th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
          }
          for (var i = 0; i < this.iterations; i++) {
            var th_n_re = th_re;
            var th_n_im = th_im;
            var th_n_re1;
            var th_n_im1;
            var num_re = z_re;
            var num_im = z_im;
            for (n = 2; n <= 6; n++) {
              th_n_re1 = th_n_re * th_re - th_n_im * th_im;
              th_n_im1 = th_n_im * th_re + th_n_re * th_im;
              th_n_re = th_n_re1;
              th_n_im = th_n_im1;
              num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
              num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
            }
            th_n_re = 1;
            th_n_im = 0;
            var den_re = this.B_re[1];
            var den_im = this.B_im[1];
            for (n = 2; n <= 6; n++) {
              th_n_re1 = th_n_re * th_re - th_n_im * th_im;
              th_n_im1 = th_n_im * th_re + th_n_re * th_im;
              th_n_re = th_n_re1;
              th_n_im = th_n_im1;
              den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
              den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
            }
            var den2 = den_re * den_re + den_im * den_im;
            th_re = (num_re * den_re + num_im * den_im) / den2;
            th_im = (num_im * den_re - num_re * den_im) / den2;
          }
          var d_psi = th_re;
          var d_lambda = th_im;
          var d_psi_n = 1;
          var d_phi = 0;
          for (n = 1; n <= 9; n++) {
            d_psi_n = d_psi_n * d_psi;
            d_phi = d_phi + this.D[n] * d_psi_n;
          }
          var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
          var lon = this.long0 + d_lambda;
          p.x = lon;
          p.y = lat;
          return p;
        }
        var nzmg_names = ["New_Zealand_Map_Grid", "nzmg"];
        var nzmg = {
          init: nzmg_init,
          forward: nzmg_forward,
          inverse: nzmg_inverse,
          names: nzmg_names
        };
        function mill_init() {
        }
        function mill_forward(p) {
          var lon = p.x;
          var lat = p.y;
          var dlon = adjust_lon(lon - this.long0);
          var x = this.x0 + this.a * dlon;
          var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
          p.x = x;
          p.y = y;
          return p;
        }
        function mill_inverse(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var lon = adjust_lon(this.long0 + p.x / this.a);
          var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
          p.x = lon;
          p.y = lat;
          return p;
        }
        var mill_names = ["Miller_Cylindrical", "mill"];
        var mill = {
          init: mill_init,
          forward: mill_forward,
          inverse: mill_inverse,
          names: mill_names
        };
        var sinu_MAX_ITER = 20;
        function sinu_init() {
          if (!this.sphere) {
            this.en = pj_enfn(this.es);
          } else {
            this.n = 1;
            this.m = 0;
            this.es = 0;
            this.C_y = Math.sqrt((this.m + 1) / this.n);
            this.C_x = this.C_y / (this.m + 1);
          }
        }
        function sinu_forward(p) {
          var x, y;
          var lon = p.x;
          var lat = p.y;
          lon = adjust_lon(lon - this.long0);
          if (this.sphere) {
            if (!this.m) {
              lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
            } else {
              var k = this.n * Math.sin(lat);
              for (var i = sinu_MAX_ITER; i; --i) {
                var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
                lat -= V;
                if (Math.abs(V) < EPSLN) {
                  break;
                }
              }
            }
            x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
            y = this.a * this.C_y * lat;
          } else {
            var s = Math.sin(lat);
            var c = Math.cos(lat);
            y = this.a * pj_mlfn(lat, s, c, this.en);
            x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function sinu_inverse(p) {
          var lat, temp, lon, s;
          p.x -= this.x0;
          lon = p.x / this.a;
          p.y -= this.y0;
          lat = p.y / this.a;
          if (this.sphere) {
            lat /= this.C_y;
            lon = lon / (this.C_x * (this.m + Math.cos(lat)));
            if (this.m) {
              lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
            } else if (this.n !== 1) {
              lat = asinz(Math.sin(lat) / this.n);
            }
            lon = adjust_lon(lon + this.long0);
            lat = adjust_lat(lat);
          } else {
            lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
            s = Math.abs(lat);
            if (s < HALF_PI) {
              s = Math.sin(lat);
              temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
              lon = adjust_lon(temp);
            } else if (s - EPSLN < HALF_PI) {
              lon = this.long0;
            }
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var sinu_names = ["Sinusoidal", "sinu"];
        var sinu = {
          init: sinu_init,
          forward: sinu_forward,
          inverse: sinu_inverse,
          names: sinu_names
        };
        function moll_init() {
        }
        function moll_forward(p) {
          var lon = p.x;
          var lat = p.y;
          var delta_lon = adjust_lon(lon - this.long0);
          var theta = lat;
          var con = Math.PI * Math.sin(lat);
          while (true) {
            var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
            theta += delta_theta;
            if (Math.abs(delta_theta) < EPSLN) {
              break;
            }
          }
          theta /= 2;
          if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
            delta_lon = 0;
          }
          var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
          var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
          p.x = x;
          p.y = y;
          return p;
        }
        function moll_inverse(p) {
          var theta;
          var arg;
          p.x -= this.x0;
          p.y -= this.y0;
          arg = p.y / (1.4142135623731 * this.a);
          if (Math.abs(arg) > 0.999999999999) {
            arg = 0.999999999999;
          }
          theta = Math.asin(arg);
          var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
          if (lon < -Math.PI) {
            lon = -Math.PI;
          }
          if (lon > Math.PI) {
            lon = Math.PI;
          }
          arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
          if (Math.abs(arg) > 1) {
            arg = 1;
          }
          var lat = Math.asin(arg);
          p.x = lon;
          p.y = lat;
          return p;
        }
        var moll_names = ["Mollweide", "moll"];
        var moll = {
          init: moll_init,
          forward: moll_forward,
          inverse: moll_inverse,
          names: moll_names
        };
        function eqdc_init() {
          if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
            return;
          }
          this.lat2 = this.lat2 || this.lat1;
          this.temp = this.b / this.a;
          this.es = 1 - Math.pow(this.temp, 2);
          this.e = Math.sqrt(this.es);
          this.e0 = e0fn(this.es);
          this.e1 = e1fn(this.es);
          this.e2 = e2fn(this.es);
          this.e3 = e3fn(this.es);
          this.sinphi = Math.sin(this.lat1);
          this.cosphi = Math.cos(this.lat1);
          this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
          this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
          if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
            this.ns = this.sinphi;
          } else {
            this.sinphi = Math.sin(this.lat2);
            this.cosphi = Math.cos(this.lat2);
            this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
            this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
            this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
          }
          this.g = this.ml1 + this.ms1 / this.ns;
          this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
          this.rh = this.a * (this.g - this.ml0);
        }
        function eqdc_forward(p) {
          var lon = p.x;
          var lat = p.y;
          var rh1;
          if (this.sphere) {
            rh1 = this.a * (this.g - lat);
          } else {
            var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
            rh1 = this.a * (this.g - ml);
          }
          var theta = this.ns * adjust_lon(lon - this.long0);
          var x = this.x0 + rh1 * Math.sin(theta);
          var y = this.y0 + this.rh - rh1 * Math.cos(theta);
          p.x = x;
          p.y = y;
          return p;
        }
        function eqdc_inverse(p) {
          p.x -= this.x0;
          p.y = this.rh - p.y + this.y0;
          var con, rh1, lat, lon;
          if (this.ns >= 0) {
            rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
            con = 1;
          } else {
            rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
            con = -1;
          }
          var theta = 0;
          if (rh1 !== 0) {
            theta = Math.atan2(con * p.x, con * p.y);
          }
          if (this.sphere) {
            lon = adjust_lon(this.long0 + theta / this.ns);
            lat = adjust_lat(this.g - rh1 / this.a);
            p.x = lon;
            p.y = lat;
            return p;
          } else {
            var ml = this.g - rh1 / this.a;
            lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
            lon = adjust_lon(this.long0 + theta / this.ns);
            p.x = lon;
            p.y = lat;
            return p;
          }
        }
        var eqdc_names = ["Equidistant_Conic", "eqdc"];
        var eqdc = {
          init: eqdc_init,
          forward: eqdc_forward,
          inverse: eqdc_inverse,
          names: eqdc_names
        };
        function vandg_init() {
          this.R = this.a;
        }
        function vandg_forward(p) {
          var lon = p.x;
          var lat = p.y;
          var dlon = adjust_lon(lon - this.long0);
          var x, y;
          if (Math.abs(lat) <= EPSLN) {
            x = this.x0 + this.R * dlon;
            y = this.y0;
          }
          var theta = asinz(2 * Math.abs(lat / Math.PI));
          if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
            x = this.x0;
            if (lat >= 0) {
              y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
            } else {
              y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
            }
          }
          var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
          var asq = al * al;
          var sinth = Math.sin(theta);
          var costh = Math.cos(theta);
          var g = costh / (sinth + costh - 1);
          var gsq = g * g;
          var m = g * (2 / sinth - 1);
          var msq = m * m;
          var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
          if (dlon < 0) {
            con = -con;
          }
          x = this.x0 + con;
          var q = asq + g;
          con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
          if (lat >= 0) {
            y = this.y0 + con;
          } else {
            y = this.y0 - con;
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function vandg_inverse(p) {
          var lon, lat;
          var xx, yy, xys, c1, c2, c3;
          var a1;
          var m1;
          var con;
          var th1;
          var d;
          p.x -= this.x0;
          p.y -= this.y0;
          con = Math.PI * this.R;
          xx = p.x / con;
          yy = p.y / con;
          xys = xx * xx + yy * yy;
          c1 = -Math.abs(yy) * (1 + xys);
          c2 = c1 - 2 * yy * yy + xx * xx;
          c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
          d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
          a1 = (c1 - c2 * c2 / 3 / c3) / c3;
          m1 = 2 * Math.sqrt(-a1 / 3);
          con = 3 * d / a1 / m1;
          if (Math.abs(con) > 1) {
            if (con >= 0) {
              con = 1;
            } else {
              con = -1;
            }
          }
          th1 = Math.acos(con) / 3;
          if (p.y >= 0) {
            lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
          } else {
            lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
          }
          if (Math.abs(xx) < EPSLN) {
            lon = this.long0;
          } else {
            lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
          }
          p.x = lon;
          p.y = lat;
          return p;
        }
        var vandg_names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
        var vandg = {
          init: vandg_init,
          forward: vandg_forward,
          inverse: vandg_inverse,
          names: vandg_names
        };
        function aeqd_init() {
          this.sin_p12 = Math.sin(this.lat0);
          this.cos_p12 = Math.cos(this.lat0);
        }
        function aeqd_forward(p) {
          var lon = p.x;
          var lat = p.y;
          var sinphi = Math.sin(p.y);
          var cosphi = Math.cos(p.y);
          var dlon = adjust_lon(lon - this.long0);
          var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
          if (this.sphere) {
            if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
              p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
              p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
              return p;
            } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
              p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
              p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
              return p;
            } else {
              cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
              c = Math.acos(cos_c);
              kp = c ? c / Math.sin(c) : 1;
              p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
              p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
              return p;
            }
          } else {
            e0 = e0fn(this.es);
            e1 = e1fn(this.es);
            e2 = e2fn(this.es);
            e3 = e3fn(this.es);
            if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              Ml = this.a * mlfn(e0, e1, e2, e3, lat);
              p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
              p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
              return p;
            } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              Ml = this.a * mlfn(e0, e1, e2, e3, lat);
              p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
              p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
              return p;
            } else {
              tanphi = sinphi / cosphi;
              Nl1 = gN(this.a, this.e, this.sin_p12);
              Nl = gN(this.a, this.e, sinphi);
              psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
              Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
              if (Az === 0) {
                s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
              } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
                s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
              } else {
                s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
              }
              G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
              H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
              GH = G * H;
              Hs = H * H;
              s2 = s * s;
              s3 = s2 * s;
              s4 = s3 * s;
              s5 = s4 * s;
              c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
              p.x = this.x0 + c * Math.sin(Az);
              p.y = this.y0 + c * Math.cos(Az);
              return p;
            }
          }
        }
        function aeqd_inverse(p) {
          p.x -= this.x0;
          p.y -= this.y0;
          var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
          if (this.sphere) {
            rh = Math.sqrt(p.x * p.x + p.y * p.y);
            if (rh > 2 * HALF_PI * this.a) {
              return;
            }
            z = rh / this.a;
            sinz = Math.sin(z);
            cosz = Math.cos(z);
            lon = this.long0;
            if (Math.abs(rh) <= EPSLN) {
              lat = this.lat0;
            } else {
              lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
              con = Math.abs(this.lat0) - HALF_PI;
              if (Math.abs(con) <= EPSLN) {
                if (this.lat0 >= 0) {
                  lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
                } else {
                  lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
                }
              } else {
                lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
              }
            }
            p.x = lon;
            p.y = lat;
            return p;
          } else {
            e0 = e0fn(this.es);
            e1 = e1fn(this.es);
            e2 = e2fn(this.es);
            e3 = e3fn(this.es);
            if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              rh = Math.sqrt(p.x * p.x + p.y * p.y);
              M = Mlp - rh;
              lat = imlfn(M / this.a, e0, e1, e2, e3);
              lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
              p.x = lon;
              p.y = lat;
              return p;
            } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
              Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
              rh = Math.sqrt(p.x * p.x + p.y * p.y);
              M = rh - Mlp;
              lat = imlfn(M / this.a, e0, e1, e2, e3);
              lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
              p.x = lon;
              p.y = lat;
              return p;
            } else {
              rh = Math.sqrt(p.x * p.x + p.y * p.y);
              Az = Math.atan2(p.x, p.y);
              N1 = gN(this.a, this.e, this.sin_p12);
              cosAz = Math.cos(Az);
              tmp = this.e * this.cos_p12 * cosAz;
              A = -tmp * tmp / (1 - this.es);
              B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
              D = rh / N1;
              Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
              F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
              psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
              lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
              sinpsi = Math.sin(psi);
              lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
              p.x = lon;
              p.y = lat;
              return p;
            }
          }
        }
        var aeqd_names = ["Azimuthal_Equidistant", "aeqd"];
        var aeqd = {
          init: aeqd_init,
          forward: aeqd_forward,
          inverse: aeqd_inverse,
          names: aeqd_names
        };
        function ortho_init() {
          this.sin_p14 = Math.sin(this.lat0);
          this.cos_p14 = Math.cos(this.lat0);
        }
        function ortho_forward(p) {
          var sinphi, cosphi;
          var dlon;
          var coslon;
          var ksp;
          var g, x, y;
          var lon = p.x;
          var lat = p.y;
          dlon = adjust_lon(lon - this.long0);
          sinphi = Math.sin(lat);
          cosphi = Math.cos(lat);
          coslon = Math.cos(dlon);
          g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
          ksp = 1;
          if (g > 0 || Math.abs(g) <= EPSLN) {
            x = this.a * ksp * cosphi * Math.sin(dlon);
            y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
          }
          p.x = x;
          p.y = y;
          return p;
        }
        function ortho_inverse(p) {
          var rh;
          var z;
          var sinz, cosz;
          var con;
          var lon, lat;
          p.x -= this.x0;
          p.y -= this.y0;
          rh = Math.sqrt(p.x * p.x + p.y * p.y);
          z = asinz(rh / this.a);
          sinz = Math.sin(z);
          cosz = Math.cos(z);
          lon = this.long0;
          if (Math.abs(rh) <= EPSLN) {
            lat = this.lat0;
            p.x = lon;
            p.y = lat;
            return p;
          }
          lat = asinz(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
          con = Math.abs(this.lat0) - HALF_PI;
          if (Math.abs(con) <= EPSLN) {
            if (this.lat0 >= 0) {
              lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
            } else {
              lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
            }
            p.x = lon;
            p.y = lat;
            return p;
          }
          lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
          p.x = lon;
          p.y = lat;
          return p;
        }
        var ortho_names = ["ortho"];
        var ortho = {
          init: ortho_init,
          forward: ortho_forward,
          inverse: ortho_inverse,
          names: ortho_names
        };
        var FACE_ENUM = {
          FRONT: 1,
          RIGHT: 2,
          BACK: 3,
          LEFT: 4,
          TOP: 5,
          BOTTOM: 6
        };
        var AREA_ENUM = {
          AREA_0: 1,
          AREA_1: 2,
          AREA_2: 3,
          AREA_3: 4
        };
        function qsc_init() {
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          this.lat0 = this.lat0 || 0;
          this.long0 = this.long0 || 0;
          this.lat_ts = this.lat_ts || 0;
          this.title = this.title || "Quadrilateralized Spherical Cube";
          if (this.lat0 >= HALF_PI - FORTPI / 2) {
            this.face = FACE_ENUM.TOP;
          } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
            this.face = FACE_ENUM.BOTTOM;
          } else if (Math.abs(this.long0) <= FORTPI) {
            this.face = FACE_ENUM.FRONT;
          } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
            this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
          } else {
            this.face = FACE_ENUM.BACK;
          }
          if (this.es !== 0) {
            this.one_minus_f = 1 - (this.a - this.b) / this.a;
            this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
          }
        }
        function qsc_forward(p) {
          var xy = { x: 0, y: 0 };
          var lat, lon;
          var theta, phi;
          var t, mu;
          var area = { value: 0 };
          p.x -= this.long0;
          if (this.es !== 0) {
            lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
          } else {
            lat = p.y;
          }
          lon = p.x;
          if (this.face === FACE_ENUM.TOP) {
            phi = HALF_PI - lat;
            if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
              area.value = AREA_ENUM.AREA_0;
              theta = lon - HALF_PI;
            } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
              area.value = AREA_ENUM.AREA_1;
              theta = lon > 0 ? lon - SPI : lon + SPI;
            } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
              area.value = AREA_ENUM.AREA_2;
              theta = lon + HALF_PI;
            } else {
              area.value = AREA_ENUM.AREA_3;
              theta = lon;
            }
          } else if (this.face === FACE_ENUM.BOTTOM) {
            phi = HALF_PI + lat;
            if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
              area.value = AREA_ENUM.AREA_0;
              theta = -lon + HALF_PI;
            } else if (lon < FORTPI && lon >= -FORTPI) {
              area.value = AREA_ENUM.AREA_1;
              theta = -lon;
            } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
              area.value = AREA_ENUM.AREA_2;
              theta = -lon - HALF_PI;
            } else {
              area.value = AREA_ENUM.AREA_3;
              theta = lon > 0 ? -lon + SPI : -lon - SPI;
            }
          } else {
            var q, r, s;
            var sinlat, coslat;
            var sinlon, coslon;
            if (this.face === FACE_ENUM.RIGHT) {
              lon = qsc_shift_lon_origin(lon, +HALF_PI);
            } else if (this.face === FACE_ENUM.BACK) {
              lon = qsc_shift_lon_origin(lon, +SPI);
            } else if (this.face === FACE_ENUM.LEFT) {
              lon = qsc_shift_lon_origin(lon, -HALF_PI);
            }
            sinlat = Math.sin(lat);
            coslat = Math.cos(lat);
            sinlon = Math.sin(lon);
            coslon = Math.cos(lon);
            q = coslat * coslon;
            r = coslat * sinlon;
            s = sinlat;
            if (this.face === FACE_ENUM.FRONT) {
              phi = Math.acos(q);
              theta = qsc_fwd_equat_face_theta(phi, s, r, area);
            } else if (this.face === FACE_ENUM.RIGHT) {
              phi = Math.acos(r);
              theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
            } else if (this.face === FACE_ENUM.BACK) {
              phi = Math.acos(-q);
              theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
            } else if (this.face === FACE_ENUM.LEFT) {
              phi = Math.acos(-r);
              theta = qsc_fwd_equat_face_theta(phi, s, q, area);
            } else {
              phi = theta = 0;
              area.value = AREA_ENUM.AREA_0;
            }
          }
          mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
          t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
          if (area.value === AREA_ENUM.AREA_1) {
            mu += HALF_PI;
          } else if (area.value === AREA_ENUM.AREA_2) {
            mu += SPI;
          } else if (area.value === AREA_ENUM.AREA_3) {
            mu += 1.5 * SPI;
          }
          xy.x = t * Math.cos(mu);
          xy.y = t * Math.sin(mu);
          xy.x = xy.x * this.a + this.x0;
          xy.y = xy.y * this.a + this.y0;
          p.x = xy.x;
          p.y = xy.y;
          return p;
        }
        function qsc_inverse(p) {
          var lp = { lam: 0, phi: 0 };
          var mu, nu, cosmu, tannu;
          var tantheta, theta, cosphi, phi;
          var t;
          var area = { value: 0 };
          p.x = (p.x - this.x0) / this.a;
          p.y = (p.y - this.y0) / this.a;
          nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
          mu = Math.atan2(p.y, p.x);
          if (p.x >= 0 && p.x >= Math.abs(p.y)) {
            area.value = AREA_ENUM.AREA_0;
          } else if (p.y >= 0 && p.y >= Math.abs(p.x)) {
            area.value = AREA_ENUM.AREA_1;
            mu -= HALF_PI;
          } else if (p.x < 0 && -p.x >= Math.abs(p.y)) {
            area.value = AREA_ENUM.AREA_2;
            mu = mu < 0 ? mu + SPI : mu - SPI;
          } else {
            area.value = AREA_ENUM.AREA_3;
            mu += HALF_PI;
          }
          t = SPI / 12 * Math.tan(mu);
          tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
          theta = Math.atan(tantheta);
          cosmu = Math.cos(mu);
          tannu = Math.tan(nu);
          cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
          if (cosphi < -1) {
            cosphi = -1;
          } else if (cosphi > 1) {
            cosphi = 1;
          }
          if (this.face === FACE_ENUM.TOP) {
            phi = Math.acos(cosphi);
            lp.phi = HALF_PI - phi;
            if (area.value === AREA_ENUM.AREA_0) {
              lp.lam = theta + HALF_PI;
            } else if (area.value === AREA_ENUM.AREA_1) {
              lp.lam = theta < 0 ? theta + SPI : theta - SPI;
            } else if (area.value === AREA_ENUM.AREA_2) {
              lp.lam = theta - HALF_PI;
            } else {
              lp.lam = theta;
            }
          } else if (this.face === FACE_ENUM.BOTTOM) {
            phi = Math.acos(cosphi);
            lp.phi = phi - HALF_PI;
            if (area.value === AREA_ENUM.AREA_0) {
              lp.lam = -theta + HALF_PI;
            } else if (area.value === AREA_ENUM.AREA_1) {
              lp.lam = -theta;
            } else if (area.value === AREA_ENUM.AREA_2) {
              lp.lam = -theta - HALF_PI;
            } else {
              lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
            }
          } else {
            var q, r, s;
            q = cosphi;
            t = q * q;
            if (t >= 1) {
              s = 0;
            } else {
              s = Math.sqrt(1 - t) * Math.sin(theta);
            }
            t += s * s;
            if (t >= 1) {
              r = 0;
            } else {
              r = Math.sqrt(1 - t);
            }
            if (area.value === AREA_ENUM.AREA_1) {
              t = r;
              r = -s;
              s = t;
            } else if (area.value === AREA_ENUM.AREA_2) {
              r = -r;
              s = -s;
            } else if (area.value === AREA_ENUM.AREA_3) {
              t = r;
              r = s;
              s = -t;
            }
            if (this.face === FACE_ENUM.RIGHT) {
              t = q;
              q = -r;
              r = t;
            } else if (this.face === FACE_ENUM.BACK) {
              q = -q;
              r = -r;
            } else if (this.face === FACE_ENUM.LEFT) {
              t = q;
              q = r;
              r = -t;
            }
            lp.phi = Math.acos(-s) - HALF_PI;
            lp.lam = Math.atan2(r, q);
            if (this.face === FACE_ENUM.RIGHT) {
              lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
            } else if (this.face === FACE_ENUM.BACK) {
              lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
            } else if (this.face === FACE_ENUM.LEFT) {
              lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
            }
          }
          if (this.es !== 0) {
            var invert_sign;
            var tanphi, xa;
            invert_sign = lp.phi < 0 ? 1 : 0;
            tanphi = Math.tan(lp.phi);
            xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
            lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
            if (invert_sign) {
              lp.phi = -lp.phi;
            }
          }
          lp.lam += this.long0;
          p.x = lp.lam;
          p.y = lp.phi;
          return p;
        }
        function qsc_fwd_equat_face_theta(phi, y, x, area) {
          var theta;
          if (phi < EPSLN) {
            area.value = AREA_ENUM.AREA_0;
            theta = 0;
          } else {
            theta = Math.atan2(y, x);
            if (Math.abs(theta) <= FORTPI) {
              area.value = AREA_ENUM.AREA_0;
            } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
              area.value = AREA_ENUM.AREA_1;
              theta -= HALF_PI;
            } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
              area.value = AREA_ENUM.AREA_2;
              theta = theta >= 0 ? theta - SPI : theta + SPI;
            } else {
              area.value = AREA_ENUM.AREA_3;
              theta += HALF_PI;
            }
          }
          return theta;
        }
        function qsc_shift_lon_origin(lon, offset) {
          var slon = lon + offset;
          if (slon < -SPI) {
            slon += TWO_PI;
          } else if (slon > +SPI) {
            slon -= TWO_PI;
          }
          return slon;
        }
        var qsc_names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
        var qsc = {
          init: qsc_init,
          forward: qsc_forward,
          inverse: qsc_inverse,
          names: qsc_names
        };
        var COEFS_X = [
          [1, 22199e-21, -715515e-10, 31103e-10],
          [0.9986, -482243e-9, -24897e-9, -13309e-10],
          [0.9954, -83103e-8, -448605e-10, -986701e-12],
          [0.99, -135364e-8, -59661e-9, 36777e-10],
          [0.9822, -167442e-8, -449547e-11, -572411e-11],
          [0.973, -214868e-8, -903571e-10, 18736e-12],
          [0.96, -305085e-8, -900761e-10, 164917e-11],
          [0.9427, -382792e-8, -653386e-10, -26154e-10],
          [0.9216, -467746e-8, -10457e-8, 481243e-11],
          [0.8962, -536223e-8, -323831e-10, -543432e-11],
          [0.8679, -609363e-8, -113898e-9, 332484e-11],
          [0.835, -698325e-8, -640253e-10, 934959e-12],
          [0.7986, -755338e-8, -500009e-10, 935324e-12],
          [0.7597, -798324e-8, -35971e-9, -227626e-11],
          [0.7186, -851367e-8, -701149e-10, -86303e-10],
          [0.6732, -986209e-8, -199569e-9, 191974e-10],
          [0.6213, -0.010418, 883923e-10, 624051e-11],
          [0.5722, -906601e-8, 182e-6, 624051e-11],
          [0.5322, -677797e-8, 275608e-9, 624051e-11]
        ];
        var COEFS_Y = [
          [-520417e-23, 0.0124, 121431e-23, -845284e-16],
          [0.062, 0.0124, -126793e-14, 422642e-15],
          [0.124, 0.0124, 507171e-14, -160604e-14],
          [0.186, 0.0123999, -190189e-13, 600152e-14],
          [0.248, 0.0124002, 710039e-13, -224e-10],
          [0.31, 0.0123992, -264997e-12, 835986e-13],
          [0.372, 0.0124029, 988983e-12, -311994e-12],
          [0.434, 0.0123893, -369093e-11, -435621e-12],
          [0.4958, 0.0123198, -102252e-10, -345523e-12],
          [0.5571, 0.0121916, -154081e-10, -582288e-12],
          [0.6176, 0.0119938, -241424e-10, -525327e-12],
          [0.6769, 0.011713, -320223e-10, -516405e-12],
          [0.7346, 0.0113541, -397684e-10, -609052e-12],
          [0.7903, 0.0109107, -489042e-10, -104739e-11],
          [0.8435, 0.0103431, -64615e-9, -140374e-14],
          [0.8936, 969686e-8, -64636e-9, -8547e-9],
          [0.9394, 840947e-8, -192841e-9, -42106e-10],
          [0.9761, 616527e-8, -256e-6, -42106e-10],
          [1, 328947e-8, -319159e-9, -42106e-10]
        ];
        var FXC = 0.8487;
        var FYC = 1.3523;
        var C1 = R2D / 5;
        var RC1 = 1 / C1;
        var NODES = 18;
        var poly3_val = function(coefs, x) {
          return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
        };
        var poly3_der = function(coefs, x) {
          return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
        };
        function newton_rapshon(f_df, start, max_err, iters) {
          var x = start;
          for (; iters; --iters) {
            var upd = f_df(x);
            x -= upd;
            if (Math.abs(upd) < max_err) {
              break;
            }
          }
          return x;
        }
        function robin_init() {
          this.x0 = this.x0 || 0;
          this.y0 = this.y0 || 0;
          this.long0 = this.long0 || 0;
          this.es = 0;
          this.title = this.title || "Robinson";
        }
        function robin_forward(ll) {
          var lon = adjust_lon(ll.x - this.long0);
          var dphi = Math.abs(ll.y);
          var i = Math.floor(dphi * C1);
          if (i < 0) {
            i = 0;
          } else if (i >= NODES) {
            i = NODES - 1;
          }
          dphi = R2D * (dphi - RC1 * i);
          var xy = {
            x: poly3_val(COEFS_X[i], dphi) * lon,
            y: poly3_val(COEFS_Y[i], dphi)
          };
          if (ll.y < 0) {
            xy.y = -xy.y;
          }
          xy.x = xy.x * this.a * FXC + this.x0;
          xy.y = xy.y * this.a * FYC + this.y0;
          return xy;
        }
        function robin_inverse(xy) {
          var ll = {
            x: (xy.x - this.x0) / (this.a * FXC),
            y: Math.abs(xy.y - this.y0) / (this.a * FYC)
          };
          if (ll.y >= 1) {
            ll.x /= COEFS_X[NODES][0];
            ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
          } else {
            var i = Math.floor(ll.y * NODES);
            if (i < 0) {
              i = 0;
            } else if (i >= NODES) {
              i = NODES - 1;
            }
            for (; ; ) {
              if (COEFS_Y[i][0] > ll.y) {
                --i;
              } else if (COEFS_Y[i + 1][0] <= ll.y) {
                ++i;
              } else {
                break;
              }
            }
            var coefs = COEFS_Y[i];
            var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
            t = newton_rapshon(function(x) {
              return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
            }, t, EPSLN, 100);
            ll.x /= poly3_val(COEFS_X[i], t);
            ll.y = (5 * i + t) * D2R;
            if (xy.y < 0) {
              ll.y = -ll.y;
            }
          }
          ll.x = adjust_lon(ll.x + this.long0);
          return ll;
        }
        var robin_names = ["Robinson", "robin"];
        var robin = {
          init: robin_init,
          forward: robin_forward,
          inverse: robin_inverse,
          names: robin_names
        };
        function geocent_init() {
          this.name = "geocent";
        }
        function geocent_forward(p) {
          var point = geodeticToGeocentric(p, this.es, this.a);
          return point;
        }
        function geocent_inverse(p) {
          var point = geocentricToGeodetic(p, this.es, this.a, this.b);
          return point;
        }
        var geocent_names = ["Geocentric", "geocentric", "geocent", "Geocent"];
        var geocent = {
          init: geocent_init,
          forward: geocent_forward,
          inverse: geocent_inverse,
          names: geocent_names
        };
        var tpers_mode = {
          N_POLE: 0,
          S_POLE: 1,
          EQUIT: 2,
          OBLIQ: 3
        };
        var tpers_params = {
          h: { def: 1e5, num: true },
          azi: { def: 0, num: true, degrees: true },
          tilt: { def: 0, num: true, degrees: true },
          long0: { def: 0, num: true },
          lat0: { def: 0, num: true }
        };
        function tpers_init() {
          Object.keys(tpers_params).forEach(function(p) {
            if (typeof this[p] === "undefined") {
              this[p] = tpers_params[p].def;
            } else if (tpers_params[p].num && isNaN(this[p])) {
              throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
            } else if (tpers_params[p].num) {
              this[p] = parseFloat(this[p]);
            }
            if (tpers_params[p].degrees) {
              this[p] = this[p] * D2R;
            }
          }.bind(this));
          if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
            this.mode = this.lat0 < 0 ? tpers_mode.S_POLE : tpers_mode.N_POLE;
          } else if (Math.abs(this.lat0) < EPSLN) {
            this.mode = tpers_mode.EQUIT;
          } else {
            this.mode = tpers_mode.OBLIQ;
            this.sinph0 = Math.sin(this.lat0);
            this.cosph0 = Math.cos(this.lat0);
          }
          this.pn1 = this.h / this.a;
          if (this.pn1 <= 0 || this.pn1 > 1e10) {
            throw new Error("Invalid height");
          }
          this.p = 1 + this.pn1;
          this.rp = 1 / this.p;
          this.h1 = 1 / this.pn1;
          this.pfact = (this.p + 1) * this.h1;
          this.es = 0;
          var omega = this.tilt;
          var gamma = this.azi;
          this.cg = Math.cos(gamma);
          this.sg = Math.sin(gamma);
          this.cw = Math.cos(omega);
          this.sw = Math.sin(omega);
        }
        function tpers_forward(p) {
          p.x -= this.long0;
          var sinphi = Math.sin(p.y);
          var cosphi = Math.cos(p.y);
          var coslam = Math.cos(p.x);
          var x, y;
          switch (this.mode) {
            case tpers_mode.OBLIQ:
              y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
              break;
            case tpers_mode.EQUIT:
              y = cosphi * coslam;
              break;
            case tpers_mode.S_POLE:
              y = -sinphi;
              break;
            case tpers_mode.N_POLE:
              y = sinphi;
              break;
          }
          y = this.pn1 / (this.p - y);
          x = y * cosphi * Math.sin(p.x);
          switch (this.mode) {
            case tpers_mode.OBLIQ:
              y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
              break;
            case tpers_mode.EQUIT:
              y *= sinphi;
              break;
            case tpers_mode.N_POLE:
              y *= -(cosphi * coslam);
              break;
            case tpers_mode.S_POLE:
              y *= cosphi * coslam;
              break;
          }
          var yt, ba;
          yt = y * this.cg + x * this.sg;
          ba = 1 / (yt * this.sw * this.h1 + this.cw);
          x = (x * this.cg - y * this.sg) * this.cw * ba;
          y = yt * ba;
          p.x = x * this.a;
          p.y = y * this.a;
          return p;
        }
        function tpers_inverse(p) {
          p.x /= this.a;
          p.y /= this.a;
          var r = { x: p.x, y: p.y };
          var bm, bq, yt;
          yt = 1 / (this.pn1 - p.y * this.sw);
          bm = this.pn1 * p.x * yt;
          bq = this.pn1 * p.y * this.cw * yt;
          p.x = bm * this.cg + bq * this.sg;
          p.y = bq * this.cg - bm * this.sg;
          var rh = hypot(p.x, p.y);
          if (Math.abs(rh) < EPSLN) {
            r.x = 0;
            r.y = p.y;
          } else {
            var cosz, sinz;
            sinz = 1 - rh * rh * this.pfact;
            sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
            cosz = Math.sqrt(1 - sinz * sinz);
            switch (this.mode) {
              case tpers_mode.OBLIQ:
                r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
                p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
                p.x *= sinz * this.cosph0;
                break;
              case tpers_mode.EQUIT:
                r.y = Math.asin(p.y * sinz / rh);
                p.y = cosz * rh;
                p.x *= sinz;
                break;
              case tpers_mode.N_POLE:
                r.y = Math.asin(cosz);
                p.y = -p.y;
                break;
              case tpers_mode.S_POLE:
                r.y = -Math.asin(cosz);
                break;
            }
            r.x = Math.atan2(p.x, p.y);
          }
          p.x = r.x + this.long0;
          p.y = r.y;
          return p;
        }
        var tpers_names = ["Tilted_Perspective", "tpers"];
        var tpers = {
          init: tpers_init,
          forward: tpers_forward,
          inverse: tpers_inverse,
          names: tpers_names
        };
        var proj4_projs = function(proj4) {
          proj4.Proj.projections.add(tmerc);
          proj4.Proj.projections.add(etmerc);
          proj4.Proj.projections.add(utm);
          proj4.Proj.projections.add(sterea);
          proj4.Proj.projections.add(stere);
          proj4.Proj.projections.add(somerc);
          proj4.Proj.projections.add(omerc);
          proj4.Proj.projections.add(lcc);
          proj4.Proj.projections.add(krovak);
          proj4.Proj.projections.add(cass);
          proj4.Proj.projections.add(laea);
          proj4.Proj.projections.add(aea);
          proj4.Proj.projections.add(gnom);
          proj4.Proj.projections.add(cea);
          proj4.Proj.projections.add(eqc);
          proj4.Proj.projections.add(projections_poly);
          proj4.Proj.projections.add(nzmg);
          proj4.Proj.projections.add(mill);
          proj4.Proj.projections.add(sinu);
          proj4.Proj.projections.add(moll);
          proj4.Proj.projections.add(eqdc);
          proj4.Proj.projections.add(vandg);
          proj4.Proj.projections.add(aeqd);
          proj4.Proj.projections.add(ortho);
          proj4.Proj.projections.add(qsc);
          proj4.Proj.projections.add(robin);
          proj4.Proj.projections.add(geocent);
          proj4.Proj.projections.add(tpers);
        };
        core.defaultDatum = "WGS84";
        core.Proj = Proj;
        core.WGS84 = new core.Proj("WGS84");
        core.Point = lib_Point;
        core.toPoint = toPoint;
        core.defs = lib_defs;
        core.nadgrid = nadgrid;
        core.transform = transform_transform;
        core.mgrs = mgrs;
        core.version = "__VERSION__";
        proj4_projs(core);
        var lib = core;
        function proj4_register(proj4) {
          var projCodes = Object.keys(proj4.defs);
          var len = projCodes.length;
          var i, j;
          for (i = 0; i < len; ++i) {
            var code = projCodes[i];
            if (!proj_get(code)) {
              var def = proj4.defs(code);
              var units = def.units;
              if (!units && def.projName === "longlat") {
                units = proj_Units.DEGREES;
              }
              addProjection(new proj_Projection({
                code,
                axisOrientation: def.axis,
                metersPerUnit: def.to_meter,
                units
              }));
            }
          }
          for (i = 0; i < len; ++i) {
            var code1 = projCodes[i];
            var proj1 = proj_get(code1);
            for (j = 0; j < len; ++j) {
              var code2 = projCodes[j];
              var proj2 = proj_get(code2);
              if (!transforms_get(code1, code2)) {
                if (proj4.defs[code1] === proj4.defs[code2]) {
                  addEquivalentProjections([proj1, proj2]);
                } else {
                  var transform2 = proj4(code1, code2);
                  addCoordinateTransforms(proj1, proj2, createSafeCoordinateTransform(proj1, proj2, transform2.forward), createSafeCoordinateTransform(proj2, proj1, transform2.inverse));
                }
              }
            }
          }
        }
        var Projectionvue_type_script_lang_js = {
          name: "ol-projection-register",
          setup: function setup(props) {
            var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props), projectionName = _toRefs.projectionName, projectionDef = _toRefs.projectionDef, projectionExtent = _toRefs.projectionExtent;
            lib.defs(projectionName.value, projectionDef.value);
            proj4_register(lib);
            var projection = new proj_Projection({
              code: projectionName.value,
              extent: projectionExtent.value
            });
            return {
              projection
            };
          },
          props: {
            projectionName: {
              type: String
            },
            projectionDef: {
              type: String
            },
            projectionExtent: {
              type: Array
            }
          }
        };
        const Projection_exports_ = exportHelper_default()(Projectionvue_type_script_lang_js, [["render", Projectionvue_type_template_id_07dd68fa_lang_true_render]]);
        var map_Projection = Projection_exports_;
        function install(app) {
          if (install.installed) {
            return;
          }
          install.installed = true;
          app.component(map_Map.name, map_Map);
          app.component(map_View.name, map_View);
          app.component(map_Feature.name, map_Feature);
          app.component(map_Overlay.name, map_Overlay);
          app.component(GeoLocation.name, GeoLocation);
          app.component(map_Projection.name, map_Projection);
        }
        var components_map = install;
        function TileLayervue_type_template_id_33e916fb_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var TileProperty = {
          PRELOAD: "preload",
          USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
        };
        var BaseTile_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var BaseTile_BaseTileLayer = function(_super) {
          BaseTile_extends(BaseTileLayer, _super);
          function BaseTileLayer(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var baseOptions = Object(ol_obj["a"])({}, options);
            delete baseOptions.preload;
            delete baseOptions.useInterimTilesOnError;
            _this = _super.call(this, baseOptions) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.setPreload(options.preload !== void 0 ? options.preload : 0);
            _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);
            return _this;
          }
          BaseTileLayer.prototype.getPreload = function() {
            return this.get(TileProperty.PRELOAD);
          };
          BaseTileLayer.prototype.setPreload = function(preload) {
            this.set(TileProperty.PRELOAD, preload);
          };
          BaseTileLayer.prototype.getUseInterimTilesOnError = function() {
            return this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR);
          };
          BaseTileLayer.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
            this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
          };
          return BaseTileLayer;
        }(layer_Layer);
        var BaseTile = BaseTile_BaseTileLayer;
        var ImageState = {
          IDLE: 0,
          LOADING: 1,
          LOADED: 2,
          ERROR: 3,
          EMPTY: 4
        };
        var Observable = __webpack_require__("35a7");
        var renderer_Layer_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Layer_LayerRenderer = function(_super) {
          renderer_Layer_extends(LayerRenderer, _super);
          function LayerRenderer(layer) {
            var _this = _super.call(this) || this;
            _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
            _this.layer_ = layer;
            _this.declutterExecutorGroup = null;
            return _this;
          }
          LayerRenderer.prototype.getFeatures = function(pixel) {
            return Object(util["b"])();
          };
          LayerRenderer.prototype.prepareFrame = function(frameState) {
            return Object(util["b"])();
          };
          LayerRenderer.prototype.renderFrame = function(frameState, target) {
            return Object(util["b"])();
          };
          LayerRenderer.prototype.loadedTileCallback = function(tiles, zoom, tile) {
            if (!tiles[zoom]) {
              tiles[zoom] = {};
            }
            tiles[zoom][tile.tileCoord.toString()] = tile;
            return void 0;
          };
          LayerRenderer.prototype.createLoadedTileFinder = function(source, projection, tiles) {
            return function(zoom, tileRange) {
              var callback = this.loadedTileCallback.bind(this, tiles, zoom);
              return source.forEachLoadedTile(projection, zoom, tileRange, callback);
            }.bind(this);
          };
          LayerRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
            return void 0;
          };
          LayerRenderer.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
            return null;
          };
          LayerRenderer.prototype.getLayer = function() {
            return this.layer_;
          };
          LayerRenderer.prototype.handleFontsChanged = function() {
          };
          LayerRenderer.prototype.handleImageChange_ = function(event) {
            var image = event.target;
            if (image.getState() === ImageState.LOADED) {
              this.renderIfReadyAndVisible();
            }
          };
          LayerRenderer.prototype.loadImage = function(image) {
            var imageState = image.getState();
            if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
              image.addEventListener(EventType["a"].CHANGE, this.boundHandleImageChange_);
            }
            if (imageState == ImageState.IDLE) {
              image.load();
              imageState = image.getState();
            }
            return imageState == ImageState.LOADED;
          };
          LayerRenderer.prototype.renderIfReadyAndVisible = function() {
            var layer = this.getLayer();
            if (layer.getVisible() && layer.getSourceState() == State.READY) {
              layer.changed();
            }
          };
          return LayerRenderer;
        }(Observable["a"]);
        var renderer_Layer = Layer_LayerRenderer;
        var canvas_Layer_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Layer_CanvasLayerRenderer = function(_super) {
          canvas_Layer_extends(CanvasLayerRenderer, _super);
          function CanvasLayerRenderer(layer) {
            var _this = _super.call(this, layer) || this;
            _this.container = null;
            _this.renderedResolution;
            _this.tempTransform = create();
            _this.pixelTransform = create();
            _this.inversePixelTransform = create();
            _this.context = null;
            _this.containerReused = false;
            _this.pixelContext_ = null;
            return _this;
          }
          CanvasLayerRenderer.prototype.getBackground = function(frameState) {
            var layer = this.getLayer();
            var background = layer.getBackground();
            if (typeof background === "function") {
              background = background(frameState.viewState.resolution);
            }
            return background || void 0;
          };
          CanvasLayerRenderer.prototype.useContainer = function(target, transform2, opacity, opt_backgroundColor) {
            var layerClassName = this.getLayer().getClassName();
            var container, context;
            if (target && target.className === layerClassName && target.style.opacity === "" && opacity === 1 && (!opt_backgroundColor || target.style.backgroundColor && Object(ol_array["b"])(asArray(target.style.backgroundColor), asArray(opt_backgroundColor)))) {
              var canvas = target.firstElementChild;
              if (canvas instanceof HTMLCanvasElement) {
                context = canvas.getContext("2d");
              }
            }
            if (context && context.canvas.style.transform === transform2) {
              this.container = target;
              this.context = context;
              this.containerReused = true;
            } else if (this.containerReused) {
              this.container = null;
              this.context = null;
              this.containerReused = false;
            }
            if (!this.container) {
              container = document.createElement("div");
              container.className = layerClassName;
              var style = container.style;
              style.position = "absolute";
              style.width = "100%";
              style.height = "100%";
              if (opt_backgroundColor) {
                style.backgroundColor = opt_backgroundColor;
              }
              context = Object(dom["a"])();
              var canvas = context.canvas;
              container.appendChild(canvas);
              style = canvas.style;
              style.position = "absolute";
              style.left = "0";
              style.transformOrigin = "top left";
              this.container = container;
              this.context = context;
            }
          };
          CanvasLayerRenderer.prototype.clipUnrotated = function(context, frameState, extent) {
            var topLeft = getTopLeft(extent);
            var topRight = getTopRight(extent);
            var bottomRight = getBottomRight(extent);
            var bottomLeft = getBottomLeft(extent);
            apply(frameState.coordinateToPixelTransform, topLeft);
            apply(frameState.coordinateToPixelTransform, topRight);
            apply(frameState.coordinateToPixelTransform, bottomRight);
            apply(frameState.coordinateToPixelTransform, bottomLeft);
            var inverted = this.inversePixelTransform;
            apply(inverted, topLeft);
            apply(inverted, topRight);
            apply(inverted, bottomRight);
            apply(inverted, bottomLeft);
            context.save();
            context.beginPath();
            context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
            context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
            context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
            context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
            context.clip();
          };
          CanvasLayerRenderer.prototype.dispatchRenderEvent_ = function(type, context, frameState) {
            var layer = this.getLayer();
            if (layer.hasListener(type)) {
              var event_1 = new render_Event(type, this.inversePixelTransform, frameState, context);
              layer.dispatchEvent(event_1);
            }
          };
          CanvasLayerRenderer.prototype.preRender = function(context, frameState) {
            this.dispatchRenderEvent_(render_EventType.PRERENDER, context, frameState);
          };
          CanvasLayerRenderer.prototype.postRender = function(context, frameState) {
            this.dispatchRenderEvent_(render_EventType.POSTRENDER, context, frameState);
          };
          CanvasLayerRenderer.prototype.getRenderTransform = function(center, resolution, rotation, pixelRatio, width, height, offsetX) {
            var dx1 = width / 2;
            var dy1 = height / 2;
            var sx = pixelRatio / resolution;
            var sy = -sx;
            var dx2 = -center[0] + offsetX;
            var dy2 = -center[1];
            return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
          };
          CanvasLayerRenderer.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
            var renderPixel = apply(this.inversePixelTransform, pixel.slice());
            var context = this.context;
            var layer = this.getLayer();
            var layerExtent = layer.getExtent();
            if (layerExtent) {
              var renderCoordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
              if (!containsCoordinate(layerExtent, renderCoordinate)) {
                return null;
              }
            }
            var x = Math.round(renderPixel[0]);
            var y = Math.round(renderPixel[1]);
            var pixelContext = this.pixelContext_;
            if (!pixelContext) {
              var pixelCanvas = document.createElement("canvas");
              pixelCanvas.width = 1;
              pixelCanvas.height = 1;
              pixelContext = pixelCanvas.getContext("2d");
              this.pixelContext_ = pixelContext;
            }
            pixelContext.clearRect(0, 0, 1, 1);
            var data;
            try {
              pixelContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
              data = pixelContext.getImageData(0, 0, 1, 1).data;
            } catch (err) {
              if (err.name === "SecurityError") {
                this.pixelContext_ = null;
                return new Uint8Array();
              }
              return data;
            }
            if (data[3] === 0) {
              return null;
            }
            return data;
          };
          return CanvasLayerRenderer;
        }(renderer_Layer);
        var canvas_Layer = Layer_CanvasLayerRenderer;
        var TileRange = function() {
          function TileRange2(minX, maxX, minY, maxY) {
            this.minX = minX;
            this.maxX = maxX;
            this.minY = minY;
            this.maxY = maxY;
          }
          TileRange2.prototype.contains = function(tileCoord) {
            return this.containsXY(tileCoord[1], tileCoord[2]);
          };
          TileRange2.prototype.containsTileRange = function(tileRange) {
            return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
          };
          TileRange2.prototype.containsXY = function(x, y) {
            return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
          };
          TileRange2.prototype.equals = function(tileRange) {
            return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
          };
          TileRange2.prototype.extend = function(tileRange) {
            if (tileRange.minX < this.minX) {
              this.minX = tileRange.minX;
            }
            if (tileRange.maxX > this.maxX) {
              this.maxX = tileRange.maxX;
            }
            if (tileRange.minY < this.minY) {
              this.minY = tileRange.minY;
            }
            if (tileRange.maxY > this.maxY) {
              this.maxY = tileRange.maxY;
            }
          };
          TileRange2.prototype.getHeight = function() {
            return this.maxY - this.minY + 1;
          };
          TileRange2.prototype.getSize = function() {
            return [this.getWidth(), this.getHeight()];
          };
          TileRange2.prototype.getWidth = function() {
            return this.maxX - this.minX + 1;
          };
          TileRange2.prototype.intersects = function(tileRange) {
            return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
          };
          return TileRange2;
        }();
        function TileRange_createOrUpdate(minX, maxX, minY, maxY, tileRange) {
          if (tileRange !== void 0) {
            tileRange.minX = minX;
            tileRange.maxX = maxX;
            tileRange.minY = minY;
            tileRange.maxY = maxY;
            return tileRange;
          } else {
            return new TileRange(minX, maxX, minY, maxY);
          }
        }
        var ol_TileRange = TileRange;
        var IMAGE_SMOOTHING_DISABLED = {
          imageSmoothingEnabled: false,
          msImageSmoothingEnabled: false
        };
        var IMAGE_SMOOTHING_ENABLED = {
          imageSmoothingEnabled: true,
          msImageSmoothingEnabled: true
        };
        var TileLayer_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var TileLayer_CanvasTileLayerRenderer = function(_super) {
          TileLayer_extends(CanvasTileLayerRenderer, _super);
          function CanvasTileLayerRenderer(tileLayer) {
            var _this = _super.call(this, tileLayer) || this;
            _this.extentChanged = true;
            _this.renderedExtent_ = null;
            _this.renderedPixelRatio;
            _this.renderedProjection = null;
            _this.renderedRevision;
            _this.renderedTiles = [];
            _this.newTiles_ = false;
            _this.tmpExtent = createEmpty();
            _this.tmpTileRange_ = new ol_TileRange(0, 0, 0, 0);
            return _this;
          }
          CanvasTileLayerRenderer.prototype.isDrawableTile = function(tile) {
            var tileLayer = this.getLayer();
            var tileState = tile.getState();
            var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
            return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;
          };
          CanvasTileLayerRenderer.prototype.getTile = function(z, x, y, frameState) {
            var pixelRatio = frameState.pixelRatio;
            var projection = frameState.viewState.projection;
            var tileLayer = this.getLayer();
            var tileSource = tileLayer.getSource();
            var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == TileState.ERROR) {
              if (!tileLayer.getUseInterimTilesOnError()) {
                tile.setState(TileState.LOADED);
              } else if (tileLayer.getPreload() > 0) {
                this.newTiles_ = true;
              }
            }
            if (!this.isDrawableTile(tile)) {
              tile = tile.getInterimTile();
            }
            return tile;
          };
          CanvasTileLayerRenderer.prototype.loadedTileCallback = function(tiles, zoom, tile) {
            if (this.isDrawableTile(tile)) {
              return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);
            }
            return false;
          };
          CanvasTileLayerRenderer.prototype.prepareFrame = function(frameState) {
            return !!this.getLayer().getSource();
          };
          CanvasTileLayerRenderer.prototype.renderFrame = function(frameState, target) {
            var layerState = frameState.layerStatesArray[frameState.layerIndex];
            var viewState = frameState.viewState;
            var projection = viewState.projection;
            var viewResolution = viewState.resolution;
            var viewCenter = viewState.center;
            var rotation = viewState.rotation;
            var pixelRatio = frameState.pixelRatio;
            var tileLayer = this.getLayer();
            var tileSource = tileLayer.getSource();
            var sourceRevision = tileSource.getRevision();
            var tileGrid = tileSource.getTileGridForProjection(projection);
            var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
            var tileResolution = tileGrid.getResolution(z);
            var extent = frameState.extent;
            var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
            if (layerExtent) {
              extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));
            }
            var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
            var width = Math.round(frameState.size[0] * tilePixelRatio);
            var height = Math.round(frameState.size[1] * tilePixelRatio);
            if (rotation) {
              var size = Math.round(Math.sqrt(width * width + height * height));
              width = size;
              height = size;
            }
            var dx = tileResolution * width / 2 / tilePixelRatio;
            var dy = tileResolution * height / 2 / tilePixelRatio;
            var canvasExtent = [
              viewCenter[0] - dx,
              viewCenter[1] - dy,
              viewCenter[0] + dx,
              viewCenter[1] + dy
            ];
            var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
            var tilesToDrawByZ = {};
            tilesToDrawByZ[z] = {};
            var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
            var tmpExtent = this.tmpExtent;
            var tmpTileRange = this.tmpTileRange_;
            this.newTiles_ = false;
            for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
              for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                var tile = this.getTile(z, x, y, frameState);
                if (this.isDrawableTile(tile)) {
                  var uid = Object(util["c"])(this);
                  if (tile.getState() == TileState.LOADED) {
                    tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
                    var inTransition = tile.inTransition(uid);
                    if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
                      this.newTiles_ = true;
                    }
                  }
                  if (tile.getAlpha(uid, frameState.time) === 1) {
                    continue;
                  }
                }
                var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
                var covered = false;
                if (childTileRange) {
                  covered = findLoadedTiles(z + 1, childTileRange);
                }
                if (!covered) {
                  tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
                }
              }
            }
            var canvasScale = tileResolution / viewResolution;
            compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
            var canvasTransform = transform_toString(this.pixelTransform);
            this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
            var context = this.context;
            var canvas = context.canvas;
            makeInverse(this.inversePixelTransform, this.pixelTransform);
            compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
            if (canvas.width != width || canvas.height != height) {
              canvas.width = width;
              canvas.height = height;
            } else if (!this.containerReused) {
              context.clearRect(0, 0, width, height);
            }
            if (layerExtent) {
              this.clipUnrotated(context, frameState, layerExtent);
            }
            if (!tileSource.getInterpolate()) {
              Object(ol_obj["a"])(context, IMAGE_SMOOTHING_DISABLED);
            }
            this.preRender(context, frameState);
            this.renderedTiles.length = 0;
            var zs = Object.keys(tilesToDrawByZ).map(Number);
            zs.sort(ol_array["i"]);
            var clips, clipZs, currentClip;
            if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
              zs = zs.reverse();
            } else {
              clips = [];
              clipZs = [];
            }
            for (var i = zs.length - 1; i >= 0; --i) {
              var currentZ = zs[i];
              var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
              var currentResolution = tileGrid.getResolution(currentZ);
              var currentScale = currentResolution / tileResolution;
              var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
              var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
              var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);
              var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
              var origin_1 = apply(this.tempTransform, [
                tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
                tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
              ]);
              var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
              var tilesToDraw = tilesToDrawByZ[currentZ];
              for (var tileCoordKey in tilesToDraw) {
                var tile = tilesToDraw[tileCoordKey];
                var tileCoord = tile.tileCoord;
                var xIndex = originTileCoord[1] - tileCoord[1];
                var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);
                var yIndex = originTileCoord[2] - tileCoord[2];
                var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);
                var x = Math.round(origin_1[0] - xIndex * dx_1);
                var y = Math.round(origin_1[1] - yIndex * dy_1);
                var w = nextX - x;
                var h = nextY - y;
                var transition = z === currentZ;
                var inTransition = transition && tile.getAlpha(Object(util["c"])(this), frameState.time) !== 1;
                if (!inTransition) {
                  if (clips) {
                    context.save();
                    currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
                    for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
                      if (z !== currentZ && currentZ < clipZs[i_1]) {
                        var clip = clips[i_1];
                        context.beginPath();
                        context.moveTo(currentClip[0], currentClip[1]);
                        context.lineTo(currentClip[2], currentClip[3]);
                        context.lineTo(currentClip[4], currentClip[5]);
                        context.lineTo(currentClip[6], currentClip[7]);
                        context.moveTo(clip[6], clip[7]);
                        context.lineTo(clip[4], clip[5]);
                        context.lineTo(clip[2], clip[3]);
                        context.lineTo(clip[0], clip[1]);
                        context.clip();
                      }
                    }
                    clips.push(currentClip);
                    clipZs.push(currentZ);
                  } else {
                    context.clearRect(x, y, w, h);
                  }
                }
                this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);
                if (clips && !inTransition) {
                  context.restore();
                  this.renderedTiles.unshift(tile);
                } else {
                  this.renderedTiles.push(tile);
                }
                this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
              }
            }
            this.renderedRevision = sourceRevision;
            this.renderedResolution = tileResolution;
            this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);
            this.renderedExtent_ = canvasExtent;
            this.renderedPixelRatio = pixelRatio;
            this.renderedProjection = projection;
            this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
            this.scheduleExpireCache(frameState, tileSource);
            this.postRender(context, frameState);
            if (layerState.extent) {
              context.restore();
            }
            Object(ol_obj["a"])(context, IMAGE_SMOOTHING_ENABLED);
            if (canvasTransform !== canvas.style.transform) {
              canvas.style.transform = canvasTransform;
            }
            var opacity = cssOpacity(layerState.opacity);
            var container = this.container;
            if (opacity !== container.style.opacity) {
              container.style.opacity = opacity;
            }
            return this.container;
          };
          CanvasTileLayerRenderer.prototype.drawTileImage = function(tile, frameState, x, y, w, h, gutter, transition) {
            var image = this.getTileImage(tile);
            if (!image) {
              return;
            }
            var uid = Object(util["c"])(this);
            var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
            var alphaChanged = alpha !== this.context.globalAlpha;
            if (alphaChanged) {
              this.context.save();
              this.context.globalAlpha = alpha;
            }
            this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
            if (alphaChanged) {
              this.context.restore();
            }
            if (alpha !== 1) {
              frameState.animate = true;
            } else if (transition) {
              tile.endTransition(uid);
            }
          };
          CanvasTileLayerRenderer.prototype.getImage = function() {
            var context = this.context;
            return context ? context.canvas : null;
          };
          CanvasTileLayerRenderer.prototype.getTileImage = function(tile) {
            return tile.getImage();
          };
          CanvasTileLayerRenderer.prototype.scheduleExpireCache = function(frameState, tileSource) {
            if (tileSource.canExpireCache()) {
              var postRenderFunction = function(tileSource2, map, frameState2) {
                var tileSourceKey = Object(util["c"])(tileSource2);
                if (tileSourceKey in frameState2.usedTiles) {
                  tileSource2.expireCache(frameState2.viewState.projection, frameState2.usedTiles[tileSourceKey]);
                }
              }.bind(null, tileSource);
              frameState.postRenderFunctions.push(postRenderFunction);
            }
          };
          CanvasTileLayerRenderer.prototype.updateUsedTiles = function(usedTiles, tileSource, tile) {
            var tileSourceKey = Object(util["c"])(tileSource);
            if (!(tileSourceKey in usedTiles)) {
              usedTiles[tileSourceKey] = {};
            }
            usedTiles[tileSourceKey][tile.getKey()] = true;
          };
          CanvasTileLayerRenderer.prototype.manageTilePyramid = function(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {
            var tileSourceKey = Object(util["c"])(tileSource);
            if (!(tileSourceKey in frameState.wantedTiles)) {
              frameState.wantedTiles[tileSourceKey] = {};
            }
            var wantedTiles = frameState.wantedTiles[tileSourceKey];
            var tileQueue = frameState.tileQueue;
            var minZoom = tileGrid.getMinZoom();
            var tileCount = 0;
            var tile, tileRange, tileResolution, x, y, z;
            for (z = minZoom; z <= currentZ; ++z) {
              tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
              tileResolution = tileGrid.getResolution(z);
              for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
                for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
                  if (currentZ - z <= preload) {
                    ++tileCount;
                    tile = tileSource.getTile(z, x, y, pixelRatio, projection);
                    if (tile.getState() == TileState.IDLE) {
                      wantedTiles[tile.getKey()] = true;
                      if (!tileQueue.isKeyQueued(tile.getKey())) {
                        tileQueue.enqueue([
                          tile,
                          tileSourceKey,
                          tileGrid.getTileCoordCenter(tile.tileCoord),
                          tileResolution
                        ]);
                      }
                    }
                    if (opt_tileCallback !== void 0) {
                      opt_tileCallback(tile);
                    }
                  } else {
                    tileSource.useTile(z, x, y, projection);
                  }
                }
              }
            }
            tileSource.updateCacheSize(tileCount, projection);
          };
          return CanvasTileLayerRenderer;
        }(canvas_Layer);
        TileLayer_CanvasTileLayerRenderer.prototype.getLayer;
        var canvas_TileLayer = TileLayer_CanvasTileLayerRenderer;
        var Tile_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Tile_TileLayer = function(_super) {
          Tile_extends(TileLayer, _super);
          function TileLayer(opt_options) {
            return _super.call(this, opt_options) || this;
          }
          TileLayer.prototype.createRenderer = function() {
            return new canvas_TileLayer(this);
          };
          return TileLayer;
        }(BaseTile);
        var layer_Tile = Tile_TileLayer;
        function BaseLayervue_type_template_id_47df3f30_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div");
        }
        var BaseLayervue_type_script_lang_js = {
          props: {
            className: {
              type: String,
              default: "ol-layer"
            },
            opacity: {
              type: Number,
              default: 1
            },
            visible: {
              type: Boolean,
              default: true
            },
            extent: {
              type: Array
            },
            zIndex: {
              type: Number
            },
            minResolution: {
              type: Number
            },
            maxResolution: {
              type: Number
            },
            minZoom: {
              type: Number
            },
            maxZoom: {
              type: Number
            },
            title: {
              type: String
            },
            name: {
              type: String
            },
            preview: {
              type: String
            },
            baseLayer: {
              type: Boolean
            },
            properties: {
              type: Object,
              default: function _default() {
              }
            }
          }
        };
        const BaseLayer_exports_ = exportHelper_default()(BaseLayervue_type_script_lang_js, [["render", BaseLayervue_type_template_id_47df3f30_lang_true_render]]);
        var layers_BaseLayer = BaseLayer_exports_;
        var TileLayervue_type_script_lang_js = {
          extends: layers_BaseLayer,
          name: "ol-tile-layer",
          setup: function setup(props) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var overViewMap = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("overviewMap", null);
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var tileLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new layer_Tile(properties);
            });
            var applyTileLayer = function applyTileLayer2() {
              if (overViewMap != null) {
                overViewMap.value.getOverviewMap().addLayer(tileLayer.value);
                overViewMap.value.changed();
              } else {
                map.addLayer(tileLayer.value);
              }
            };
            var removeTileLayer = function removeTileLayer2() {
              if (overViewMap != null) {
                overViewMap.value.getOverviewMap().removeLayer(tileLayer.value);
                overViewMap.value.changed();
              } else {
                map.removeLayer(tileLayer.value);
              }
            };
            if (overViewMap != null) {
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(overViewMap, function() {
                removeTileLayer();
                applyTileLayer();
              });
            }
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              applyTileLayer();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              removeTileLayer();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("tileLayer", tileLayer);
            return {
              tileLayer
            };
          },
          props: {
            preload: {
              type: Number,
              default: 1
            }
          }
        };
        const TileLayer_exports_ = exportHelper_default()(TileLayervue_type_script_lang_js, [["render", TileLayervue_type_template_id_33e916fb_lang_true_render]]);
        var layers_TileLayer = TileLayer_exports_;
        function ImageLayervue_type_template_id_6ec52b37_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var BaseImage_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var BaseImageLayer = function(_super) {
          BaseImage_extends(BaseImageLayer2, _super);
          function BaseImageLayer2(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, options) || this;
            return _this;
          }
          return BaseImageLayer2;
        }(layer_Layer);
        var BaseImage = BaseImageLayer;
        var ERROR_THRESHOLD = 0.5;
        var ENABLE_RASTER_REPROJECTION = true;
        var ImageLayer_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ImageLayer_CanvasImageLayerRenderer = function(_super) {
          ImageLayer_extends(CanvasImageLayerRenderer, _super);
          function CanvasImageLayerRenderer(imageLayer) {
            var _this = _super.call(this, imageLayer) || this;
            _this.image_ = null;
            return _this;
          }
          CanvasImageLayerRenderer.prototype.getImage = function() {
            return !this.image_ ? null : this.image_.getImage();
          };
          CanvasImageLayerRenderer.prototype.prepareFrame = function(frameState) {
            var layerState = frameState.layerStatesArray[frameState.layerIndex];
            var pixelRatio = frameState.pixelRatio;
            var viewState = frameState.viewState;
            var viewResolution = viewState.resolution;
            var imageSource = this.getLayer().getSource();
            var hints = frameState.viewHints;
            var renderedExtent = frameState.extent;
            if (layerState.extent !== void 0) {
              renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));
            }
            if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] && !extent_isEmpty(renderedExtent)) {
              if (imageSource) {
                var projection = viewState.projection;
                if (!ENABLE_RASTER_REPROJECTION) {
                  var sourceProjection = imageSource.getProjection();
                  if (sourceProjection) {
                    projection = sourceProjection;
                  }
                }
                var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
                if (image && this.loadImage(image)) {
                  this.image_ = image;
                }
              } else {
                this.image_ = null;
              }
            }
            return !!this.image_;
          };
          CanvasImageLayerRenderer.prototype.renderFrame = function(frameState, target) {
            var image = this.image_;
            var imageExtent = image.getExtent();
            var imageResolution = image.getResolution();
            var imagePixelRatio = image.getPixelRatio();
            var layerState = frameState.layerStatesArray[frameState.layerIndex];
            var pixelRatio = frameState.pixelRatio;
            var viewState = frameState.viewState;
            var viewCenter = viewState.center;
            var viewResolution = viewState.resolution;
            var size = frameState.size;
            var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
            var width = Math.round(size[0] * pixelRatio);
            var height = Math.round(size[1] * pixelRatio);
            var rotation = viewState.rotation;
            if (rotation) {
              var size_1 = Math.round(Math.sqrt(width * width + height * height));
              width = size_1;
              height = size_1;
            }
            compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
            makeInverse(this.inversePixelTransform, this.pixelTransform);
            var canvasTransform = transform_toString(this.pixelTransform);
            this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
            var context = this.context;
            var canvas = context.canvas;
            if (canvas.width != width || canvas.height != height) {
              canvas.width = width;
              canvas.height = height;
            } else if (!this.containerReused) {
              context.clearRect(0, 0, width, height);
            }
            var clipped = false;
            var render = true;
            if (layerState.extent) {
              var layerExtent = fromUserExtent(layerState.extent, viewState.projection);
              render = extent_intersects(layerExtent, frameState.extent);
              clipped = render && !containsExtent(layerExtent, frameState.extent);
              if (clipped) {
                this.clipUnrotated(context, frameState, layerExtent);
              }
            }
            var img = image.getImage();
            var transform2 = compose(this.tempTransform, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
            this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
            var dw = img.width * transform2[0];
            var dh = img.height * transform2[3];
            if (!this.getLayer().getSource().getInterpolate()) {
              Object(ol_obj["a"])(context, IMAGE_SMOOTHING_DISABLED);
            }
            this.preRender(context, frameState);
            if (render && dw >= 0.5 && dh >= 0.5) {
              var dx = transform2[4];
              var dy = transform2[5];
              var opacity = layerState.opacity;
              var previousAlpha = void 0;
              if (opacity !== 1) {
                previousAlpha = context.globalAlpha;
                context.globalAlpha = opacity;
              }
              context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
              if (opacity !== 1) {
                context.globalAlpha = previousAlpha;
              }
            }
            this.postRender(context, frameState);
            if (clipped) {
              context.restore();
            }
            Object(ol_obj["a"])(context, IMAGE_SMOOTHING_ENABLED);
            if (canvasTransform !== canvas.style.transform) {
              canvas.style.transform = canvasTransform;
            }
            return this.container;
          };
          return CanvasImageLayerRenderer;
        }(canvas_Layer);
        var canvas_ImageLayer = ImageLayer_CanvasImageLayerRenderer;
        var Image_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Image_ImageLayer = function(_super) {
          Image_extends(ImageLayer, _super);
          function ImageLayer(opt_options) {
            return _super.call(this, opt_options) || this;
          }
          ImageLayer.prototype.createRenderer = function() {
            return new canvas_ImageLayer(this);
          };
          return ImageLayer;
        }(BaseImage);
        var layer_Image = Image_ImageLayer;
        var ImageLayervue_type_script_lang_js = {
          extends: layers_BaseLayer,
          name: "ol-image-layer",
          setup: function setup(props) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var imageLayer = new layer_Image(properties);
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              imageLayer.setProperties(properties);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addLayer(imageLayer);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeLayer(imageLayer);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("imageLayer", imageLayer);
            return {
              imageLayer
            };
          }
        };
        const ImageLayer_exports_ = exportHelper_default()(ImageLayervue_type_script_lang_js, [["render", ImageLayervue_type_template_id_6ec52b37_lang_true_render]]);
        var layers_ImageLayer = ImageLayer_exports_;
        function VectorLayervue_type_template_id_6b3006ca_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var rbush_min = __webpack_require__("25a5");
        var rbush_min_default = __webpack_require__.n(rbush_min);
        var Image_ImageStyle = function() {
          function ImageStyle(options) {
            this.opacity_ = options.opacity;
            this.rotateWithView_ = options.rotateWithView;
            this.rotation_ = options.rotation;
            this.scale_ = options.scale;
            this.scaleArray_ = toSize(options.scale);
            this.displacement_ = options.displacement;
          }
          ImageStyle.prototype.clone = function() {
            var scale = this.getScale();
            return new ImageStyle({
              opacity: this.getOpacity(),
              scale: Array.isArray(scale) ? scale.slice() : scale,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice()
            });
          };
          ImageStyle.prototype.getOpacity = function() {
            return this.opacity_;
          };
          ImageStyle.prototype.getRotateWithView = function() {
            return this.rotateWithView_;
          };
          ImageStyle.prototype.getRotation = function() {
            return this.rotation_;
          };
          ImageStyle.prototype.getScale = function() {
            return this.scale_;
          };
          ImageStyle.prototype.getScaleArray = function() {
            return this.scaleArray_;
          };
          ImageStyle.prototype.getDisplacement = function() {
            return this.displacement_;
          };
          ImageStyle.prototype.getAnchor = function() {
            return Object(util["b"])();
          };
          ImageStyle.prototype.getImage = function(pixelRatio) {
            return Object(util["b"])();
          };
          ImageStyle.prototype.getHitDetectionImage = function() {
            return Object(util["b"])();
          };
          ImageStyle.prototype.getPixelRatio = function(pixelRatio) {
            return 1;
          };
          ImageStyle.prototype.getImageState = function() {
            return Object(util["b"])();
          };
          ImageStyle.prototype.getImageSize = function() {
            return Object(util["b"])();
          };
          ImageStyle.prototype.getOrigin = function() {
            return Object(util["b"])();
          };
          ImageStyle.prototype.getSize = function() {
            return Object(util["b"])();
          };
          ImageStyle.prototype.setDisplacement = function(displacement) {
            this.displacement_ = displacement;
          };
          ImageStyle.prototype.setOpacity = function(opacity) {
            this.opacity_ = opacity;
          };
          ImageStyle.prototype.setRotateWithView = function(rotateWithView) {
            this.rotateWithView_ = rotateWithView;
          };
          ImageStyle.prototype.setRotation = function(rotation) {
            this.rotation_ = rotation;
          };
          ImageStyle.prototype.setScale = function(scale) {
            this.scale_ = scale;
            this.scaleArray_ = toSize(scale);
          };
          ImageStyle.prototype.listenImageChange = function(listener) {
            Object(util["b"])();
          };
          ImageStyle.prototype.load = function() {
            Object(util["b"])();
          };
          ImageStyle.prototype.unlistenImageChange = function(listener) {
            Object(util["b"])();
          };
          return ImageStyle;
        }();
        var style_Image = Image_ImageStyle;
        function asColorLike(color) {
          if (Array.isArray(color)) {
            return color_toString(color);
          } else {
            return color;
          }
        }
        var RegularShape_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var RegularShape_RegularShape = function(_super) {
          RegularShape_extends(RegularShape, _super);
          function RegularShape(options) {
            var _this = this;
            var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
            _this = _super.call(this, {
              opacity: 1,
              rotateWithView,
              rotation: options.rotation !== void 0 ? options.rotation : 0,
              scale: options.scale !== void 0 ? options.scale : 1,
              displacement: options.displacement !== void 0 ? options.displacement : [0, 0]
            }) || this;
            _this.canvas_ = void 0;
            _this.hitDetectionCanvas_ = null;
            _this.fill_ = options.fill !== void 0 ? options.fill : null;
            _this.origin_ = [0, 0];
            _this.points_ = options.points;
            _this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
            _this.radius2_ = options.radius2;
            _this.angle_ = options.angle !== void 0 ? options.angle : 0;
            _this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
            _this.size_ = null;
            _this.renderOptions_ = null;
            _this.render();
            return _this;
          }
          RegularShape.prototype.clone = function() {
            var scale = this.getScale();
            var style = new RegularShape({
              fill: this.getFill() ? this.getFill().clone() : void 0,
              points: this.getPoints(),
              radius: this.getRadius(),
              radius2: this.getRadius2(),
              angle: this.getAngle(),
              stroke: this.getStroke() ? this.getStroke().clone() : void 0,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              scale: Array.isArray(scale) ? scale.slice() : scale,
              displacement: this.getDisplacement().slice()
            });
            style.setOpacity(this.getOpacity());
            return style;
          };
          RegularShape.prototype.getAnchor = function() {
            var size = this.size_;
            if (!size) {
              return null;
            }
            var displacement = this.getDisplacement();
            return [size[0] / 2 - displacement[0], size[1] / 2 + displacement[1]];
          };
          RegularShape.prototype.getAngle = function() {
            return this.angle_;
          };
          RegularShape.prototype.getFill = function() {
            return this.fill_;
          };
          RegularShape.prototype.getHitDetectionImage = function() {
            if (!this.hitDetectionCanvas_) {
              this.createHitDetectionCanvas_(this.renderOptions_);
            }
            return this.hitDetectionCanvas_;
          };
          RegularShape.prototype.getImage = function(pixelRatio) {
            var image = this.canvas_[pixelRatio];
            if (!image) {
              var renderOptions = this.renderOptions_;
              var context = Object(dom["a"])(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
              this.draw_(renderOptions, context, pixelRatio);
              image = context.canvas;
              this.canvas_[pixelRatio] = image;
            }
            return image;
          };
          RegularShape.prototype.getPixelRatio = function(pixelRatio) {
            return pixelRatio;
          };
          RegularShape.prototype.getImageSize = function() {
            return this.size_;
          };
          RegularShape.prototype.getImageState = function() {
            return ImageState.LOADED;
          };
          RegularShape.prototype.getOrigin = function() {
            return this.origin_;
          };
          RegularShape.prototype.getPoints = function() {
            return this.points_;
          };
          RegularShape.prototype.getRadius = function() {
            return this.radius_;
          };
          RegularShape.prototype.getRadius2 = function() {
            return this.radius2_;
          };
          RegularShape.prototype.getSize = function() {
            return this.size_;
          };
          RegularShape.prototype.getStroke = function() {
            return this.stroke_;
          };
          RegularShape.prototype.listenImageChange = function(listener) {
          };
          RegularShape.prototype.load = function() {
          };
          RegularShape.prototype.unlistenImageChange = function(listener) {
          };
          RegularShape.prototype.calculateLineJoinSize_ = function(lineJoin, strokeWidth, miterLimit) {
            if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
              return strokeWidth;
            }
            var r1 = this.radius_;
            var r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
            if (r1 < r2) {
              var tmp = r1;
              r1 = r2;
              r2 = tmp;
            }
            var points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
            var alpha = 2 * Math.PI / points;
            var a = r2 * Math.sin(alpha);
            var b = Math.sqrt(r2 * r2 - a * a);
            var d = r1 - b;
            var e = Math.sqrt(a * a + d * d);
            var miterRatio = e / a;
            if (lineJoin === "miter" && miterRatio <= miterLimit) {
              return miterRatio * strokeWidth;
            }
            var k = strokeWidth / 2 / miterRatio;
            var l = strokeWidth / 2 * (d / e);
            var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
            var bevelAdd = maxr - r1;
            if (this.radius2_ === void 0 || lineJoin === "bevel") {
              return bevelAdd * 2;
            }
            var aa = r1 * Math.sin(alpha);
            var bb = Math.sqrt(r1 * r1 - aa * aa);
            var dd = r2 - bb;
            var ee = Math.sqrt(aa * aa + dd * dd);
            var innerMiterRatio = ee / aa;
            if (innerMiterRatio <= miterLimit) {
              var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
              return 2 * Math.max(bevelAdd, innerLength);
            }
            return bevelAdd * 2;
          };
          RegularShape.prototype.createRenderOptions = function() {
            var lineJoin = defaultLineJoin;
            var miterLimit = 0;
            var lineDash = null;
            var lineDashOffset = 0;
            var strokeStyle;
            var strokeWidth = 0;
            if (this.stroke_) {
              strokeStyle = this.stroke_.getColor();
              if (strokeStyle === null) {
                strokeStyle = defaultStrokeStyle;
              }
              strokeStyle = asColorLike(strokeStyle);
              strokeWidth = this.stroke_.getWidth();
              if (strokeWidth === void 0) {
                strokeWidth = defaultLineWidth;
              }
              lineDash = this.stroke_.getLineDash();
              lineDashOffset = this.stroke_.getLineDashOffset();
              lineJoin = this.stroke_.getLineJoin();
              if (lineJoin === void 0) {
                lineJoin = defaultLineJoin;
              }
              miterLimit = this.stroke_.getMiterLimit();
              if (miterLimit === void 0) {
                miterLimit = defaultMiterLimit;
              }
            }
            var add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
            var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
            var size = Math.ceil(2 * maxRadius + add);
            return {
              strokeStyle,
              strokeWidth,
              size,
              lineDash,
              lineDashOffset,
              lineJoin,
              miterLimit
            };
          };
          RegularShape.prototype.render = function() {
            this.renderOptions_ = this.createRenderOptions();
            var size = this.renderOptions_.size;
            this.canvas_ = {};
            this.size_ = [size, size];
          };
          RegularShape.prototype.draw_ = function(renderOptions, context, pixelRatio) {
            context.scale(pixelRatio, pixelRatio);
            context.translate(renderOptions.size / 2, renderOptions.size / 2);
            this.createPath_(context);
            if (this.fill_) {
              var color = this.fill_.getColor();
              if (color === null) {
                color = defaultFillStyle;
              }
              context.fillStyle = asColorLike(color);
              context.fill();
            }
            if (this.stroke_) {
              context.strokeStyle = renderOptions.strokeStyle;
              context.lineWidth = renderOptions.strokeWidth;
              if (context.setLineDash && renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
              }
              context.lineJoin = renderOptions.lineJoin;
              context.miterLimit = renderOptions.miterLimit;
              context.stroke();
            }
          };
          RegularShape.prototype.createHitDetectionCanvas_ = function(renderOptions) {
            if (this.fill_) {
              var color = this.fill_.getColor();
              var opacity = 0;
              if (typeof color === "string") {
                color = asArray(color);
              }
              if (color === null) {
                opacity = 1;
              } else if (Array.isArray(color)) {
                opacity = color.length === 4 ? color[3] : 1;
              }
              if (opacity === 0) {
                var context = Object(dom["a"])(renderOptions.size, renderOptions.size);
                this.hitDetectionCanvas_ = context.canvas;
                this.drawHitDetectionCanvas_(renderOptions, context);
              }
            }
            if (!this.hitDetectionCanvas_) {
              this.hitDetectionCanvas_ = this.getImage(1);
            }
          };
          RegularShape.prototype.createPath_ = function(context) {
            var points = this.points_;
            var radius = this.radius_;
            if (points === Infinity) {
              context.arc(0, 0, radius, 0, 2 * Math.PI);
            } else {
              var radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
              if (this.radius2_ !== void 0) {
                points *= 2;
              }
              var startAngle = this.angle_ - Math.PI / 2;
              var step = 2 * Math.PI / points;
              for (var i = 0; i < points; i++) {
                var angle0 = startAngle + i * step;
                var radiusC = i % 2 === 0 ? radius : radius2;
                context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
              }
              context.closePath();
            }
          };
          RegularShape.prototype.drawHitDetectionCanvas_ = function(renderOptions, context) {
            context.translate(renderOptions.size / 2, renderOptions.size / 2);
            this.createPath_(context);
            context.fillStyle = defaultFillStyle;
            context.fill();
            if (this.stroke_) {
              context.strokeStyle = renderOptions.strokeStyle;
              context.lineWidth = renderOptions.strokeWidth;
              if (renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
              }
              context.lineJoin = renderOptions.lineJoin;
              context.miterLimit = renderOptions.miterLimit;
              context.stroke();
            }
          };
          return RegularShape;
        }(style_Image);
        var style_RegularShape = RegularShape_RegularShape;
        var Circle_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var CircleStyle = function(_super) {
          Circle_extends(CircleStyle2, _super);
          function CircleStyle2(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
              points: Infinity,
              fill: options.fill,
              radius: options.radius,
              stroke: options.stroke,
              scale: options.scale !== void 0 ? options.scale : 1,
              rotation: options.rotation !== void 0 ? options.rotation : 0,
              rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
              displacement: options.displacement !== void 0 ? options.displacement : [0, 0]
            }) || this;
            return _this;
          }
          CircleStyle2.prototype.clone = function() {
            var scale = this.getScale();
            var style = new CircleStyle2({
              fill: this.getFill() ? this.getFill().clone() : void 0,
              stroke: this.getStroke() ? this.getStroke().clone() : void 0,
              radius: this.getRadius(),
              scale: Array.isArray(scale) ? scale.slice() : scale,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice()
            });
            style.setOpacity(this.getOpacity());
            return style;
          };
          CircleStyle2.prototype.setRadius = function(radius) {
            this.radius_ = radius;
            this.render();
          };
          return CircleStyle2;
        }(style_RegularShape);
        var style_Circle = CircleStyle;
        var Fill = function() {
          function Fill2(opt_options) {
            var options = opt_options || {};
            this.color_ = options.color !== void 0 ? options.color : null;
          }
          Fill2.prototype.clone = function() {
            var color = this.getColor();
            return new Fill2({
              color: Array.isArray(color) ? color.slice() : color || void 0
            });
          };
          Fill2.prototype.getColor = function() {
            return this.color_;
          };
          Fill2.prototype.setColor = function(color) {
            this.color_ = color;
          };
          return Fill2;
        }();
        var style_Fill = Fill;
        var Stroke = function() {
          function Stroke2(opt_options) {
            var options = opt_options || {};
            this.color_ = options.color !== void 0 ? options.color : null;
            this.lineCap_ = options.lineCap;
            this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
            this.lineDashOffset_ = options.lineDashOffset;
            this.lineJoin_ = options.lineJoin;
            this.miterLimit_ = options.miterLimit;
            this.width_ = options.width;
          }
          Stroke2.prototype.clone = function() {
            var color = this.getColor();
            return new Stroke2({
              color: Array.isArray(color) ? color.slice() : color || void 0,
              lineCap: this.getLineCap(),
              lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
              lineDashOffset: this.getLineDashOffset(),
              lineJoin: this.getLineJoin(),
              miterLimit: this.getMiterLimit(),
              width: this.getWidth()
            });
          };
          Stroke2.prototype.getColor = function() {
            return this.color_;
          };
          Stroke2.prototype.getLineCap = function() {
            return this.lineCap_;
          };
          Stroke2.prototype.getLineDash = function() {
            return this.lineDash_;
          };
          Stroke2.prototype.getLineDashOffset = function() {
            return this.lineDashOffset_;
          };
          Stroke2.prototype.getLineJoin = function() {
            return this.lineJoin_;
          };
          Stroke2.prototype.getMiterLimit = function() {
            return this.miterLimit_;
          };
          Stroke2.prototype.getWidth = function() {
            return this.width_;
          };
          Stroke2.prototype.setColor = function(color) {
            this.color_ = color;
          };
          Stroke2.prototype.setLineCap = function(lineCap) {
            this.lineCap_ = lineCap;
          };
          Stroke2.prototype.setLineDash = function(lineDash) {
            this.lineDash_ = lineDash;
          };
          Stroke2.prototype.setLineDashOffset = function(lineDashOffset) {
            this.lineDashOffset_ = lineDashOffset;
          };
          Stroke2.prototype.setLineJoin = function(lineJoin) {
            this.lineJoin_ = lineJoin;
          };
          Stroke2.prototype.setMiterLimit = function(miterLimit) {
            this.miterLimit_ = miterLimit;
          };
          Stroke2.prototype.setWidth = function(width) {
            this.width_ = width;
          };
          return Stroke2;
        }();
        var style_Stroke = Stroke;
        var Style = function() {
          function Style2(opt_options) {
            var options = opt_options || {};
            this.geometry_ = null;
            this.geometryFunction_ = defaultGeometryFunction;
            if (options.geometry !== void 0) {
              this.setGeometry(options.geometry);
            }
            this.fill_ = options.fill !== void 0 ? options.fill : null;
            this.image_ = options.image !== void 0 ? options.image : null;
            this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
            this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
            this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
            this.text_ = options.text !== void 0 ? options.text : null;
            this.zIndex_ = options.zIndex;
          }
          Style2.prototype.clone = function() {
            var geometry = this.getGeometry();
            if (geometry && typeof geometry === "object") {
              geometry = geometry.clone();
            }
            return new Style2({
              geometry,
              fill: this.getFill() ? this.getFill().clone() : void 0,
              image: this.getImage() ? this.getImage().clone() : void 0,
              renderer: this.getRenderer(),
              stroke: this.getStroke() ? this.getStroke().clone() : void 0,
              text: this.getText() ? this.getText().clone() : void 0,
              zIndex: this.getZIndex()
            });
          };
          Style2.prototype.getRenderer = function() {
            return this.renderer_;
          };
          Style2.prototype.setRenderer = function(renderer) {
            this.renderer_ = renderer;
          };
          Style2.prototype.setHitDetectionRenderer = function(renderer) {
            this.hitDetectionRenderer_ = renderer;
          };
          Style2.prototype.getHitDetectionRenderer = function() {
            return this.hitDetectionRenderer_;
          };
          Style2.prototype.getGeometry = function() {
            return this.geometry_;
          };
          Style2.prototype.getGeometryFunction = function() {
            return this.geometryFunction_;
          };
          Style2.prototype.getFill = function() {
            return this.fill_;
          };
          Style2.prototype.setFill = function(fill) {
            this.fill_ = fill;
          };
          Style2.prototype.getImage = function() {
            return this.image_;
          };
          Style2.prototype.setImage = function(image) {
            this.image_ = image;
          };
          Style2.prototype.getStroke = function() {
            return this.stroke_;
          };
          Style2.prototype.setStroke = function(stroke) {
            this.stroke_ = stroke;
          };
          Style2.prototype.getText = function() {
            return this.text_;
          };
          Style2.prototype.setText = function(text) {
            this.text_ = text;
          };
          Style2.prototype.getZIndex = function() {
            return this.zIndex_;
          };
          Style2.prototype.setGeometry = function(geometry) {
            if (typeof geometry === "function") {
              this.geometryFunction_ = geometry;
            } else if (typeof geometry === "string") {
              this.geometryFunction_ = function(feature) {
                return feature.get(geometry);
              };
            } else if (!geometry) {
              this.geometryFunction_ = defaultGeometryFunction;
            } else if (geometry !== void 0) {
              this.geometryFunction_ = function() {
                return geometry;
              };
            }
            this.geometry_ = geometry;
          };
          Style2.prototype.setZIndex = function(zIndex) {
            this.zIndex_ = zIndex;
          };
          return Style2;
        }();
        function toFunction(obj) {
          var styleFunction;
          if (typeof obj === "function") {
            styleFunction = obj;
          } else {
            var styles_1;
            if (Array.isArray(obj)) {
              styles_1 = obj;
            } else {
              assert2(typeof obj.getZIndex === "function", 41);
              var style = obj;
              styles_1 = [style];
            }
            styleFunction = function() {
              return styles_1;
            };
          }
          return styleFunction;
        }
        var defaultStyles = null;
        function createDefaultStyle(feature, resolution) {
          if (!defaultStyles) {
            var fill = new style_Fill({
              color: "rgba(255,255,255,0.4)"
            });
            var stroke = new style_Stroke({
              color: "#3399CC",
              width: 1.25
            });
            defaultStyles = [
              new Style({
                image: new style_Circle({
                  fill,
                  stroke,
                  radius: 5
                }),
                fill,
                stroke
              })
            ];
          }
          return defaultStyles;
        }
        function createEditingStyle() {
          var styles = {};
          var white = [255, 255, 255, 1];
          var blue = [0, 153, 255, 1];
          var width = 3;
          styles[geom_GeometryType.POLYGON] = [
            new Style({
              fill: new style_Fill({
                color: [255, 255, 255, 0.5]
              })
            })
          ];
          styles[geom_GeometryType.MULTI_POLYGON] = styles[geom_GeometryType.POLYGON];
          styles[geom_GeometryType.LINE_STRING] = [
            new Style({
              stroke: new style_Stroke({
                color: white,
                width: width + 2
              })
            }),
            new Style({
              stroke: new style_Stroke({
                color: blue,
                width
              })
            })
          ];
          styles[geom_GeometryType.MULTI_LINE_STRING] = styles[geom_GeometryType.LINE_STRING];
          styles[geom_GeometryType.CIRCLE] = styles[geom_GeometryType.POLYGON].concat(styles[geom_GeometryType.LINE_STRING]);
          styles[geom_GeometryType.POINT] = [
            new Style({
              image: new style_Circle({
                radius: width * 2,
                fill: new style_Fill({
                  color: blue
                }),
                stroke: new style_Stroke({
                  color: white,
                  width: width / 2
                })
              }),
              zIndex: Infinity
            })
          ];
          styles[geom_GeometryType.MULTI_POINT] = styles[geom_GeometryType.POINT];
          styles[geom_GeometryType.GEOMETRY_COLLECTION] = styles[geom_GeometryType.POLYGON].concat(styles[geom_GeometryType.LINE_STRING], styles[geom_GeometryType.POINT]);
          return styles;
        }
        function defaultGeometryFunction(feature) {
          return feature.getGeometry();
        }
        var style_Style = Style;
        var BaseVector_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var BaseVector_Property = {
          RENDER_ORDER: "renderOrder"
        };
        var BaseVector_BaseVectorLayer = function(_super) {
          BaseVector_extends(BaseVectorLayer, _super);
          function BaseVectorLayer(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var baseOptions = Object(ol_obj["a"])({}, options);
            delete baseOptions.style;
            delete baseOptions.renderBuffer;
            delete baseOptions.updateWhileAnimating;
            delete baseOptions.updateWhileInteracting;
            _this = _super.call(this, baseOptions) || this;
            _this.declutter_ = options.declutter !== void 0 ? options.declutter : false;
            _this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
            _this.style_ = null;
            _this.styleFunction_ = void 0;
            _this.setStyle(options.style);
            _this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
            _this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
            return _this;
          }
          BaseVectorLayer.prototype.getDeclutter = function() {
            return this.declutter_;
          };
          BaseVectorLayer.prototype.getFeatures = function(pixel) {
            return _super.prototype.getFeatures.call(this, pixel);
          };
          BaseVectorLayer.prototype.getRenderBuffer = function() {
            return this.renderBuffer_;
          };
          BaseVectorLayer.prototype.getRenderOrder = function() {
            return this.get(BaseVector_Property.RENDER_ORDER);
          };
          BaseVectorLayer.prototype.getStyle = function() {
            return this.style_;
          };
          BaseVectorLayer.prototype.getStyleFunction = function() {
            return this.styleFunction_;
          };
          BaseVectorLayer.prototype.getUpdateWhileAnimating = function() {
            return this.updateWhileAnimating_;
          };
          BaseVectorLayer.prototype.getUpdateWhileInteracting = function() {
            return this.updateWhileInteracting_;
          };
          BaseVectorLayer.prototype.renderDeclutter = function(frameState) {
            if (!frameState.declutterTree) {
              frameState.declutterTree = new rbush_min_default.a(9);
            }
            this.getRenderer().renderDeclutter(frameState);
          };
          BaseVectorLayer.prototype.setRenderOrder = function(renderOrder) {
            this.set(BaseVector_Property.RENDER_ORDER, renderOrder);
          };
          BaseVectorLayer.prototype.setStyle = function(opt_style) {
            this.style_ = opt_style !== void 0 ? opt_style : createDefaultStyle;
            this.styleFunction_ = opt_style === null ? void 0 : toFunction(this.style_);
            this.changed();
          };
          return BaseVectorLayer;
        }(layer_Layer);
        var BaseVector = BaseVector_BaseVectorLayer;
        var Instruction = {
          BEGIN_GEOMETRY: 0,
          BEGIN_PATH: 1,
          CIRCLE: 2,
          CLOSE_PATH: 3,
          CUSTOM: 4,
          DRAW_CHARS: 5,
          DRAW_IMAGE: 6,
          END_GEOMETRY: 7,
          FILL: 8,
          MOVE_TO_LINE_TO: 9,
          SET_FILL_STYLE: 10,
          SET_STROKE_STYLE: 11,
          STROKE: 12
        };
        var Instruction_fillInstruction = [Instruction.FILL];
        var Instruction_strokeInstruction = [Instruction.STROKE];
        var beginPathInstruction = [Instruction.BEGIN_PATH];
        var closePathInstruction = [Instruction.CLOSE_PATH];
        var canvas_Instruction = Instruction;
        var VectorContext = function() {
          function VectorContext2() {
          }
          VectorContext2.prototype.drawCustom = function(geometry, feature, renderer, hitDetectionRenderer) {
          };
          VectorContext2.prototype.drawGeometry = function(geometry) {
          };
          VectorContext2.prototype.setStyle = function(style) {
          };
          VectorContext2.prototype.drawCircle = function(circleGeometry, feature) {
          };
          VectorContext2.prototype.drawFeature = function(feature, style) {
          };
          VectorContext2.prototype.drawGeometryCollection = function(geometryCollectionGeometry, feature) {
          };
          VectorContext2.prototype.drawLineString = function(lineStringGeometry, feature) {
          };
          VectorContext2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
          };
          VectorContext2.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
          };
          VectorContext2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
          };
          VectorContext2.prototype.drawPoint = function(pointGeometry, feature) {
          };
          VectorContext2.prototype.drawPolygon = function(polygonGeometry, feature) {
          };
          VectorContext2.prototype.drawText = function(geometry, feature) {
          };
          VectorContext2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
          };
          VectorContext2.prototype.setImageStyle = function(imageStyle, opt_declutterImageWithText) {
          };
          VectorContext2.prototype.setTextStyle = function(textStyle, opt_declutterImageWithText) {
          };
          return VectorContext2;
        }();
        var render_VectorContext = VectorContext;
        var Builder_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Builder_CanvasBuilder = function(_super) {
          Builder_extends(CanvasBuilder, _super);
          function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
            var _this = _super.call(this) || this;
            _this.tolerance = tolerance;
            _this.maxExtent = maxExtent;
            _this.pixelRatio = pixelRatio;
            _this.maxLineWidth = 0;
            _this.resolution = resolution;
            _this.beginGeometryInstruction1_ = null;
            _this.beginGeometryInstruction2_ = null;
            _this.bufferedMaxExtent_ = null;
            _this.instructions = [];
            _this.coordinates = [];
            _this.tmpCoordinate_ = [];
            _this.hitDetectionInstructions = [];
            _this.state = {};
            return _this;
          }
          CanvasBuilder.prototype.applyPixelRatio = function(dashArray) {
            var pixelRatio = this.pixelRatio;
            return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
              return dash * pixelRatio;
            });
          };
          CanvasBuilder.prototype.appendFlatPointCoordinates = function(flatCoordinates, stride) {
            var extent = this.getBufferedMaxExtent();
            var tmpCoord = this.tmpCoordinate_;
            var coordinates = this.coordinates;
            var myEnd = coordinates.length;
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              tmpCoord[0] = flatCoordinates[i];
              tmpCoord[1] = flatCoordinates[i + 1];
              if (containsCoordinate(extent, tmpCoord)) {
                coordinates[myEnd++] = tmpCoord[0];
                coordinates[myEnd++] = tmpCoord[1];
              }
            }
            return myEnd;
          };
          CanvasBuilder.prototype.appendFlatLineCoordinates = function(flatCoordinates, offset, end, stride, closed, skipFirst) {
            var coordinates = this.coordinates;
            var myEnd = coordinates.length;
            var extent = this.getBufferedMaxExtent();
            if (skipFirst) {
              offset += stride;
            }
            var lastXCoord = flatCoordinates[offset];
            var lastYCoord = flatCoordinates[offset + 1];
            var nextCoord = this.tmpCoordinate_;
            var skipped = true;
            var i, lastRel, nextRel;
            for (i = offset + stride; i < end; i += stride) {
              nextCoord[0] = flatCoordinates[i];
              nextCoord[1] = flatCoordinates[i + 1];
              nextRel = coordinateRelationship(extent, nextCoord);
              if (nextRel !== lastRel) {
                if (skipped) {
                  coordinates[myEnd++] = lastXCoord;
                  coordinates[myEnd++] = lastYCoord;
                  skipped = false;
                }
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
              } else if (nextRel === Relationship.INTERSECTING) {
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
                skipped = false;
              } else {
                skipped = true;
              }
              lastXCoord = nextCoord[0];
              lastYCoord = nextCoord[1];
              lastRel = nextRel;
            }
            if (closed && skipped || i === offset + stride) {
              coordinates[myEnd++] = lastXCoord;
              coordinates[myEnd++] = lastYCoord;
            }
            return myEnd;
          };
          CanvasBuilder.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset, ends, stride, builderEnds) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
              builderEnds.push(builderEnd);
              offset = end;
            }
            return offset;
          };
          CanvasBuilder.prototype.drawCustom = function(geometry, feature, renderer, hitDetectionRenderer) {
            this.beginGeometry(geometry, feature);
            var type = geometry.getType();
            var stride = geometry.getStride();
            var builderBegin = this.coordinates.length;
            var flatCoordinates, builderEnd, builderEnds, builderEndss;
            var offset;
            switch (type) {
              case geom_GeometryType.MULTI_POLYGON:
                flatCoordinates = geometry.getOrientedFlatCoordinates();
                builderEndss = [];
                var endss = geometry.getEndss();
                offset = 0;
                for (var i = 0, ii = endss.length; i < ii; ++i) {
                  var myEnds = [];
                  offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                  builderEndss.push(myEnds);
                }
                this.instructions.push([
                  canvas_Instruction.CUSTOM,
                  builderBegin,
                  builderEndss,
                  geometry,
                  renderer,
                  inflateMultiCoordinatesArray
                ]);
                this.hitDetectionInstructions.push([
                  canvas_Instruction.CUSTOM,
                  builderBegin,
                  builderEndss,
                  geometry,
                  hitDetectionRenderer || renderer,
                  inflateMultiCoordinatesArray
                ]);
                break;
              case geom_GeometryType.POLYGON:
              case geom_GeometryType.MULTI_LINE_STRING:
                builderEnds = [];
                flatCoordinates = type == geom_GeometryType.POLYGON ? geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
                offset = this.drawCustomCoordinates_(flatCoordinates, 0, geometry.getEnds(), stride, builderEnds);
                this.instructions.push([
                  canvas_Instruction.CUSTOM,
                  builderBegin,
                  builderEnds,
                  geometry,
                  renderer,
                  inflateCoordinatesArray
                ]);
                this.hitDetectionInstructions.push([
                  canvas_Instruction.CUSTOM,
                  builderBegin,
                  builderEnds,
                  geometry,
                  hitDetectionRenderer || renderer,
                  inflateCoordinatesArray
                ]);
                break;
              case geom_GeometryType.LINE_STRING:
              case geom_GeometryType.CIRCLE:
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
                this.instructions.push([
                  canvas_Instruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  renderer,
                  inflateCoordinates
                ]);
                this.hitDetectionInstructions.push([
                  canvas_Instruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  hitDetectionRenderer || renderer,
                  inflateCoordinates
                ]);
                break;
              case geom_GeometryType.MULTI_POINT:
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
                if (builderEnd > builderBegin) {
                  this.instructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer,
                    inflateCoordinates
                  ]);
                  this.hitDetectionInstructions.push([
                    canvas_Instruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    hitDetectionRenderer || renderer,
                    inflateCoordinates
                  ]);
                }
                break;
              case geom_GeometryType.POINT:
                flatCoordinates = geometry.getFlatCoordinates();
                this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
                builderEnd = this.coordinates.length;
                this.instructions.push([
                  canvas_Instruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  renderer
                ]);
                this.hitDetectionInstructions.push([
                  canvas_Instruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  hitDetectionRenderer || renderer
                ]);
                break;
              default:
            }
            this.endGeometry(feature);
          };
          CanvasBuilder.prototype.beginGeometry = function(geometry, feature) {
            this.beginGeometryInstruction1_ = [
              canvas_Instruction.BEGIN_GEOMETRY,
              feature,
              0,
              geometry
            ];
            this.instructions.push(this.beginGeometryInstruction1_);
            this.beginGeometryInstruction2_ = [
              canvas_Instruction.BEGIN_GEOMETRY,
              feature,
              0,
              geometry
            ];
            this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
          };
          CanvasBuilder.prototype.finish = function() {
            return {
              instructions: this.instructions,
              hitDetectionInstructions: this.hitDetectionInstructions,
              coordinates: this.coordinates
            };
          };
          CanvasBuilder.prototype.reverseHitDetectionInstructions = function() {
            var hitDetectionInstructions = this.hitDetectionInstructions;
            hitDetectionInstructions.reverse();
            var i;
            var n = hitDetectionInstructions.length;
            var instruction;
            var type;
            var begin = -1;
            for (i = 0; i < n; ++i) {
              instruction = hitDetectionInstructions[i];
              type = instruction[0];
              if (type == canvas_Instruction.END_GEOMETRY) {
                begin = i;
              } else if (type == canvas_Instruction.BEGIN_GEOMETRY) {
                instruction[2] = i;
                Object(ol_array["j"])(this.hitDetectionInstructions, begin, i);
                begin = -1;
              }
            }
          };
          CanvasBuilder.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
            var state = this.state;
            if (fillStyle) {
              var fillStyleColor = fillStyle.getColor();
              state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
            } else {
              state.fillStyle = void 0;
            }
            if (strokeStyle) {
              var strokeStyleColor = strokeStyle.getColor();
              state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
              var strokeStyleLineCap = strokeStyle.getLineCap();
              state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
              var strokeStyleLineDash = strokeStyle.getLineDash();
              state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
              var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
              state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
              var strokeStyleLineJoin = strokeStyle.getLineJoin();
              state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
              var strokeStyleWidth = strokeStyle.getWidth();
              state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
              var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
              state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
              if (state.lineWidth > this.maxLineWidth) {
                this.maxLineWidth = state.lineWidth;
                this.bufferedMaxExtent_ = null;
              }
            } else {
              state.strokeStyle = void 0;
              state.lineCap = void 0;
              state.lineDash = null;
              state.lineDashOffset = void 0;
              state.lineJoin = void 0;
              state.lineWidth = void 0;
              state.miterLimit = void 0;
            }
          };
          CanvasBuilder.prototype.createFill = function(state) {
            var fillStyle = state.fillStyle;
            var fillInstruction = [canvas_Instruction.SET_FILL_STYLE, fillStyle];
            if (typeof fillStyle !== "string") {
              fillInstruction.push(true);
            }
            return fillInstruction;
          };
          CanvasBuilder.prototype.applyStroke = function(state) {
            this.instructions.push(this.createStroke(state));
          };
          CanvasBuilder.prototype.createStroke = function(state) {
            return [
              canvas_Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth * this.pixelRatio,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              this.applyPixelRatio(state.lineDash),
              state.lineDashOffset * this.pixelRatio
            ];
          };
          CanvasBuilder.prototype.updateFillStyle = function(state, createFill) {
            var fillStyle = state.fillStyle;
            if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
              if (fillStyle !== void 0) {
                this.instructions.push(createFill.call(this, state));
              }
              state.currentFillStyle = fillStyle;
            }
          };
          CanvasBuilder.prototype.updateStrokeStyle = function(state, applyStroke) {
            var strokeStyle = state.strokeStyle;
            var lineCap = state.lineCap;
            var lineDash = state.lineDash;
            var lineDashOffset = state.lineDashOffset;
            var lineJoin = state.lineJoin;
            var lineWidth = state.lineWidth;
            var miterLimit = state.miterLimit;
            if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !Object(ol_array["b"])(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
              if (strokeStyle !== void 0) {
                applyStroke.call(this, state);
              }
              state.currentStrokeStyle = strokeStyle;
              state.currentLineCap = lineCap;
              state.currentLineDash = lineDash;
              state.currentLineDashOffset = lineDashOffset;
              state.currentLineJoin = lineJoin;
              state.currentLineWidth = lineWidth;
              state.currentMiterLimit = miterLimit;
            }
          };
          CanvasBuilder.prototype.endGeometry = function(feature) {
            this.beginGeometryInstruction1_[2] = this.instructions.length;
            this.beginGeometryInstruction1_ = null;
            this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
            this.beginGeometryInstruction2_ = null;
            var endGeometryInstruction = [canvas_Instruction.END_GEOMETRY, feature];
            this.instructions.push(endGeometryInstruction);
            this.hitDetectionInstructions.push(endGeometryInstruction);
          };
          CanvasBuilder.prototype.getBufferedMaxExtent = function() {
            if (!this.bufferedMaxExtent_) {
              this.bufferedMaxExtent_ = clone(this.maxExtent);
              if (this.maxLineWidth > 0) {
                var width = this.resolution * (this.maxLineWidth + 1) / 2;
                extent_buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
              }
            }
            return this.bufferedMaxExtent_;
          };
          return CanvasBuilder;
        }(render_VectorContext);
        var Builder = Builder_CanvasBuilder;
        var ImageBuilder_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ImageBuilder_CanvasImageBuilder = function(_super) {
          ImageBuilder_extends(CanvasImageBuilder, _super);
          function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
            var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
            _this.hitDetectionImage_ = null;
            _this.image_ = null;
            _this.imagePixelRatio_ = void 0;
            _this.anchorX_ = void 0;
            _this.anchorY_ = void 0;
            _this.height_ = void 0;
            _this.opacity_ = void 0;
            _this.originX_ = void 0;
            _this.originY_ = void 0;
            _this.rotateWithView_ = void 0;
            _this.rotation_ = void 0;
            _this.scale_ = void 0;
            _this.width_ = void 0;
            _this.declutterImageWithText_ = void 0;
            return _this;
          }
          CanvasImageBuilder.prototype.drawPoint = function(pointGeometry, feature) {
            if (!this.image_) {
              return;
            }
            this.beginGeometry(pointGeometry, feature);
            var flatCoordinates = pointGeometry.getFlatCoordinates();
            var stride = pointGeometry.getStride();
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            this.instructions.push([
              canvas_Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.image_,
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
              this.declutterImageWithText_
            ]);
            this.hitDetectionInstructions.push([
              canvas_Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.hitDetectionImage_,
              this.anchorX_,
              this.anchorY_,
              this.height_,
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              this.scale_,
              this.width_,
              this.declutterImageWithText_
            ]);
            this.endGeometry(feature);
          };
          CanvasImageBuilder.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
            if (!this.image_) {
              return;
            }
            this.beginGeometry(multiPointGeometry, feature);
            var flatCoordinates = multiPointGeometry.getFlatCoordinates();
            var stride = multiPointGeometry.getStride();
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            this.instructions.push([
              canvas_Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.image_,
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
              this.declutterImageWithText_
            ]);
            this.hitDetectionInstructions.push([
              canvas_Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.hitDetectionImage_,
              this.anchorX_,
              this.anchorY_,
              this.height_,
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              this.scale_,
              this.width_,
              this.declutterImageWithText_
            ]);
            this.endGeometry(feature);
          };
          CanvasImageBuilder.prototype.finish = function() {
            this.reverseHitDetectionInstructions();
            this.anchorX_ = void 0;
            this.anchorY_ = void 0;
            this.hitDetectionImage_ = null;
            this.image_ = null;
            this.imagePixelRatio_ = void 0;
            this.height_ = void 0;
            this.scale_ = void 0;
            this.opacity_ = void 0;
            this.originX_ = void 0;
            this.originY_ = void 0;
            this.rotateWithView_ = void 0;
            this.rotation_ = void 0;
            this.width_ = void 0;
            return _super.prototype.finish.call(this);
          };
          CanvasImageBuilder.prototype.setImageStyle = function(imageStyle, opt_sharedData) {
            var anchor = imageStyle.getAnchor();
            var size = imageStyle.getSize();
            var hitDetectionImage = imageStyle.getHitDetectionImage();
            var image = imageStyle.getImage(this.pixelRatio);
            var origin = imageStyle.getOrigin();
            this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
            this.anchorX_ = anchor[0];
            this.anchorY_ = anchor[1];
            this.hitDetectionImage_ = hitDetectionImage;
            this.image_ = image;
            this.height_ = size[1];
            this.opacity_ = imageStyle.getOpacity();
            this.originX_ = origin[0] * this.imagePixelRatio_;
            this.originY_ = origin[1] * this.imagePixelRatio_;
            this.rotateWithView_ = imageStyle.getRotateWithView();
            this.rotation_ = imageStyle.getRotation();
            this.scale_ = imageStyle.getScaleArray();
            this.width_ = size[0];
            this.declutterImageWithText_ = opt_sharedData;
          };
          return CanvasImageBuilder;
        }(Builder);
        var ImageBuilder = ImageBuilder_CanvasImageBuilder;
        var LineStringBuilder_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var LineStringBuilder_CanvasLineStringBuilder = function(_super) {
          LineStringBuilder_extends(CanvasLineStringBuilder, _super);
          function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
            return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
          }
          CanvasLineStringBuilder.prototype.drawFlatCoordinates_ = function(flatCoordinates, offset, end, stride) {
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
            var moveToLineToInstruction = [
              canvas_Instruction.MOVE_TO_LINE_TO,
              myBegin,
              myEnd
            ];
            this.instructions.push(moveToLineToInstruction);
            this.hitDetectionInstructions.push(moveToLineToInstruction);
            return end;
          };
          CanvasLineStringBuilder.prototype.drawLineString = function(lineStringGeometry, feature) {
            var state = this.state;
            var strokeStyle = state.strokeStyle;
            var lineWidth = state.lineWidth;
            if (strokeStyle === void 0 || lineWidth === void 0) {
              return;
            }
            this.updateStrokeStyle(state, this.applyStroke);
            this.beginGeometry(lineStringGeometry, feature);
            this.hitDetectionInstructions.push([
              canvas_Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              defaultLineDash,
              defaultLineDashOffset
            ], beginPathInstruction);
            var flatCoordinates = lineStringGeometry.getFlatCoordinates();
            var stride = lineStringGeometry.getStride();
            this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
            this.hitDetectionInstructions.push(Instruction_strokeInstruction);
            this.endGeometry(feature);
          };
          CanvasLineStringBuilder.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
            var state = this.state;
            var strokeStyle = state.strokeStyle;
            var lineWidth = state.lineWidth;
            if (strokeStyle === void 0 || lineWidth === void 0) {
              return;
            }
            this.updateStrokeStyle(state, this.applyStroke);
            this.beginGeometry(multiLineStringGeometry, feature);
            this.hitDetectionInstructions.push([
              canvas_Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              state.lineDash,
              state.lineDashOffset
            ], beginPathInstruction);
            var ends = multiLineStringGeometry.getEnds();
            var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
            var stride = multiLineStringGeometry.getStride();
            var offset = 0;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
            }
            this.hitDetectionInstructions.push(Instruction_strokeInstruction);
            this.endGeometry(feature);
          };
          CanvasLineStringBuilder.prototype.finish = function() {
            var state = this.state;
            if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
              this.instructions.push(Instruction_strokeInstruction);
            }
            this.reverseHitDetectionInstructions();
            this.state = null;
            return _super.prototype.finish.call(this);
          };
          CanvasLineStringBuilder.prototype.applyStroke = function(state) {
            if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
              this.instructions.push(Instruction_strokeInstruction);
              state.lastStroke = this.coordinates.length;
            }
            state.lastStroke = 0;
            _super.prototype.applyStroke.call(this, state);
            this.instructions.push(beginPathInstruction);
          };
          return CanvasLineStringBuilder;
        }(Builder);
        var LineStringBuilder = LineStringBuilder_CanvasLineStringBuilder;
        var PolygonBuilder_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var PolygonBuilder_CanvasPolygonBuilder = function(_super) {
          PolygonBuilder_extends(CanvasPolygonBuilder, _super);
          function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
            return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
          }
          CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset, ends, stride) {
            var state = this.state;
            var fill = state.fillStyle !== void 0;
            var stroke = state.strokeStyle !== void 0;
            var numEnds = ends.length;
            this.instructions.push(beginPathInstruction);
            this.hitDetectionInstructions.push(beginPathInstruction);
            for (var i = 0; i < numEnds; ++i) {
              var end = ends[i];
              var myBegin = this.coordinates.length;
              var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
              var moveToLineToInstruction = [
                canvas_Instruction.MOVE_TO_LINE_TO,
                myBegin,
                myEnd
              ];
              this.instructions.push(moveToLineToInstruction);
              this.hitDetectionInstructions.push(moveToLineToInstruction);
              if (stroke) {
                this.instructions.push(closePathInstruction);
                this.hitDetectionInstructions.push(closePathInstruction);
              }
              offset = end;
            }
            if (fill) {
              this.instructions.push(Instruction_fillInstruction);
              this.hitDetectionInstructions.push(Instruction_fillInstruction);
            }
            if (stroke) {
              this.instructions.push(Instruction_strokeInstruction);
              this.hitDetectionInstructions.push(Instruction_strokeInstruction);
            }
            return offset;
          };
          CanvasPolygonBuilder.prototype.drawCircle = function(circleGeometry, feature) {
            var state = this.state;
            var fillStyle = state.fillStyle;
            var strokeStyle = state.strokeStyle;
            if (fillStyle === void 0 && strokeStyle === void 0) {
              return;
            }
            this.setFillStrokeStyles_();
            this.beginGeometry(circleGeometry, feature);
            if (state.fillStyle !== void 0) {
              this.hitDetectionInstructions.push([
                canvas_Instruction.SET_FILL_STYLE,
                defaultFillStyle
              ]);
            }
            if (state.strokeStyle !== void 0) {
              this.hitDetectionInstructions.push([
                canvas_Instruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset
              ]);
            }
            var flatCoordinates = circleGeometry.getFlatCoordinates();
            var stride = circleGeometry.getStride();
            var myBegin = this.coordinates.length;
            this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
            var circleInstruction = [canvas_Instruction.CIRCLE, myBegin];
            this.instructions.push(beginPathInstruction, circleInstruction);
            this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
            if (state.fillStyle !== void 0) {
              this.instructions.push(Instruction_fillInstruction);
              this.hitDetectionInstructions.push(Instruction_fillInstruction);
            }
            if (state.strokeStyle !== void 0) {
              this.instructions.push(Instruction_strokeInstruction);
              this.hitDetectionInstructions.push(Instruction_strokeInstruction);
            }
            this.endGeometry(feature);
          };
          CanvasPolygonBuilder.prototype.drawPolygon = function(polygonGeometry, feature) {
            var state = this.state;
            var fillStyle = state.fillStyle;
            var strokeStyle = state.strokeStyle;
            if (fillStyle === void 0 && strokeStyle === void 0) {
              return;
            }
            this.setFillStrokeStyles_();
            this.beginGeometry(polygonGeometry, feature);
            if (state.fillStyle !== void 0) {
              this.hitDetectionInstructions.push([
                canvas_Instruction.SET_FILL_STYLE,
                defaultFillStyle
              ]);
            }
            if (state.strokeStyle !== void 0) {
              this.hitDetectionInstructions.push([
                canvas_Instruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset
              ]);
            }
            var ends = polygonGeometry.getEnds();
            var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
            var stride = polygonGeometry.getStride();
            this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
            this.endGeometry(feature);
          };
          CanvasPolygonBuilder.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
            var state = this.state;
            var fillStyle = state.fillStyle;
            var strokeStyle = state.strokeStyle;
            if (fillStyle === void 0 && strokeStyle === void 0) {
              return;
            }
            this.setFillStrokeStyles_();
            this.beginGeometry(multiPolygonGeometry, feature);
            if (state.fillStyle !== void 0) {
              this.hitDetectionInstructions.push([
                canvas_Instruction.SET_FILL_STYLE,
                defaultFillStyle
              ]);
            }
            if (state.strokeStyle !== void 0) {
              this.hitDetectionInstructions.push([
                canvas_Instruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset
              ]);
            }
            var endss = multiPolygonGeometry.getEndss();
            var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
            var stride = multiPolygonGeometry.getStride();
            var offset = 0;
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
            }
            this.endGeometry(feature);
          };
          CanvasPolygonBuilder.prototype.finish = function() {
            this.reverseHitDetectionInstructions();
            this.state = null;
            var tolerance = this.tolerance;
            if (tolerance !== 0) {
              var coordinates = this.coordinates;
              for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                coordinates[i] = simplify_snap(coordinates[i], tolerance);
              }
            }
            return _super.prototype.finish.call(this);
          };
          CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function() {
            var state = this.state;
            var fillStyle = state.fillStyle;
            if (fillStyle !== void 0) {
              this.updateFillStyle(state, this.createFill);
            }
            if (state.strokeStyle !== void 0) {
              this.updateStrokeStyle(state, this.applyStroke);
            }
          };
          return CanvasPolygonBuilder;
        }(Builder);
        var PolygonBuilder = PolygonBuilder_CanvasPolygonBuilder;
        var TextPlacement = {
          POINT: "point",
          LINE: "line"
        };
        function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
          var chunkStart = offset;
          var chunkEnd = offset;
          var chunkM = 0;
          var m = 0;
          var start = offset;
          var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
          for (i = offset; i < end; i += stride) {
            var x2 = flatCoordinates[i];
            var y2 = flatCoordinates[i + 1];
            if (x1 !== void 0) {
              x23 = x2 - x1;
              y23 = y2 - y1;
              m23 = Math.sqrt(x23 * x23 + y23 * y23);
              if (x12 !== void 0) {
                m += m12;
                acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                if (acos > maxAngle) {
                  if (m > chunkM) {
                    chunkM = m;
                    chunkStart = start;
                    chunkEnd = i;
                  }
                  m = 0;
                  start = i - stride;
                }
              }
              m12 = m23;
              x12 = x23;
              y12 = y23;
            }
            x1 = x2;
            y1 = y2;
          }
          m += m23;
          return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
        }
        var TextBuilder_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var TEXT_ALIGN = {
          "left": 0,
          "end": 0,
          "center": 0.5,
          "right": 1,
          "start": 1,
          "top": 0,
          "middle": 0.5,
          "hanging": 0.2,
          "alphabetic": 0.8,
          "ideographic": 0.8,
          "bottom": 1
        };
        var TextBuilder_CanvasTextBuilder = function(_super) {
          TextBuilder_extends(CanvasTextBuilder, _super);
          function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
            var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
            _this.labels_ = null;
            _this.text_ = "";
            _this.textOffsetX_ = 0;
            _this.textOffsetY_ = 0;
            _this.textRotateWithView_ = void 0;
            _this.textRotation_ = 0;
            _this.textFillState_ = null;
            _this.fillStates = {};
            _this.textStrokeState_ = null;
            _this.strokeStates = {};
            _this.textState_ = {};
            _this.textStates = {};
            _this.textKey_ = "";
            _this.fillKey_ = "";
            _this.strokeKey_ = "";
            _this.declutterImageWithText_ = void 0;
            return _this;
          }
          CanvasTextBuilder.prototype.finish = function() {
            var instructions = _super.prototype.finish.call(this);
            instructions.textStates = this.textStates;
            instructions.fillStates = this.fillStates;
            instructions.strokeStates = this.strokeStates;
            return instructions;
          };
          CanvasTextBuilder.prototype.drawText = function(geometry, feature) {
            var fillState = this.textFillState_;
            var strokeState = this.textStrokeState_;
            var textState = this.textState_;
            if (this.text_ === "" || !textState || !fillState && !strokeState) {
              return;
            }
            var coordinates = this.coordinates;
            var begin = coordinates.length;
            var geometryType = geometry.getType();
            var flatCoordinates = null;
            var stride = geometry.getStride();
            if (textState.placement === TextPlacement.LINE && (geometryType == geom_GeometryType.LINE_STRING || geometryType == geom_GeometryType.MULTI_LINE_STRING || geometryType == geom_GeometryType.POLYGON || geometryType == geom_GeometryType.MULTI_POLYGON)) {
              if (!extent_intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
                return;
              }
              var ends = void 0;
              flatCoordinates = geometry.getFlatCoordinates();
              if (geometryType == geom_GeometryType.LINE_STRING) {
                ends = [flatCoordinates.length];
              } else if (geometryType == geom_GeometryType.MULTI_LINE_STRING) {
                ends = geometry.getEnds();
              } else if (geometryType == geom_GeometryType.POLYGON) {
                ends = geometry.getEnds().slice(0, 1);
              } else if (geometryType == geom_GeometryType.MULTI_POLYGON) {
                var endss = geometry.getEndss();
                ends = [];
                for (var i = 0, ii = endss.length; i < ii; ++i) {
                  ends.push(endss[i][0]);
                }
              }
              this.beginGeometry(geometry, feature);
              var textAlign = textState.textAlign;
              var flatOffset = 0;
              var flatEnd = void 0;
              for (var o = 0, oo = ends.length; o < oo; ++o) {
                if (textAlign == void 0) {
                  var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
                  flatOffset = range[0];
                  flatEnd = range[1];
                } else {
                  flatEnd = ends[o];
                }
                for (var i = flatOffset; i < flatEnd; i += stride) {
                  coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
                }
                var end = coordinates.length;
                flatOffset = ends[o];
                this.drawChars_(begin, end);
                begin = end;
              }
              this.endGeometry(feature);
            } else {
              var geometryWidths = textState.overflow ? null : [];
              switch (geometryType) {
                case geom_GeometryType.POINT:
                case geom_GeometryType.MULTI_POINT:
                  flatCoordinates = geometry.getFlatCoordinates();
                  break;
                case geom_GeometryType.LINE_STRING:
                  flatCoordinates = geometry.getFlatMidpoint();
                  break;
                case geom_GeometryType.CIRCLE:
                  flatCoordinates = geometry.getCenter();
                  break;
                case geom_GeometryType.MULTI_LINE_STRING:
                  flatCoordinates = geometry.getFlatMidpoints();
                  stride = 2;
                  break;
                case geom_GeometryType.POLYGON:
                  flatCoordinates = geometry.getFlatInteriorPoint();
                  if (!textState.overflow) {
                    geometryWidths.push(flatCoordinates[2] / this.resolution);
                  }
                  stride = 3;
                  break;
                case geom_GeometryType.MULTI_POLYGON:
                  var interiorPoints = geometry.getFlatInteriorPoints();
                  flatCoordinates = [];
                  for (var i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                    if (!textState.overflow) {
                      geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                    }
                    flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                  }
                  if (flatCoordinates.length === 0) {
                    return;
                  }
                  stride = 2;
                  break;
                default:
              }
              var end = this.appendFlatPointCoordinates(flatCoordinates, stride);
              if (end === begin) {
                return;
              }
              if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
                var beg_1 = begin / 2;
                geometryWidths = geometryWidths.filter(function(w, i2) {
                  var keep = coordinates[(beg_1 + i2) * 2] === flatCoordinates[i2 * stride] && coordinates[(beg_1 + i2) * 2 + 1] === flatCoordinates[i2 * stride + 1];
                  if (!keep) {
                    --beg_1;
                  }
                  return keep;
                });
              }
              this.saveTextStates_();
              if (textState.backgroundFill || textState.backgroundStroke) {
                this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                if (textState.backgroundFill) {
                  this.updateFillStyle(this.state, this.createFill);
                  this.hitDetectionInstructions.push(this.createFill(this.state));
                }
                if (textState.backgroundStroke) {
                  this.updateStrokeStyle(this.state, this.applyStroke);
                  this.hitDetectionInstructions.push(this.createStroke(this.state));
                }
              }
              this.beginGeometry(geometry, feature);
              var padding = textState.padding;
              if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                var p0 = textState.padding[0];
                var p1 = textState.padding[1];
                var p2 = textState.padding[2];
                var p3 = textState.padding[3];
                if (textState.scale[0] < 0) {
                  p1 = -p1;
                  p3 = -p3;
                }
                if (textState.scale[1] < 0) {
                  p0 = -p0;
                  p2 = -p2;
                }
                padding = [p0, p1, p2, p3];
              }
              var pixelRatio_1 = this.pixelRatio;
              this.instructions.push([
                canvas_Instruction.DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [1, 1],
                NaN,
                this.declutterImageWithText_,
                padding == defaultPadding ? defaultPadding : padding.map(function(p) {
                  return p * pixelRatio_1;
                }),
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths
              ]);
              var scale = 1 / pixelRatio_1;
              this.hitDetectionInstructions.push([
                canvas_Instruction.DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [scale, scale],
                NaN,
                this.declutterImageWithText_,
                padding,
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths
              ]);
              this.endGeometry(feature);
            }
          };
          CanvasTextBuilder.prototype.saveTextStates_ = function() {
            var strokeState = this.textStrokeState_;
            var textState = this.textState_;
            var fillState = this.textFillState_;
            var strokeKey = this.strokeKey_;
            if (strokeState) {
              if (!(strokeKey in this.strokeStates)) {
                this.strokeStates[strokeKey] = {
                  strokeStyle: strokeState.strokeStyle,
                  lineCap: strokeState.lineCap,
                  lineDashOffset: strokeState.lineDashOffset,
                  lineWidth: strokeState.lineWidth,
                  lineJoin: strokeState.lineJoin,
                  miterLimit: strokeState.miterLimit,
                  lineDash: strokeState.lineDash
                };
              }
            }
            var textKey = this.textKey_;
            if (!(textKey in this.textStates)) {
              this.textStates[textKey] = {
                font: textState.font,
                textAlign: textState.textAlign || defaultTextAlign,
                textBaseline: textState.textBaseline || defaultTextBaseline,
                scale: textState.scale
              };
            }
            var fillKey = this.fillKey_;
            if (fillState) {
              if (!(fillKey in this.fillStates)) {
                this.fillStates[fillKey] = {
                  fillStyle: fillState.fillStyle
                };
              }
            }
          };
          CanvasTextBuilder.prototype.drawChars_ = function(begin, end) {
            var strokeState = this.textStrokeState_;
            var textState = this.textState_;
            var strokeKey = this.strokeKey_;
            var textKey = this.textKey_;
            var fillKey = this.fillKey_;
            this.saveTextStates_();
            var pixelRatio = this.pixelRatio;
            var baseline = TEXT_ALIGN[textState.textBaseline];
            var offsetY = this.textOffsetY_ * pixelRatio;
            var text = this.text_;
            var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
            this.instructions.push([
              canvas_Instruction.DRAW_CHARS,
              begin,
              end,
              baseline,
              textState.overflow,
              fillKey,
              textState.maxAngle,
              pixelRatio,
              offsetY,
              strokeKey,
              strokeWidth * pixelRatio,
              text,
              textKey,
              1
            ]);
            this.hitDetectionInstructions.push([
              canvas_Instruction.DRAW_CHARS,
              begin,
              end,
              baseline,
              textState.overflow,
              fillKey,
              textState.maxAngle,
              1,
              offsetY,
              strokeKey,
              strokeWidth,
              text,
              textKey,
              1 / pixelRatio
            ]);
          };
          CanvasTextBuilder.prototype.setTextStyle = function(textStyle, opt_sharedData) {
            var textState, fillState, strokeState;
            if (!textStyle) {
              this.text_ = "";
            } else {
              var textFillStyle = textStyle.getFill();
              if (!textFillStyle) {
                fillState = null;
                this.textFillState_ = fillState;
              } else {
                fillState = this.textFillState_;
                if (!fillState) {
                  fillState = {};
                  this.textFillState_ = fillState;
                }
                fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
              }
              var textStrokeStyle = textStyle.getStroke();
              if (!textStrokeStyle) {
                strokeState = null;
                this.textStrokeState_ = strokeState;
              } else {
                strokeState = this.textStrokeState_;
                if (!strokeState) {
                  strokeState = {};
                  this.textStrokeState_ = strokeState;
                }
                var lineDash = textStrokeStyle.getLineDash();
                var lineDashOffset = textStrokeStyle.getLineDashOffset();
                var lineWidth = textStrokeStyle.getWidth();
                var miterLimit = textStrokeStyle.getMiterLimit();
                strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
                strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
                strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
                strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
                strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
                strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
                strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
              }
              textState = this.textState_;
              var font = textStyle.getFont() || defaultFont;
              registerFont(font);
              var textScale = textStyle.getScaleArray();
              textState.overflow = textStyle.getOverflow();
              textState.font = font;
              textState.maxAngle = textStyle.getMaxAngle();
              textState.placement = textStyle.getPlacement();
              textState.textAlign = textStyle.getTextAlign();
              textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
              textState.backgroundFill = textStyle.getBackgroundFill();
              textState.backgroundStroke = textStyle.getBackgroundStroke();
              textState.padding = textStyle.getPadding() || defaultPadding;
              textState.scale = textScale === void 0 ? [1, 1] : textScale;
              var textOffsetX = textStyle.getOffsetX();
              var textOffsetY = textStyle.getOffsetY();
              var textRotateWithView = textStyle.getRotateWithView();
              var textRotation = textStyle.getRotation();
              this.text_ = textStyle.getText() || "";
              this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
              this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
              this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
              this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
              this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : Object(util["c"])(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
              this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.textBaseline || "?");
              this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + Object(util["c"])(fillState.fillStyle) : "";
            }
            this.declutterImageWithText_ = opt_sharedData;
          };
          return CanvasTextBuilder;
        }(Builder);
        var TextBuilder = TextBuilder_CanvasTextBuilder;
        var BATCH_CONSTRUCTORS = {
          "Circle": PolygonBuilder,
          "Default": Builder,
          "Image": ImageBuilder,
          "LineString": LineStringBuilder,
          "Polygon": PolygonBuilder,
          "Text": TextBuilder
        };
        var BuilderGroup = function() {
          function BuilderGroup2(tolerance, maxExtent, resolution, pixelRatio) {
            this.tolerance_ = tolerance;
            this.maxExtent_ = maxExtent;
            this.pixelRatio_ = pixelRatio;
            this.resolution_ = resolution;
            this.buildersByZIndex_ = {};
          }
          BuilderGroup2.prototype.finish = function() {
            var builderInstructions = {};
            for (var zKey in this.buildersByZIndex_) {
              builderInstructions[zKey] = builderInstructions[zKey] || {};
              var builders = this.buildersByZIndex_[zKey];
              for (var builderKey in builders) {
                var builderInstruction = builders[builderKey].finish();
                builderInstructions[zKey][builderKey] = builderInstruction;
              }
            }
            return builderInstructions;
          };
          BuilderGroup2.prototype.getBuilder = function(zIndex, builderType) {
            var zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
            var replays = this.buildersByZIndex_[zIndexKey];
            if (replays === void 0) {
              replays = {};
              this.buildersByZIndex_[zIndexKey] = replays;
            }
            var replay = replays[builderType];
            if (replay === void 0) {
              var Constructor = BATCH_CONSTRUCTORS[builderType];
              replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
              replays[builderType] = replay;
            }
            return replay;
          };
          return BuilderGroup2;
        }();
        var canvas_BuilderGroup = BuilderGroup;
        var BuilderType = {
          CIRCLE: "Circle",
          DEFAULT: "Default",
          IMAGE: "Image",
          LINE_STRING: "LineString",
          POLYGON: "Polygon",
          TEXT: "Text"
        };
        function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          var x1 = 0;
          var y1 = 0;
          var segmentLength = 0;
          var segmentM = 0;
          function advance() {
            x1 = x2;
            y1 = y2;
            offset += stride;
            x2 = flatCoordinates[offset];
            y2 = flatCoordinates[offset + 1];
            segmentM += segmentLength;
            segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
          }
          do {
            advance();
          } while (offset < end - stride && segmentM + segmentLength < startM);
          var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
          var beginX = lerp(x1, x2, interpolate);
          var beginY = lerp(y1, y2, interpolate);
          var startOffset = offset - stride;
          var startLength = segmentM;
          var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
          while (offset < end - stride && segmentM + segmentLength < endM) {
            advance();
          }
          interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
          var endX = lerp(x1, x2, interpolate);
          var endY = lerp(y1, y2, interpolate);
          var reverse;
          if (rotation) {
            var flat = [beginX, beginY, endX, endY];
            transform_rotate(flat, 0, 4, 2, rotation, flat, flat);
            reverse = flat[0] > flat[2];
          } else {
            reverse = beginX > endX;
          }
          var PI = Math.PI;
          var result = [];
          var singleSegment = startOffset + stride === offset;
          offset = startOffset;
          segmentLength = 0;
          segmentM = startLength;
          x2 = flatCoordinates[offset];
          y2 = flatCoordinates[offset + 1];
          var previousAngle;
          if (singleSegment) {
            advance();
            previousAngle = Math.atan2(y2 - y1, x2 - x1);
            if (reverse) {
              previousAngle += previousAngle > 0 ? -PI : PI;
            }
            var x = (endX + beginX) / 2;
            var y = (endY + beginY) / 2;
            result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
            return result;
          }
          for (var i = 0, ii = text.length; i < ii; ) {
            advance();
            var angle = Math.atan2(y2 - y1, x2 - x1);
            if (reverse) {
              angle += angle > 0 ? -PI : PI;
            }
            if (previousAngle !== void 0) {
              var delta = angle - previousAngle;
              delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
              if (Math.abs(delta) > maxAngle) {
                return null;
              }
            }
            previousAngle = angle;
            var iStart = i;
            var charLength = 0;
            for (; i < ii; ++i) {
              var index = reverse ? ii - i - 1 : i;
              var len = scale * measureAndCacheTextWidth(font, text[index], cache);
              if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
                break;
              }
              charLength += len;
            }
            if (i === iStart) {
              continue;
            }
            var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
            interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
            var x = lerp(x1, x2, interpolate);
            var y = lerp(y1, y2, interpolate);
            result.push([x, y, charLength / 2, angle, chars]);
            startM += charLength;
          }
          return result;
        }
        function lineStringLength(flatCoordinates, offset, end, stride) {
          var x1 = flatCoordinates[offset];
          var y1 = flatCoordinates[offset + 1];
          var length = 0;
          for (var i = offset + stride; i < end; i += stride) {
            var x2 = flatCoordinates[i];
            var y2 = flatCoordinates[i + 1];
            length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            x1 = x2;
            y1 = y2;
          }
          return length;
        }
        function linearRingLength(flatCoordinates, offset, end, stride) {
          var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
          var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
          var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
          perimeter += Math.sqrt(dx * dx + dy * dy);
          return perimeter;
        }
        var Executor_tmpExtent = createEmpty();
        var Executor_p1 = [];
        var Executor_p2 = [];
        var Executor_p3 = [];
        var p4 = [];
        function getDeclutterBox(replayImageOrLabelArgs) {
          return replayImageOrLabelArgs[3].declutterBox;
        }
        var rtlRegEx = new RegExp("[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]");
        function horizontalTextAlign(text, align) {
          if ((align === "start" || align === "end") && !rtlRegEx.test(text)) {
            align = align === "start" ? "left" : "right";
          }
          return TEXT_ALIGN[align];
        }
        var Executor_Executor = function() {
          function Executor(resolution, pixelRatio, overlaps, instructions) {
            this.overlaps = overlaps;
            this.pixelRatio = pixelRatio;
            this.resolution = resolution;
            this.alignFill_;
            this.instructions = instructions.instructions;
            this.coordinates = instructions.coordinates;
            this.coordinateCache_ = {};
            this.renderedTransform_ = create();
            this.hitDetectionInstructions = instructions.hitDetectionInstructions;
            this.pixelCoordinates_ = null;
            this.viewRotation_ = 0;
            this.fillStates = instructions.fillStates || {};
            this.strokeStates = instructions.strokeStates || {};
            this.textStates = instructions.textStates || {};
            this.widths_ = {};
            this.labels_ = {};
          }
          Executor.prototype.createLabel = function(text, textKey, fillKey, strokeKey) {
            var key = text + textKey + fillKey + strokeKey;
            if (this.labels_[key]) {
              return this.labels_[key];
            }
            var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
            var fillState = fillKey ? this.fillStates[fillKey] : null;
            var textState = this.textStates[textKey];
            var pixelRatio = this.pixelRatio;
            var scale = [
              textState.scale[0] * pixelRatio,
              textState.scale[1] * pixelRatio
            ];
            var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);
            var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
            var lines = text.split("\n");
            var numLines = lines.length;
            var widths = [];
            var width = measureTextWidths(textState.font, lines, widths);
            var lineHeight = measureTextHeight(textState.font);
            var height = lineHeight * numLines;
            var renderWidth = width + strokeWidth;
            var contextInstructions = [];
            var w = (renderWidth + 2) * scale[0];
            var h = (height + strokeWidth) * scale[1];
            var label = {
              width: w < 0 ? Math.floor(w) : Math.ceil(w),
              height: h < 0 ? Math.floor(h) : Math.ceil(h),
              contextInstructions
            };
            if (scale[0] != 1 || scale[1] != 1) {
              contextInstructions.push("scale", scale);
            }
            contextInstructions.push("font", textState.font);
            if (strokeKey) {
              contextInstructions.push("strokeStyle", strokeState.strokeStyle);
              contextInstructions.push("lineWidth", strokeWidth);
              contextInstructions.push("lineCap", strokeState.lineCap);
              contextInstructions.push("lineJoin", strokeState.lineJoin);
              contextInstructions.push("miterLimit", strokeState.miterLimit);
              var Context = has["g"] ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
              if (Context.prototype.setLineDash) {
                contextInstructions.push("setLineDash", [strokeState.lineDash]);
                contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
              }
            }
            if (fillKey) {
              contextInstructions.push("fillStyle", fillState.fillStyle);
            }
            contextInstructions.push("textBaseline", "middle");
            contextInstructions.push("textAlign", "center");
            var leftRight = 0.5 - align;
            var x = align * renderWidth + leftRight * strokeWidth;
            var i;
            if (strokeKey) {
              for (i = 0; i < numLines; ++i) {
                contextInstructions.push("strokeText", [
                  lines[i],
                  x + leftRight * widths[i],
                  0.5 * (strokeWidth + lineHeight) + i * lineHeight
                ]);
              }
            }
            if (fillKey) {
              for (i = 0; i < numLines; ++i) {
                contextInstructions.push("fillText", [
                  lines[i],
                  x + leftRight * widths[i],
                  0.5 * (strokeWidth + lineHeight) + i * lineHeight
                ]);
              }
            }
            this.labels_[key] = label;
            return label;
          };
          Executor.prototype.replayTextBackground_ = function(context, p1, p2, p3, p42, fillInstruction, strokeInstruction) {
            context.beginPath();
            context.moveTo.apply(context, p1);
            context.lineTo.apply(context, p2);
            context.lineTo.apply(context, p3);
            context.lineTo.apply(context, p42);
            context.lineTo.apply(context, p1);
            if (fillInstruction) {
              this.alignFill_ = fillInstruction[2];
              this.fill_(context);
            }
            if (strokeInstruction) {
              this.setStrokeStyle_(context, strokeInstruction);
              context.stroke();
            }
          };
          Executor.prototype.calculateImageOrLabelDimensions_ = function(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
            anchorX *= scale[0];
            anchorY *= scale[1];
            var x = centerX - anchorX;
            var y = centerY - anchorY;
            var w = width + originX > sheetWidth ? sheetWidth - originX : width;
            var h = height + originY > sheetHeight ? sheetHeight - originY : height;
            var boxW = padding[3] + w * scale[0] + padding[1];
            var boxH = padding[0] + h * scale[1] + padding[2];
            var boxX = x - padding[3];
            var boxY = y - padding[0];
            if (fillStroke || rotation !== 0) {
              Executor_p1[0] = boxX;
              p4[0] = boxX;
              Executor_p1[1] = boxY;
              Executor_p2[1] = boxY;
              Executor_p2[0] = boxX + boxW;
              Executor_p3[0] = Executor_p2[0];
              Executor_p3[1] = boxY + boxH;
              p4[1] = Executor_p3[1];
            }
            var transform2;
            if (rotation !== 0) {
              transform2 = compose(create(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
              apply(transform2, Executor_p1);
              apply(transform2, Executor_p2);
              apply(transform2, Executor_p3);
              apply(transform2, p4);
              createOrUpdate(Math.min(Executor_p1[0], Executor_p2[0], Executor_p3[0], p4[0]), Math.min(Executor_p1[1], Executor_p2[1], Executor_p3[1], p4[1]), Math.max(Executor_p1[0], Executor_p2[0], Executor_p3[0], p4[0]), Math.max(Executor_p1[1], Executor_p2[1], Executor_p3[1], p4[1]), Executor_tmpExtent);
            } else {
              createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), Executor_tmpExtent);
            }
            if (snapToPixel) {
              x = Math.round(x);
              y = Math.round(y);
            }
            return {
              drawImageX: x,
              drawImageY: y,
              drawImageW: w,
              drawImageH: h,
              originX,
              originY,
              declutterBox: {
                minX: Executor_tmpExtent[0],
                minY: Executor_tmpExtent[1],
                maxX: Executor_tmpExtent[2],
                maxY: Executor_tmpExtent[3],
                value: feature
              },
              canvasTransform: transform2,
              scale
            };
          };
          Executor.prototype.replayImageOrLabel_ = function(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
            var fillStroke = !!(fillInstruction || strokeInstruction);
            var box = dimensions.declutterBox;
            var canvas = context.canvas;
            var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
            var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
            if (intersects) {
              if (fillStroke) {
                this.replayTextBackground_(context, Executor_p1, Executor_p2, Executor_p3, p4, fillInstruction, strokeInstruction);
              }
              drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
            }
            return true;
          };
          Executor.prototype.fill_ = function(context) {
            if (this.alignFill_) {
              var origin_1 = apply(this.renderedTransform_, [0, 0]);
              var repeatSize = 512 * this.pixelRatio;
              context.save();
              context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
              context.rotate(this.viewRotation_);
            }
            context.fill();
            if (this.alignFill_) {
              context.restore();
            }
          };
          Executor.prototype.setStrokeStyle_ = function(context, instruction) {
            context["strokeStyle"] = instruction[1];
            context.lineWidth = instruction[2];
            context.lineCap = instruction[3];
            context.lineJoin = instruction[4];
            context.miterLimit = instruction[5];
            if (context.setLineDash) {
              context.lineDashOffset = instruction[7];
              context.setLineDash(instruction[6]);
            }
          };
          Executor.prototype.drawLabelWithPointPlacement_ = function(text, textKey, strokeKey, fillKey) {
            var textState = this.textStates[textKey];
            var label = this.createLabel(text, textKey, fillKey, strokeKey);
            var strokeState = this.strokeStates[strokeKey];
            var pixelRatio = this.pixelRatio;
            var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);
            var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
            var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
            var width = label.width / pixelRatio - 2 * textState.scale[0];
            var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
            var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
            return {
              label,
              anchorX,
              anchorY
            };
          };
          Executor.prototype.execute_ = function(context, contextScale, transform2, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {
            var pixelCoordinates;
            if (this.pixelCoordinates_ && Object(ol_array["b"])(transform2, this.renderedTransform_)) {
              pixelCoordinates = this.pixelCoordinates_;
            } else {
              if (!this.pixelCoordinates_) {
                this.pixelCoordinates_ = [];
              }
              pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform2, this.pixelCoordinates_);
              setFromArray(this.renderedTransform_, transform2);
            }
            var i = 0;
            var ii = instructions.length;
            var d = 0;
            var dd;
            var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
            var pendingFill = 0;
            var pendingStroke = 0;
            var lastFillInstruction = null;
            var lastStrokeInstruction = null;
            var coordinateCache = this.coordinateCache_;
            var viewRotation = this.viewRotation_;
            var viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
            var state = {
              context,
              pixelRatio: this.pixelRatio,
              resolution: this.resolution,
              rotation: viewRotation
            };
            var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
            var feature;
            var x, y, currentGeometry;
            while (i < ii) {
              var instruction = instructions[i];
              var type = instruction[0];
              switch (type) {
                case canvas_Instruction.BEGIN_GEOMETRY:
                  feature = instruction[1];
                  currentGeometry = instruction[3];
                  if (!feature.getGeometry()) {
                    i = instruction[2];
                  } else if (opt_hitExtent !== void 0 && !extent_intersects(opt_hitExtent, currentGeometry.getExtent())) {
                    i = instruction[2] + 1;
                  } else {
                    ++i;
                  }
                  break;
                case canvas_Instruction.BEGIN_PATH:
                  if (pendingFill > batchSize) {
                    this.fill_(context);
                    pendingFill = 0;
                  }
                  if (pendingStroke > batchSize) {
                    context.stroke();
                    pendingStroke = 0;
                  }
                  if (!pendingFill && !pendingStroke) {
                    context.beginPath();
                    prevX = NaN;
                    prevY = NaN;
                  }
                  ++i;
                  break;
                case canvas_Instruction.CIRCLE:
                  d = instruction[1];
                  var x1 = pixelCoordinates[d];
                  var y1 = pixelCoordinates[d + 1];
                  var x2 = pixelCoordinates[d + 2];
                  var y2 = pixelCoordinates[d + 3];
                  var dx = x2 - x1;
                  var dy = y2 - y1;
                  var r = Math.sqrt(dx * dx + dy * dy);
                  context.moveTo(x1 + r, y1);
                  context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                  ++i;
                  break;
                case canvas_Instruction.CLOSE_PATH:
                  context.closePath();
                  ++i;
                  break;
                case canvas_Instruction.CUSTOM:
                  d = instruction[1];
                  dd = instruction[2];
                  var geometry = instruction[3];
                  var renderer = instruction[4];
                  var fn = instruction.length == 6 ? instruction[5] : void 0;
                  state.geometry = geometry;
                  state.feature = feature;
                  if (!(i in coordinateCache)) {
                    coordinateCache[i] = [];
                  }
                  var coords = coordinateCache[i];
                  if (fn) {
                    fn(pixelCoordinates, d, dd, 2, coords);
                  } else {
                    coords[0] = pixelCoordinates[d];
                    coords[1] = pixelCoordinates[d + 1];
                    coords.length = 2;
                  }
                  renderer(coords, state);
                  ++i;
                  break;
                case canvas_Instruction.DRAW_IMAGE:
                  d = instruction[1];
                  dd = instruction[2];
                  image = instruction[3];
                  anchorX = instruction[4];
                  anchorY = instruction[5];
                  var height = instruction[6];
                  var opacity = instruction[7];
                  var originX = instruction[8];
                  var originY = instruction[9];
                  var rotateWithView = instruction[10];
                  var rotation = instruction[11];
                  var scale = instruction[12];
                  var width = instruction[13];
                  var declutterImageWithText = instruction[14];
                  if (!image && instruction.length >= 19) {
                    text = instruction[18];
                    textKey = instruction[19];
                    strokeKey = instruction[20];
                    fillKey = instruction[21];
                    var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                    image = labelWithAnchor.label;
                    instruction[3] = image;
                    var textOffsetX = instruction[22];
                    anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                    instruction[4] = anchorX;
                    var textOffsetY = instruction[23];
                    anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                    instruction[5] = anchorY;
                    height = image.height;
                    instruction[6] = height;
                    width = image.width;
                    instruction[13] = width;
                  }
                  var geometryWidths = void 0;
                  if (instruction.length > 24) {
                    geometryWidths = instruction[24];
                  }
                  var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
                  if (instruction.length > 16) {
                    padding = instruction[15];
                    backgroundFill = instruction[16];
                    backgroundStroke = instruction[17];
                  } else {
                    padding = defaultPadding;
                    backgroundFill = false;
                    backgroundStroke = false;
                  }
                  if (rotateWithView && viewRotationFromTransform) {
                    rotation += viewRotation;
                  } else if (!rotateWithView && !viewRotationFromTransform) {
                    rotation -= viewRotation;
                  }
                  var widthIndex = 0;
                  for (; d < dd; d += 2) {
                    if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                      continue;
                    }
                    var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
                    var args = [
                      context,
                      contextScale,
                      image,
                      dimensions,
                      opacity,
                      backgroundFill ? lastFillInstruction : null,
                      backgroundStroke ? lastStrokeInstruction : null
                    ];
                    var imageArgs = void 0;
                    var imageDeclutterBox = void 0;
                    if (opt_declutterTree && declutterImageWithText) {
                      var index = dd - d;
                      if (!declutterImageWithText[index]) {
                        declutterImageWithText[index] = args;
                        continue;
                      }
                      imageArgs = declutterImageWithText[index];
                      delete declutterImageWithText[index];
                      imageDeclutterBox = getDeclutterBox(imageArgs);
                      if (opt_declutterTree.collides(imageDeclutterBox)) {
                        continue;
                      }
                    }
                    if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                      continue;
                    }
                    if (imageArgs) {
                      if (opt_declutterTree) {
                        opt_declutterTree.insert(imageDeclutterBox);
                      }
                      this.replayImageOrLabel_.apply(this, imageArgs);
                    }
                    if (opt_declutterTree) {
                      opt_declutterTree.insert(dimensions.declutterBox);
                    }
                    this.replayImageOrLabel_.apply(this, args);
                  }
                  ++i;
                  break;
                case canvas_Instruction.DRAW_CHARS:
                  var begin = instruction[1];
                  var end = instruction[2];
                  var baseline = instruction[3];
                  var overflow = instruction[4];
                  fillKey = instruction[5];
                  var maxAngle = instruction[6];
                  var measurePixelRatio = instruction[7];
                  var offsetY = instruction[8];
                  strokeKey = instruction[9];
                  var strokeWidth = instruction[10];
                  text = instruction[11];
                  textKey = instruction[12];
                  var pixelRatioScale = [
                    instruction[13],
                    instruction[13]
                  ];
                  var textState = this.textStates[textKey];
                  var font = textState.font;
                  var textScale = [
                    textState.scale[0] * measurePixelRatio,
                    textState.scale[1] * measurePixelRatio
                  ];
                  var cachedWidths = void 0;
                  if (font in this.widths_) {
                    cachedWidths = this.widths_[font];
                  } else {
                    cachedWidths = {};
                    this.widths_[font] = cachedWidths;
                  }
                  var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
                  var textLength = Math.abs(textScale[0]) * canvas_measureAndCacheTextWidth(font, text, cachedWidths);
                  if (overflow || textLength <= pathLength) {
                    var textAlign = this.textStates[textKey].textAlign;
                    var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
                    var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), canvas_measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                    drawChars:
                      if (parts) {
                        var replayImageOrLabelArgs = [];
                        var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;
                        if (strokeKey) {
                          for (c = 0, cc = parts.length; c < cc; ++c) {
                            part = parts[c];
                            chars = part[4];
                            label = this.createLabel(chars, textKey, "", strokeKey);
                            anchorX = part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                            anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                            var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                            if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                              break drawChars;
                            }
                            replayImageOrLabelArgs.push([
                              context,
                              contextScale,
                              label,
                              dimensions,
                              1,
                              null,
                              null
                            ]);
                          }
                        }
                        if (fillKey) {
                          for (c = 0, cc = parts.length; c < cc; ++c) {
                            part = parts[c];
                            chars = part[4];
                            label = this.createLabel(chars, textKey, fillKey, "");
                            anchorX = part[2];
                            anchorY = baseline * label.height - offsetY;
                            var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                            if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                              break drawChars;
                            }
                            replayImageOrLabelArgs.push([
                              context,
                              contextScale,
                              label,
                              dimensions,
                              1,
                              null,
                              null
                            ]);
                          }
                        }
                        if (opt_declutterTree) {
                          opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                        }
                        for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {
                          this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);
                        }
                      }
                  }
                  ++i;
                  break;
                case canvas_Instruction.END_GEOMETRY:
                  if (opt_featureCallback !== void 0) {
                    feature = instruction[1];
                    var result = opt_featureCallback(feature, currentGeometry);
                    if (result) {
                      return result;
                    }
                  }
                  ++i;
                  break;
                case canvas_Instruction.FILL:
                  if (batchSize) {
                    pendingFill++;
                  } else {
                    this.fill_(context);
                  }
                  ++i;
                  break;
                case canvas_Instruction.MOVE_TO_LINE_TO:
                  d = instruction[1];
                  dd = instruction[2];
                  x = pixelCoordinates[d];
                  y = pixelCoordinates[d + 1];
                  roundX = x + 0.5 | 0;
                  roundY = y + 0.5 | 0;
                  if (roundX !== prevX || roundY !== prevY) {
                    context.moveTo(x, y);
                    prevX = roundX;
                    prevY = roundY;
                  }
                  for (d += 2; d < dd; d += 2) {
                    x = pixelCoordinates[d];
                    y = pixelCoordinates[d + 1];
                    roundX = x + 0.5 | 0;
                    roundY = y + 0.5 | 0;
                    if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                      context.lineTo(x, y);
                      prevX = roundX;
                      prevY = roundY;
                    }
                  }
                  ++i;
                  break;
                case canvas_Instruction.SET_FILL_STYLE:
                  lastFillInstruction = instruction;
                  this.alignFill_ = instruction[2];
                  if (pendingFill) {
                    this.fill_(context);
                    pendingFill = 0;
                    if (pendingStroke) {
                      context.stroke();
                      pendingStroke = 0;
                    }
                  }
                  context.fillStyle = instruction[1];
                  ++i;
                  break;
                case canvas_Instruction.SET_STROKE_STYLE:
                  lastStrokeInstruction = instruction;
                  if (pendingStroke) {
                    context.stroke();
                    pendingStroke = 0;
                  }
                  this.setStrokeStyle_(context, instruction);
                  ++i;
                  break;
                case canvas_Instruction.STROKE:
                  if (batchSize) {
                    pendingStroke++;
                  } else {
                    context.stroke();
                  }
                  ++i;
                  break;
                default:
                  ++i;
                  break;
              }
            }
            if (pendingFill) {
              this.fill_(context);
            }
            if (pendingStroke) {
              context.stroke();
            }
            return void 0;
          };
          Executor.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree) {
            this.viewRotation_ = viewRotation;
            this.execute_(context, contextScale, transform2, this.instructions, snapToPixel, void 0, void 0, opt_declutterTree);
          };
          Executor.prototype.executeHitDetection = function(context, transform2, viewRotation, opt_featureCallback, opt_hitExtent) {
            this.viewRotation_ = viewRotation;
            return this.execute_(context, 1, transform2, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
          };
          return Executor;
        }();
        var canvas_Executor = Executor_Executor;
        var ORDER = [
          BuilderType.POLYGON,
          BuilderType.CIRCLE,
          BuilderType.LINE_STRING,
          BuilderType.IMAGE,
          BuilderType.TEXT,
          BuilderType.DEFAULT
        ];
        var ExecutorGroup_ExecutorGroup = function() {
          function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
            this.maxExtent_ = maxExtent;
            this.overlaps_ = overlaps;
            this.pixelRatio_ = pixelRatio;
            this.resolution_ = resolution;
            this.renderBuffer_ = opt_renderBuffer;
            this.executorsByZIndex_ = {};
            this.hitDetectionContext_ = null;
            this.hitDetectionTransform_ = create();
            this.createExecutors_(allInstructions);
          }
          ExecutorGroup.prototype.clip = function(context, transform2) {
            var flatClipCoords = this.getClipCoords(transform2);
            context.beginPath();
            context.moveTo(flatClipCoords[0], flatClipCoords[1]);
            context.lineTo(flatClipCoords[2], flatClipCoords[3]);
            context.lineTo(flatClipCoords[4], flatClipCoords[5]);
            context.lineTo(flatClipCoords[6], flatClipCoords[7]);
            context.clip();
          };
          ExecutorGroup.prototype.createExecutors_ = function(allInstructions) {
            for (var zIndex in allInstructions) {
              var executors = this.executorsByZIndex_[zIndex];
              if (executors === void 0) {
                executors = {};
                this.executorsByZIndex_[zIndex] = executors;
              }
              var instructionByZindex = allInstructions[zIndex];
              for (var builderType in instructionByZindex) {
                var instructions = instructionByZindex[builderType];
                executors[builderType] = new canvas_Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
              }
            }
          };
          ExecutorGroup.prototype.hasExecutors = function(executors) {
            for (var zIndex in this.executorsByZIndex_) {
              var candidates = this.executorsByZIndex_[zIndex];
              for (var i = 0, ii = executors.length; i < ii; ++i) {
                if (executors[i] in candidates) {
                  return true;
                }
              }
            }
            return false;
          };
          ExecutorGroup.prototype.forEachFeatureAtCoordinate = function(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
            hitTolerance = Math.round(hitTolerance);
            var contextSize = hitTolerance * 2 + 1;
            var transform2 = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
            var newContext = !this.hitDetectionContext_;
            if (newContext) {
              this.hitDetectionContext_ = Object(dom["a"])(contextSize, contextSize);
            }
            var context = this.hitDetectionContext_;
            if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
              context.canvas.width = contextSize;
              context.canvas.height = contextSize;
            } else if (!newContext) {
              context.clearRect(0, 0, contextSize, contextSize);
            }
            var hitExtent;
            if (this.renderBuffer_ !== void 0) {
              hitExtent = createEmpty();
              extendCoordinate(hitExtent, coordinate);
              extent_buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
            }
            var indexes = getPixelIndexArray(hitTolerance);
            var builderType;
            function featureCallback(feature, geometry) {
              var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
              for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {
                if (imageData[indexes[i_1]] > 0) {
                  if (!declutteredFeatures || builderType !== BuilderType.IMAGE && builderType !== BuilderType.TEXT || declutteredFeatures.indexOf(feature) !== -1) {
                    var idx = (indexes[i_1] - 3) / 4;
                    var x = hitTolerance - idx % contextSize;
                    var y = hitTolerance - (idx / contextSize | 0);
                    var result_1 = callback(feature, geometry, x * x + y * y);
                    if (result_1) {
                      return result_1;
                    }
                  }
                  context.clearRect(0, 0, contextSize, contextSize);
                  break;
                }
              }
              return void 0;
            }
            var zs = Object.keys(this.executorsByZIndex_).map(Number);
            zs.sort(ol_array["i"]);
            var i, j, executors, executor, result;
            for (i = zs.length - 1; i >= 0; --i) {
              var zIndexKey = zs[i].toString();
              executors = this.executorsByZIndex_[zIndexKey];
              for (j = ORDER.length - 1; j >= 0; --j) {
                builderType = ORDER[j];
                executor = executors[builderType];
                if (executor !== void 0) {
                  result = executor.executeHitDetection(context, transform2, rotation, featureCallback, hitExtent);
                  if (result) {
                    return result;
                  }
                }
              }
            }
            return void 0;
          };
          ExecutorGroup.prototype.getClipCoords = function(transform2) {
            var maxExtent = this.maxExtent_;
            if (!maxExtent) {
              return null;
            }
            var minX = maxExtent[0];
            var minY = maxExtent[1];
            var maxX = maxExtent[2];
            var maxY = maxExtent[3];
            var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
            transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
            return flatClipCoords;
          };
          ExecutorGroup.prototype.isEmpty = function() {
            return Object(ol_obj["d"])(this.executorsByZIndex_);
          };
          ExecutorGroup.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {
            var zs = Object.keys(this.executorsByZIndex_).map(Number);
            zs.sort(ol_array["i"]);
            if (this.maxExtent_) {
              context.save();
              this.clip(context, transform2);
            }
            var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
            var i, ii, j, jj, replays, replay;
            if (opt_declutterTree) {
              zs.reverse();
            }
            for (i = 0, ii = zs.length; i < ii; ++i) {
              var zIndexKey = zs[i].toString();
              replays = this.executorsByZIndex_[zIndexKey];
              for (j = 0, jj = builderTypes.length; j < jj; ++j) {
                var builderType = builderTypes[j];
                replay = replays[builderType];
                if (replay !== void 0) {
                  replay.execute(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree);
                }
              }
            }
            if (this.maxExtent_) {
              context.restore();
            }
          };
          return ExecutorGroup;
        }();
        var circlePixelIndexArrayCache = {};
        function getPixelIndexArray(radius) {
          if (circlePixelIndexArrayCache[radius] !== void 0) {
            return circlePixelIndexArrayCache[radius];
          }
          var size = radius * 2 + 1;
          var maxDistanceSq = radius * radius;
          var distances = new Array(maxDistanceSq + 1);
          for (var i = 0; i <= radius; ++i) {
            for (var j = 0; j <= radius; ++j) {
              var distanceSq = i * i + j * j;
              if (distanceSq > maxDistanceSq) {
                break;
              }
              var distance = distances[distanceSq];
              if (!distance) {
                distance = [];
                distances[distanceSq] = distance;
              }
              distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
              if (i > 0) {
                distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
              }
              if (j > 0) {
                distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
                if (i > 0) {
                  distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
                }
              }
            }
          }
          var pixelIndex = [];
          for (var i = 0, ii = distances.length; i < ii; ++i) {
            if (distances[i]) {
              pixelIndex.push.apply(pixelIndex, distances[i]);
            }
          }
          circlePixelIndexArrayCache[radius] = pixelIndex;
          return pixelIndex;
        }
        var canvas_ExecutorGroup = ExecutorGroup_ExecutorGroup;
        var Immediate_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Immediate_CanvasImmediateRenderer = function(_super) {
          Immediate_extends(CanvasImmediateRenderer, _super);
          function CanvasImmediateRenderer(context, pixelRatio, extent, transform2, viewRotation, opt_squaredTolerance, opt_userTransform) {
            var _this = _super.call(this) || this;
            _this.context_ = context;
            _this.pixelRatio_ = pixelRatio;
            _this.extent_ = extent;
            _this.transform_ = transform2;
            _this.viewRotation_ = viewRotation;
            _this.squaredTolerance_ = opt_squaredTolerance;
            _this.userTransform_ = opt_userTransform;
            _this.contextFillState_ = null;
            _this.contextStrokeState_ = null;
            _this.contextTextState_ = null;
            _this.fillState_ = null;
            _this.strokeState_ = null;
            _this.image_ = null;
            _this.imageAnchorX_ = 0;
            _this.imageAnchorY_ = 0;
            _this.imageHeight_ = 0;
            _this.imageOpacity_ = 0;
            _this.imageOriginX_ = 0;
            _this.imageOriginY_ = 0;
            _this.imageRotateWithView_ = false;
            _this.imageRotation_ = 0;
            _this.imageScale_ = [0, 0];
            _this.imageWidth_ = 0;
            _this.text_ = "";
            _this.textOffsetX_ = 0;
            _this.textOffsetY_ = 0;
            _this.textRotateWithView_ = false;
            _this.textRotation_ = 0;
            _this.textScale_ = [0, 0];
            _this.textFillState_ = null;
            _this.textStrokeState_ = null;
            _this.textState_ = null;
            _this.pixelCoordinates_ = [];
            _this.tmpLocalTransform_ = create();
            return _this;
          }
          CanvasImmediateRenderer.prototype.drawImages_ = function(flatCoordinates, offset, end, stride) {
            if (!this.image_) {
              return;
            }
            var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
            var context = this.context_;
            var localTransform = this.tmpLocalTransform_;
            var alpha = context.globalAlpha;
            if (this.imageOpacity_ != 1) {
              context.globalAlpha = alpha * this.imageOpacity_;
            }
            var rotation = this.imageRotation_;
            if (this.imageRotateWithView_) {
              rotation += this.viewRotation_;
            }
            for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
              var x = pixelCoordinates[i] - this.imageAnchorX_;
              var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
              if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
                var centerX = x + this.imageAnchorX_;
                var centerY = y + this.imageAnchorY_;
                compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                context.setTransform.apply(context, localTransform);
                context.translate(centerX, centerY);
                context.scale(this.imageScale_[0], this.imageScale_[1]);
                context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                context.setTransform(1, 0, 0, 1, 0, 0);
              } else {
                context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
              }
            }
            if (this.imageOpacity_ != 1) {
              context.globalAlpha = alpha;
            }
          };
          CanvasImmediateRenderer.prototype.drawText_ = function(flatCoordinates, offset, end, stride) {
            if (!this.textState_ || this.text_ === "") {
              return;
            }
            if (this.textFillState_) {
              this.setContextFillState_(this.textFillState_);
            }
            if (this.textStrokeState_) {
              this.setContextStrokeState_(this.textStrokeState_);
            }
            this.setContextTextState_(this.textState_);
            var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
            var context = this.context_;
            var rotation = this.textRotation_;
            if (this.textRotateWithView_) {
              rotation += this.viewRotation_;
            }
            for (; offset < end; offset += stride) {
              var x = pixelCoordinates[offset] + this.textOffsetX_;
              var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
              if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
                var localTransform = compose(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
                context.setTransform.apply(context, localTransform);
                context.translate(x, y);
                context.scale(this.textScale_[0], this.textScale_[1]);
                if (this.textStrokeState_) {
                  context.strokeText(this.text_, 0, 0);
                }
                if (this.textFillState_) {
                  context.fillText(this.text_, 0, 0);
                }
                context.setTransform(1, 0, 0, 1, 0, 0);
              } else {
                if (this.textStrokeState_) {
                  context.strokeText(this.text_, x, y);
                }
                if (this.textFillState_) {
                  context.fillText(this.text_, x, y);
                }
              }
            }
          };
          CanvasImmediateRenderer.prototype.moveToLineTo_ = function(flatCoordinates, offset, end, stride, close) {
            var context = this.context_;
            var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
            context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
            var length = pixelCoordinates.length;
            if (close) {
              length -= 2;
            }
            for (var i = 2; i < length; i += 2) {
              context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
            }
            if (close) {
              context.closePath();
            }
            return end;
          };
          CanvasImmediateRenderer.prototype.drawRings_ = function(flatCoordinates, offset, ends, stride) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
            }
            return offset;
          };
          CanvasImmediateRenderer.prototype.drawCircle = function(geometry) {
            if (!extent_intersects(this.extent_, geometry.getExtent())) {
              return;
            }
            if (this.fillState_ || this.strokeState_) {
              if (this.fillState_) {
                this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
              }
              var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
              var dx = pixelCoordinates[2] - pixelCoordinates[0];
              var dy = pixelCoordinates[3] - pixelCoordinates[1];
              var radius = Math.sqrt(dx * dx + dy * dy);
              var context = this.context_;
              context.beginPath();
              context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
              if (this.fillState_) {
                context.fill();
              }
              if (this.strokeState_) {
                context.stroke();
              }
            }
            if (this.text_ !== "") {
              this.drawText_(geometry.getCenter(), 0, 2, 2);
            }
          };
          CanvasImmediateRenderer.prototype.setStyle = function(style) {
            this.setFillStrokeStyle(style.getFill(), style.getStroke());
            this.setImageStyle(style.getImage());
            this.setTextStyle(style.getText());
          };
          CanvasImmediateRenderer.prototype.setTransform = function(transform2) {
            this.transform_ = transform2;
          };
          CanvasImmediateRenderer.prototype.drawGeometry = function(geometry) {
            var type = geometry.getType();
            switch (type) {
              case geom_GeometryType.POINT:
                this.drawPoint(geometry);
                break;
              case geom_GeometryType.LINE_STRING:
                this.drawLineString(geometry);
                break;
              case geom_GeometryType.POLYGON:
                this.drawPolygon(geometry);
                break;
              case geom_GeometryType.MULTI_POINT:
                this.drawMultiPoint(geometry);
                break;
              case geom_GeometryType.MULTI_LINE_STRING:
                this.drawMultiLineString(geometry);
                break;
              case geom_GeometryType.MULTI_POLYGON:
                this.drawMultiPolygon(geometry);
                break;
              case geom_GeometryType.GEOMETRY_COLLECTION:
                this.drawGeometryCollection(geometry);
                break;
              case geom_GeometryType.CIRCLE:
                this.drawCircle(geometry);
                break;
              default:
            }
          };
          CanvasImmediateRenderer.prototype.drawFeature = function(feature, style) {
            var geometry = style.getGeometryFunction()(feature);
            if (!geometry || !extent_intersects(this.extent_, geometry.getExtent())) {
              return;
            }
            this.setStyle(style);
            this.drawGeometry(geometry);
          };
          CanvasImmediateRenderer.prototype.drawGeometryCollection = function(geometry) {
            var geometries = geometry.getGeometriesArray();
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              this.drawGeometry(geometries[i]);
            }
          };
          CanvasImmediateRenderer.prototype.drawPoint = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            var flatCoordinates = geometry.getFlatCoordinates();
            var stride = geometry.getStride();
            if (this.image_) {
              this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
            if (this.text_ !== "") {
              this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
          };
          CanvasImmediateRenderer.prototype.drawMultiPoint = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            var flatCoordinates = geometry.getFlatCoordinates();
            var stride = geometry.getStride();
            if (this.image_) {
              this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
            if (this.text_ !== "") {
              this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
          };
          CanvasImmediateRenderer.prototype.drawLineString = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            if (!extent_intersects(this.extent_, geometry.getExtent())) {
              return;
            }
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              var context = this.context_;
              var flatCoordinates = geometry.getFlatCoordinates();
              context.beginPath();
              this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
              context.stroke();
            }
            if (this.text_ !== "") {
              var flatMidpoint = geometry.getFlatMidpoint();
              this.drawText_(flatMidpoint, 0, 2, 2);
            }
          };
          CanvasImmediateRenderer.prototype.drawMultiLineString = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            var geometryExtent = geometry.getExtent();
            if (!extent_intersects(this.extent_, geometryExtent)) {
              return;
            }
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              var context = this.context_;
              var flatCoordinates = geometry.getFlatCoordinates();
              var offset = 0;
              var ends = geometry.getEnds();
              var stride = geometry.getStride();
              context.beginPath();
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
              }
              context.stroke();
            }
            if (this.text_ !== "") {
              var flatMidpoints = geometry.getFlatMidpoints();
              this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
            }
          };
          CanvasImmediateRenderer.prototype.drawPolygon = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            if (!extent_intersects(this.extent_, geometry.getExtent())) {
              return;
            }
            if (this.strokeState_ || this.fillState_) {
              if (this.fillState_) {
                this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
              }
              var context = this.context_;
              context.beginPath();
              this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());
              if (this.fillState_) {
                context.fill();
              }
              if (this.strokeState_) {
                context.stroke();
              }
            }
            if (this.text_ !== "") {
              var flatInteriorPoint = geometry.getFlatInteriorPoint();
              this.drawText_(flatInteriorPoint, 0, 2, 2);
            }
          };
          CanvasImmediateRenderer.prototype.drawMultiPolygon = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            if (!extent_intersects(this.extent_, geometry.getExtent())) {
              return;
            }
            if (this.strokeState_ || this.fillState_) {
              if (this.fillState_) {
                this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
              }
              var context = this.context_;
              var flatCoordinates = geometry.getOrientedFlatCoordinates();
              var offset = 0;
              var endss = geometry.getEndss();
              var stride = geometry.getStride();
              context.beginPath();
              for (var i = 0, ii = endss.length; i < ii; ++i) {
                var ends = endss[i];
                offset = this.drawRings_(flatCoordinates, offset, ends, stride);
              }
              if (this.fillState_) {
                context.fill();
              }
              if (this.strokeState_) {
                context.stroke();
              }
            }
            if (this.text_ !== "") {
              var flatInteriorPoints = geometry.getFlatInteriorPoints();
              this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
            }
          };
          CanvasImmediateRenderer.prototype.setContextFillState_ = function(fillState) {
            var context = this.context_;
            var contextFillState = this.contextFillState_;
            if (!contextFillState) {
              context.fillStyle = fillState.fillStyle;
              this.contextFillState_ = {
                fillStyle: fillState.fillStyle
              };
            } else {
              if (contextFillState.fillStyle != fillState.fillStyle) {
                contextFillState.fillStyle = fillState.fillStyle;
                context.fillStyle = fillState.fillStyle;
              }
            }
          };
          CanvasImmediateRenderer.prototype.setContextStrokeState_ = function(strokeState) {
            var context = this.context_;
            var contextStrokeState = this.contextStrokeState_;
            if (!contextStrokeState) {
              context.lineCap = strokeState.lineCap;
              if (context.setLineDash) {
                context.setLineDash(strokeState.lineDash);
                context.lineDashOffset = strokeState.lineDashOffset;
              }
              context.lineJoin = strokeState.lineJoin;
              context.lineWidth = strokeState.lineWidth;
              context.miterLimit = strokeState.miterLimit;
              context.strokeStyle = strokeState.strokeStyle;
              this.contextStrokeState_ = {
                lineCap: strokeState.lineCap,
                lineDash: strokeState.lineDash,
                lineDashOffset: strokeState.lineDashOffset,
                lineJoin: strokeState.lineJoin,
                lineWidth: strokeState.lineWidth,
                miterLimit: strokeState.miterLimit,
                strokeStyle: strokeState.strokeStyle
              };
            } else {
              if (contextStrokeState.lineCap != strokeState.lineCap) {
                contextStrokeState.lineCap = strokeState.lineCap;
                context.lineCap = strokeState.lineCap;
              }
              if (context.setLineDash) {
                if (!Object(ol_array["b"])(contextStrokeState.lineDash, strokeState.lineDash)) {
                  context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
                }
                if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                  contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                  context.lineDashOffset = strokeState.lineDashOffset;
                }
              }
              if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                contextStrokeState.lineJoin = strokeState.lineJoin;
                context.lineJoin = strokeState.lineJoin;
              }
              if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                contextStrokeState.lineWidth = strokeState.lineWidth;
                context.lineWidth = strokeState.lineWidth;
              }
              if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                contextStrokeState.miterLimit = strokeState.miterLimit;
                context.miterLimit = strokeState.miterLimit;
              }
              if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                contextStrokeState.strokeStyle = strokeState.strokeStyle;
                context.strokeStyle = strokeState.strokeStyle;
              }
            }
          };
          CanvasImmediateRenderer.prototype.setContextTextState_ = function(textState) {
            var context = this.context_;
            var contextTextState = this.contextTextState_;
            var textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;
            if (!contextTextState) {
              context.font = textState.font;
              context.textAlign = textAlign;
              context.textBaseline = textState.textBaseline;
              this.contextTextState_ = {
                font: textState.font,
                textAlign,
                textBaseline: textState.textBaseline
              };
            } else {
              if (contextTextState.font != textState.font) {
                contextTextState.font = textState.font;
                context.font = textState.font;
              }
              if (contextTextState.textAlign != textAlign) {
                contextTextState.textAlign = textAlign;
                context.textAlign = textAlign;
              }
              if (contextTextState.textBaseline != textState.textBaseline) {
                contextTextState.textBaseline = textState.textBaseline;
                context.textBaseline = textState.textBaseline;
              }
            }
          };
          CanvasImmediateRenderer.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
            var _this = this;
            if (!fillStyle) {
              this.fillState_ = null;
            } else {
              var fillStyleColor = fillStyle.getColor();
              this.fillState_ = {
                fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle)
              };
            }
            if (!strokeStyle) {
              this.strokeState_ = null;
            } else {
              var strokeStyleColor = strokeStyle.getColor();
              var strokeStyleLineCap = strokeStyle.getLineCap();
              var strokeStyleLineDash = strokeStyle.getLineDash();
              var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
              var strokeStyleLineJoin = strokeStyle.getLineJoin();
              var strokeStyleWidth = strokeStyle.getWidth();
              var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
              var lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
              this.strokeState_ = {
                lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
                lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map(function(n) {
                  return n * _this.pixelRatio_;
                }),
                lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
                lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
                lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
                miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
                strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle)
              };
            }
          };
          CanvasImmediateRenderer.prototype.setImageStyle = function(imageStyle) {
            var imageSize;
            if (!imageStyle || !(imageSize = imageStyle.getSize())) {
              this.image_ = null;
              return;
            }
            var imageAnchor = imageStyle.getAnchor();
            var imageOrigin = imageStyle.getOrigin();
            this.image_ = imageStyle.getImage(this.pixelRatio_);
            this.imageAnchorX_ = imageAnchor[0] * this.pixelRatio_;
            this.imageAnchorY_ = imageAnchor[1] * this.pixelRatio_;
            this.imageHeight_ = imageSize[1] * this.pixelRatio_;
            this.imageOpacity_ = imageStyle.getOpacity();
            this.imageOriginX_ = imageOrigin[0];
            this.imageOriginY_ = imageOrigin[1];
            this.imageRotateWithView_ = imageStyle.getRotateWithView();
            this.imageRotation_ = imageStyle.getRotation();
            this.imageScale_ = imageStyle.getScaleArray();
            this.imageWidth_ = imageSize[0] * this.pixelRatio_;
          };
          CanvasImmediateRenderer.prototype.setTextStyle = function(textStyle) {
            if (!textStyle) {
              this.text_ = "";
            } else {
              var textFillStyle = textStyle.getFill();
              if (!textFillStyle) {
                this.textFillState_ = null;
              } else {
                var textFillStyleColor = textFillStyle.getColor();
                this.textFillState_ = {
                  fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle)
                };
              }
              var textStrokeStyle = textStyle.getStroke();
              if (!textStrokeStyle) {
                this.textStrokeState_ = null;
              } else {
                var textStrokeStyleColor = textStrokeStyle.getColor();
                var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                var textStrokeStyleWidth = textStrokeStyle.getWidth();
                var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                this.textStrokeState_ = {
                  lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
                  lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
                  lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
                  lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
                  lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
                  miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
                  strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle)
                };
              }
              var textFont = textStyle.getFont();
              var textOffsetX = textStyle.getOffsetX();
              var textOffsetY = textStyle.getOffsetY();
              var textRotateWithView = textStyle.getRotateWithView();
              var textRotation = textStyle.getRotation();
              var textScale = textStyle.getScaleArray();
              var textText = textStyle.getText();
              var textTextAlign = textStyle.getTextAlign();
              var textTextBaseline = textStyle.getTextBaseline();
              this.textState_ = {
                font: textFont !== void 0 ? textFont : defaultFont,
                textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
                textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
              };
              this.text_ = textText !== void 0 ? textText : "";
              this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
              this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
              this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
              this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
              this.textScale_ = [
                this.pixelRatio_ * textScale[0],
                this.pixelRatio_ * textScale[1]
              ];
            }
          };
          return CanvasImmediateRenderer;
        }(render_VectorContext);
        var Immediate = Immediate_CanvasImmediateRenderer;
        var IconAnchorUnits = {
          FRACTION: "fraction",
          PIXELS: "pixels"
        };
        var IconOrigin = {
          BOTTOM_LEFT: "bottom-left",
          BOTTOM_RIGHT: "bottom-right",
          TOP_LEFT: "top-left",
          TOP_RIGHT: "top-right"
        };
        var ImageBase_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ImageBase_ImageBase = function(_super) {
          ImageBase_extends(ImageBase, _super);
          function ImageBase(extent, resolution, pixelRatio, state) {
            var _this = _super.call(this) || this;
            _this.extent = extent;
            _this.pixelRatio_ = pixelRatio;
            _this.resolution = resolution;
            _this.state = state;
            return _this;
          }
          ImageBase.prototype.changed = function() {
            this.dispatchEvent(EventType["a"].CHANGE);
          };
          ImageBase.prototype.getExtent = function() {
            return this.extent;
          };
          ImageBase.prototype.getImage = function() {
            return Object(util["b"])();
          };
          ImageBase.prototype.getPixelRatio = function() {
            return this.pixelRatio_;
          };
          ImageBase.prototype.getResolution = function() {
            return this.resolution;
          };
          ImageBase.prototype.getState = function() {
            return this.state;
          };
          ImageBase.prototype.load = function() {
            Object(util["b"])();
          };
          return ImageBase;
        }(Target["a"]);
        var ol_ImageBase = ImageBase_ImageBase;
        var ol_Image_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Image_ImageWrapper = function(_super) {
          ol_Image_extends(ImageWrapper, _super);
          function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
            var _this = _super.call(this, extent, resolution, pixelRatio, ImageState.IDLE) || this;
            _this.src_ = src;
            _this.image_ = new Image();
            if (crossOrigin !== null) {
              _this.image_.crossOrigin = crossOrigin;
            }
            _this.unlisten_ = null;
            _this.state = ImageState.IDLE;
            _this.imageLoadFunction_ = imageLoadFunction;
            return _this;
          }
          ImageWrapper.prototype.getImage = function() {
            return this.image_;
          };
          ImageWrapper.prototype.handleImageError_ = function() {
            this.state = ImageState.ERROR;
            this.unlistenImage_();
            this.changed();
          };
          ImageWrapper.prototype.handleImageLoad_ = function() {
            if (this.resolution === void 0) {
              this.resolution = getHeight(this.extent) / this.image_.height;
            }
            this.state = ImageState.LOADED;
            this.unlistenImage_();
            this.changed();
          };
          ImageWrapper.prototype.load = function() {
            if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
              this.state = ImageState.LOADING;
              this.changed();
              this.imageLoadFunction_(this, this.src_);
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
            }
          };
          ImageWrapper.prototype.setImage = function(image) {
            this.image_ = image;
            this.resolution = getHeight(this.extent) / this.image_.height;
          };
          ImageWrapper.prototype.unlistenImage_ = function() {
            if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
            }
          };
          return ImageWrapper;
        }(ol_ImageBase);
        function listenImage(image, loadHandler, errorHandler) {
          var img = image;
          var listening = true;
          var decoding = false;
          var loaded = false;
          var listenerKeys = [
            Object(events["b"])(img, EventType["a"].LOAD, function() {
              loaded = true;
              if (!decoding) {
                loadHandler();
              }
            })
          ];
          if (img.src && has["c"]) {
            decoding = true;
            img.decode().then(function() {
              if (listening) {
                loadHandler();
              }
            }).catch(function(error) {
              if (listening) {
                if (loaded) {
                  loadHandler();
                } else {
                  errorHandler();
                }
              }
            });
          } else {
            listenerKeys.push(Object(events["b"])(img, EventType["a"].ERROR, errorHandler));
          }
          return function unlisten() {
            listening = false;
            listenerKeys.forEach(events["c"]);
          };
        }
        var ol_Image = Image_ImageWrapper;
        var IconImage_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var taintedTestContext = null;
        var IconImage_IconImage = function(_super) {
          IconImage_extends(IconImage, _super);
          function IconImage(image, src, size, crossOrigin, imageState, color) {
            var _this = _super.call(this) || this;
            _this.hitDetectionImage_ = null;
            _this.image_ = !image ? new Image() : image;
            if (crossOrigin !== null) {
              _this.image_.crossOrigin = crossOrigin;
            }
            _this.canvas_ = {};
            _this.color_ = color;
            _this.unlisten_ = null;
            _this.imageState_ = imageState;
            _this.size_ = size;
            _this.src_ = src;
            _this.tainted_;
            return _this;
          }
          IconImage.prototype.isTainted_ = function() {
            if (this.tainted_ === void 0 && this.imageState_ === ImageState.LOADED) {
              if (!taintedTestContext) {
                taintedTestContext = Object(dom["a"])(1, 1);
              }
              taintedTestContext.drawImage(this.image_, 0, 0);
              try {
                taintedTestContext.getImageData(0, 0, 1, 1);
                this.tainted_ = false;
              } catch (e) {
                taintedTestContext = null;
                this.tainted_ = true;
              }
            }
            return this.tainted_ === true;
          };
          IconImage.prototype.dispatchChangeEvent_ = function() {
            this.dispatchEvent(EventType["a"].CHANGE);
          };
          IconImage.prototype.handleImageError_ = function() {
            this.imageState_ = ImageState.ERROR;
            this.unlistenImage_();
            this.dispatchChangeEvent_();
          };
          IconImage.prototype.handleImageLoad_ = function() {
            this.imageState_ = ImageState.LOADED;
            if (this.size_) {
              this.image_.width = this.size_[0];
              this.image_.height = this.size_[1];
            } else {
              this.size_ = [this.image_.width, this.image_.height];
            }
            this.unlistenImage_();
            this.dispatchChangeEvent_();
          };
          IconImage.prototype.getImage = function(pixelRatio) {
            this.replaceColor_(pixelRatio);
            return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
          };
          IconImage.prototype.getPixelRatio = function(pixelRatio) {
            this.replaceColor_(pixelRatio);
            return this.canvas_[pixelRatio] ? pixelRatio : 1;
          };
          IconImage.prototype.getImageState = function() {
            return this.imageState_;
          };
          IconImage.prototype.getHitDetectionImage = function() {
            if (!this.hitDetectionImage_) {
              if (this.isTainted_()) {
                var width = this.size_[0];
                var height = this.size_[1];
                var context = Object(dom["a"])(width, height);
                context.fillRect(0, 0, width, height);
                this.hitDetectionImage_ = context.canvas;
              } else {
                this.hitDetectionImage_ = this.image_;
              }
            }
            return this.hitDetectionImage_;
          };
          IconImage.prototype.getSize = function() {
            return this.size_;
          };
          IconImage.prototype.getSrc = function() {
            return this.src_;
          };
          IconImage.prototype.load = function() {
            if (this.imageState_ == ImageState.IDLE) {
              this.imageState_ = ImageState.LOADING;
              try {
                this.image_.src = this.src_;
              } catch (e) {
                this.handleImageError_();
              }
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
            }
          };
          IconImage.prototype.replaceColor_ = function(pixelRatio) {
            if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState.LOADED) {
              return;
            }
            var canvas = document.createElement("canvas");
            this.canvas_[pixelRatio] = canvas;
            canvas.width = Math.ceil(this.image_.width * pixelRatio);
            canvas.height = Math.ceil(this.image_.height * pixelRatio);
            var ctx = canvas.getContext("2d");
            ctx.scale(pixelRatio, pixelRatio);
            ctx.drawImage(this.image_, 0, 0);
            ctx.globalCompositeOperation = "multiply";
            if (ctx.globalCompositeOperation === "multiply" || this.isTainted_()) {
              ctx.fillStyle = asString(this.color_);
              ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
              ctx.globalCompositeOperation = "destination-in";
              ctx.drawImage(this.image_, 0, 0);
            } else {
              var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              var data = imgData.data;
              var r = this.color_[0] / 255;
              var g = this.color_[1] / 255;
              var b = this.color_[2] / 255;
              var a = this.color_[3];
              for (var i = 0, ii = data.length; i < ii; i += 4) {
                data[i] *= r;
                data[i + 1] *= g;
                data[i + 2] *= b;
                data[i + 3] *= a;
              }
              ctx.putImageData(imgData, 0, 0);
            }
          };
          IconImage.prototype.unlistenImage_ = function() {
            if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
            }
          };
          return IconImage;
        }(Target["a"]);
        function IconImage_get(image, src, size, crossOrigin, imageState, color) {
          var iconImage = shared.get(src, crossOrigin, color);
          if (!iconImage) {
            iconImage = new IconImage_IconImage(image, src, size, crossOrigin, imageState, color);
            shared.set(src, crossOrigin, color, iconImage);
          }
          return iconImage;
        }
        var style_IconImage = IconImage_IconImage;
        var Icon_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Icon_Icon = function(_super) {
          Icon_extends(Icon, _super);
          function Icon(opt_options) {
            var _this = this;
            var options = opt_options || {};
            var opacity = options.opacity !== void 0 ? options.opacity : 1;
            var rotation = options.rotation !== void 0 ? options.rotation : 0;
            var scale = options.scale !== void 0 ? options.scale : 1;
            var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
            _this = _super.call(this, {
              opacity,
              rotation,
              scale,
              displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
              rotateWithView
            }) || this;
            _this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
            _this.normalizedAnchor_ = null;
            _this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : IconOrigin.TOP_LEFT;
            _this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : IconAnchorUnits.FRACTION;
            _this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : IconAnchorUnits.FRACTION;
            _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
            var image = options.img !== void 0 ? options.img : null;
            var imgSize = options.imgSize !== void 0 ? options.imgSize : null;
            var src = options.src;
            assert2(!(src !== void 0 && image), 4);
            assert2(!image || image && imgSize, 5);
            if ((src === void 0 || src.length === 0) && image) {
              src = image.src || Object(util["c"])(image);
            }
            assert2(src !== void 0 && src.length > 0, 6);
            var imageState = options.src !== void 0 ? ImageState.IDLE : ImageState.LOADED;
            _this.color_ = options.color !== void 0 ? asArray(options.color) : null;
            _this.iconImage_ = IconImage_get(image, src, imgSize, _this.crossOrigin_, imageState, _this.color_);
            _this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
            _this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : IconOrigin.TOP_LEFT;
            _this.origin_ = null;
            _this.size_ = options.size !== void 0 ? options.size : null;
            return _this;
          }
          Icon.prototype.clone = function() {
            var scale = this.getScale();
            return new Icon({
              anchor: this.anchor_.slice(),
              anchorOrigin: this.anchorOrigin_,
              anchorXUnits: this.anchorXUnits_,
              anchorYUnits: this.anchorYUnits_,
              crossOrigin: this.crossOrigin_,
              color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
              src: this.getSrc(),
              offset: this.offset_.slice(),
              offsetOrigin: this.offsetOrigin_,
              size: this.size_ !== null ? this.size_.slice() : void 0,
              opacity: this.getOpacity(),
              scale: Array.isArray(scale) ? scale.slice() : scale,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView()
            });
          };
          Icon.prototype.getAnchor = function() {
            var anchor = this.normalizedAnchor_;
            if (!anchor) {
              anchor = this.anchor_;
              var size = this.getSize();
              if (this.anchorXUnits_ == IconAnchorUnits.FRACTION || this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
                if (!size) {
                  return null;
                }
                anchor = this.anchor_.slice();
                if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {
                  anchor[0] *= size[0];
                }
                if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
                  anchor[1] *= size[1];
                }
              }
              if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {
                if (!size) {
                  return null;
                }
                if (anchor === this.anchor_) {
                  anchor = this.anchor_.slice();
                }
                if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  anchor[0] = -anchor[0] + size[0];
                }
                if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  anchor[1] = -anchor[1] + size[1];
                }
              }
              this.normalizedAnchor_ = anchor;
            }
            var displacement = this.getDisplacement();
            return [anchor[0] - displacement[0], anchor[1] + displacement[1]];
          };
          Icon.prototype.setAnchor = function(anchor) {
            this.anchor_ = anchor;
            this.normalizedAnchor_ = null;
          };
          Icon.prototype.getColor = function() {
            return this.color_;
          };
          Icon.prototype.getImage = function(pixelRatio) {
            return this.iconImage_.getImage(pixelRatio);
          };
          Icon.prototype.getPixelRatio = function(pixelRatio) {
            return this.iconImage_.getPixelRatio(pixelRatio);
          };
          Icon.prototype.getImageSize = function() {
            return this.iconImage_.getSize();
          };
          Icon.prototype.getImageState = function() {
            return this.iconImage_.getImageState();
          };
          Icon.prototype.getHitDetectionImage = function() {
            return this.iconImage_.getHitDetectionImage();
          };
          Icon.prototype.getOrigin = function() {
            if (this.origin_) {
              return this.origin_;
            }
            var offset = this.offset_;
            if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {
              var size = this.getSize();
              var iconImageSize = this.iconImage_.getSize();
              if (!size || !iconImageSize) {
                return null;
              }
              offset = offset.slice();
              if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                offset[0] = iconImageSize[0] - size[0] - offset[0];
              }
              if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                offset[1] = iconImageSize[1] - size[1] - offset[1];
              }
            }
            this.origin_ = offset;
            return this.origin_;
          };
          Icon.prototype.getSrc = function() {
            return this.iconImage_.getSrc();
          };
          Icon.prototype.getSize = function() {
            return !this.size_ ? this.iconImage_.getSize() : this.size_;
          };
          Icon.prototype.listenImageChange = function(listener) {
            this.iconImage_.addEventListener(EventType["a"].CHANGE, listener);
          };
          Icon.prototype.load = function() {
            this.iconImage_.load();
          };
          Icon.prototype.unlistenImageChange = function(listener) {
            this.iconImage_.removeEventListener(EventType["a"].CHANGE, listener);
          };
          return Icon;
        }(style_Image);
        var style_Icon = Icon_Icon;
        var HIT_DETECT_RESOLUTION = 0.5;
        function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
          var width = size[0] * HIT_DETECT_RESOLUTION;
          var height = size[1] * HIT_DETECT_RESOLUTION;
          var context = Object(dom["a"])(width, height);
          context.imageSmoothingEnabled = false;
          var canvas = context.canvas;
          var renderer = new Immediate(context, HIT_DETECT_RESOLUTION, extent, null, rotation);
          var featureCount = features.length;
          var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
          var featuresByZIndex = {};
          for (var i = 1; i <= featureCount; ++i) {
            var feature = features[i - 1];
            var featureStyleFunction = feature.getStyleFunction() || styleFunction;
            if (!styleFunction) {
              continue;
            }
            var styles = featureStyleFunction(feature, resolution);
            if (!styles) {
              continue;
            }
            if (!Array.isArray(styles)) {
              styles = [styles];
            }
            var index = i * indexFactor;
            var color = "#" + ("000000" + index.toString(16)).slice(-6);
            for (var j = 0, jj = styles.length; j < jj; ++j) {
              var originalStyle = styles[j];
              var geometry = originalStyle.getGeometryFunction()(feature);
              if (!geometry || !extent_intersects(extent, geometry.getExtent())) {
                continue;
              }
              var style = originalStyle.clone();
              var fill = style.getFill();
              if (fill) {
                fill.setColor(color);
              }
              var stroke = style.getStroke();
              if (stroke) {
                stroke.setColor(color);
                stroke.setLineDash(null);
              }
              style.setText(void 0);
              var image = originalStyle.getImage();
              if (image && image.getOpacity() !== 0) {
                var imgSize = image.getImageSize();
                if (!imgSize) {
                  continue;
                }
                var imgContext = Object(dom["a"])(imgSize[0], imgSize[1], void 0, { alpha: false });
                var img = imgContext.canvas;
                imgContext.fillStyle = color;
                imgContext.fillRect(0, 0, img.width, img.height);
                style.setImage(new style_Icon({
                  img,
                  imgSize,
                  anchor: image.getAnchor(),
                  anchorXUnits: IconAnchorUnits.PIXELS,
                  anchorYUnits: IconAnchorUnits.PIXELS,
                  offset: image.getOrigin(),
                  opacity: 1,
                  size: image.getSize(),
                  scale: image.getScale(),
                  rotation: image.getRotation(),
                  rotateWithView: image.getRotateWithView()
                }));
              }
              var zIndex = style.getZIndex() || 0;
              var byGeometryType = featuresByZIndex[zIndex];
              if (!byGeometryType) {
                byGeometryType = {};
                featuresByZIndex[zIndex] = byGeometryType;
                byGeometryType[geom_GeometryType.POLYGON] = [];
                byGeometryType[geom_GeometryType.CIRCLE] = [];
                byGeometryType[geom_GeometryType.LINE_STRING] = [];
                byGeometryType[geom_GeometryType.POINT] = [];
              }
              byGeometryType[geometry.getType().replace("Multi", "")].push(geometry, style);
            }
          }
          var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(ol_array["i"]);
          for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {
            var byGeometryType = featuresByZIndex[zIndexKeys[i]];
            for (var type in byGeometryType) {
              var geomAndStyle = byGeometryType[type];
              for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
                renderer.setStyle(geomAndStyle[j + 1]);
                for (var k = 0, kk = transforms.length; k < kk; ++k) {
                  renderer.setTransform(transforms[k]);
                  renderer.drawGeometry(geomAndStyle[j]);
                }
              }
            }
          }
          return context.getImageData(0, 0, canvas.width, canvas.height);
        }
        function hitDetect(pixel, features, imageData) {
          var resultFeatures = [];
          if (imageData) {
            var x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
            var y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
            var index = (clamp(x, 0, imageData.width - 1) + clamp(y, 0, imageData.height - 1) * imageData.width) * 4;
            var r = imageData.data[index];
            var g = imageData.data[index + 1];
            var b = imageData.data[index + 2];
            var i = b + 256 * (g + 256 * r);
            var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
            if (i && i % indexFactor === 0) {
              resultFeatures.push(features[i / indexFactor - 1]);
            }
          }
          return resultFeatures;
        }
        var SIMPLIFY_TOLERANCE = 0.5;
        var GEOMETRY_RENDERERS = {
          "Point": renderPointGeometry,
          "LineString": renderLineStringGeometry,
          "Polygon": renderPolygonGeometry,
          "MultiPoint": renderMultiPointGeometry,
          "MultiLineString": renderMultiLineStringGeometry,
          "MultiPolygon": renderMultiPolygonGeometry,
          "GeometryCollection": renderGeometryCollectionGeometry,
          "Circle": renderCircleGeometry
        };
        function defaultOrder(feature1, feature2) {
          return parseInt(Object(util["c"])(feature1), 10) - parseInt(Object(util["c"])(feature2), 10);
        }
        function getSquaredTolerance(resolution, pixelRatio) {
          var tolerance = getTolerance(resolution, pixelRatio);
          return tolerance * tolerance;
        }
        function getTolerance(resolution, pixelRatio) {
          return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
        }
        function renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
          var fillStyle = style.getFill();
          var strokeStyle = style.getStroke();
          if (fillStyle || strokeStyle) {
            var circleReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.CIRCLE);
            circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
            circleReplay.drawCircle(geometry, feature);
          }
          var textStyle = style.getText();
          if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(geometry, feature);
          }
        }
        function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {
          var loading = false;
          var imageStyle = style.getImage();
          if (imageStyle) {
            var imageState = imageStyle.getImageState();
            if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
              imageStyle.unlistenImageChange(listener);
            } else {
              if (imageState == ImageState.IDLE) {
                imageStyle.load();
              }
              imageState = imageStyle.getImageState();
              imageStyle.listenImageChange(listener);
              loading = true;
            }
          }
          renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);
          return loading;
        }
        function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {
          var geometry = style.getGeometryFunction()(feature);
          if (!geometry) {
            return;
          }
          var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
          var renderer = style.getRenderer();
          if (renderer) {
            renderGeometry(replayGroup, simplifiedGeometry, style, feature);
          } else {
            var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
            geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);
          }
        }
        function renderGeometry(replayGroup, geometry, style, feature) {
          if (geometry.getType() == geom_GeometryType.GEOMETRY_COLLECTION) {
            var geometries = geometry.getGeometries();
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              renderGeometry(replayGroup, geometries[i], style, feature);
            }
            return;
          }
          var replay = replayGroup.getBuilder(style.getZIndex(), BuilderType.DEFAULT);
          replay.drawCustom(geometry, feature, style.getRenderer(), style.getHitDetectionRenderer());
        }
        function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {
          var geometries = geometry.getGeometriesArray();
          var i, ii;
          for (i = 0, ii = geometries.length; i < ii; ++i) {
            var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
            geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);
          }
        }
        function renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
          var strokeStyle = style.getStroke();
          if (strokeStyle) {
            var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);
            lineStringReplay.setFillStrokeStyle(null, strokeStyle);
            lineStringReplay.drawLineString(geometry, feature);
          }
          var textStyle = style.getText();
          if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(geometry, feature);
          }
        }
        function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
          var strokeStyle = style.getStroke();
          if (strokeStyle) {
            var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);
            lineStringReplay.setFillStrokeStyle(null, strokeStyle);
            lineStringReplay.drawMultiLineString(geometry, feature);
          }
          var textStyle = style.getText();
          if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(geometry, feature);
          }
        }
        function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
          var fillStyle = style.getFill();
          var strokeStyle = style.getStroke();
          if (strokeStyle || fillStyle) {
            var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);
            polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
            polygonReplay.drawMultiPolygon(geometry, feature);
          }
          var textStyle = style.getText();
          if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(geometry, feature);
          }
        }
        function renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
          var imageStyle = style.getImage();
          var textStyle = style.getText();
          var declutterImageWithText;
          if (opt_declutterBuilderGroup) {
            builderGroup = opt_declutterBuilderGroup;
            declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : void 0;
          }
          if (imageStyle) {
            if (imageStyle.getImageState() != ImageState.LOADED) {
              return;
            }
            var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);
            imageReplay.setImageStyle(imageStyle, declutterImageWithText);
            imageReplay.drawPoint(geometry, feature);
          }
          if (textStyle && textStyle.getText()) {
            var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
            textReplay.setTextStyle(textStyle, declutterImageWithText);
            textReplay.drawText(geometry, feature);
          }
        }
        function renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
          var imageStyle = style.getImage();
          var textStyle = style.getText();
          var declutterImageWithText;
          if (opt_declutterBuilderGroup) {
            builderGroup = opt_declutterBuilderGroup;
            declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : void 0;
          }
          if (imageStyle) {
            if (imageStyle.getImageState() != ImageState.LOADED) {
              return;
            }
            var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);
            imageReplay.setImageStyle(imageStyle, declutterImageWithText);
            imageReplay.drawMultiPoint(geometry, feature);
          }
          if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
            textReplay.setTextStyle(textStyle, declutterImageWithText);
            textReplay.drawText(geometry, feature);
          }
        }
        function renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
          var fillStyle = style.getFill();
          var strokeStyle = style.getStroke();
          if (fillStyle || strokeStyle) {
            var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);
            polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
            polygonReplay.drawPolygon(geometry, feature);
          }
          var textStyle = style.getText();
          if (textStyle && textStyle.getText()) {
            var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(geometry, feature);
          }
        }
        var VectorLayer_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var VectorLayer_CanvasVectorLayerRenderer = function(_super) {
          VectorLayer_extends(CanvasVectorLayerRenderer, _super);
          function CanvasVectorLayerRenderer(vectorLayer) {
            var _this = _super.call(this, vectorLayer) || this;
            _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
            _this.animatingOrInteracting_;
            _this.dirty_ = false;
            _this.hitDetectionImageData_ = null;
            _this.renderedFeatures_ = null;
            _this.renderedRevision_ = -1;
            _this.renderedResolution_ = NaN;
            _this.renderedExtent_ = createEmpty();
            _this.wrappedRenderedExtent_ = createEmpty();
            _this.renderedRotation_;
            _this.renderedCenter_ = null;
            _this.renderedProjection_ = null;
            _this.renderedRenderOrder_ = null;
            _this.replayGroup_ = null;
            _this.replayGroupChanged = true;
            _this.declutterExecutorGroup = null;
            _this.clipping = true;
            return _this;
          }
          CanvasVectorLayerRenderer.prototype.renderWorlds = function(executorGroup, frameState, opt_declutterTree) {
            var extent = frameState.extent;
            var viewState = frameState.viewState;
            var center = viewState.center;
            var resolution = viewState.resolution;
            var projection = viewState.projection;
            var rotation = viewState.rotation;
            var projectionExtent = projection.getExtent();
            var vectorSource = this.getLayer().getSource();
            var pixelRatio = frameState.pixelRatio;
            var viewHints = frameState.viewHints;
            var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
            var context = this.context;
            var width = Math.round(frameState.size[0] * pixelRatio);
            var height = Math.round(frameState.size[1] * pixelRatio);
            var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
            var worldWidth = multiWorld ? getWidth(projectionExtent) : null;
            var endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
            var world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
            do {
              var transform2 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
              executorGroup.execute(context, 1, transform2, rotation, snapToPixel, void 0, opt_declutterTree);
            } while (++world < endWorld);
          };
          CanvasVectorLayerRenderer.prototype.renderDeclutter = function(frameState) {
            if (this.declutterExecutorGroup) {
              this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
            }
          };
          CanvasVectorLayerRenderer.prototype.renderFrame = function(frameState, target) {
            var pixelRatio = frameState.pixelRatio;
            var layerState = frameState.layerStatesArray[frameState.layerIndex];
            makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
            makeInverse(this.inversePixelTransform, this.pixelTransform);
            var canvasTransform = transform_toString(this.pixelTransform);
            this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
            var context = this.context;
            var canvas = context.canvas;
            var replayGroup = this.replayGroup_;
            var declutterExecutorGroup = this.declutterExecutorGroup;
            if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {
              return null;
            }
            var width = Math.round(frameState.size[0] * pixelRatio);
            var height = Math.round(frameState.size[1] * pixelRatio);
            if (canvas.width != width || canvas.height != height) {
              canvas.width = width;
              canvas.height = height;
              if (canvas.style.transform !== canvasTransform) {
                canvas.style.transform = canvasTransform;
              }
            } else if (!this.containerReused) {
              context.clearRect(0, 0, width, height);
            }
            this.preRender(context, frameState);
            var viewState = frameState.viewState;
            var projection = viewState.projection;
            var clipped = false;
            var render = true;
            if (layerState.extent && this.clipping) {
              var layerExtent = fromUserExtent(layerState.extent, projection);
              render = extent_intersects(layerExtent, frameState.extent);
              clipped = render && !containsExtent(layerExtent, frameState.extent);
              if (clipped) {
                this.clipUnrotated(context, frameState, layerExtent);
              }
            }
            if (render) {
              this.renderWorlds(replayGroup, frameState);
            }
            if (clipped) {
              context.restore();
            }
            this.postRender(context, frameState);
            var opacity = cssOpacity(layerState.opacity);
            var container = this.container;
            if (opacity !== container.style.opacity) {
              container.style.opacity = opacity;
            }
            if (this.renderedRotation_ !== viewState.rotation) {
              this.renderedRotation_ = viewState.rotation;
              this.hitDetectionImageData_ = null;
            }
            return this.container;
          };
          CanvasVectorLayerRenderer.prototype.getFeatures = function(pixel) {
            return new Promise(function(resolve) {
              if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                var size = [this.context.canvas.width, this.context.canvas.height];
                apply(this.pixelTransform, size);
                var center = this.renderedCenter_;
                var resolution = this.renderedResolution_;
                var rotation = this.renderedRotation_;
                var projection = this.renderedProjection_;
                var extent = this.wrappedRenderedExtent_;
                var layer = this.getLayer();
                var transforms = [];
                var width = size[0] * HIT_DETECT_RESOLUTION;
                var height = size[1] * HIT_DETECT_RESOLUTION;
                transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, 0).slice());
                var source = layer.getSource();
                var projectionExtent = projection.getExtent();
                if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
                  var startX = extent[0];
                  var worldWidth = getWidth(projectionExtent);
                  var world = 0;
                  var offsetX = void 0;
                  while (startX < projectionExtent[0]) {
                    --world;
                    offsetX = worldWidth * world;
                    transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
                    startX += worldWidth;
                  }
                  world = 0;
                  startX = extent[2];
                  while (startX > projectionExtent[2]) {
                    ++world;
                    offsetX = worldWidth * world;
                    transforms.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
                    startX -= worldWidth;
                  }
                }
                this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
              }
              resolve(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
            }.bind(this));
          };
          CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
            var _this = this;
            if (!this.replayGroup_) {
              return void 0;
            }
            var resolution = frameState.viewState.resolution;
            var rotation = frameState.viewState.rotation;
            var layer = this.getLayer();
            var features = {};
            var featureCallback = function(feature, geometry, distanceSq) {
              var key = Object(util["c"])(feature);
              var match = features[key];
              if (!match) {
                if (distanceSq === 0) {
                  features[key] = true;
                  return callback(feature, layer, geometry);
                }
                matches.push(features[key] = {
                  feature,
                  layer,
                  geometry,
                  distanceSq,
                  callback
                });
              } else if (match !== true && distanceSq < match.distanceSq) {
                if (distanceSq === 0) {
                  features[key] = true;
                  matches.splice(matches.lastIndexOf(match), 1);
                  return callback(feature, layer, geometry);
                }
                match.geometry = geometry;
                match.distanceSq = distanceSq;
              }
              return void 0;
            };
            var result;
            var executorGroups = [this.replayGroup_];
            if (this.declutterExecutorGroup) {
              executorGroups.push(this.declutterExecutorGroup);
            }
            executorGroups.some(function(executorGroup) {
              return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map(function(item) {
                return item.value;
              }) : null);
            });
            return result;
          };
          CanvasVectorLayerRenderer.prototype.handleFontsChanged = function() {
            var layer = this.getLayer();
            if (layer.getVisible() && this.replayGroup_) {
              layer.changed();
            }
          };
          CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function(event) {
            this.renderIfReadyAndVisible();
          };
          CanvasVectorLayerRenderer.prototype.prepareFrame = function(frameState) {
            var vectorLayer = this.getLayer();
            var vectorSource = vectorLayer.getSource();
            if (!vectorSource) {
              return false;
            }
            var animating = frameState.viewHints[ViewHint.ANIMATING];
            var interacting = frameState.viewHints[ViewHint.INTERACTING];
            var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
            var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
            if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
              this.animatingOrInteracting_ = true;
              return true;
            }
            this.animatingOrInteracting_ = false;
            var frameStateExtent = frameState.extent;
            var viewState = frameState.viewState;
            var projection = viewState.projection;
            var resolution = viewState.resolution;
            var pixelRatio = frameState.pixelRatio;
            var vectorLayerRevision = vectorLayer.getRevision();
            var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
            var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
            if (vectorLayerRenderOrder === void 0) {
              vectorLayerRenderOrder = defaultOrder;
            }
            var center = viewState.center.slice();
            var extent = extent_buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
            var renderedExtent = extent.slice();
            var loadExtents = [extent.slice()];
            var projectionExtent = projection.getExtent();
            if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
              var worldWidth = getWidth(projectionExtent);
              var gutter = Math.max(getWidth(extent) / 2, worldWidth);
              extent[0] = projectionExtent[0] - gutter;
              extent[2] = projectionExtent[2] + gutter;
              coordinate_wrapX(center, projection);
              var loadExtent = extent_wrapX(loadExtents[0], projection);
              if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
                loadExtents.push([
                  loadExtent[0] + worldWidth,
                  loadExtent[1],
                  loadExtent[2] + worldWidth,
                  loadExtent[3]
                ]);
              } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
                loadExtents.push([
                  loadExtent[0] - worldWidth,
                  loadExtent[1],
                  loadExtent[2] - worldWidth,
                  loadExtent[3]
                ]);
              }
            }
            if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent)) {
              if (!Object(ol_array["b"])(this.renderedExtent_, renderedExtent)) {
                this.hitDetectionImageData_ = null;
                this.renderedExtent_ = renderedExtent;
              }
              this.renderedCenter_ = center;
              this.replayGroupChanged = false;
              return true;
            }
            this.replayGroup_ = null;
            this.dirty_ = false;
            var replayGroup = new canvas_BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
            var declutterBuilderGroup;
            if (this.getLayer().getDeclutter()) {
              declutterBuilderGroup = new canvas_BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
            }
            var userProjection = getUserProjection();
            var userTransform;
            if (userProjection) {
              for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                var extent_1 = loadExtents[i];
                var userExtent_1 = toUserExtent(extent_1, projection);
                vectorSource.loadFeatures(userExtent_1, toUserResolution(resolution, projection), userProjection);
              }
              userTransform = getTransformFromProjections(userProjection, projection);
            } else {
              for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                vectorSource.loadFeatures(loadExtents[i], resolution, projection);
              }
            }
            var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
            var render = function(feature) {
              var styles;
              var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
              if (styleFunction) {
                styles = styleFunction(feature, resolution);
              }
              if (styles) {
                var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
                this.dirty_ = this.dirty_ || dirty;
              }
            }.bind(this);
            var userExtent = toUserExtent(extent, projection);
            var features = vectorSource.getFeaturesInExtent(userExtent);
            if (vectorLayerRenderOrder) {
              features.sort(vectorLayerRenderOrder);
            }
            for (var i = 0, ii = features.length; i < ii; ++i) {
              render(features[i]);
            }
            this.renderedFeatures_ = features;
            var replayGroupInstructions = replayGroup.finish();
            var executorGroup = new canvas_ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
            if (declutterBuilderGroup) {
              this.declutterExecutorGroup = new canvas_ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
            }
            this.renderedResolution_ = resolution;
            this.renderedRevision_ = vectorLayerRevision;
            this.renderedRenderOrder_ = vectorLayerRenderOrder;
            this.renderedExtent_ = renderedExtent;
            this.wrappedRenderedExtent_ = extent;
            this.renderedCenter_ = center;
            this.renderedProjection_ = projection;
            this.replayGroup_ = executorGroup;
            this.hitDetectionImageData_ = null;
            this.replayGroupChanged = true;
            return true;
          };
          CanvasVectorLayerRenderer.prototype.renderFeature = function(feature, squaredTolerance, styles, builderGroup, opt_transform, opt_declutterBuilderGroup) {
            if (!styles) {
              return false;
            }
            var loading = false;
            if (Array.isArray(styles)) {
              for (var i = 0, ii = styles.length; i < ii; ++i) {
                loading = renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup) || loading;
              }
            } else {
              loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup);
            }
            return loading;
          };
          return CanvasVectorLayerRenderer;
        }(canvas_Layer);
        var canvas_VectorLayer = VectorLayer_CanvasVectorLayerRenderer;
        var Vector_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Vector_VectorLayer = function(_super) {
          Vector_extends(VectorLayer, _super);
          function VectorLayer(opt_options) {
            return _super.call(this, opt_options) || this;
          }
          VectorLayer.prototype.createRenderer = function() {
            return new canvas_VectorLayer(this);
          };
          return VectorLayer;
        }(BaseVector);
        var Vector = Vector_VectorLayer;
        var VectorLayervue_type_script_lang_js = {
          extends: layers_BaseLayer,
          name: "ol-vector-layer",
          setup: function setup(props) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var vectorLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new Vector(properties);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              vectorLayer.value.setProperties(properties);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addLayer(vectorLayer.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeLayer(vectorLayer.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("vectorLayer", vectorLayer);
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", vectorLayer);
            return {
              vectorLayer
            };
          },
          props: {
            renderBuffer: {
              type: Number,
              default: 100
            },
            updateWhileAnimating: {
              type: Boolean,
              default: false
            },
            style: {
              type: Function
            },
            updateWhileInteracting: {
              type: Boolean,
              default: false
            }
          }
        };
        const VectorLayer_exports_ = exportHelper_default()(VectorLayervue_type_script_lang_js, [["render", VectorLayervue_type_template_id_6b3006ca_lang_true_render]]);
        var layers_VectorLayer = VectorLayer_exports_;
        function AnimatedClusterLayervue_type_template_id_2797d6d8_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var RBush_RBush = function() {
          function RBush(opt_maxEntries) {
            this.rbush_ = new rbush_min_default.a(opt_maxEntries);
            this.items_ = {};
          }
          RBush.prototype.insert = function(extent, value) {
            var item = {
              minX: extent[0],
              minY: extent[1],
              maxX: extent[2],
              maxY: extent[3],
              value
            };
            this.rbush_.insert(item);
            this.items_[Object(util["c"])(value)] = item;
          };
          RBush.prototype.load = function(extents, values) {
            var items = new Array(values.length);
            for (var i = 0, l = values.length; i < l; i++) {
              var extent = extents[i];
              var value = values[i];
              var item = {
                minX: extent[0],
                minY: extent[1],
                maxX: extent[2],
                maxY: extent[3],
                value
              };
              items[i] = item;
              this.items_[Object(util["c"])(value)] = item;
            }
            this.rbush_.load(items);
          };
          RBush.prototype.remove = function(value) {
            var uid = Object(util["c"])(value);
            var item = this.items_[uid];
            delete this.items_[uid];
            return this.rbush_.remove(item) !== null;
          };
          RBush.prototype.update = function(extent, value) {
            var item = this.items_[Object(util["c"])(value)];
            var bbox = [item.minX, item.minY, item.maxX, item.maxY];
            if (!equals(bbox, extent)) {
              this.remove(value);
              this.insert(extent, value);
            }
          };
          RBush.prototype.getAll = function() {
            var items = this.rbush_.all();
            return items.map(function(item) {
              return item.value;
            });
          };
          RBush.prototype.getInExtent = function(extent) {
            var bbox = {
              minX: extent[0],
              minY: extent[1],
              maxX: extent[2],
              maxY: extent[3]
            };
            var items = this.rbush_.search(bbox);
            return items.map(function(item) {
              return item.value;
            });
          };
          RBush.prototype.forEach = function(callback) {
            return this.forEach_(this.getAll(), callback);
          };
          RBush.prototype.forEachInExtent = function(extent, callback) {
            return this.forEach_(this.getInExtent(extent), callback);
          };
          RBush.prototype.forEach_ = function(values, callback) {
            var result;
            for (var i = 0, l = values.length; i < l; i++) {
              result = callback(values[i]);
              if (result) {
                return result;
              }
            }
            return result;
          };
          RBush.prototype.isEmpty = function() {
            return Object(ol_obj["d"])(this.items_);
          };
          RBush.prototype.clear = function() {
            this.rbush_.clear();
            this.items_ = {};
          };
          RBush.prototype.getExtent = function(opt_extent) {
            var data = this.rbush_.toJSON();
            return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
          };
          RBush.prototype.concat = function(rbush) {
            this.rbush_.load(rbush.rbush_.all());
            for (var i in rbush.items_) {
              this.items_[i] = rbush.items_[i];
            }
          };
          return RBush;
        }();
        var structs_RBush = RBush_RBush;
        var Source_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Source_Source = function(_super) {
          Source_extends(Source, _super);
          function Source(options) {
            var _this = _super.call(this) || this;
            _this.projection = proj_get(options.projection);
            _this.attributions_ = adaptAttributions(options.attributions);
            _this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
            _this.loading = false;
            _this.state_ = options.state !== void 0 ? options.state : State.READY;
            _this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
            _this.interpolate_ = !!options.interpolate;
            _this.viewResolver = null;
            _this.viewRejector = null;
            var self2 = _this;
            _this.viewPromise_ = new Promise(function(resolve, reject) {
              self2.viewResolver = resolve;
              self2.viewRejector = reject;
            });
            return _this;
          }
          Source.prototype.getAttributions = function() {
            return this.attributions_;
          };
          Source.prototype.getAttributionsCollapsible = function() {
            return this.attributionsCollapsible_;
          };
          Source.prototype.getProjection = function() {
            return this.projection;
          };
          Source.prototype.getResolutions = function() {
            return Object(util["b"])();
          };
          Source.prototype.getView = function() {
            return this.viewPromise_;
          };
          Source.prototype.getState = function() {
            return this.state_;
          };
          Source.prototype.getWrapX = function() {
            return this.wrapX_;
          };
          Source.prototype.getInterpolate = function() {
            return this.interpolate_;
          };
          Source.prototype.refresh = function() {
            this.changed();
          };
          Source.prototype.setAttributions = function(attributions) {
            this.attributions_ = adaptAttributions(attributions);
            this.changed();
          };
          Source.prototype.setState = function(state) {
            this.state_ = state;
            this.changed();
          };
          return Source;
        }(ol_Object["a"]);
        function adaptAttributions(attributionLike) {
          if (!attributionLike) {
            return null;
          }
          if (Array.isArray(attributionLike)) {
            return function(frameState) {
              return attributionLike;
            };
          }
          if (typeof attributionLike === "function") {
            return attributionLike;
          }
          return function(frameState) {
            return [attributionLike];
          };
        }
        var source_Source = Source_Source;
        var VectorEventType = {
          ADDFEATURE: "addfeature",
          CHANGEFEATURE: "changefeature",
          CLEAR: "clear",
          REMOVEFEATURE: "removefeature",
          FEATURESLOADSTART: "featuresloadstart",
          FEATURESLOADEND: "featuresloadend",
          FEATURESLOADERROR: "featuresloaderror"
        };
        function loadingstrategy_all(extent, resolution) {
          return [[-Infinity, -Infinity, Infinity, Infinity]];
        }
        function loadingstrategy_bbox(extent, resolution) {
          return [extent];
        }
        function loadingstrategy_tile(tileGrid) {
          return function(extent, resolution, projection) {
            var z = tileGrid.getZForResolution(fromUserResolution(resolution, projection));
            var tileRange = tileGrid.getTileRangeForExtentAndZ(fromUserExtent(extent, projection), z);
            var extents = [];
            var tileCoord = [z, 0, 0];
            for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
              for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
                extents.push(toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection));
              }
            }
            return extents;
          };
        }
        var FormatType = {
          ARRAY_BUFFER: "arraybuffer",
          JSON: "json",
          TEXT: "text",
          XML: "xml"
        };
        var withCredentials = false;
        function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", typeof url === "function" ? url(extent, resolution, projection) : url, true);
          if (format.getType() == FormatType.ARRAY_BUFFER) {
            xhr.responseType = "arraybuffer";
          }
          xhr.withCredentials = withCredentials;
          xhr.onload = function(event) {
            if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
              var type = format.getType();
              var source = void 0;
              if (type == FormatType.JSON || type == FormatType.TEXT) {
                source = xhr.responseText;
              } else if (type == FormatType.XML) {
                source = xhr.responseXML;
                if (!source) {
                  source = new DOMParser().parseFromString(xhr.responseText, "application/xml");
                }
              } else if (type == FormatType.ARRAY_BUFFER) {
                source = xhr.response;
              }
              if (source) {
                success(format.readFeatures(source, {
                  extent,
                  featureProjection: projection
                }), format.readProjection(source));
              } else {
                failure();
              }
            } else {
              failure();
            }
          };
          xhr.onerror = failure;
          xhr.send();
        }
        function featureloader_xhr(url, format) {
          return function(extent, resolution, projection, success, failure) {
            var source = this;
            loadFeaturesXhr(url, format, extent, resolution, projection, function(features, dataProjection) {
              source.addFeatures(features);
              if (success !== void 0) {
                success(features);
              }
            }, failure ? failure : functions["c"]);
          };
        }
        function setWithCredentials(xhrWithCredentials) {
          withCredentials = xhrWithCredentials;
        }
        var source_Vector_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var VectorSourceEvent = function(_super) {
          source_Vector_extends(VectorSourceEvent2, _super);
          function VectorSourceEvent2(type, opt_feature, opt_features) {
            var _this = _super.call(this, type) || this;
            _this.feature = opt_feature;
            _this.features = opt_features;
            return _this;
          }
          return VectorSourceEvent2;
        }(events_Event["a"]);
        var Vector_VectorSource = function(_super) {
          source_Vector_extends(VectorSource, _super);
          function VectorSource(opt_options) {
            var _this = this;
            var options = opt_options || {};
            _this = _super.call(this, {
              attributions: options.attributions,
              interpolate: true,
              projection: void 0,
              state: State.READY,
              wrapX: options.wrapX !== void 0 ? options.wrapX : true
            }) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.loader_ = functions["c"];
            _this.format_ = options.format;
            _this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
            _this.url_ = options.url;
            if (options.loader !== void 0) {
              _this.loader_ = options.loader;
            } else if (_this.url_ !== void 0) {
              assert2(_this.format_, 7);
              _this.loader_ = featureloader_xhr(_this.url_, _this.format_);
            }
            _this.strategy_ = options.strategy !== void 0 ? options.strategy : loadingstrategy_all;
            var useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
            _this.featuresRtree_ = useSpatialIndex ? new structs_RBush() : null;
            _this.loadedExtentsRtree_ = new structs_RBush();
            _this.loadingExtentsCount_ = 0;
            _this.nullGeometryFeatures_ = {};
            _this.idIndex_ = {};
            _this.uidIndex_ = {};
            _this.featureChangeKeys_ = {};
            _this.featuresCollection_ = null;
            var collection, features;
            if (Array.isArray(options.features)) {
              features = options.features;
            } else if (options.features) {
              collection = options.features;
              features = collection.getArray();
            }
            if (!useSpatialIndex && collection === void 0) {
              collection = new ol_Collection(features);
            }
            if (features !== void 0) {
              _this.addFeaturesInternal(features);
            }
            if (collection !== void 0) {
              _this.bindFeaturesCollection_(collection);
            }
            return _this;
          }
          VectorSource.prototype.addFeature = function(feature) {
            this.addFeatureInternal(feature);
            this.changed();
          };
          VectorSource.prototype.addFeatureInternal = function(feature) {
            var featureKey = Object(util["c"])(feature);
            if (!this.addToIndex_(featureKey, feature)) {
              if (this.featuresCollection_) {
                this.featuresCollection_.remove(feature);
              }
              return;
            }
            this.setupChangeEvents_(featureKey, feature);
            var geometry = feature.getGeometry();
            if (geometry) {
              var extent = geometry.getExtent();
              if (this.featuresRtree_) {
                this.featuresRtree_.insert(extent, feature);
              }
            } else {
              this.nullGeometryFeatures_[featureKey] = feature;
            }
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));
          };
          VectorSource.prototype.setupChangeEvents_ = function(featureKey, feature) {
            this.featureChangeKeys_[featureKey] = [
              Object(events["a"])(feature, EventType["a"].CHANGE, this.handleFeatureChange_, this),
              Object(events["a"])(feature, ObjectEventType["a"].PROPERTYCHANGE, this.handleFeatureChange_, this)
            ];
          };
          VectorSource.prototype.addToIndex_ = function(featureKey, feature) {
            var valid = true;
            var id = feature.getId();
            if (id !== void 0) {
              if (!(id.toString() in this.idIndex_)) {
                this.idIndex_[id.toString()] = feature;
              } else {
                valid = false;
              }
            }
            if (valid) {
              assert2(!(featureKey in this.uidIndex_), 30);
              this.uidIndex_[featureKey] = feature;
            }
            return valid;
          };
          VectorSource.prototype.addFeatures = function(features) {
            this.addFeaturesInternal(features);
            this.changed();
          };
          VectorSource.prototype.addFeaturesInternal = function(features) {
            var extents = [];
            var newFeatures = [];
            var geometryFeatures = [];
            for (var i = 0, length_1 = features.length; i < length_1; i++) {
              var feature = features[i];
              var featureKey = Object(util["c"])(feature);
              if (this.addToIndex_(featureKey, feature)) {
                newFeatures.push(feature);
              }
            }
            for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
              var feature = newFeatures[i];
              var featureKey = Object(util["c"])(feature);
              this.setupChangeEvents_(featureKey, feature);
              var geometry = feature.getGeometry();
              if (geometry) {
                var extent = geometry.getExtent();
                extents.push(extent);
                geometryFeatures.push(feature);
              } else {
                this.nullGeometryFeatures_[featureKey] = feature;
              }
            }
            if (this.featuresRtree_) {
              this.featuresRtree_.load(extents, geometryFeatures);
            }
            for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
              this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]));
            }
          };
          VectorSource.prototype.bindFeaturesCollection_ = function(collection) {
            var modifyingCollection = false;
            this.addEventListener(VectorEventType.ADDFEATURE, function(evt) {
              if (!modifyingCollection) {
                modifyingCollection = true;
                collection.push(evt.feature);
                modifyingCollection = false;
              }
            });
            this.addEventListener(VectorEventType.REMOVEFEATURE, function(evt) {
              if (!modifyingCollection) {
                modifyingCollection = true;
                collection.remove(evt.feature);
                modifyingCollection = false;
              }
            });
            collection.addEventListener(CollectionEventType.ADD, function(evt) {
              if (!modifyingCollection) {
                modifyingCollection = true;
                this.addFeature(evt.element);
                modifyingCollection = false;
              }
            }.bind(this));
            collection.addEventListener(CollectionEventType.REMOVE, function(evt) {
              if (!modifyingCollection) {
                modifyingCollection = true;
                this.removeFeature(evt.element);
                modifyingCollection = false;
              }
            }.bind(this));
            this.featuresCollection_ = collection;
          };
          VectorSource.prototype.clear = function(opt_fast) {
            if (opt_fast) {
              for (var featureId in this.featureChangeKeys_) {
                var keys = this.featureChangeKeys_[featureId];
                keys.forEach(events["c"]);
              }
              if (!this.featuresCollection_) {
                this.featureChangeKeys_ = {};
                this.idIndex_ = {};
                this.uidIndex_ = {};
              }
            } else {
              if (this.featuresRtree_) {
                var removeAndIgnoreReturn = function(feature) {
                  this.removeFeatureInternal(feature);
                }.bind(this);
                this.featuresRtree_.forEach(removeAndIgnoreReturn);
                for (var id in this.nullGeometryFeatures_) {
                  this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
                }
              }
            }
            if (this.featuresCollection_) {
              this.featuresCollection_.clear();
            }
            if (this.featuresRtree_) {
              this.featuresRtree_.clear();
            }
            this.nullGeometryFeatures_ = {};
            var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
            this.dispatchEvent(clearEvent);
            this.changed();
          };
          VectorSource.prototype.forEachFeature = function(callback) {
            if (this.featuresRtree_) {
              return this.featuresRtree_.forEach(callback);
            } else if (this.featuresCollection_) {
              this.featuresCollection_.forEach(callback);
            }
          };
          VectorSource.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {
            var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
            return this.forEachFeatureInExtent(extent, function(feature) {
              var geometry = feature.getGeometry();
              if (geometry.intersectsCoordinate(coordinate)) {
                return callback(feature);
              } else {
                return void 0;
              }
            });
          };
          VectorSource.prototype.forEachFeatureInExtent = function(extent, callback) {
            if (this.featuresRtree_) {
              return this.featuresRtree_.forEachInExtent(extent, callback);
            } else if (this.featuresCollection_) {
              this.featuresCollection_.forEach(callback);
            }
          };
          VectorSource.prototype.forEachFeatureIntersectingExtent = function(extent, callback) {
            return this.forEachFeatureInExtent(extent, function(feature) {
              var geometry = feature.getGeometry();
              if (geometry.intersectsExtent(extent)) {
                var result = callback(feature);
                if (result) {
                  return result;
                }
              }
            });
          };
          VectorSource.prototype.getFeaturesCollection = function() {
            return this.featuresCollection_;
          };
          VectorSource.prototype.getFeatures = function() {
            var features;
            if (this.featuresCollection_) {
              features = this.featuresCollection_.getArray().slice(0);
            } else if (this.featuresRtree_) {
              features = this.featuresRtree_.getAll();
              if (!Object(ol_obj["d"])(this.nullGeometryFeatures_)) {
                Object(ol_array["c"])(features, Object(ol_obj["c"])(this.nullGeometryFeatures_));
              }
            }
            return features;
          };
          VectorSource.prototype.getFeaturesAtCoordinate = function(coordinate) {
            var features = [];
            this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
              features.push(feature);
            });
            return features;
          };
          VectorSource.prototype.getFeaturesInExtent = function(extent) {
            if (this.featuresRtree_) {
              return this.featuresRtree_.getInExtent(extent);
            } else if (this.featuresCollection_) {
              return this.featuresCollection_.getArray().slice(0);
            } else {
              return [];
            }
          };
          VectorSource.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {
            var x = coordinate[0];
            var y = coordinate[1];
            var closestFeature = null;
            var closestPoint = [NaN, NaN];
            var minSquaredDistance = Infinity;
            var extent = [-Infinity, -Infinity, Infinity, Infinity];
            var filter = opt_filter ? opt_filter : functions["b"];
            this.featuresRtree_.forEachInExtent(extent, function(feature) {
              if (filter(feature)) {
                var geometry = feature.getGeometry();
                var previousMinSquaredDistance = minSquaredDistance;
                minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                if (minSquaredDistance < previousMinSquaredDistance) {
                  closestFeature = feature;
                  var minDistance = Math.sqrt(minSquaredDistance);
                  extent[0] = x - minDistance;
                  extent[1] = y - minDistance;
                  extent[2] = x + minDistance;
                  extent[3] = y + minDistance;
                }
              }
            });
            return closestFeature;
          };
          VectorSource.prototype.getExtent = function(opt_extent) {
            return this.featuresRtree_.getExtent(opt_extent);
          };
          VectorSource.prototype.getFeatureById = function(id) {
            var feature = this.idIndex_[id.toString()];
            return feature !== void 0 ? feature : null;
          };
          VectorSource.prototype.getFeatureByUid = function(uid) {
            var feature = this.uidIndex_[uid];
            return feature !== void 0 ? feature : null;
          };
          VectorSource.prototype.getFormat = function() {
            return this.format_;
          };
          VectorSource.prototype.getOverlaps = function() {
            return this.overlaps_;
          };
          VectorSource.prototype.getUrl = function() {
            return this.url_;
          };
          VectorSource.prototype.handleFeatureChange_ = function(event) {
            var feature = event.target;
            var featureKey = Object(util["c"])(feature);
            var geometry = feature.getGeometry();
            if (!geometry) {
              if (!(featureKey in this.nullGeometryFeatures_)) {
                if (this.featuresRtree_) {
                  this.featuresRtree_.remove(feature);
                }
                this.nullGeometryFeatures_[featureKey] = feature;
              }
            } else {
              var extent = geometry.getExtent();
              if (featureKey in this.nullGeometryFeatures_) {
                delete this.nullGeometryFeatures_[featureKey];
                if (this.featuresRtree_) {
                  this.featuresRtree_.insert(extent, feature);
                }
              } else {
                if (this.featuresRtree_) {
                  this.featuresRtree_.update(extent, feature);
                }
              }
            }
            var id = feature.getId();
            if (id !== void 0) {
              var sid = id.toString();
              if (this.idIndex_[sid] !== feature) {
                this.removeFromIdIndex_(feature);
                this.idIndex_[sid] = feature;
              }
            } else {
              this.removeFromIdIndex_(feature);
              this.uidIndex_[featureKey] = feature;
            }
            this.changed();
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));
          };
          VectorSource.prototype.hasFeature = function(feature) {
            var id = feature.getId();
            if (id !== void 0) {
              return id in this.idIndex_;
            } else {
              return Object(util["c"])(feature) in this.uidIndex_;
            }
          };
          VectorSource.prototype.isEmpty = function() {
            return this.featuresRtree_.isEmpty() && Object(ol_obj["d"])(this.nullGeometryFeatures_);
          };
          VectorSource.prototype.loadFeatures = function(extent, resolution, projection) {
            var loadedExtentsRtree = this.loadedExtentsRtree_;
            var extentsToLoad = this.strategy_(extent, resolution, projection);
            var _loop_1 = function(i2, ii2) {
              var extentToLoad = extentsToLoad[i2];
              var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, function(object) {
                return containsExtent(object.extent, extentToLoad);
              });
              if (!alreadyLoaded) {
                ++this_1.loadingExtentsCount_;
                this_1.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART));
                this_1.loader_.call(this_1, extentToLoad, resolution, projection, function(features) {
                  --this.loadingExtentsCount_;
                  this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND, void 0, features));
                }.bind(this_1), function() {
                  --this.loadingExtentsCount_;
                  this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR));
                }.bind(this_1));
                loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
              }
            };
            var this_1 = this;
            for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
              _loop_1(i, ii);
            }
            this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
          };
          VectorSource.prototype.refresh = function() {
            this.clear(true);
            this.loadedExtentsRtree_.clear();
            _super.prototype.refresh.call(this);
          };
          VectorSource.prototype.removeLoadedExtent = function(extent) {
            var loadedExtentsRtree = this.loadedExtentsRtree_;
            var obj;
            loadedExtentsRtree.forEachInExtent(extent, function(object) {
              if (equals(object.extent, extent)) {
                obj = object;
                return true;
              }
            });
            if (obj) {
              loadedExtentsRtree.remove(obj);
            }
          };
          VectorSource.prototype.removeFeature = function(feature) {
            if (!feature) {
              return;
            }
            var featureKey = Object(util["c"])(feature);
            if (featureKey in this.nullGeometryFeatures_) {
              delete this.nullGeometryFeatures_[featureKey];
            } else {
              if (this.featuresRtree_) {
                this.featuresRtree_.remove(feature);
              }
            }
            var result = this.removeFeatureInternal(feature);
            if (result) {
              this.changed();
            }
          };
          VectorSource.prototype.removeFeatureInternal = function(feature) {
            var featureKey = Object(util["c"])(feature);
            var featureChangeKeys = this.featureChangeKeys_[featureKey];
            if (!featureChangeKeys) {
              return;
            }
            featureChangeKeys.forEach(events["c"]);
            delete this.featureChangeKeys_[featureKey];
            var id = feature.getId();
            if (id !== void 0) {
              delete this.idIndex_[id.toString()];
            }
            delete this.uidIndex_[featureKey];
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));
            return feature;
          };
          VectorSource.prototype.removeFromIdIndex_ = function(feature) {
            var removed = false;
            for (var id in this.idIndex_) {
              if (this.idIndex_[id] === feature) {
                delete this.idIndex_[id];
                removed = true;
                break;
              }
            }
            return removed;
          };
          VectorSource.prototype.setLoader = function(loader) {
            this.loader_ = loader;
          };
          VectorSource.prototype.setUrl = function(url) {
            assert2(this.format_, 7);
            this.url_ = url;
            this.setLoader(featureloader_xhr(url, this.format_));
          };
          return VectorSource;
        }(source_Source);
        var source_Vector = Vector_VectorSource;
        var Cluster_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Cluster_Cluster = function(_super) {
          Cluster_extends(Cluster, _super);
          function Cluster(options) {
            var _this = _super.call(this, {
              attributions: options.attributions,
              wrapX: options.wrapX
            }) || this;
            _this.resolution = void 0;
            _this.distance = options.distance !== void 0 ? options.distance : 20;
            _this.minDistance = options.minDistance || 0;
            _this.interpolationRatio = 0;
            _this.features = [];
            _this.geometryFunction = options.geometryFunction || function(feature) {
              var geometry = feature.getGeometry();
              assert2(geometry.getType() == geom_GeometryType.POINT, 10);
              return geometry;
            };
            _this.createCustomCluster_ = options.createCluster;
            _this.source = null;
            _this.boundRefresh_ = _this.refresh.bind(_this);
            _this.updateDistance(_this.distance, _this.minDistance);
            _this.setSource(options.source || null);
            return _this;
          }
          Cluster.prototype.clear = function(opt_fast) {
            this.features.length = 0;
            _super.prototype.clear.call(this, opt_fast);
          };
          Cluster.prototype.getDistance = function() {
            return this.distance;
          };
          Cluster.prototype.getSource = function() {
            return this.source;
          };
          Cluster.prototype.loadFeatures = function(extent, resolution, projection) {
            this.source.loadFeatures(extent, resolution, projection);
            if (resolution !== this.resolution) {
              this.resolution = resolution;
              this.refresh();
            }
          };
          Cluster.prototype.setDistance = function(distance) {
            this.updateDistance(distance, this.minDistance);
          };
          Cluster.prototype.setMinDistance = function(minDistance) {
            this.updateDistance(this.distance, minDistance);
          };
          Cluster.prototype.getMinDistance = function() {
            return this.minDistance;
          };
          Cluster.prototype.setSource = function(source) {
            if (this.source) {
              this.source.removeEventListener(EventType["a"].CHANGE, this.boundRefresh_);
            }
            this.source = source;
            if (source) {
              source.addEventListener(EventType["a"].CHANGE, this.boundRefresh_);
            }
            this.refresh();
          };
          Cluster.prototype.refresh = function() {
            this.clear();
            this.cluster();
            this.addFeatures(this.features);
          };
          Cluster.prototype.updateDistance = function(distance, minDistance) {
            var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;
            var changed = distance !== this.distance || this.interpolationRatio !== ratio;
            this.distance = distance;
            this.minDistance = minDistance;
            this.interpolationRatio = ratio;
            if (changed) {
              this.refresh();
            }
          };
          Cluster.prototype.cluster = function() {
            if (this.resolution === void 0 || !this.source) {
              return;
            }
            var extent = createEmpty();
            var mapDistance = this.distance * this.resolution;
            var features = this.source.getFeatures();
            var clustered = {};
            for (var i = 0, ii = features.length; i < ii; i++) {
              var feature = features[i];
              if (!(Object(util["c"])(feature) in clustered)) {
                var geometry = this.geometryFunction(feature);
                if (geometry) {
                  var coordinates = geometry.getCoordinates();
                  createOrUpdateFromCoordinate(coordinates, extent);
                  extent_buffer(extent, mapDistance, extent);
                  var neighbors = this.source.getFeaturesInExtent(extent).filter(function(neighbor) {
                    var uid = Object(util["c"])(neighbor);
                    if (uid in clustered) {
                      return false;
                    }
                    clustered[uid] = true;
                    return true;
                  });
                  this.features.push(this.createCluster(neighbors, extent));
                }
              }
            }
          };
          Cluster.prototype.createCluster = function(features, extent) {
            var centroid = [0, 0];
            for (var i = features.length - 1; i >= 0; --i) {
              var geometry_1 = this.geometryFunction(features[i]);
              if (geometry_1) {
                coordinate_add(centroid, geometry_1.getCoordinates());
              } else {
                features.splice(i, 1);
              }
            }
            coordinate_scale(centroid, 1 / features.length);
            var searchCenter = extent_getCenter(extent);
            var ratio = this.interpolationRatio;
            var geometry = new geom_Point([
              centroid[0] * (1 - ratio) + searchCenter[0] * ratio,
              centroid[1] * (1 - ratio) + searchCenter[1] * ratio
            ]);
            if (this.createCustomCluster_) {
              return this.createCustomCluster_(geometry, features);
            } else {
              return new ol_Feature({
                geometry,
                features
              });
            }
          };
          return Cluster;
        }(source_Vector);
        var source_Cluster = Cluster_Cluster;
        if (window.ol && !ol.ext) {
          ol.ext = {};
        }
        var ol_ext_inherits = function(child, parent) {
          child.prototype = Object.create(parent.prototype);
          child.prototype.constructor = child;
        };
        if (window.ol) {
          if (!ol.inherits)
            ol.inherits = ol_ext_inherits;
        }
        if (window.NodeList && !NodeList.prototype.forEach) {
          NodeList.prototype.forEach = Array.prototype.forEach;
        }
        if (window.Element && !Element.prototype.remove) {
          Element.prototype.remove = function() {
            if (this.parentNode)
              this.parentNode.removeChild(this);
          };
        }
        var util_ext = ol_ext_inherits;
        function getVectorContext(event) {
          const frameState = event.frameState;
          const transform2 = multiply(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);
          return new Immediate(event.context, frameState.pixelRatio, frameState.extent, transform2, frameState.viewState.rotation);
        }
        var util_getVectorContext = getVectorContext;
        var ol_layer_AnimatedCluster = function(opt_options) {
          var options = opt_options || {};
          Vector.call(this, options);
          this.oldcluster = new source_Vector();
          this.clusters = [];
          this.animation = { start: false };
          this.set("animationDuration", typeof options.animationDuration == "number" ? options.animationDuration : 700);
          this.set("animationMethod", options.animationMethod || easeOut);
          this.getSource().on("change", this.saveCluster.bind(this));
          this.on(["precompose", "prerender"], this.animate.bind(this));
          this.on(["postcompose", "postrender"], this.postanimate.bind(this));
        };
        util_ext(ol_layer_AnimatedCluster, Vector);
        ol_layer_AnimatedCluster.prototype.saveCluster = function() {
          if (this.oldcluster) {
            this.oldcluster.clear();
            if (!this.get("animationDuration"))
              return;
            var features = this.getSource().getFeatures();
            if (features.length && features[0].get("features")) {
              this.oldcluster.addFeatures(this.clusters);
              this.clusters = features.slice(0);
              this.sourceChanged = true;
            }
          }
        };
        ol_layer_AnimatedCluster.prototype.getClusterForFeature = function(f, cluster) {
          for (var j = 0, c; c = cluster[j]; j++) {
            var features = c.get("features");
            if (features && features.length) {
              for (var k = 0, f2; f2 = features[k]; k++) {
                if (f === f2) {
                  return c;
                }
              }
            }
          }
          return false;
        };
        ol_layer_AnimatedCluster.prototype.stopAnimation = function() {
          this.animation.start = false;
          this.animation.cA = [];
          this.animation.cB = [];
        };
        ol_layer_AnimatedCluster.prototype.animate = function(e) {
          var duration = this.get("animationDuration");
          if (!duration)
            return;
          var resolution = e.frameState.viewState.resolution;
          var i, c0, a = this.animation;
          var time = e.frameState.time;
          if (a.resolution != resolution && this.sourceChanged) {
            var extent = e.frameState.extent;
            if (a.resolution < resolution) {
              extent = extent_buffer(extent, 100 * resolution);
              a.cA = this.oldcluster.getFeaturesInExtent(extent);
              a.cB = this.getSource().getFeaturesInExtent(extent);
              a.revers = false;
            } else {
              extent = extent_buffer(extent, 100 * resolution);
              a.cA = this.getSource().getFeaturesInExtent(extent);
              a.cB = this.oldcluster.getFeaturesInExtent(extent);
              a.revers = true;
            }
            a.clusters = [];
            for (i = 0, c0; c0 = a.cA[i]; i++) {
              var f = c0.get("features");
              if (f && f.length) {
                var c = this.getClusterForFeature(f[0], a.cB);
                if (c)
                  a.clusters.push({ f: c0, pt: c.getGeometry().getCoordinates() });
              }
            }
            a.resolution = resolution;
            this.sourceChanged = false;
            if (!a.clusters.length || a.clusters.length > 1e3) {
              this.stopAnimation();
              return;
            }
            time = a.start = new Date().getTime();
          }
          if (a.start) {
            var vectorContext = e.vectorContext || util_getVectorContext(e);
            var d = (time - a.start) / duration;
            if (d > 1) {
              this.stopAnimation();
              d = 1;
            }
            d = this.get("animationMethod")(d);
            var style = this.getStyle();
            var stylefn = typeof style == "function" ? style : style.length ? function() {
              return style;
            } : function() {
              return [style];
            };
            e.context.save();
            e.context.globalAlpha = this.getOpacity();
            for (i = 0, c; c = a.clusters[i]; i++) {
              var pt = c.f.getGeometry().getCoordinates();
              var dx = pt[0] - c.pt[0];
              var dy = pt[1] - c.pt[1];
              if (a.revers) {
                pt[0] = c.pt[0] + d * dx;
                pt[1] = c.pt[1] + d * dy;
              } else {
                pt[0] = pt[0] - d * dx;
                pt[1] = pt[1] - d * dy;
              }
              var st = stylefn(c.f, resolution, true);
              if (!st.length)
                st = [st];
              if (c.f.get("features").length === 1 && !dx && !dy) {
                f = c.f.get("features")[0];
              } else {
                var geo = new geom_Point(pt);
                f = new ol_Feature(geo);
              }
              for (var k = 0, s; s = st[k]; k++) {
                if (s.getText() && /\n/.test(s.getText().getText())) {
                  var offsetX = s.getText().getOffsetX();
                  var offsetY = s.getText().getOffsetY();
                  var rot = s.getText().getRotation() || 0;
                  var fontSize = Number((s.getText().getFont() || "10px").match(/\d+/)) * 1.2;
                  var str = s.getText().getText().split("\n");
                  var dl, nb = str.length - 1;
                  var s2 = s.clone();
                  str.forEach(function(t, i2) {
                    if (i2 == 1) {
                      s2.setImage();
                      s2.setFill();
                      s2.setStroke();
                    }
                    switch (s.getText().getTextBaseline()) {
                      case "alphabetic":
                      case "ideographic":
                      case "bottom": {
                        dl = nb;
                        break;
                      }
                      case "hanging":
                      case "top": {
                        dl = 0;
                        break;
                      }
                      default: {
                        dl = nb / 2;
                        break;
                      }
                    }
                    s2.getText().setOffsetX(offsetX - Math.sin(rot) * fontSize * (i2 - dl));
                    s2.getText().setOffsetY(offsetY + Math.cos(rot) * fontSize * (i2 - dl));
                    s2.getText().setText(t);
                    vectorContext.drawFeature(f, s2);
                  });
                } else {
                  vectorContext.drawFeature(f, s);
                }
              }
            }
            e.context.restore();
            e.frameState.animate = true;
            e.context.save();
            e.context.beginPath();
            e.context.rect(0, 0, 0, 0);
            e.context.clip();
            this.clip_ = true;
          }
          return;
        };
        ol_layer_AnimatedCluster.prototype.postanimate = function(e) {
          if (this.clip_) {
            e.context.restore();
            this.clip_ = false;
          }
        };
        var AnimatedCluster = ol_layer_AnimatedCluster;
        var AnimatedClusterLayervue_type_script_lang_js = {
          extends: layers_BaseLayer,
          name: "ol-animated-clusterlayer",
          setup: function setup(props) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var vectorLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var ac = new AnimatedCluster(_objectSpread2(_objectSpread2({}, properties), {}, {
                source: new source_Cluster({
                  distance: properties.distance,
                  geometryFunction: function geometryFunction(feature) {
                    return feature.getGeometry();
                  }
                })
              }));
              return ac;
            });
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return vectorLayer.value.getSource();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              vectorLayer.value.setProperties(properties);
              vectorLayer.value.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addLayer(vectorLayer.value);
              vectorLayer.value.changed();
              map.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeLayer(vectorLayer.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("vectorLayer", source);
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", vectorLayer);
            return {
              vectorLayer,
              map
            };
          },
          props: {
            animationDuration: {
              type: Number,
              default: 700
            },
            distance: {
              type: Number,
              default: 20
            },
            animationMethod: {
              type: Function,
              default: easeOut
            },
            updateWhileAnimating: {
              type: Boolean,
              default: false
            },
            updateWhileInteracting: {
              type: Boolean,
              default: false
            }
          }
        };
        const AnimatedClusterLayer_exports_ = exportHelper_default()(AnimatedClusterLayervue_type_script_lang_js, [["render", AnimatedClusterLayervue_type_template_id_2797d6d8_lang_true_render]]);
        var AnimatedClusterLayer = AnimatedClusterLayer_exports_;
        function layers_install(app) {
          if (layers_install.installed) {
            return;
          }
          layers_install.installed = true;
          app.component(layers_TileLayer.name, layers_TileLayer);
          app.component(layers_ImageLayer.name, layers_ImageLayer);
          app.component(layers_VectorLayer.name, layers_VectorLayer);
          app.component(AnimatedClusterLayer.name, AnimatedClusterLayer);
        }
        var components_layers = layers_install;
        var SourceXYZvue_type_template_id_12bc2b74_hoisted_1 = {
          key: 0
        };
        function SourceXYZvue_type_template_id_12bc2b74_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ol_Tile_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Tile_Tile = function(_super) {
          ol_Tile_extends(Tile, _super);
          function Tile(tileCoord, state, opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.tileCoord = tileCoord;
            _this.state = state;
            _this.interimTile = null;
            _this.key = "";
            _this.transition_ = options.transition === void 0 ? 250 : options.transition;
            _this.transitionStarts_ = {};
            _this.interpolate = !!options.interpolate;
            return _this;
          }
          Tile.prototype.changed = function() {
            this.dispatchEvent(EventType["a"].CHANGE);
          };
          Tile.prototype.release = function() {
          };
          Tile.prototype.getKey = function() {
            return this.key + "/" + this.tileCoord;
          };
          Tile.prototype.getInterimTile = function() {
            if (!this.interimTile) {
              return this;
            }
            var tile = this.interimTile;
            do {
              if (tile.getState() == TileState.LOADED) {
                this.transition_ = 0;
                return tile;
              }
              tile = tile.interimTile;
            } while (tile);
            return this;
          };
          Tile.prototype.refreshInterimChain = function() {
            if (!this.interimTile) {
              return;
            }
            var tile = this.interimTile;
            var prev = this;
            do {
              if (tile.getState() == TileState.LOADED) {
                tile.interimTile = null;
                break;
              } else if (tile.getState() == TileState.LOADING) {
                prev = tile;
              } else if (tile.getState() == TileState.IDLE) {
                prev.interimTile = tile.interimTile;
              } else {
                prev = tile;
              }
              tile = prev.interimTile;
            } while (tile);
          };
          Tile.prototype.getTileCoord = function() {
            return this.tileCoord;
          };
          Tile.prototype.getState = function() {
            return this.state;
          };
          Tile.prototype.setState = function(state) {
            if (this.state !== TileState.ERROR && this.state > state) {
              throw new Error("Tile load sequence violation");
            }
            this.state = state;
            this.changed();
          };
          Tile.prototype.load = function() {
            Object(util["b"])();
          };
          Tile.prototype.getAlpha = function(id, time) {
            if (!this.transition_) {
              return 1;
            }
            var start = this.transitionStarts_[id];
            if (!start) {
              start = time;
              this.transitionStarts_[id] = start;
            } else if (start === -1) {
              return 1;
            }
            var delta = time - start + 1e3 / 60;
            if (delta >= this.transition_) {
              return 1;
            }
            return easeIn(delta / this.transition_);
          };
          Tile.prototype.inTransition = function(id) {
            if (!this.transition_) {
              return false;
            }
            return this.transitionStarts_[id] !== -1;
          };
          Tile.prototype.endTransition = function(id) {
            if (this.transition_) {
              this.transitionStarts_[id] = -1;
            }
          };
          return Tile;
        }(Target["a"]);
        var ol_Tile = Tile_Tile;
        var ImageTile_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ImageTile_ImageTile = function(_super) {
          ImageTile_extends(ImageTile, _super);
          function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
            var _this = _super.call(this, tileCoord, state, opt_options) || this;
            _this.crossOrigin_ = crossOrigin;
            _this.src_ = src;
            _this.key = src;
            _this.image_ = new Image();
            if (crossOrigin !== null) {
              _this.image_.crossOrigin = crossOrigin;
            }
            _this.unlisten_ = null;
            _this.tileLoadFunction_ = tileLoadFunction;
            return _this;
          }
          ImageTile.prototype.getImage = function() {
            return this.image_;
          };
          ImageTile.prototype.setImage = function(element) {
            this.image_ = element;
            this.state = TileState.LOADED;
            this.unlistenImage_();
            this.changed();
          };
          ImageTile.prototype.handleImageError_ = function() {
            this.state = TileState.ERROR;
            this.unlistenImage_();
            this.image_ = getBlankImage();
            this.changed();
          };
          ImageTile.prototype.handleImageLoad_ = function() {
            var image = this.image_;
            if (image.naturalWidth && image.naturalHeight) {
              this.state = TileState.LOADED;
            } else {
              this.state = TileState.EMPTY;
            }
            this.unlistenImage_();
            this.changed();
          };
          ImageTile.prototype.load = function() {
            if (this.state == TileState.ERROR) {
              this.state = TileState.IDLE;
              this.image_ = new Image();
              if (this.crossOrigin_ !== null) {
                this.image_.crossOrigin = this.crossOrigin_;
              }
            }
            if (this.state == TileState.IDLE) {
              this.state = TileState.LOADING;
              this.changed();
              this.tileLoadFunction_(this, this.src_);
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
            }
          };
          ImageTile.prototype.unlistenImage_ = function() {
            if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
            }
          };
          return ImageTile;
        }(ol_Tile);
        function getBlankImage() {
          var ctx = Object(dom["a"])(1, 1);
          ctx.fillStyle = "rgba(0,0,0,0)";
          ctx.fillRect(0, 0, 1, 1);
          return ctx.canvas;
        }
        var ol_ImageTile = ImageTile_ImageTile;
        var MAX_SUBDIVISION = 10;
        var MAX_TRIANGLE_WIDTH = 0.25;
        var Triangulation_Triangulation = function() {
          function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
            this.sourceProj_ = sourceProj;
            this.targetProj_ = targetProj;
            var transformInvCache = {};
            var transformInv = getTransform(this.targetProj_, this.sourceProj_);
            this.transformInv_ = function(c) {
              var key = c[0] + "/" + c[1];
              if (!transformInvCache[key]) {
                transformInvCache[key] = transformInv(c);
              }
              return transformInvCache[key];
            };
            this.maxSourceExtent_ = maxSourceExtent;
            this.errorThresholdSquared_ = errorThreshold * errorThreshold;
            this.triangles_ = [];
            this.wrapsXInSource_ = false;
            this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());
            this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
            this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
            var destinationTopLeft = getTopLeft(targetExtent);
            var destinationTopRight = getTopRight(targetExtent);
            var destinationBottomRight = getBottomRight(targetExtent);
            var destinationBottomLeft = getBottomLeft(targetExtent);
            var sourceTopLeft = this.transformInv_(destinationTopLeft);
            var sourceTopRight = this.transformInv_(destinationTopRight);
            var sourceBottomRight = this.transformInv_(destinationBottomRight);
            var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
            var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil(log2(getArea(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);
            this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
            if (this.wrapsXInSource_) {
              var leftBound_1 = Infinity;
              this.triangles_.forEach(function(triangle, i, arr) {
                leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
              });
              this.triangles_.forEach(function(triangle) {
                if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {
                  var newTriangle = [
                    [triangle.source[0][0], triangle.source[0][1]],
                    [triangle.source[1][0], triangle.source[1][1]],
                    [triangle.source[2][0], triangle.source[2][1]]
                  ];
                  if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                    newTriangle[0][0] -= this.sourceWorldWidth_;
                  }
                  if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                    newTriangle[1][0] -= this.sourceWorldWidth_;
                  }
                  if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                    newTriangle[2][0] -= this.sourceWorldWidth_;
                  }
                  var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                  var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                  if (maxX - minX < this.sourceWorldWidth_ / 2) {
                    triangle.source = newTriangle;
                  }
                }
              }.bind(this));
            }
            transformInvCache = {};
          }
          Triangulation.prototype.addTriangle_ = function(a, b, c, aSrc, bSrc, cSrc) {
            this.triangles_.push({
              source: [aSrc, bSrc, cSrc],
              target: [a, b, c]
            });
          };
          Triangulation.prototype.addQuad_ = function(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
            var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
            var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
            var sourceWorldWidth = this.sourceWorldWidth_;
            var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
            var needsSubdivision = false;
            if (maxSubdivision > 0) {
              if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
                var targetQuadExtent = boundingExtent([a, b, c, d]);
                var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
                needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
              }
              if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
                needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
              }
            }
            if (!needsSubdivision && this.maxSourceExtent_) {
              if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
                if (!extent_intersects(sourceQuadExtent, this.maxSourceExtent_)) {
                  return;
                }
              }
            }
            var isNotFinite = 0;
            if (!needsSubdivision) {
              if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
                if (maxSubdivision > 0) {
                  needsSubdivision = true;
                } else {
                  isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
                  if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
                    return;
                  }
                }
              }
            }
            if (maxSubdivision > 0) {
              if (!needsSubdivision) {
                var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
                var centerSrc = this.transformInv_(center);
                var dx = void 0;
                if (wrapsX) {
                  var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
                  dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
                } else {
                  dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
                }
                var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
                var centerSrcErrorSquared = dx * dx + dy * dy;
                needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
              }
              if (needsSubdivision) {
                if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
                  var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
                  var bcSrc = this.transformInv_(bc);
                  var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
                  var daSrc = this.transformInv_(da);
                  this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
                  this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
                } else {
                  var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
                  var abSrc = this.transformInv_(ab);
                  var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
                  var cdSrc = this.transformInv_(cd);
                  this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
                  this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
                }
                return;
              }
            }
            if (wrapsX) {
              if (!this.canWrapXInSource_) {
                return;
              }
              this.wrapsXInSource_ = true;
            }
            if ((isNotFinite & 11) == 0) {
              this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
            }
            if ((isNotFinite & 14) == 0) {
              this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
            }
            if (isNotFinite) {
              if ((isNotFinite & 13) == 0) {
                this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
              }
              if ((isNotFinite & 7) == 0) {
                this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
              }
            }
          };
          Triangulation.prototype.calculateSourceExtent = function() {
            var extent = createEmpty();
            this.triangles_.forEach(function(triangle, i, arr) {
              var src = triangle.source;
              extendCoordinate(extent, src[0]);
              extendCoordinate(extent, src[1]);
              extendCoordinate(extent, src[2]);
            });
            return extent;
          };
          Triangulation.prototype.getTriangles = function() {
            return this.triangles_;
          };
          return Triangulation;
        }();
        var reproj_Triangulation = Triangulation_Triangulation;
        var brokenDiagonalRendering_;
        function drawTestTriangle(ctx, u1, v1, u2, v2) {
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(u1, v1);
          ctx.lineTo(u2, v2);
          ctx.closePath();
          ctx.save();
          ctx.clip();
          ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
          ctx.restore();
        }
        function verifyBrokenDiagonalRendering(data, offset) {
          return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
        }
        function isBrokenDiagonalRendering() {
          if (brokenDiagonalRendering_ === void 0) {
            var ctx = document.createElement("canvas").getContext("2d");
            ctx.globalCompositeOperation = "lighter";
            ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
            drawTestTriangle(ctx, 4, 5, 4, 0);
            drawTestTriangle(ctx, 4, 5, 0, 5);
            var data = ctx.getImageData(0, 0, 3, 3).data;
            brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
          }
          return brokenDiagonalRendering_;
        }
        function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
          var sourceCenter = proj_transform(targetCenter, targetProj, sourceProj);
          var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);
          var targetMetersPerUnit = targetProj.getMetersPerUnit();
          if (targetMetersPerUnit !== void 0) {
            sourceResolution *= targetMetersPerUnit;
          }
          var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
          if (sourceMetersPerUnit !== void 0) {
            sourceResolution /= sourceMetersPerUnit;
          }
          var sourceExtent = sourceProj.getExtent();
          if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
            var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
            if (isFinite(compensationFactor) && compensationFactor > 0) {
              sourceResolution /= compensationFactor;
            }
          }
          return sourceResolution;
        }
        function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
          var targetCenter = extent_getCenter(targetExtent);
          var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
          if (!isFinite(sourceResolution) || sourceResolution <= 0) {
            forEachCorner(targetExtent, function(corner) {
              sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
              return isFinite(sourceResolution) && sourceResolution > 0;
            });
          }
          return sourceResolution;
        }
        function reproj_render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_interpolate) {
          var context = Object(dom["a"])(Math.round(pixelRatio * width), Math.round(pixelRatio * height));
          if (!opt_interpolate) {
            Object(ol_obj["a"])(context, IMAGE_SMOOTHING_DISABLED);
          }
          if (sources.length === 0) {
            return context.canvas;
          }
          context.scale(pixelRatio, pixelRatio);
          function pixelRound(value) {
            return Math.round(value * pixelRatio) / pixelRatio;
          }
          context.globalCompositeOperation = "lighter";
          var sourceDataExtent = createEmpty();
          sources.forEach(function(src, i, arr) {
            extend2(sourceDataExtent, src.extent);
          });
          var canvasWidthInUnits = getWidth(sourceDataExtent);
          var canvasHeightInUnits = getHeight(sourceDataExtent);
          var stitchContext = Object(dom["a"])(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));
          if (!opt_interpolate) {
            Object(ol_obj["a"])(stitchContext, IMAGE_SMOOTHING_DISABLED);
          }
          var stitchScale = pixelRatio / sourceResolution;
          sources.forEach(function(src, i, arr) {
            var xPos = src.extent[0] - sourceDataExtent[0];
            var yPos = -(src.extent[3] - sourceDataExtent[3]);
            var srcWidth = getWidth(src.extent);
            var srcHeight = getHeight(src.extent);
            if (src.image.width > 0 && src.image.height > 0) {
              stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
            }
          });
          var targetTopLeft = getTopLeft(targetExtent);
          triangulation.getTriangles().forEach(function(triangle, i, arr) {
            var source = triangle.source;
            var target = triangle.target;
            var x0 = source[0][0], y0 = source[0][1];
            var x1 = source[1][0], y1 = source[1][1];
            var x2 = source[2][0], y2 = source[2][1];
            var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
            var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
            var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
            var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
            var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
            var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
            var sourceNumericalShiftX = x0;
            var sourceNumericalShiftY = y0;
            x0 = 0;
            y0 = 0;
            x1 -= sourceNumericalShiftX;
            y1 -= sourceNumericalShiftY;
            x2 -= sourceNumericalShiftX;
            y2 -= sourceNumericalShiftY;
            var augmentedMatrix = [
              [x1, y1, 0, 0, u1 - u0],
              [x2, y2, 0, 0, u2 - u0],
              [0, 0, x1, y1, v1 - v0],
              [0, 0, x2, y2, v2 - v0]
            ];
            var affineCoefs = solveLinearSystem(augmentedMatrix);
            if (!affineCoefs) {
              return;
            }
            context.save();
            context.beginPath();
            if (isBrokenDiagonalRendering() || !opt_interpolate) {
              context.moveTo(u1, v1);
              var steps = 4;
              var ud = u0 - u1;
              var vd = v0 - v1;
              for (var step = 0; step < steps; step++) {
                context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));
                if (step != steps - 1) {
                  context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
                }
              }
              context.lineTo(u2, v2);
            } else {
              context.moveTo(u1, v1);
              context.lineTo(u0, v0);
              context.lineTo(u2, v2);
            }
            context.clip();
            context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
            context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
            context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
            context.drawImage(stitchContext.canvas, 0, 0);
            context.restore();
          });
          if (opt_renderEdges) {
            context.save();
            context.globalCompositeOperation = "source-over";
            context.strokeStyle = "black";
            context.lineWidth = 1;
            triangulation.getTriangles().forEach(function(triangle, i, arr) {
              var target = triangle.target;
              var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
              var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
              var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
              var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
              var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
              var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
              context.beginPath();
              context.moveTo(u1, v1);
              context.lineTo(u0, v0);
              context.lineTo(u2, v2);
              context.closePath();
              context.stroke();
            });
            context.restore();
          }
          return context.canvas;
        }
        var reproj_Tile_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Tile_ReprojTile = function(_super) {
          reproj_Tile_extends(ReprojTile, _super);
          function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {
            var _this = _super.call(this, tileCoord, TileState.IDLE, { interpolate: !!opt_interpolate }) || this;
            _this.renderEdges_ = opt_renderEdges !== void 0 ? opt_renderEdges : false;
            _this.pixelRatio_ = pixelRatio;
            _this.gutter_ = gutter;
            _this.canvas_ = null;
            _this.sourceTileGrid_ = sourceTileGrid;
            _this.targetTileGrid_ = targetTileGrid;
            _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
            _this.sourceTiles_ = [];
            _this.sourcesListenerKeys_ = null;
            _this.sourceZ_ = 0;
            var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);
            var maxTargetExtent = _this.targetTileGrid_.getExtent();
            var maxSourceExtent = _this.sourceTileGrid_.getExtent();
            var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
            if (getArea(limitedTargetExtent) === 0) {
              _this.state = TileState.EMPTY;
              return _this;
            }
            var sourceProjExtent = sourceProj.getExtent();
            if (sourceProjExtent) {
              if (!maxSourceExtent) {
                maxSourceExtent = sourceProjExtent;
              } else {
                maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
              }
            }
            var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
            var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);
            if (!isFinite(sourceResolution) || sourceResolution <= 0) {
              _this.state = TileState.EMPTY;
              return _this;
            }
            var errorThresholdInPixels = opt_errorThreshold !== void 0 ? opt_errorThreshold : ERROR_THRESHOLD;
            _this.triangulation_ = new reproj_Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
            if (_this.triangulation_.getTriangles().length === 0) {
              _this.state = TileState.EMPTY;
              return _this;
            }
            _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
            var sourceExtent = _this.triangulation_.calculateSourceExtent();
            if (maxSourceExtent) {
              if (sourceProj.canWrapX()) {
                sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
                sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
              } else {
                sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
              }
            }
            if (!getArea(sourceExtent)) {
              _this.state = TileState.EMPTY;
            } else {
              var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);
              for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
                for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
                  var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);
                  if (tile) {
                    _this.sourceTiles_.push(tile);
                  }
                }
              }
              if (_this.sourceTiles_.length === 0) {
                _this.state = TileState.EMPTY;
              }
            }
            return _this;
          }
          ReprojTile.prototype.getImage = function() {
            return this.canvas_;
          };
          ReprojTile.prototype.reproject_ = function() {
            var sources = [];
            this.sourceTiles_.forEach(function(tile, i, arr) {
              if (tile && tile.getState() == TileState.LOADED) {
                sources.push({
                  extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
                  image: tile.getImage()
                });
              }
            }.bind(this));
            this.sourceTiles_.length = 0;
            if (sources.length === 0) {
              this.state = TileState.ERROR;
            } else {
              var z = this.wrappedTileCoord_[0];
              var size = this.targetTileGrid_.getTileSize(z);
              var width = typeof size === "number" ? size : size[0];
              var height = typeof size === "number" ? size : size[1];
              var targetResolution = this.targetTileGrid_.getResolution(z);
              var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
              var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
              this.canvas_ = reproj_render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
              this.state = TileState.LOADED;
            }
            this.changed();
          };
          ReprojTile.prototype.load = function() {
            if (this.state == TileState.IDLE) {
              this.state = TileState.LOADING;
              this.changed();
              var leftToLoad_1 = 0;
              this.sourcesListenerKeys_ = [];
              this.sourceTiles_.forEach(function(tile, i, arr) {
                var state = tile.getState();
                if (state == TileState.IDLE || state == TileState.LOADING) {
                  leftToLoad_1++;
                  var sourceListenKey_1 = Object(events["a"])(tile, EventType["a"].CHANGE, function(e) {
                    var state2 = tile.getState();
                    if (state2 == TileState.LOADED || state2 == TileState.ERROR || state2 == TileState.EMPTY) {
                      Object(events["c"])(sourceListenKey_1);
                      leftToLoad_1--;
                      if (leftToLoad_1 === 0) {
                        this.unlistenSources_();
                        this.reproject_();
                      }
                    }
                  }, this);
                  this.sourcesListenerKeys_.push(sourceListenKey_1);
                }
              }.bind(this));
              if (leftToLoad_1 === 0) {
                setTimeout(this.reproject_.bind(this), 0);
              } else {
                this.sourceTiles_.forEach(function(tile, i, arr) {
                  var state = tile.getState();
                  if (state == TileState.IDLE) {
                    tile.load();
                  }
                });
              }
            }
          };
          ReprojTile.prototype.unlistenSources_ = function() {
            this.sourcesListenerKeys_.forEach(events["c"]);
            this.sourcesListenerKeys_ = null;
          };
          return ReprojTile;
        }(ol_Tile);
        var reproj_Tile = Tile_ReprojTile;
        var LRUCache_LRUCache = function() {
          function LRUCache(opt_highWaterMark) {
            this.highWaterMark = opt_highWaterMark !== void 0 ? opt_highWaterMark : 2048;
            this.count_ = 0;
            this.entries_ = {};
            this.oldest_ = null;
            this.newest_ = null;
          }
          LRUCache.prototype.canExpireCache = function() {
            return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
          };
          LRUCache.prototype.clear = function() {
            this.count_ = 0;
            this.entries_ = {};
            this.oldest_ = null;
            this.newest_ = null;
          };
          LRUCache.prototype.containsKey = function(key) {
            return this.entries_.hasOwnProperty(key);
          };
          LRUCache.prototype.forEach = function(f) {
            var entry = this.oldest_;
            while (entry) {
              f(entry.value_, entry.key_, this);
              entry = entry.newer;
            }
          };
          LRUCache.prototype.get = function(key, opt_options) {
            var entry = this.entries_[key];
            assert2(entry !== void 0, 15);
            if (entry === this.newest_) {
              return entry.value_;
            } else if (entry === this.oldest_) {
              this.oldest_ = this.oldest_.newer;
              this.oldest_.older = null;
            } else {
              entry.newer.older = entry.older;
              entry.older.newer = entry.newer;
            }
            entry.newer = null;
            entry.older = this.newest_;
            this.newest_.newer = entry;
            this.newest_ = entry;
            return entry.value_;
          };
          LRUCache.prototype.remove = function(key) {
            var entry = this.entries_[key];
            assert2(entry !== void 0, 15);
            if (entry === this.newest_) {
              this.newest_ = entry.older;
              if (this.newest_) {
                this.newest_.newer = null;
              }
            } else if (entry === this.oldest_) {
              this.oldest_ = entry.newer;
              if (this.oldest_) {
                this.oldest_.older = null;
              }
            } else {
              entry.newer.older = entry.older;
              entry.older.newer = entry.newer;
            }
            delete this.entries_[key];
            --this.count_;
            return entry.value_;
          };
          LRUCache.prototype.getCount = function() {
            return this.count_;
          };
          LRUCache.prototype.getKeys = function() {
            var keys = new Array(this.count_);
            var i = 0;
            var entry;
            for (entry = this.newest_; entry; entry = entry.older) {
              keys[i++] = entry.key_;
            }
            return keys;
          };
          LRUCache.prototype.getValues = function() {
            var values = new Array(this.count_);
            var i = 0;
            var entry;
            for (entry = this.newest_; entry; entry = entry.older) {
              values[i++] = entry.value_;
            }
            return values;
          };
          LRUCache.prototype.peekLast = function() {
            return this.oldest_.value_;
          };
          LRUCache.prototype.peekLastKey = function() {
            return this.oldest_.key_;
          };
          LRUCache.prototype.peekFirstKey = function() {
            return this.newest_.key_;
          };
          LRUCache.prototype.pop = function() {
            var entry = this.oldest_;
            delete this.entries_[entry.key_];
            if (entry.newer) {
              entry.newer.older = null;
            }
            this.oldest_ = entry.newer;
            if (!this.oldest_) {
              this.newest_ = null;
            }
            --this.count_;
            return entry.value_;
          };
          LRUCache.prototype.replace = function(key, value) {
            this.get(key);
            this.entries_[key].value_ = value;
          };
          LRUCache.prototype.set = function(key, value) {
            assert2(!(key in this.entries_), 16);
            var entry = {
              key_: key,
              newer: null,
              older: this.newest_,
              value_: value
            };
            if (!this.newest_) {
              this.oldest_ = entry;
            } else {
              this.newest_.newer = entry;
            }
            this.newest_ = entry;
            this.entries_[key] = entry;
            ++this.count_;
          };
          LRUCache.prototype.setSize = function(size) {
            this.highWaterMark = size;
          };
          return LRUCache;
        }();
        var structs_LRUCache = LRUCache_LRUCache;
        function tilecoord_createOrUpdate(z, x, y, opt_tileCoord) {
          if (opt_tileCoord !== void 0) {
            opt_tileCoord[0] = z;
            opt_tileCoord[1] = x;
            opt_tileCoord[2] = y;
            return opt_tileCoord;
          } else {
            return [z, x, y];
          }
        }
        function getKeyZXY(z, x, y) {
          return z + "/" + x + "/" + y;
        }
        function tilecoord_getKey(tileCoord) {
          return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
        }
        function getCacheKeyForTileKey(tileKey) {
          var _a = tileKey.substring(tileKey.lastIndexOf("/") + 1, tileKey.length).split(",").map(Number), z = _a[0], x = _a[1], y = _a[2];
          return getKeyZXY(z, x, y);
        }
        function fromKey(key) {
          return key.split("/").map(Number);
        }
        function hash(tileCoord) {
          return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
        }
        function withinExtentAndZ(tileCoord, tileGrid) {
          var z = tileCoord[0];
          var x = tileCoord[1];
          var y = tileCoord[2];
          if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
            return false;
          }
          var tileRange = tileGrid.getFullTileRange(z);
          if (!tileRange) {
            return true;
          } else {
            return tileRange.containsXY(x, y);
          }
        }
        var TileCache_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var TileCache_TileCache = function(_super) {
          TileCache_extends(TileCache, _super);
          function TileCache() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          TileCache.prototype.expireCache = function(usedTiles) {
            while (this.canExpireCache()) {
              var tile = this.peekLast();
              if (tile.getKey() in usedTiles) {
                break;
              } else {
                this.pop().release();
              }
            }
          };
          TileCache.prototype.pruneExceptNewestZ = function() {
            if (this.getCount() === 0) {
              return;
            }
            var key = this.peekFirstKey();
            var tileCoord = fromKey(key);
            var z = tileCoord[0];
            this.forEach(function(tile) {
              if (tile.tileCoord[0] !== z) {
                this.remove(tilecoord_getKey(tile.tileCoord));
                tile.release();
              }
            }.bind(this));
          };
          return TileCache;
        }(structs_LRUCache);
        var ol_TileCache = TileCache_TileCache;
        var TileEventType = {
          TILELOADSTART: "tileloadstart",
          TILELOADEND: "tileloadend",
          TILELOADERROR: "tileloaderror"
        };
        var tmpTileCoord = [0, 0, 0];
        var DECIMALS = 5;
        var TileGrid_TileGrid = function() {
          function TileGrid(options) {
            this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
            this.resolutions_ = options.resolutions;
            assert2(Object(ol_array["g"])(this.resolutions_, function(a, b) {
              return b - a;
            }, true), 17);
            var zoomFactor;
            if (!options.origins) {
              for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
                if (!zoomFactor) {
                  zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
                } else {
                  if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
                    zoomFactor = void 0;
                    break;
                  }
                }
              }
            }
            this.zoomFactor_ = zoomFactor;
            this.maxZoom = this.resolutions_.length - 1;
            this.origin_ = options.origin !== void 0 ? options.origin : null;
            this.origins_ = null;
            if (options.origins !== void 0) {
              this.origins_ = options.origins;
              assert2(this.origins_.length == this.resolutions_.length, 20);
            }
            var extent = options.extent;
            if (extent !== void 0 && !this.origin_ && !this.origins_) {
              this.origin_ = getTopLeft(extent);
            }
            assert2(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18);
            this.tileSizes_ = null;
            if (options.tileSizes !== void 0) {
              this.tileSizes_ = options.tileSizes;
              assert2(this.tileSizes_.length == this.resolutions_.length, 19);
            }
            this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
            assert2(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22);
            this.extent_ = extent !== void 0 ? extent : null;
            this.fullTileRanges_ = null;
            this.tmpSize_ = [0, 0];
            this.tmpExtent_ = [0, 0, 0, 0];
            if (options.sizes !== void 0) {
              this.fullTileRanges_ = options.sizes.map(function(size, z) {
                var tileRange = new ol_TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
                if (extent) {
                  var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
                  tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
                  tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
                  tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
                  tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
                }
                return tileRange;
              }, this);
            } else if (extent) {
              this.calculateTileRanges_(extent);
            }
          }
          TileGrid.prototype.forEachTileCoord = function(extent, zoom, callback) {
            var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
            for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
              for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
                callback([zoom, i, j]);
              }
            }
          };
          TileGrid.prototype.forEachTileCoordParentTileRange = function(tileCoord, callback, opt_tileRange, opt_extent) {
            var tileRange, x, y;
            var tileCoordExtent = null;
            var z = tileCoord[0] - 1;
            if (this.zoomFactor_ === 2) {
              x = tileCoord[1];
              y = tileCoord[2];
            } else {
              tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
            }
            while (z >= this.minZoom) {
              if (this.zoomFactor_ === 2) {
                x = Math.floor(x / 2);
                y = Math.floor(y / 2);
                tileRange = TileRange_createOrUpdate(x, x, y, y, opt_tileRange);
              } else {
                tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
              }
              if (callback(z, tileRange)) {
                return true;
              }
              --z;
            }
            return false;
          };
          TileGrid.prototype.getExtent = function() {
            return this.extent_;
          };
          TileGrid.prototype.getMaxZoom = function() {
            return this.maxZoom;
          };
          TileGrid.prototype.getMinZoom = function() {
            return this.minZoom;
          };
          TileGrid.prototype.getOrigin = function(z) {
            if (this.origin_) {
              return this.origin_;
            } else {
              return this.origins_[z];
            }
          };
          TileGrid.prototype.getResolution = function(z) {
            return this.resolutions_[z];
          };
          TileGrid.prototype.getResolutions = function() {
            return this.resolutions_;
          };
          TileGrid.prototype.getTileCoordChildTileRange = function(tileCoord, opt_tileRange, opt_extent) {
            if (tileCoord[0] < this.maxZoom) {
              if (this.zoomFactor_ === 2) {
                var minX = tileCoord[1] * 2;
                var minY = tileCoord[2] * 2;
                return TileRange_createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);
              }
              var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);
              return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
            }
            return null;
          };
          TileGrid.prototype.getTileRangeForTileCoordAndZ = function(tileCoord, z, opt_tileRange) {
            if (z > this.maxZoom || z < this.minZoom) {
              return null;
            }
            var tileCoordZ = tileCoord[0];
            var tileCoordX = tileCoord[1];
            var tileCoordY = tileCoord[2];
            if (z === tileCoordZ) {
              return TileRange_createOrUpdate(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);
            }
            if (this.zoomFactor_) {
              var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
              var minX = Math.floor(tileCoordX * factor);
              var minY = Math.floor(tileCoordY * factor);
              if (z < tileCoordZ) {
                return TileRange_createOrUpdate(minX, minX, minY, minY, opt_tileRange);
              }
              var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
              var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
              return TileRange_createOrUpdate(minX, maxX, minY, maxY, opt_tileRange);
            }
            var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
          };
          TileGrid.prototype.getTileRangeExtent = function(z, tileRange, opt_extent) {
            var origin = this.getOrigin(z);
            var resolution = this.getResolution(z);
            var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
            var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
            var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
            var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
            var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
            return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
          };
          TileGrid.prototype.getTileRangeForExtentAndZ = function(extent, z, opt_tileRange) {
            var tileCoord = tmpTileCoord;
            this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
            var minX = tileCoord[1];
            var minY = tileCoord[2];
            this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
            return TileRange_createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
          };
          TileGrid.prototype.getTileCoordCenter = function(tileCoord) {
            var origin = this.getOrigin(tileCoord[0]);
            var resolution = this.getResolution(tileCoord[0]);
            var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
            return [
              origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
              origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
            ];
          };
          TileGrid.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {
            var origin = this.getOrigin(tileCoord[0]);
            var resolution = this.getResolution(tileCoord[0]);
            var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
            var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
            var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
            var maxX = minX + tileSize[0] * resolution;
            var maxY = minY + tileSize[1] * resolution;
            return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
          };
          TileGrid.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {
            return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
          };
          TileGrid.prototype.getTileCoordForXYAndResolution_ = function(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
            var z = this.getZForResolution(resolution);
            var scale = resolution / this.getResolution(z);
            var origin = this.getOrigin(z);
            var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
            var tileCoordX = scale * (x - origin[0]) / resolution / tileSize[0];
            var tileCoordY = scale * (origin[1] - y) / resolution / tileSize[1];
            if (reverseIntersectionPolicy) {
              tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
              tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
            } else {
              tileCoordX = floor(tileCoordX, DECIMALS);
              tileCoordY = floor(tileCoordY, DECIMALS);
            }
            return tilecoord_createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
          };
          TileGrid.prototype.getTileCoordForXYAndZ_ = function(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
            var origin = this.getOrigin(z);
            var resolution = this.getResolution(z);
            var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
            var tileCoordX = (x - origin[0]) / resolution / tileSize[0];
            var tileCoordY = (origin[1] - y) / resolution / tileSize[1];
            if (reverseIntersectionPolicy) {
              tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
              tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
            } else {
              tileCoordX = floor(tileCoordX, DECIMALS);
              tileCoordY = floor(tileCoordY, DECIMALS);
            }
            return tilecoord_createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
          };
          TileGrid.prototype.getTileCoordForCoordAndZ = function(coordinate, z, opt_tileCoord) {
            return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
          };
          TileGrid.prototype.getTileCoordResolution = function(tileCoord) {
            return this.resolutions_[tileCoord[0]];
          };
          TileGrid.prototype.getTileSize = function(z) {
            if (this.tileSize_) {
              return this.tileSize_;
            } else {
              return this.tileSizes_[z];
            }
          };
          TileGrid.prototype.getFullTileRange = function(z) {
            if (!this.fullTileRanges_) {
              return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
            } else {
              return this.fullTileRanges_[z];
            }
          };
          TileGrid.prototype.getZForResolution = function(resolution, opt_direction) {
            var z = Object(ol_array["h"])(this.resolutions_, resolution, opt_direction || 0);
            return clamp(z, this.minZoom, this.maxZoom);
          };
          TileGrid.prototype.calculateTileRanges_ = function(extent) {
            var length = this.resolutions_.length;
            var fullTileRanges = new Array(length);
            for (var z = this.minZoom; z < length; ++z) {
              fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
            }
            this.fullTileRanges_ = fullTileRanges;
          };
          return TileGrid;
        }();
        var tilegrid_TileGrid = TileGrid_TileGrid;
        function getForProjection(projection) {
          var tileGrid = projection.getDefaultTileGrid();
          if (!tileGrid) {
            tileGrid = createForProjection(projection);
            projection.setDefaultTileGrid(tileGrid);
          }
          return tileGrid;
        }
        function tilegrid_wrapX(tileGrid, tileCoord, projection) {
          var z = tileCoord[0];
          var center = tileGrid.getTileCoordCenter(tileCoord);
          var projectionExtent = extentFromProjection(projection);
          if (!containsCoordinate(projectionExtent, center)) {
            var worldWidth = getWidth(projectionExtent);
            var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
            center[0] += worldWidth * worldsAway;
            return tileGrid.getTileCoordForCoordAndZ(center, z);
          } else {
            return tileCoord;
          }
        }
        function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
          var corner = opt_corner !== void 0 ? opt_corner : Corner.TOP_LEFT;
          var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
          return new tilegrid_TileGrid({
            extent,
            origin: getCorner(extent, corner),
            resolutions,
            tileSize: opt_tileSize
          });
        }
        function createXYZ(opt_options) {
          var xyzOptions = opt_options || {};
          var extent = xyzOptions.extent || proj_get("EPSG:3857").getExtent();
          var gridOptions = {
            extent,
            minZoom: xyzOptions.minZoom,
            tileSize: xyzOptions.tileSize,
            resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
          };
          return new tilegrid_TileGrid(gridOptions);
        }
        function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {
          var maxZoom = opt_maxZoom !== void 0 ? opt_maxZoom : DEFAULT_MAX_ZOOM;
          var height = getHeight(extent);
          var width = getWidth(extent);
          var tileSize = toSize(opt_tileSize !== void 0 ? opt_tileSize : DEFAULT_TILE_SIZE);
          var maxResolution = opt_maxResolution > 0 ? opt_maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
          var length = maxZoom + 1;
          var resolutions = new Array(length);
          for (var z = 0; z < length; ++z) {
            resolutions[z] = maxResolution / Math.pow(2, z);
          }
          return resolutions;
        }
        function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
          var extent = extentFromProjection(projection);
          return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
        }
        function extentFromProjection(projection) {
          projection = proj_get(projection);
          var extent = projection.getExtent();
          if (!extent) {
            var half = 180 * METERS_PER_UNIT[proj_Units.DEGREES] / projection.getMetersPerUnit();
            extent = createOrUpdate(-half, -half, half, half);
          }
          return extent;
        }
        var source_Tile_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Tile_TileSource = function(_super) {
          source_Tile_extends(TileSource, _super);
          function TileSource(options) {
            var _this = _super.call(this, {
              attributions: options.attributions,
              attributionsCollapsible: options.attributionsCollapsible,
              projection: options.projection,
              state: options.state,
              wrapX: options.wrapX,
              interpolate: options.interpolate
            }) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.opaque_ = options.opaque !== void 0 ? options.opaque : false;
            _this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
            _this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
            var tileSize = [256, 256];
            var tileGrid = options.tileGrid;
            if (tileGrid) {
              toSize(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);
            }
            _this.tileCache = new ol_TileCache(options.cacheSize || 0);
            _this.tmpSize = [0, 0];
            _this.key_ = options.key || "";
            _this.tileOptions = {
              transition: options.transition,
              interpolate: options.interpolate
            };
            _this.zDirection = options.zDirection ? options.zDirection : 0;
            return _this;
          }
          TileSource.prototype.canExpireCache = function() {
            return this.tileCache.canExpireCache();
          };
          TileSource.prototype.expireCache = function(projection, usedTiles) {
            var tileCache = this.getTileCacheForProjection(projection);
            if (tileCache) {
              tileCache.expireCache(usedTiles);
            }
          };
          TileSource.prototype.forEachLoadedTile = function(projection, z, tileRange, callback) {
            var tileCache = this.getTileCacheForProjection(projection);
            if (!tileCache) {
              return false;
            }
            var covered = true;
            var tile, tileCoordKey, loaded;
            for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
              for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                tileCoordKey = getKeyZXY(z, x, y);
                loaded = false;
                if (tileCache.containsKey(tileCoordKey)) {
                  tile = tileCache.get(tileCoordKey);
                  loaded = tile.getState() === TileState.LOADED;
                  if (loaded) {
                    loaded = callback(tile) !== false;
                  }
                }
                if (!loaded) {
                  covered = false;
                }
              }
            }
            return covered;
          };
          TileSource.prototype.getGutterForProjection = function(projection) {
            return 0;
          };
          TileSource.prototype.getKey = function() {
            return this.key_;
          };
          TileSource.prototype.setKey = function(key) {
            if (this.key_ !== key) {
              this.key_ = key;
              this.changed();
            }
          };
          TileSource.prototype.getOpaque = function(projection) {
            return this.opaque_;
          };
          TileSource.prototype.getResolutions = function() {
            return this.tileGrid.getResolutions();
          };
          TileSource.prototype.getTile = function(z, x, y, pixelRatio, projection) {
            return Object(util["b"])();
          };
          TileSource.prototype.getTileGrid = function() {
            return this.tileGrid;
          };
          TileSource.prototype.getTileGridForProjection = function(projection) {
            if (!this.tileGrid) {
              return getForProjection(projection);
            } else {
              return this.tileGrid;
            }
          };
          TileSource.prototype.getTileCacheForProjection = function(projection) {
            assert2(equivalent(this.getProjection(), projection), 68);
            return this.tileCache;
          };
          TileSource.prototype.getTilePixelRatio = function(pixelRatio) {
            return this.tilePixelRatio_;
          };
          TileSource.prototype.getTilePixelSize = function(z, pixelRatio, projection) {
            var tileGrid = this.getTileGridForProjection(projection);
            var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
            var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
            if (tilePixelRatio == 1) {
              return tileSize;
            } else {
              return size_scale(tileSize, tilePixelRatio, this.tmpSize);
            }
          };
          TileSource.prototype.getTileCoordForTileUrlFunction = function(tileCoord, opt_projection) {
            var projection = opt_projection !== void 0 ? opt_projection : this.getProjection();
            var tileGrid = this.getTileGridForProjection(projection);
            if (this.getWrapX() && projection.isGlobal()) {
              tileCoord = tilegrid_wrapX(tileGrid, tileCoord, projection);
            }
            return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
          };
          TileSource.prototype.clear = function() {
            this.tileCache.clear();
          };
          TileSource.prototype.refresh = function() {
            this.clear();
            _super.prototype.refresh.call(this);
          };
          TileSource.prototype.updateCacheSize = function(tileCount, projection) {
            var tileCache = this.getTileCacheForProjection(projection);
            if (tileCount > tileCache.highWaterMark) {
              tileCache.highWaterMark = tileCount;
            }
          };
          TileSource.prototype.useTile = function(z, x, y, projection) {
          };
          return TileSource;
        }(source_Source);
        var TileSourceEvent = function(_super) {
          source_Tile_extends(TileSourceEvent2, _super);
          function TileSourceEvent2(type, tile) {
            var _this = _super.call(this, type) || this;
            _this.tile = tile;
            return _this;
          }
          return TileSourceEvent2;
        }(events_Event["a"]);
        var source_Tile = Tile_TileSource;
        function createFromTemplate(template, tileGrid) {
          var zRegEx = /\{z\}/g;
          var xRegEx = /\{x\}/g;
          var yRegEx = /\{y\}/g;
          var dashYRegEx = /\{-y\}/g;
          return function(tileCoord, pixelRatio, projection) {
            if (!tileCoord) {
              return void 0;
            } else {
              return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
                var z = tileCoord[0];
                var range = tileGrid.getFullTileRange(z);
                assert2(range, 55);
                var y = range.getHeight() - tileCoord[2] - 1;
                return y.toString();
              });
            }
          };
        }
        function createFromTemplates(templates, tileGrid) {
          var len = templates.length;
          var tileUrlFunctions = new Array(len);
          for (var i = 0; i < len; ++i) {
            tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
          }
          return createFromTileUrlFunctions(tileUrlFunctions);
        }
        function createFromTileUrlFunctions(tileUrlFunctions) {
          if (tileUrlFunctions.length === 1) {
            return tileUrlFunctions[0];
          }
          return function(tileCoord, pixelRatio, projection) {
            if (!tileCoord) {
              return void 0;
            } else {
              var h = hash(tileCoord);
              var index = modulo(h, tileUrlFunctions.length);
              return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
            }
          };
        }
        function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
          return void 0;
        }
        function expandUrl(url) {
          var urls = [];
          var match = /\{([a-z])-([a-z])\}/.exec(url);
          if (match) {
            var startCharCode = match[1].charCodeAt(0);
            var stopCharCode = match[2].charCodeAt(0);
            var charCode = void 0;
            for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
              urls.push(url.replace(match[0], String.fromCharCode(charCode)));
            }
            return urls;
          }
          match = /\{(\d+)-(\d+)\}/.exec(url);
          if (match) {
            var stop_1 = parseInt(match[2], 10);
            for (var i = parseInt(match[1], 10); i <= stop_1; i++) {
              urls.push(url.replace(match[0], i.toString()));
            }
            return urls;
          }
          urls.push(url);
          return urls;
        }
        var UrlTile_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var UrlTile_UrlTile = function(_super) {
          UrlTile_extends(UrlTile, _super);
          function UrlTile(options) {
            var _this = _super.call(this, {
              attributions: options.attributions,
              cacheSize: options.cacheSize,
              opaque: options.opaque,
              projection: options.projection,
              state: options.state,
              tileGrid: options.tileGrid,
              tilePixelRatio: options.tilePixelRatio,
              wrapX: options.wrapX,
              transition: options.transition,
              interpolate: options.interpolate,
              key: options.key,
              attributionsCollapsible: options.attributionsCollapsible,
              zDirection: options.zDirection
            }) || this;
            _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
            _this.tileLoadFunction = options.tileLoadFunction;
            if (options.tileUrlFunction) {
              _this.tileUrlFunction = options.tileUrlFunction;
            }
            _this.urls = null;
            if (options.urls) {
              _this.setUrls(options.urls);
            } else if (options.url) {
              _this.setUrl(options.url);
            }
            _this.tileLoadingKeys_ = {};
            return _this;
          }
          UrlTile.prototype.getTileLoadFunction = function() {
            return this.tileLoadFunction;
          };
          UrlTile.prototype.getTileUrlFunction = function() {
            return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
          };
          UrlTile.prototype.getUrls = function() {
            return this.urls;
          };
          UrlTile.prototype.handleTileChange = function(event) {
            var tile = event.target;
            var uid = Object(util["c"])(tile);
            var tileState = tile.getState();
            var type;
            if (tileState == TileState.LOADING) {
              this.tileLoadingKeys_[uid] = true;
              type = TileEventType.TILELOADSTART;
            } else if (uid in this.tileLoadingKeys_) {
              delete this.tileLoadingKeys_[uid];
              type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : void 0;
            }
            if (type != void 0) {
              this.dispatchEvent(new TileSourceEvent(type, tile));
            }
          };
          UrlTile.prototype.setTileLoadFunction = function(tileLoadFunction) {
            this.tileCache.clear();
            this.tileLoadFunction = tileLoadFunction;
            this.changed();
          };
          UrlTile.prototype.setTileUrlFunction = function(tileUrlFunction, key) {
            this.tileUrlFunction = tileUrlFunction;
            this.tileCache.pruneExceptNewestZ();
            if (typeof key !== "undefined") {
              this.setKey(key);
            } else {
              this.changed();
            }
          };
          UrlTile.prototype.setUrl = function(url) {
            var urls = expandUrl(url);
            this.urls = urls;
            this.setUrls(urls);
          };
          UrlTile.prototype.setUrls = function(urls) {
            this.urls = urls;
            var key = urls.join("\n");
            if (this.generateTileUrlFunction_) {
              this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
            } else {
              this.setKey(key);
            }
          };
          UrlTile.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {
            return void 0;
          };
          UrlTile.prototype.useTile = function(z, x, y) {
            var tileCoordKey = getKeyZXY(z, x, y);
            if (this.tileCache.containsKey(tileCoordKey)) {
              this.tileCache.get(tileCoordKey);
            }
          };
          return UrlTile;
        }(source_Tile);
        var source_UrlTile = UrlTile_UrlTile;
        var TileImage_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var TileImage_TileImage = function(_super) {
          TileImage_extends(TileImage, _super);
          function TileImage(options) {
            var _this = this;
            var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
            if (options.interpolate !== void 0) {
              interpolate = options.interpolate;
            }
            _this = _super.call(this, {
              attributions: options.attributions,
              cacheSize: options.cacheSize,
              opaque: options.opaque,
              projection: options.projection,
              state: options.state,
              tileGrid: options.tileGrid,
              tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
              tilePixelRatio: options.tilePixelRatio,
              tileUrlFunction: options.tileUrlFunction,
              url: options.url,
              urls: options.urls,
              wrapX: options.wrapX,
              transition: options.transition,
              interpolate,
              key: options.key,
              attributionsCollapsible: options.attributionsCollapsible,
              zDirection: options.zDirection
            }) || this;
            _this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
            _this.tileClass = options.tileClass !== void 0 ? options.tileClass : ol_ImageTile;
            _this.tileCacheForProjection = {};
            _this.tileGridForProjection = {};
            _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
            _this.renderReprojectionEdges_ = false;
            return _this;
          }
          TileImage.prototype.canExpireCache = function() {
            if (!ENABLE_RASTER_REPROJECTION) {
              return _super.prototype.canExpireCache.call(this);
            }
            if (this.tileCache.canExpireCache()) {
              return true;
            } else {
              for (var key in this.tileCacheForProjection) {
                if (this.tileCacheForProjection[key].canExpireCache()) {
                  return true;
                }
              }
            }
            return false;
          };
          TileImage.prototype.expireCache = function(projection, usedTiles) {
            if (!ENABLE_RASTER_REPROJECTION) {
              _super.prototype.expireCache.call(this, projection, usedTiles);
              return;
            }
            var usedTileCache = this.getTileCacheForProjection(projection);
            this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
            for (var id in this.tileCacheForProjection) {
              var tileCache = this.tileCacheForProjection[id];
              tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
            }
          };
          TileImage.prototype.getGutterForProjection = function(projection) {
            if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
              return 0;
            } else {
              return this.getGutter();
            }
          };
          TileImage.prototype.getGutter = function() {
            return 0;
          };
          TileImage.prototype.getKey = function() {
            var key = _super.prototype.getKey.call(this);
            if (!this.getInterpolate()) {
              key += ":disable-interpolation";
            }
            return key;
          };
          TileImage.prototype.getOpaque = function(projection) {
            if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
              return false;
            } else {
              return _super.prototype.getOpaque.call(this, projection);
            }
          };
          TileImage.prototype.getTileGridForProjection = function(projection) {
            if (!ENABLE_RASTER_REPROJECTION) {
              return _super.prototype.getTileGridForProjection.call(this, projection);
            }
            var thisProj = this.getProjection();
            if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
              return this.tileGrid;
            } else {
              var projKey = Object(util["c"])(projection);
              if (!(projKey in this.tileGridForProjection)) {
                this.tileGridForProjection[projKey] = getForProjection(projection);
              }
              return this.tileGridForProjection[projKey];
            }
          };
          TileImage.prototype.getTileCacheForProjection = function(projection) {
            if (!ENABLE_RASTER_REPROJECTION) {
              return _super.prototype.getTileCacheForProjection.call(this, projection);
            }
            var thisProj = this.getProjection();
            if (!thisProj || equivalent(thisProj, projection)) {
              return this.tileCache;
            } else {
              var projKey = Object(util["c"])(projection);
              if (!(projKey in this.tileCacheForProjection)) {
                this.tileCacheForProjection[projKey] = new ol_TileCache(this.tileCache.highWaterMark);
              }
              return this.tileCacheForProjection[projKey];
            }
          };
          TileImage.prototype.createTile_ = function(z, x, y, pixelRatio, projection, key) {
            var tileCoord = [z, x, y];
            var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
            var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
            var tile = new this.tileClass(tileCoord, tileUrl !== void 0 ? TileState.IDLE : TileState.EMPTY, tileUrl !== void 0 ? tileUrl : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
            tile.key = key;
            tile.addEventListener(EventType["a"].CHANGE, this.handleTileChange.bind(this));
            return tile;
          };
          TileImage.prototype.getTile = function(z, x, y, pixelRatio, projection) {
            var sourceProjection = this.getProjection();
            if (!ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || equivalent(sourceProjection, projection)) {
              return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
            } else {
              var cache = this.getTileCacheForProjection(projection);
              var tileCoord = [z, x, y];
              var tile = void 0;
              var tileCoordKey = tilecoord_getKey(tileCoord);
              if (cache.containsKey(tileCoordKey)) {
                tile = cache.get(tileCoordKey);
              }
              var key = this.getKey();
              if (tile && tile.key == key) {
                return tile;
              } else {
                var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
                var targetTileGrid = this.getTileGridForProjection(projection);
                var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
                var newTile = new reproj_Tile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function(z2, x2, y2, pixelRatio2) {
                  return this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection);
                }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
                newTile.key = key;
                if (tile) {
                  newTile.interimTile = tile;
                  newTile.refreshInterimChain();
                  cache.replace(tileCoordKey, newTile);
                } else {
                  cache.set(tileCoordKey, newTile);
                }
                return newTile;
              }
            }
          };
          TileImage.prototype.getTileInternal = function(z, x, y, pixelRatio, projection) {
            var tile = null;
            var tileCoordKey = getKeyZXY(z, x, y);
            var key = this.getKey();
            if (!this.tileCache.containsKey(tileCoordKey)) {
              tile = this.createTile_(z, x, y, pixelRatio, projection, key);
              this.tileCache.set(tileCoordKey, tile);
            } else {
              tile = this.tileCache.get(tileCoordKey);
              if (tile.key != key) {
                var interimTile = tile;
                tile = this.createTile_(z, x, y, pixelRatio, projection, key);
                if (interimTile.getState() == TileState.IDLE) {
                  tile.interimTile = interimTile.interimTile;
                } else {
                  tile.interimTile = interimTile;
                }
                tile.refreshInterimChain();
                this.tileCache.replace(tileCoordKey, tile);
              }
            }
            return tile;
          };
          TileImage.prototype.setRenderReprojectionEdges = function(render) {
            if (!ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
              return;
            }
            this.renderReprojectionEdges_ = render;
            for (var id in this.tileCacheForProjection) {
              this.tileCacheForProjection[id].clear();
            }
            this.changed();
          };
          TileImage.prototype.setTileGridForProjection = function(projection, tilegrid) {
            if (ENABLE_RASTER_REPROJECTION) {
              var proj = proj_get(projection);
              if (proj) {
                var projKey = Object(util["c"])(proj);
                if (!(projKey in this.tileGridForProjection)) {
                  this.tileGridForProjection[projKey] = tilegrid;
                }
              }
            }
          };
          return TileImage;
        }(source_UrlTile);
        function defaultTileLoadFunction(imageTile, src) {
          imageTile.getImage().src = src;
        }
        var source_TileImage = TileImage_TileImage;
        var XYZ_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var XYZ_XYZ = function(_super) {
          XYZ_extends(XYZ, _super);
          function XYZ(opt_options) {
            var _this = this;
            var options = opt_options || {};
            var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
            if (options.interpolate !== void 0) {
              interpolate = options.interpolate;
            }
            var projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
            var tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
              extent: extentFromProjection(projection),
              maxResolution: options.maxResolution,
              maxZoom: options.maxZoom,
              minZoom: options.minZoom,
              tileSize: options.tileSize
            });
            _this = _super.call(this, {
              attributions: options.attributions,
              cacheSize: options.cacheSize,
              crossOrigin: options.crossOrigin,
              interpolate,
              opaque: options.opaque,
              projection,
              reprojectionErrorThreshold: options.reprojectionErrorThreshold,
              tileGrid,
              tileLoadFunction: options.tileLoadFunction,
              tilePixelRatio: options.tilePixelRatio,
              tileUrlFunction: options.tileUrlFunction,
              url: options.url,
              urls: options.urls,
              wrapX: options.wrapX !== void 0 ? options.wrapX : true,
              transition: options.transition,
              attributionsCollapsible: options.attributionsCollapsible,
              zDirection: options.zDirection
            }) || this;
            return _this;
          }
          return XYZ;
        }(source_TileImage);
        var source_XYZ = XYZ_XYZ;
        var SourceXYZvue_type_script_lang_js = {
          name: "ol-source-xyz",
          setup: function setup(props) {
            var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("tileLayer");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new source_XYZ(properties);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(source, function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              layer.value.setSource(null);
            });
            return {
              layer,
              source
            };
          },
          props: {
            attributions: {
              type: [String, Array]
            },
            url: {
              type: String
            },
            cacheSize: {
              type: Number,
              default: 2048
            },
            crossOrigin: {
              type: String
            },
            maxZoom: {
              type: Number,
              default: 28
            },
            minZoom: {
              type: Number,
              default: 0
            },
            opaque: {
              type: Boolean
            },
            projection: {
              type: String,
              default: "EPSG:3857"
            },
            reprojectionErrorThreshold: {
              type: Number,
              default: 0.5
            },
            tileSize: {
              type: Array,
              default: function _default() {
                return [256, 256];
              }
            },
            tilePixelRatio: {
              type: Number,
              default: 1
            },
            tileKey: {
              type: String
            },
            transition: {
              type: Number
            },
            tileGrid: {
              type: Object
            }
          }
        };
        const SourceXYZ_exports_ = exportHelper_default()(SourceXYZvue_type_script_lang_js, [["render", SourceXYZvue_type_template_id_12bc2b74_render]]);
        var SourceXYZ = SourceXYZ_exports_;
        var SourceOSMvue_type_template_id_ab26ab7a_hoisted_1 = {
          key: 0
        };
        function SourceOSMvue_type_template_id_ab26ab7a_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var OSM_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ATTRIBUTION = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
        var OSM = function(_super) {
          OSM_extends(OSM2, _super);
          function OSM2(opt_options) {
            var _this = this;
            var options = opt_options || {};
            var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
            if (options.interpolate !== void 0) {
              interpolate = options.interpolate;
            }
            var attributions;
            if (options.attributions !== void 0) {
              attributions = options.attributions;
            } else {
              attributions = [ATTRIBUTION];
            }
            var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
            var url = options.url !== void 0 ? options.url : "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png";
            _this = _super.call(this, {
              attributions,
              attributionsCollapsible: false,
              cacheSize: options.cacheSize,
              crossOrigin,
              interpolate,
              maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 19,
              opaque: options.opaque !== void 0 ? options.opaque : true,
              reprojectionErrorThreshold: options.reprojectionErrorThreshold,
              tileLoadFunction: options.tileLoadFunction,
              transition: options.transition,
              url,
              wrapX: options.wrapX,
              zDirection: options.zDirection
            }) || this;
            return _this;
          }
          return OSM2;
        }(source_XYZ);
        var source_OSM = OSM;
        var SourceOSMvue_type_script_lang_js = {
          name: "ol-source-osm",
          setup: function setup(props) {
            var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("tileLayer");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new source_OSM(properties);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(source, function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              layer.value.setSource(null);
            });
            return {
              layer,
              source
            };
          },
          props: {
            attributions: {
              type: String
            },
            cacheSize: {
              type: Number,
              default: 2048
            },
            crossOrigin: {
              type: String,
              default: "anonymous"
            },
            imageSmoothing: {
              type: Boolean,
              default: true
            },
            minZoom: {
              type: Number,
              default: 0
            },
            maxZoom: {
              type: Number,
              default: 19
            },
            opaque: {
              type: Boolean,
              default: true
            },
            reprojectionErrorThreshold: {
              type: Number,
              default: 0.5
            },
            transition: {
              type: Number,
              default: 250
            },
            url: {
              type: String,
              default: "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            },
            wrapX: {
              type: Boolean,
              default: true
            }
          }
        };
        const SourceOSM_exports_ = exportHelper_default()(SourceOSMvue_type_script_lang_js, [["render", SourceOSMvue_type_template_id_ab26ab7a_render]]);
        var SourceOSM = SourceOSM_exports_;
        var SourceImageStaticvue_type_template_id_80caf7c2_hoisted_1 = {
          key: 0
        };
        function SourceImageStaticvue_type_template_id_80caf7c2_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var reproj_Image_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Image_ReprojImage = function(_super) {
          reproj_Image_extends(ReprojImage, _super);
          function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate) {
            var _this = this;
            var maxSourceExtent = sourceProj.getExtent();
            var maxTargetExtent = targetProj.getExtent();
            var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
            var targetCenter = extent_getCenter(limitedTargetExtent);
            var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
            var errorThresholdInPixels = ERROR_THRESHOLD;
            var triangulation = new reproj_Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
            var sourceExtent = triangulation.calculateSourceExtent();
            var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
            var state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;
            var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
            _this = _super.call(this, targetExtent, targetResolution, sourcePixelRatio, state) || this;
            _this.targetProj_ = targetProj;
            _this.maxSourceExtent_ = maxSourceExtent;
            _this.triangulation_ = triangulation;
            _this.targetResolution_ = targetResolution;
            _this.targetExtent_ = targetExtent;
            _this.sourceImage_ = sourceImage;
            _this.sourcePixelRatio_ = sourcePixelRatio;
            _this.interpolate_ = interpolate;
            _this.canvas_ = null;
            _this.sourceListenerKey_ = null;
            return _this;
          }
          ReprojImage.prototype.disposeInternal = function() {
            if (this.state == ImageState.LOADING) {
              this.unlistenSource_();
            }
            _super.prototype.disposeInternal.call(this);
          };
          ReprojImage.prototype.getImage = function() {
            return this.canvas_;
          };
          ReprojImage.prototype.getProjection = function() {
            return this.targetProj_;
          };
          ReprojImage.prototype.reproject_ = function() {
            var sourceState = this.sourceImage_.getState();
            if (sourceState == ImageState.LOADED) {
              var width = getWidth(this.targetExtent_) / this.targetResolution_;
              var height = getHeight(this.targetExtent_) / this.targetResolution_;
              this.canvas_ = reproj_render(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [
                {
                  extent: this.sourceImage_.getExtent(),
                  image: this.sourceImage_.getImage()
                }
              ], 0, void 0, this.interpolate_);
            }
            this.state = sourceState;
            this.changed();
          };
          ReprojImage.prototype.load = function() {
            if (this.state == ImageState.IDLE) {
              this.state = ImageState.LOADING;
              this.changed();
              var sourceState = this.sourceImage_.getState();
              if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {
                this.reproject_();
              } else {
                this.sourceListenerKey_ = Object(events["a"])(this.sourceImage_, EventType["a"].CHANGE, function(e) {
                  var sourceState2 = this.sourceImage_.getState();
                  if (sourceState2 == ImageState.LOADED || sourceState2 == ImageState.ERROR) {
                    this.unlistenSource_();
                    this.reproject_();
                  }
                }, this);
                this.sourceImage_.load();
              }
            }
          };
          ReprojImage.prototype.unlistenSource_ = function() {
            Object(events["c"])(this.sourceListenerKey_);
            this.sourceListenerKey_ = null;
          };
          return ReprojImage;
        }(ol_ImageBase);
        var reproj_Image = Image_ReprojImage;
        var source_Image_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ImageSourceEventType = {
          IMAGELOADSTART: "imageloadstart",
          IMAGELOADEND: "imageloadend",
          IMAGELOADERROR: "imageloaderror"
        };
        var ImageSourceEvent = function(_super) {
          source_Image_extends(ImageSourceEvent2, _super);
          function ImageSourceEvent2(type, image) {
            var _this = _super.call(this, type) || this;
            _this.image = image;
            return _this;
          }
          return ImageSourceEvent2;
        }(events_Event["a"]);
        var Image_ImageSource = function(_super) {
          source_Image_extends(ImageSource, _super);
          function ImageSource(options) {
            var _this = this;
            var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
            if (options.interpolate !== void 0) {
              interpolate = options.interpolate;
            }
            _this = _super.call(this, {
              attributions: options.attributions,
              projection: options.projection,
              state: options.state,
              interpolate
            }) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.resolutions_ = options.resolutions !== void 0 ? options.resolutions : null;
            _this.reprojectedImage_ = null;
            _this.reprojectedRevision_ = 0;
            return _this;
          }
          ImageSource.prototype.getResolutions = function() {
            return this.resolutions_;
          };
          ImageSource.prototype.findNearestResolution = function(resolution) {
            if (this.resolutions_) {
              var idx = Object(ol_array["h"])(this.resolutions_, resolution, 0);
              resolution = this.resolutions_[idx];
            }
            return resolution;
          };
          ImageSource.prototype.getImage = function(extent, resolution, pixelRatio, projection) {
            var sourceProjection = this.getProjection();
            if (!ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || equivalent(sourceProjection, projection)) {
              if (sourceProjection) {
                projection = sourceProjection;
              }
              return this.getImageInternal(extent, resolution, pixelRatio, projection);
            } else {
              if (this.reprojectedImage_) {
                if (this.reprojectedRevision_ == this.getRevision() && equivalent(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && equals(this.reprojectedImage_.getExtent(), extent)) {
                  return this.reprojectedImage_;
                }
                this.reprojectedImage_.dispose();
                this.reprojectedImage_ = null;
              }
              this.reprojectedImage_ = new reproj_Image(sourceProjection, projection, extent, resolution, pixelRatio, function(extent2, resolution2, pixelRatio2) {
                return this.getImageInternal(extent2, resolution2, pixelRatio2, sourceProjection);
              }.bind(this), this.getInterpolate());
              this.reprojectedRevision_ = this.getRevision();
              return this.reprojectedImage_;
            }
          };
          ImageSource.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
            return Object(util["b"])();
          };
          ImageSource.prototype.handleImageChange = function(event) {
            var image = event.target;
            switch (image.getState()) {
              case ImageState.LOADING:
                this.loading = true;
                this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADSTART, image));
                break;
              case ImageState.LOADED:
                this.loading = false;
                this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADEND, image));
                break;
              case ImageState.ERROR:
                this.loading = false;
                this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADERROR, image));
                break;
              default:
            }
          };
          return ImageSource;
        }(source_Source);
        function defaultImageLoadFunction(image, src) {
          image.getImage().src = src;
        }
        var source_Image = Image_ImageSource;
        var ImageStatic_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ImageStatic_Static = function(_super) {
          ImageStatic_extends(Static, _super);
          function Static(options) {
            var _this = this;
            var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
            var imageLoadFunction = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
            var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
            if (options.interpolate !== void 0) {
              interpolate = options.interpolate;
            }
            _this = _super.call(this, {
              attributions: options.attributions,
              interpolate,
              projection: proj_get(options.projection)
            }) || this;
            _this.url_ = options.url;
            _this.imageExtent_ = options.imageExtent;
            _this.image_ = new ol_Image(_this.imageExtent_, void 0, 1, _this.url_, crossOrigin, imageLoadFunction);
            _this.imageSize_ = options.imageSize ? options.imageSize : null;
            _this.image_.addEventListener(EventType["a"].CHANGE, _this.handleImageChange.bind(_this));
            return _this;
          }
          Static.prototype.getImageExtent = function() {
            return this.imageExtent_;
          };
          Static.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
            if (extent_intersects(extent, this.image_.getExtent())) {
              return this.image_;
            }
            return null;
          };
          Static.prototype.getUrl = function() {
            return this.url_;
          };
          Static.prototype.handleImageChange = function(evt) {
            if (this.image_.getState() == ImageState.LOADED) {
              var imageExtent = this.image_.getExtent();
              var image = this.image_.getImage();
              var imageWidth = void 0, imageHeight = void 0;
              if (this.imageSize_) {
                imageWidth = this.imageSize_[0];
                imageHeight = this.imageSize_[1];
              } else {
                imageWidth = image.width;
                imageHeight = image.height;
              }
              var extentWidth = getWidth(imageExtent);
              var extentHeight = getHeight(imageExtent);
              var xResolution = extentWidth / imageWidth;
              var yResolution = extentHeight / imageHeight;
              var targetWidth = imageWidth;
              var targetHeight = imageHeight;
              if (xResolution > yResolution) {
                targetWidth = Math.round(extentWidth / yResolution);
              } else {
                targetHeight = Math.round(extentHeight / xResolution);
              }
              if (targetWidth !== imageWidth || targetHeight !== imageHeight) {
                var context = Object(dom["a"])(targetWidth, targetHeight);
                if (!this.getInterpolate()) {
                  Object(ol_obj["a"])(context, IMAGE_SMOOTHING_DISABLED);
                }
                var canvas = context.canvas;
                context.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
                this.image_.setImage(canvas);
              }
            }
            _super.prototype.handleImageChange.call(this, evt);
          };
          return Static;
        }(source_Image);
        var ImageStatic = ImageStatic_Static;
        var SourceImageStaticvue_type_script_lang_js = {
          name: "ol-source-image-static",
          setup: function setup(props) {
            var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("imageLayer");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var createSource = function createSource2() {
              return new ImageStatic(_objectSpread2(_objectSpread2({}, properties), {}, {
                projection: typeof properties.projection == "string" ? properties.projection : new proj_Projection(_objectSpread2({}, properties.projection))
              }));
            };
            var source = createSource();
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              layer.setSource(null);
              source = createSource();
              layer.setSource(source);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              layer.setSource(source);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              layer.setSource(null);
            });
            return {
              layer,
              source
            };
          },
          props: {
            attributions: {
              type: String
            },
            crossOrigin: {
              type: String
            },
            imageExtent: {
              type: Array
            },
            projection: {
              type: [String, Object]
            },
            imageSmoothing: {
              type: Boolean,
              default: true
            },
            imageSize: {
              type: Array
            },
            url: {
              type: String
            }
          }
        };
        const SourceImageStatic_exports_ = exportHelper_default()(SourceImageStaticvue_type_script_lang_js, [["render", SourceImageStaticvue_type_template_id_80caf7c2_render]]);
        var SourceImageStatic = SourceImageStatic_exports_;
        var SourceWMTSvue_type_template_id_a8349fac_hoisted_1 = {
          key: 0
        };
        function SourceWMTSvue_type_template_id_a8349fac_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var WMTSRequestEncoding = {
          KVP: "KVP",
          REST: "REST"
        };
        function appendParams(uri, params) {
          var keyParams = [];
          Object.keys(params).forEach(function(k) {
            if (params[k] !== null && params[k] !== void 0) {
              keyParams.push(k + "=" + encodeURIComponent(params[k]));
            }
          });
          var qs = keyParams.join("&");
          uri = uri.replace(/[?&]$/, "");
          uri = uri.indexOf("?") === -1 ? uri + "?" : uri + "&";
          return uri + qs;
        }
        var WMTS_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var WMTSTileGrid = function(_super) {
          WMTS_extends(WMTSTileGrid2, _super);
          function WMTSTileGrid2(options) {
            var _this = _super.call(this, {
              extent: options.extent,
              origin: options.origin,
              origins: options.origins,
              resolutions: options.resolutions,
              tileSize: options.tileSize,
              tileSizes: options.tileSizes,
              sizes: options.sizes
            }) || this;
            _this.matrixIds_ = options.matrixIds;
            return _this;
          }
          WMTSTileGrid2.prototype.getMatrixId = function(z) {
            return this.matrixIds_[z];
          };
          WMTSTileGrid2.prototype.getMatrixIds = function() {
            return this.matrixIds_;
          };
          return WMTSTileGrid2;
        }(tilegrid_TileGrid);
        var tilegrid_WMTS = WMTSTileGrid;
        function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {
          var resolutions = [];
          var matrixIds = [];
          var origins = [];
          var tileSizes = [];
          var sizes = [];
          var matrixLimits = opt_matrixLimits !== void 0 ? opt_matrixLimits : [];
          var supportedCRSPropName = "SupportedCRS";
          var matrixIdsPropName = "TileMatrix";
          var identifierPropName = "Identifier";
          var scaleDenominatorPropName = "ScaleDenominator";
          var topLeftCornerPropName = "TopLeftCorner";
          var tileWidthPropName = "TileWidth";
          var tileHeightPropName = "TileHeight";
          var code = matrixSet[supportedCRSPropName];
          var projection = proj_get(code);
          var metersPerUnit = projection.getMetersPerUnit();
          var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == "ne";
          matrixSet[matrixIdsPropName].sort(function(a, b) {
            return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
          });
          matrixSet[matrixIdsPropName].forEach(function(elt) {
            var matrixAvailable;
            if (matrixLimits.length > 0) {
              matrixAvailable = Object(ol_array["d"])(matrixLimits, function(elt_ml) {
                if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {
                  return true;
                }
                if (elt[identifierPropName].indexOf(":") === -1) {
                  return matrixSet[identifierPropName] + ":" + elt[identifierPropName] === elt_ml[matrixIdsPropName];
                }
                return false;
              });
            } else {
              matrixAvailable = true;
            }
            if (matrixAvailable) {
              matrixIds.push(elt[identifierPropName]);
              var resolution = elt[scaleDenominatorPropName] * 28e-5 / metersPerUnit;
              var tileWidth = elt[tileWidthPropName];
              var tileHeight = elt[tileHeightPropName];
              if (switchOriginXY) {
                origins.push([
                  elt[topLeftCornerPropName][1],
                  elt[topLeftCornerPropName][0]
                ]);
              } else {
                origins.push(elt[topLeftCornerPropName]);
              }
              resolutions.push(resolution);
              tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);
              sizes.push([elt["MatrixWidth"], elt["MatrixHeight"]]);
            }
          });
          return new WMTSTileGrid({
            extent: opt_extent,
            origins,
            resolutions,
            matrixIds,
            tileSizes,
            sizes
          });
        }
        var source_WMTS_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var WMTS_WMTS = function(_super) {
          source_WMTS_extends(WMTS, _super);
          function WMTS(options) {
            var _this = this;
            var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
            if (options.interpolate !== void 0) {
              interpolate = options.interpolate;
            }
            var requestEncoding = options.requestEncoding !== void 0 ? options.requestEncoding : WMTSRequestEncoding.KVP;
            var tileGrid = options.tileGrid;
            var urls = options.urls;
            if (urls === void 0 && options.url !== void 0) {
              urls = expandUrl(options.url);
            }
            _this = _super.call(this, {
              attributions: options.attributions,
              attributionsCollapsible: options.attributionsCollapsible,
              cacheSize: options.cacheSize,
              crossOrigin: options.crossOrigin,
              interpolate,
              projection: options.projection,
              reprojectionErrorThreshold: options.reprojectionErrorThreshold,
              tileClass: options.tileClass,
              tileGrid,
              tileLoadFunction: options.tileLoadFunction,
              tilePixelRatio: options.tilePixelRatio,
              urls,
              wrapX: options.wrapX !== void 0 ? options.wrapX : false,
              transition: options.transition,
              zDirection: options.zDirection
            }) || this;
            _this.version_ = options.version !== void 0 ? options.version : "1.0.0";
            _this.format_ = options.format !== void 0 ? options.format : "image/jpeg";
            _this.dimensions_ = options.dimensions !== void 0 ? options.dimensions : {};
            _this.layer_ = options.layer;
            _this.matrixSet_ = options.matrixSet;
            _this.style_ = options.style;
            _this.requestEncoding_ = requestEncoding;
            _this.setKey(_this.getKeyForDimensions_());
            if (urls && urls.length > 0) {
              _this.tileUrlFunction = createFromTileUrlFunctions(urls.map(_this.createFromWMTSTemplate.bind(_this)));
            }
            return _this;
          }
          WMTS.prototype.setUrls = function(urls) {
            this.urls = urls;
            var key = urls.join("\n");
            this.setTileUrlFunction(createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate.bind(this))), key);
          };
          WMTS.prototype.getDimensions = function() {
            return this.dimensions_;
          };
          WMTS.prototype.getFormat = function() {
            return this.format_;
          };
          WMTS.prototype.getLayer = function() {
            return this.layer_;
          };
          WMTS.prototype.getMatrixSet = function() {
            return this.matrixSet_;
          };
          WMTS.prototype.getRequestEncoding = function() {
            return this.requestEncoding_;
          };
          WMTS.prototype.getStyle = function() {
            return this.style_;
          };
          WMTS.prototype.getVersion = function() {
            return this.version_;
          };
          WMTS.prototype.getKeyForDimensions_ = function() {
            var i = 0;
            var res = [];
            for (var key in this.dimensions_) {
              res[i++] = key + "-" + this.dimensions_[key];
            }
            return res.join("/");
          };
          WMTS.prototype.updateDimensions = function(dimensions) {
            Object(ol_obj["a"])(this.dimensions_, dimensions);
            this.setKey(this.getKeyForDimensions_());
          };
          WMTS.prototype.createFromWMTSTemplate = function(template) {
            var requestEncoding = this.requestEncoding_;
            var context = {
              "layer": this.layer_,
              "style": this.style_,
              "tilematrixset": this.matrixSet_
            };
            if (requestEncoding == WMTSRequestEncoding.KVP) {
              Object(ol_obj["a"])(context, {
                "Service": "WMTS",
                "Request": "GetTile",
                "Version": this.version_,
                "Format": this.format_
              });
            }
            template = requestEncoding == WMTSRequestEncoding.KVP ? appendParams(template, context) : template.replace(/\{(\w+?)\}/g, function(m, p) {
              return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
            });
            var tileGrid = this.tileGrid;
            var dimensions = this.dimensions_;
            return function(tileCoord, pixelRatio, projection) {
              if (!tileCoord) {
                return void 0;
              } else {
                var localContext_1 = {
                  "TileMatrix": tileGrid.getMatrixId(tileCoord[0]),
                  "TileCol": tileCoord[1],
                  "TileRow": tileCoord[2]
                };
                Object(ol_obj["a"])(localContext_1, dimensions);
                var url = template;
                if (requestEncoding == WMTSRequestEncoding.KVP) {
                  url = appendParams(url, localContext_1);
                } else {
                  url = url.replace(/\{(\w+?)\}/g, function(m, p) {
                    return localContext_1[p];
                  });
                }
                return url;
              }
            };
          };
          return WMTS;
        }(source_TileImage);
        var source_WMTS = WMTS_WMTS;
        function optionsFromCapabilities(wmtsCap, config) {
          var layers = wmtsCap["Contents"]["Layer"];
          var l = Object(ol_array["d"])(layers, function(elt, index, array) {
            return elt["Identifier"] == config["layer"];
          });
          if (l === null) {
            return null;
          }
          var tileMatrixSets = wmtsCap["Contents"]["TileMatrixSet"];
          var idx;
          if (l["TileMatrixSetLink"].length > 1) {
            if ("projection" in config) {
              idx = Object(ol_array["e"])(l["TileMatrixSetLink"], function(elt, index, array) {
                var tileMatrixSet = Object(ol_array["d"])(tileMatrixSets, function(el) {
                  return el["Identifier"] == elt["TileMatrixSet"];
                });
                var supportedCRS = tileMatrixSet["SupportedCRS"];
                var proj1 = proj_get(supportedCRS);
                var proj2 = proj_get(config["projection"]);
                if (proj1 && proj2) {
                  return equivalent(proj1, proj2);
                } else {
                  return supportedCRS == config["projection"];
                }
              });
            } else {
              idx = Object(ol_array["e"])(l["TileMatrixSetLink"], function(elt, index, array) {
                return elt["TileMatrixSet"] == config["matrixSet"];
              });
            }
          } else {
            idx = 0;
          }
          if (idx < 0) {
            idx = 0;
          }
          var matrixSet = l["TileMatrixSetLink"][idx]["TileMatrixSet"];
          var matrixLimits = l["TileMatrixSetLink"][idx]["TileMatrixSetLimits"];
          var format = l["Format"][0];
          if ("format" in config) {
            format = config["format"];
          }
          idx = Object(ol_array["e"])(l["Style"], function(elt, index, array) {
            if ("style" in config) {
              return elt["Title"] == config["style"];
            } else {
              return elt["isDefault"];
            }
          });
          if (idx < 0) {
            idx = 0;
          }
          var style = l["Style"][idx]["Identifier"];
          var dimensions = {};
          if ("Dimension" in l) {
            l["Dimension"].forEach(function(elt, index, array) {
              var key = elt["Identifier"];
              var value = elt["Default"];
              if (value === void 0) {
                value = elt["Value"][0];
              }
              dimensions[key] = value;
            });
          }
          var matrixSets = wmtsCap["Contents"]["TileMatrixSet"];
          var matrixSetObj = Object(ol_array["d"])(matrixSets, function(elt, index, array) {
            return elt["Identifier"] == matrixSet;
          });
          var projection;
          var code = matrixSetObj["SupportedCRS"];
          if (code) {
            projection = proj_get(code);
          }
          if ("projection" in config) {
            var projConfig = proj_get(config["projection"]);
            if (projConfig) {
              if (!projection || equivalent(projConfig, projection)) {
                projection = projConfig;
              }
            }
          }
          var wrapX = false;
          var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == "ne";
          var matrix = matrixSetObj.TileMatrix[0];
          var selectedMatrixLimit = {
            MinTileCol: 0,
            MinTileRow: 0,
            MaxTileCol: matrix.MatrixWidth - 1,
            MaxTileRow: matrix.MatrixHeight - 1
          };
          if (matrixLimits) {
            selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];
            var m = Object(ol_array["d"])(matrixSetObj.TileMatrix, function(tileMatrixValue) {
              return tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix || matrixSetObj.Identifier + ":" + tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix;
            });
            if (m) {
              matrix = m;
            }
          }
          var resolution = matrix.ScaleDenominator * 28e-5 / projection.getMetersPerUnit();
          var origin = switchOriginXY ? [matrix.TopLeftCorner[1], matrix.TopLeftCorner[0]] : matrix.TopLeftCorner;
          var tileSpanX = matrix.TileWidth * resolution;
          var tileSpanY = matrix.TileHeight * resolution;
          var matrixSetExtent = matrixSetObj["BoundingBox"];
          var extent = [
            origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol,
            origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow),
            origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol),
            origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow
          ];
          if (matrixSetExtent !== void 0 && !containsExtent(matrixSetExtent, extent)) {
            var wgs84BoundingBox = l["WGS84BoundingBox"];
            var wgs84ProjectionExtent = proj_get("EPSG:4326").getExtent();
            extent = matrixSetExtent;
            if (wgs84BoundingBox) {
              wrapX = wgs84BoundingBox[0] === wgs84ProjectionExtent[0] && wgs84BoundingBox[2] === wgs84ProjectionExtent[2];
            } else {
              var wgs84MatrixSetExtent = transformExtent(matrixSetExtent, matrixSetObj["SupportedCRS"], "EPSG:4326");
              wrapX = wgs84MatrixSetExtent[0] - 1e-10 <= wgs84ProjectionExtent[0] && wgs84MatrixSetExtent[2] + 1e-10 >= wgs84ProjectionExtent[2];
            }
          }
          var tileGrid = createFromCapabilitiesMatrixSet(matrixSetObj, extent, matrixLimits);
          var urls = [];
          var requestEncoding = config["requestEncoding"];
          requestEncoding = requestEncoding !== void 0 ? requestEncoding : "";
          if ("OperationsMetadata" in wmtsCap && "GetTile" in wmtsCap["OperationsMetadata"]) {
            var gets = wmtsCap["OperationsMetadata"]["GetTile"]["DCP"]["HTTP"]["Get"];
            for (var i = 0, ii = gets.length; i < ii; ++i) {
              if (gets[i]["Constraint"]) {
                var constraint = Object(ol_array["d"])(gets[i]["Constraint"], function(element) {
                  return element["name"] == "GetEncoding";
                });
                var encodings = constraint["AllowedValues"]["Value"];
                if (requestEncoding === "") {
                  requestEncoding = encodings[0];
                }
                if (requestEncoding === WMTSRequestEncoding.KVP) {
                  if (Object(ol_array["f"])(encodings, WMTSRequestEncoding.KVP)) {
                    urls.push(gets[i]["href"]);
                  }
                } else {
                  break;
                }
              } else if (gets[i]["href"]) {
                requestEncoding = WMTSRequestEncoding.KVP;
                urls.push(gets[i]["href"]);
              }
            }
          }
          if (urls.length === 0) {
            requestEncoding = WMTSRequestEncoding.REST;
            l["ResourceURL"].forEach(function(element) {
              if (element["resourceType"] === "tile") {
                format = element["format"];
                urls.push(element["template"]);
              }
            });
          }
          return {
            urls,
            layer: config["layer"],
            matrixSet,
            format,
            projection,
            requestEncoding,
            tileGrid,
            style,
            dimensions,
            wrapX,
            crossOrigin: config["crossOrigin"]
          };
        }
        var SourceWMTSvue_type_script_lang_js = {
          name: "ol-source-wmts",
          setup: function setup(props) {
            var tileLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("tileLayer");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var extent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return proj_get(properties.projection).getExtent();
            });
            var origin = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return getTopLeft(extent.value);
            });
            var size = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return getWidth(extent.value) / 256;
            });
            var getTileGrid = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var resolutions = new Array(14);
              var matrixIds = new Array(14);
              for (var z = 0; z < 14; ++z) {
                resolutions[z] = size.value / Math.pow(2, z);
                matrixIds[z] = z;
              }
              return new tilegrid_WMTS({
                origin: origin.value,
                resolutions,
                matrixIds
              });
            });
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new source_WMTS(_objectSpread2(_objectSpread2({}, properties), {}, {
                projection: typeof properties.projection == "string" ? properties.projection : new proj_Projection(_objectSpread2({}, properties.projection)),
                tileGrid: getTileGrid.value
              }));
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(source, function() {
              tileLayer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(tileLayer, function() {
              tileLayer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              tileLayer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              tileLayer.value.setSource(null);
            });
            return {
              tileLayer,
              source
            };
          },
          props: {
            attributions: {
              type: String
            },
            cacheSize: {
              type: Number
            },
            crossOrigin: {
              type: String
            },
            imageSmoothing: {
              type: Boolean,
              default: true
            },
            projection: {
              type: [String, Object],
              default: "EPSG:3857"
            },
            reprojectionErrorThreshold: {
              type: Number,
              default: 0.5
            },
            tilePixelRatio: {
              type: Number,
              default: 1
            },
            format: {
              type: String,
              default: "image/jpeg"
            },
            version: {
              type: String,
              default: "1.0.0"
            },
            matrixSet: {
              type: String
            },
            dimensions: {
              type: Object
            },
            requestEncoding: {
              type: String,
              default: "KVP"
            },
            url: {
              type: String
            },
            urls: {
              type: Array
            },
            wrapX: {
              type: Boolean,
              default: false
            },
            transition: {
              type: Number
            },
            layer: {
              type: String
            },
            style: {
              type: String
            }
          }
        };
        const SourceWMTS_exports_ = exportHelper_default()(SourceWMTSvue_type_script_lang_js, [["render", SourceWMTSvue_type_template_id_a8349fac_render]]);
        var SourceWMTS = SourceWMTS_exports_;
        function SourceVectorvue_type_template_id_352acc0f_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var SourceVectorvue_type_script_lang_js = {
          name: "ol-source-vector",
          setup: function setup(props) {
            var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorLayer");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new source_Vector(properties);
            });
            var applySource = function applySource2() {
              layer.value.setSource(null);
              layer.value.setSource(source.value);
              layer.value.changed();
            };
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              applySource();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
              applySource();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              layer.value.setSource(null);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("vectorSource", source);
            return {
              layer,
              source
            };
          },
          props: {
            attributions: {
              type: [String, Array]
            },
            features: {
              type: Array,
              default: function _default() {
                return [];
              }
            },
            format: {
              type: Object
            },
            loader: {
              type: Function
            },
            overlaps: {
              type: Boolean,
              default: true
            },
            projection: {
              type: String,
              default: "EPSG:3857"
            },
            strategy: {
              type: Function
            },
            url: {
              type: [String, Function]
            },
            useSpatialIndex: {
              type: Boolean,
              default: true
            },
            wrapX: {
              type: Boolean,
              default: true
            }
          }
        };
        const SourceVector_exports_ = exportHelper_default()(SourceVectorvue_type_script_lang_js, [["render", SourceVectorvue_type_template_id_352acc0f_render]]);
        var SourceVector = SourceVector_exports_;
        function SourceClustervue_type_template_id_0b7aeaa6_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var SourceClustervue_type_script_lang_js = {
          name: "ol-source-cluster",
          setup: function setup(props) {
            var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorLayer");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var c = new source_Cluster(properties);
              return c;
            });
            var applySource = function applySource2() {
              layer.value.setSource(null);
              layer.value.setSource(source.value);
              layer.value.changed();
            };
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              applySource();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
              applySource();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              layer.value.setSource(source.value);
              layer.value.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              layer.value.setSource(null);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("vectorLayer", source);
            return {
              layer,
              source
            };
          },
          props: {
            attributions: {
              type: [String, Array]
            },
            distance: {
              type: Number,
              default: 20
            },
            geometryFunction: {
              type: Function,
              default: function _default(feature) {
                return feature.getGeometry();
              }
            },
            wrapX: {
              type: Boolean,
              default: true
            }
          }
        };
        const SourceCluster_exports_ = exportHelper_default()(SourceClustervue_type_script_lang_js, [["render", SourceClustervue_type_template_id_0b7aeaa6_render]]);
        var SourceCluster = SourceCluster_exports_;
        var SourceBingMapsvue_type_template_id_25b5d337_hoisted_1 = {
          key: 0
        };
        function SourceBingMapsvue_type_template_id_25b5d337_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var net = __webpack_require__("e4e0");
        var BingMaps_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        function quadKey(tileCoord) {
          var z = tileCoord[0];
          var digits = new Array(z);
          var mask = 1 << z - 1;
          var i, charCode;
          for (i = 0; i < z; ++i) {
            charCode = 48;
            if (tileCoord[1] & mask) {
              charCode += 1;
            }
            if (tileCoord[2] & mask) {
              charCode += 2;
            }
            digits[i] = String.fromCharCode(charCode);
            mask >>= 1;
          }
          return digits.join("");
        }
        var TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>';
        var BingMaps_BingMaps = function(_super) {
          BingMaps_extends(BingMaps, _super);
          function BingMaps(options) {
            var _this = this;
            var hidpi = options.hidpi !== void 0 ? options.hidpi : false;
            var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
            if (options.interpolate !== void 0) {
              interpolate = options.interpolate;
            }
            _this = _super.call(this, {
              cacheSize: options.cacheSize,
              crossOrigin: "anonymous",
              interpolate,
              opaque: true,
              projection: proj_get("EPSG:3857"),
              reprojectionErrorThreshold: options.reprojectionErrorThreshold,
              state: State.LOADING,
              tileLoadFunction: options.tileLoadFunction,
              tilePixelRatio: hidpi ? 2 : 1,
              wrapX: options.wrapX !== void 0 ? options.wrapX : true,
              transition: options.transition,
              zDirection: options.zDirection
            }) || this;
            _this.hidpi_ = hidpi;
            _this.culture_ = options.culture !== void 0 ? options.culture : "en-us";
            _this.maxZoom_ = options.maxZoom !== void 0 ? options.maxZoom : -1;
            _this.apiKey_ = options.key;
            _this.imagerySet_ = options.imagerySet;
            var url = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + _this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + _this.apiKey_ + "&c=" + _this.culture_;
            Object(net["a"])(url, _this.handleImageryMetadataResponse.bind(_this), void 0, "jsonp");
            return _this;
          }
          BingMaps.prototype.getApiKey = function() {
            return this.apiKey_;
          };
          BingMaps.prototype.getImagerySet = function() {
            return this.imagerySet_;
          };
          BingMaps.prototype.handleImageryMetadataResponse = function(response) {
            if (response.statusCode != 200 || response.statusDescription != "OK" || response.authenticationResultCode != "ValidCredentials" || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {
              this.setState(State.ERROR);
              return;
            }
            var resource = response.resourceSets[0].resources[0];
            var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;
            var sourceProjection = this.getProjection();
            var extent = extentFromProjection(sourceProjection);
            var scale = this.hidpi_ ? 2 : 1;
            var tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth / scale : [resource.imageWidth / scale, resource.imageHeight / scale];
            var tileGrid = createXYZ({
              extent,
              minZoom: resource.zoomMin,
              maxZoom,
              tileSize
            });
            this.tileGrid = tileGrid;
            var culture = this.culture_;
            var hidpi = this.hidpi_;
            this.tileUrlFunction = createFromTileUrlFunctions(resource.imageUrlSubdomains.map(function(subdomain) {
              var quadKeyTileCoord = [0, 0, 0];
              var imageUrl = resource.imageUrl.replace("{subdomain}", subdomain).replace("{culture}", culture);
              return function(tileCoord, pixelRatio, projection) {
                if (!tileCoord) {
                  return void 0;
                } else {
                  tilecoord_createOrUpdate(tileCoord[0], tileCoord[1], tileCoord[2], quadKeyTileCoord);
                  var url = imageUrl;
                  if (hidpi) {
                    url += "&dpi=d1&device=mobile";
                  }
                  return url.replace("{quadkey}", quadKey(quadKeyTileCoord));
                }
              };
            }));
            if (resource.imageryProviders) {
              var transform_1 = getTransformFromProjections(proj_get("EPSG:4326"), this.getProjection());
              this.setAttributions(function(frameState) {
                var attributions = [];
                var viewState = frameState.viewState;
                var tileGrid2 = this.getTileGrid();
                var z = tileGrid2.getZForResolution(viewState.resolution, this.zDirection);
                var tileCoord = tileGrid2.getTileCoordForCoordAndZ(viewState.center, z);
                var zoom = tileCoord[0];
                resource.imageryProviders.map(function(imageryProvider) {
                  var intersecting = false;
                  var coverageAreas = imageryProvider.coverageAreas;
                  for (var i = 0, ii = coverageAreas.length; i < ii; ++i) {
                    var coverageArea = coverageAreas[i];
                    if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
                      var bbox = coverageArea.bbox;
                      var epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];
                      var extent_1 = applyTransform(epsg4326Extent, transform_1);
                      if (extent_intersects(extent_1, frameState.extent)) {
                        intersecting = true;
                        break;
                      }
                    }
                  }
                  if (intersecting) {
                    attributions.push(imageryProvider.attribution);
                  }
                });
                attributions.push(TOS_ATTRIBUTION);
                return attributions;
              }.bind(this));
            }
            this.setState(State.READY);
          };
          return BingMaps;
        }(source_TileImage);
        var source_BingMaps = BingMaps_BingMaps;
        var SourceBingMapsvue_type_script_lang_js = {
          name: "ol-source-bingmaps",
          setup: function setup(props) {
            var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("tileLayer");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new source_BingMaps(_objectSpread2(_objectSpread2({}, properties), {}, {
                key: properties.apiKey
              }));
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(source, function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              layer.value.setSource(null);
            });
            return {
              layer,
              source
            };
          },
          props: {
            cacheSize: {
              type: Number
            },
            hidpi: {
              type: Boolean,
              default: false
            },
            culture: {
              type: String,
              default: "en-us"
            },
            apiKey: {
              type: String
            },
            imagerySet: {
              type: String
            },
            imageSmoothing: {
              type: Boolean,
              default: true
            },
            maxZoom: {
              type: Number,
              default: 21
            },
            reprojectionErrorThreshold: {
              type: Number,
              default: 0.5
            },
            tileLoadFunction: {
              type: Function,
              default: function _default(imageTile, src) {
                return imageTile.getImage().src = src;
              }
            },
            wrapX: {
              type: Boolean,
              default: true
            },
            transition: {
              type: Number
            }
          }
        };
        const SourceBingMaps_exports_ = exportHelper_default()(SourceBingMapsvue_type_script_lang_js, [["render", SourceBingMapsvue_type_template_id_25b5d337_render]]);
        var SourceBingMaps = SourceBingMaps_exports_;
        var SourceTianDiTuvue_type_template_id_0724477d_hoisted_1 = {
          key: 0
        };
        function SourceTianDiTuvue_type_template_id_0724477d_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var es_error_cause = __webpack_require__("d9e2");
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", {
            writable: false
          });
          return Constructor;
        }
        function _assertThisInitialized(self2) {
          if (self2 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              writable: true,
              configurable: true
            }
          });
          Object.defineProperty(subClass, "prototype", {
            writable: false
          });
          if (superClass)
            _setPrototypeOf(subClass, superClass);
        }
        var es_reflect_construct = __webpack_require__("4ae1");
        var es_reflect_to_string_tag = __webpack_require__("f8c9");
        var es_object_get_prototype_of = __webpack_require__("3410");
        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return _getPrototypeOf(o);
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
            return true;
          } catch (e) {
            return false;
          }
        }
        var es_symbol_description = __webpack_require__("e01a");
        var es_symbol_iterator = __webpack_require__("d28b");
        var es_array_iterator = __webpack_require__("e260");
        var es_string_iterator = __webpack_require__("3ca3");
        var web_dom_collections_iterator = __webpack_require__("ddb0");
        function _typeof(obj) {
          "@babel/helpers - typeof";
          return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
            return typeof obj2;
          } : function(obj2) {
            return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, _typeof(obj);
        }
        function _possibleConstructorReturn(self2, call) {
          if (call && (_typeof(call) === "object" || typeof call === "function")) {
            return call;
          } else if (call !== void 0) {
            throw new TypeError("Derived constructors may only return object or undefined");
          }
          return _assertThisInitialized(self2);
        }
        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        var es_array_concat = __webpack_require__("99af");
        var es_regexp_exec = __webpack_require__("ac1f");
        var es_string_replace = __webpack_require__("5319");
        var SourceTianDiTuvue_type_script_lang_js_Tianditu = function(_WMTSSource) {
          _inherits(Tianditu, _WMTSSource);
          var _super = _createSuper(Tianditu);
          function Tianditu(opt_options) {
            var _this;
            _classCallCheck(this, Tianditu);
            Tianditu.layerLabelMap = {
              vec: "cva",
              ter: "cta",
              img: "cia"
            };
            Tianditu.layerZoomMap = {
              vec: 18,
              ter: 14,
              img: 18
            };
            var options = opt_options || {};
            options.layerType = options.layerType || "vec";
            options.layerType = options.isLabel ? Tianditu.layerLabelMap[options.layerType] : options.layerType;
            options.matrixSet = options.projection === "EPSG:4326" || options.projection === "EPSG:4490" ? "c" : "w";
            if (!options.url && !options.urls) {
              options.url = "https://t{0-7}.tianditu.gov.cn/{layer}_{proj}/wmts?";
            }
            if (options.tk) {
              options.url = "".concat(options.url, "tk=").concat(options.tk);
            }
            options.url = options.url.replace("{layer}", options.layerType).replace("{proj}", options.matrixSet);
            var tileGrid = options.tileGrid || Tianditu.getTileGrid(options.projection || "EPSG:3857");
            var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
            var superOptions = {
              version: options.version || "1.0.0",
              format: options.format || "tiles",
              dimensions: options.dimensions || {},
              layer: options.layerType,
              matrixSet: options.matrixSet,
              tileGrid,
              style: options.style || "default",
              cacheSize: options.cacheSize,
              crossOrigin,
              opaque: options.opaque === void 0 ? true : options.opaque,
              maxZoom: Tianditu.layerZoomMap[options.layerType],
              reprojectionErrorThreshold: options.reprojectionErrorThreshold,
              url: options.url,
              urls: options.urls,
              projection: options.projection || "EPSG:3857",
              wrapX: options.wrapX
            };
            if (options.tileProxy) {
              superOptions.tileLoadFunction = tileLoadFunction;
            }
            _this = _super.call(this, superOptions);
            if (options.tileProxy) {
              _this.tileProxy = options.tileProxy;
            }
            var me = _assertThisInitialized(_this);
            function tileLoadFunction(imageTile, src) {
              imageTile.getImage().src = me.tileProxy + encodeURIComponent(src);
            }
            return _this;
          }
          _createClass(Tianditu, null, [{
            key: "getTileGrid",
            value: function getTileGrid(projection) {
              if (projection === "EPSG:4326" || projection === "EPSG:4490") {
                return Tianditu.default4326TileGrid();
              }
              return Tianditu.default3857TileGrid();
            }
          }, {
            key: "default4326TileGrid",
            value: function default4326TileGrid() {
              var tdt_WGS84_resolutions = [];
              var matrixIds = [];
              for (var i = 1; i < 19; i++) {
                tdt_WGS84_resolutions.push(0.703125 * 2 / Math.pow(2, i));
                matrixIds.push(i);
              }
              var tileGird = new tilegrid_WMTS({
                extent: [-180, -90, 180, 90],
                resolutions: tdt_WGS84_resolutions,
                origin: [-180, 90],
                matrixIds,
                minZoom: 1
              });
              return tileGird;
            }
          }, {
            key: "default3857TileGrid",
            value: function default3857TileGrid() {
              var tdt_Mercator_resolutions = [];
              var matrixIds = [];
              for (var i = 1; i < 19; i++) {
                tdt_Mercator_resolutions.push(78271.51696402031 * 2 / Math.pow(2, i));
                matrixIds.push(i);
              }
              var tileGird = new tilegrid_WMTS({
                extent: [-200375083427892e-7, -200375083427892e-7, 200375083427892e-7, 200375083427892e-7],
                resolutions: tdt_Mercator_resolutions,
                matrixIds,
                origin: [-200375083427892e-7, 200375083427892e-7],
                minZoom: 1
              });
              return tileGird;
            }
          }]);
          return Tianditu;
        }(source_WMTS);
        var SourceTianDiTuvue_type_script_lang_js = {
          name: "ol-source-tianditu",
          setup: function setup(props) {
            var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("tileLayer");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new SourceTianDiTuvue_type_script_lang_js_Tianditu(properties);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(source, function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(layer, function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              layer.value.setSource(source.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              layer.value.setSource(null);
            });
            return {
              layer,
              source
            };
          },
          props: {
            layerType: {
              type: String,
              default: "img"
            },
            tk: {
              type: String
            },
            isLabel: {
              type: Boolean,
              default: false
            },
            cacheSize: {
              type: Number
            },
            crossOrigin: {
              type: String
            },
            projection: {
              Type: String,
              default: "EPSG:3857"
            },
            hidpi: {
              type: Boolean,
              default: false
            },
            requestEncoding: {
              type: String,
              default: "KVP"
            },
            format: {
              type: String
            },
            version: {
              type: String,
              default: "1.0.0"
            },
            culture: {
              type: String,
              default: "en-us"
            },
            matrixSet: {
              type: String
            },
            dimensions: {
              type: Object,
              default: function _default() {
              }
            },
            imageSmoothing: {
              type: Boolean,
              default: true
            },
            maxZoom: {
              type: Number,
              default: 21
            },
            reprojectionErrorThreshold: {
              type: Number
            },
            tileLoadFunction: {
              type: Function,
              default: function _default(imageTile, src) {
                return imageTile.getImage().src = src;
              }
            },
            wrapX: {
              type: Boolean,
              default: true
            },
            transition: {
              type: Number
            }
          }
        };
        const SourceTianDiTu_exports_ = exportHelper_default()(SourceTianDiTuvue_type_script_lang_js, [["render", SourceTianDiTuvue_type_template_id_0724477d_render]]);
        var SourceTianDiTu = SourceTianDiTu_exports_;
        var SourceImageWMSvue_type_template_id_41d50b5e_hoisted_1 = {
          key: 0
        };
        function SourceImageWMSvue_type_template_id_41d50b5e_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var DEFAULT_WMS_VERSION = "1.3.0";
        var WMSServerType = {
          CARMENTA_SERVER: "carmentaserver",
          GEOSERVER: "geoserver",
          MAPSERVER: "mapserver",
          QGIS: "qgis"
        };
        var ImageWMS_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ImageWMS_DECIMALS = 4;
        var GETFEATUREINFO_IMAGE_SIZE = [101, 101];
        var ImageWMS_ImageWMS = function(_super) {
          ImageWMS_extends(ImageWMS, _super);
          function ImageWMS(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
            if (options.interpolate !== void 0) {
              interpolate = options.interpolate;
            }
            _this = _super.call(this, {
              attributions: options.attributions,
              interpolate,
              projection: options.projection,
              resolutions: options.resolutions
            }) || this;
            _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
            _this.url_ = options.url;
            _this.imageLoadFunction_ = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
            _this.params_ = options.params || {};
            _this.v13_ = true;
            _this.updateV13_();
            _this.serverType_ = options.serverType;
            _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
            _this.image_ = null;
            _this.imageSize_ = [0, 0];
            _this.renderedRevision_ = 0;
            _this.ratio_ = options.ratio !== void 0 ? options.ratio : 1.5;
            return _this;
          }
          ImageWMS.prototype.getFeatureInfoUrl = function(coordinate, resolution, projection, params) {
            if (this.url_ === void 0) {
              return void 0;
            }
            var projectionObj = proj_get(projection);
            var sourceProjectionObj = this.getProjection();
            if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
              resolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, resolution);
              coordinate = proj_transform(coordinate, projectionObj, sourceProjectionObj);
            }
            var extent = getForViewAndSize(coordinate, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);
            var baseParams = {
              "SERVICE": "WMS",
              "VERSION": DEFAULT_WMS_VERSION,
              "REQUEST": "GetFeatureInfo",
              "FORMAT": "image/png",
              "TRANSPARENT": true,
              "QUERY_LAYERS": this.params_["LAYERS"]
            };
            Object(ol_obj["a"])(baseParams, this.params_, params);
            var x = floor((coordinate[0] - extent[0]) / resolution, ImageWMS_DECIMALS);
            var y = floor((extent[3] - coordinate[1]) / resolution, ImageWMS_DECIMALS);
            baseParams[this.v13_ ? "I" : "X"] = x;
            baseParams[this.v13_ ? "J" : "Y"] = y;
            return this.getRequestUrl_(extent, GETFEATUREINFO_IMAGE_SIZE, 1, sourceProjectionObj || projectionObj, baseParams);
          };
          ImageWMS.prototype.getLegendUrl = function(resolution, params) {
            if (this.url_ === void 0) {
              return void 0;
            }
            var baseParams = {
              "SERVICE": "WMS",
              "VERSION": DEFAULT_WMS_VERSION,
              "REQUEST": "GetLegendGraphic",
              "FORMAT": "image/png"
            };
            if (params === void 0 || params["LAYER"] === void 0) {
              var layers = this.params_.LAYERS;
              var isSingleLayer = !Array.isArray(layers) || layers.length === 1;
              if (!isSingleLayer) {
                return void 0;
              }
              baseParams["LAYER"] = layers;
            }
            if (resolution !== void 0) {
              var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
              var pixelSize = 28e-5;
              baseParams["SCALE"] = resolution * mpu / pixelSize;
            }
            Object(ol_obj["a"])(baseParams, params);
            return appendParams(this.url_, baseParams);
          };
          ImageWMS.prototype.getParams = function() {
            return this.params_;
          };
          ImageWMS.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
            if (this.url_ === void 0) {
              return null;
            }
            resolution = this.findNearestResolution(resolution);
            if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
              pixelRatio = 1;
            }
            var imageResolution = resolution / pixelRatio;
            var center = extent_getCenter(extent);
            var viewWidth = ceil(getWidth(extent) / imageResolution, ImageWMS_DECIMALS);
            var viewHeight = ceil(getHeight(extent) / imageResolution, ImageWMS_DECIMALS);
            var viewExtent = getForViewAndSize(center, imageResolution, 0, [
              viewWidth,
              viewHeight
            ]);
            var requestWidth = ceil(this.ratio_ * getWidth(extent) / imageResolution, ImageWMS_DECIMALS);
            var requestHeight = ceil(this.ratio_ * getHeight(extent) / imageResolution, ImageWMS_DECIMALS);
            var requestExtent = getForViewAndSize(center, imageResolution, 0, [
              requestWidth,
              requestHeight
            ]);
            var image = this.image_;
            if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && containsExtent(image.getExtent(), viewExtent)) {
              return image;
            }
            var params = {
              "SERVICE": "WMS",
              "VERSION": DEFAULT_WMS_VERSION,
              "REQUEST": "GetMap",
              "FORMAT": "image/png",
              "TRANSPARENT": true
            };
            Object(ol_obj["a"])(params, this.params_);
            this.imageSize_[0] = round(getWidth(requestExtent) / imageResolution, ImageWMS_DECIMALS);
            this.imageSize_[1] = round(getHeight(requestExtent) / imageResolution, ImageWMS_DECIMALS);
            var url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio, projection, params);
            this.image_ = new ol_Image(requestExtent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
            this.renderedRevision_ = this.getRevision();
            this.image_.addEventListener(EventType["a"].CHANGE, this.handleImageChange.bind(this));
            return this.image_;
          };
          ImageWMS.prototype.getImageLoadFunction = function() {
            return this.imageLoadFunction_;
          };
          ImageWMS.prototype.getRequestUrl_ = function(extent, size, pixelRatio, projection, params) {
            assert2(this.url_ !== void 0, 9);
            params[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
            if (!("STYLES" in this.params_)) {
              params["STYLES"] = "";
            }
            if (pixelRatio != 1) {
              switch (this.serverType_) {
                case WMSServerType.GEOSERVER:
                  var dpi = 90 * pixelRatio + 0.5 | 0;
                  if ("FORMAT_OPTIONS" in params) {
                    params["FORMAT_OPTIONS"] += ";dpi:" + dpi;
                  } else {
                    params["FORMAT_OPTIONS"] = "dpi:" + dpi;
                  }
                  break;
                case WMSServerType.MAPSERVER:
                  params["MAP_RESOLUTION"] = 90 * pixelRatio;
                  break;
                case WMSServerType.CARMENTA_SERVER:
                case WMSServerType.QGIS:
                  params["DPI"] = 90 * pixelRatio;
                  break;
                default:
                  assert2(false, 8);
                  break;
              }
            }
            params["WIDTH"] = size[0];
            params["HEIGHT"] = size[1];
            var axisOrientation = projection.getAxisOrientation();
            var bbox;
            if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
              bbox = [extent[1], extent[0], extent[3], extent[2]];
            } else {
              bbox = extent;
            }
            params["BBOX"] = bbox.join(",");
            return appendParams(this.url_, params);
          };
          ImageWMS.prototype.getUrl = function() {
            return this.url_;
          };
          ImageWMS.prototype.setImageLoadFunction = function(imageLoadFunction) {
            this.image_ = null;
            this.imageLoadFunction_ = imageLoadFunction;
            this.changed();
          };
          ImageWMS.prototype.setUrl = function(url) {
            if (url != this.url_) {
              this.url_ = url;
              this.image_ = null;
              this.changed();
            }
          };
          ImageWMS.prototype.updateParams = function(params) {
            Object(ol_obj["a"])(this.params_, params);
            this.updateV13_();
            this.image_ = null;
            this.changed();
          };
          ImageWMS.prototype.updateV13_ = function() {
            var version = this.params_["VERSION"] || DEFAULT_WMS_VERSION;
            this.v13_ = compareVersions(version, "1.3") >= 0;
          };
          return ImageWMS;
        }(source_Image);
        var source_ImageWMS = ImageWMS_ImageWMS;
        var SourceImageWMSvue_type_script_lang_js = {
          name: "ol-source-image-wms",
          setup: function setup(props) {
            var layer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("imageLayer");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var createSource = function createSource2() {
              return new source_ImageWMS(_objectSpread2(_objectSpread2({}, properties), {}, {
                params: {
                  "LAYERS": props.layers,
                  "STYLES": props.styles,
                  "TIME": props.time
                },
                projection: typeof properties.projection == "string" ? properties.projection : new proj_Projection(_objectSpread2({}, properties.projection))
              }));
            };
            var source = createSource();
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              layer.setSource(null);
              source = createSource();
              layer.setSource(source);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              layer.setSource(source);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              layer.setSource(null);
            });
            return {
              layer,
              source
            };
          },
          props: {
            attributions: {
              type: String
            },
            crossOrigin: {
              type: String
            },
            imageExtent: {
              type: Array
            },
            projection: {
              type: [String, Object],
              default: "EPSG:3857"
            },
            reprojectionErrorThreshold: {
              type: Number,
              default: 0.5
            },
            format: {
              type: String,
              default: "image/png"
            },
            version: {
              type: String,
              default: "1.3.0"
            },
            matrixSet: {
              type: String
            },
            serverType: {
              type: String,
              default: "mapserver"
            },
            imageSmoothing: {
              type: Boolean,
              default: true
            },
            layers: {
              type: [String, Array],
              required: true
            },
            styles: {
              type: [String, Array],
              default: ""
            },
            time: {
              type: String
            },
            ratio: {
              type: Number,
              default: 1
            },
            imageSize: {
              type: Array
            },
            url: {
              type: String
            },
            params: {
              type: Object
            }
          }
        };
        const SourceImageWMS_exports_ = exportHelper_default()(SourceImageWMSvue_type_script_lang_js, [["render", SourceImageWMSvue_type_template_id_41d50b5e_render]]);
        var SourceImageWMS = SourceImageWMS_exports_;
        function sources_install(app) {
          if (sources_install.installed) {
            return;
          }
          sources_install.installed = true;
          app.component(SourceXYZ.name, SourceXYZ);
          app.component(SourceOSM.name, SourceOSM);
          app.component(SourceImageStatic.name, SourceImageStatic);
          app.component(SourceWMTS.name, SourceWMTS);
          app.component(SourceVector.name, SourceVector);
          app.component(SourceCluster.name, SourceCluster);
          app.component(SourceBingMaps.name, SourceBingMaps);
          app.component(SourceTianDiTu.name, SourceTianDiTu);
          app.component(SourceImageWMS.name, SourceImageWMS);
        }
        var components_sources = sources_install;
        var FullScreenControlvue_type_template_id_2df04c6c_lang_true_hoisted_1 = {
          key: 0
        };
        function FullScreenControlvue_type_template_id_2df04c6c_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var FullScreen_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var FullScreen_events = [
          "fullscreenchange",
          "webkitfullscreenchange",
          "MSFullscreenChange"
        ];
        var FullScreenEventType = {
          ENTERFULLSCREEN: "enterfullscreen",
          LEAVEFULLSCREEN: "leavefullscreen"
        };
        var FullScreen_FullScreen = function(_super) {
          FullScreen_extends(FullScreen, _super);
          function FullScreen(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
              element: document.createElement("div"),
              target: options.target
            }) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.cssClassName_ = options.className !== void 0 ? options.className : "ol-full-screen";
            _this.documentListeners_ = [];
            _this.activeClassName_ = options.activeClassName !== void 0 ? options.activeClassName.split(" ") : [_this.cssClassName_ + "-true"];
            _this.inactiveClassName_ = options.inactiveClassName !== void 0 ? options.inactiveClassName.split(" ") : [_this.cssClassName_ + "-false"];
            var label = options.label !== void 0 ? options.label : "\u2922";
            _this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
            var labelActive = options.labelActive !== void 0 ? options.labelActive : "\xD7";
            _this.labelActiveNode_ = typeof labelActive === "string" ? document.createTextNode(labelActive) : labelActive;
            _this.button_ = document.createElement("button");
            var tipLabel = options.tipLabel ? options.tipLabel : "Toggle full-screen";
            _this.button_.setAttribute("type", "button");
            _this.button_.title = tipLabel;
            _this.button_.appendChild(_this.labelNode_);
            _this.button_.addEventListener(EventType["a"].CLICK, _this.handleClick_.bind(_this), false);
            _this.element.className = _this.cssClassName_ + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
            _this.element.appendChild(_this.button_);
            _this.keys_ = options.keys !== void 0 ? options.keys : false;
            _this.source_ = options.source;
            _this.isInFullscreen_ = false;
            _this.boundHandleMapTargetChange_ = _this.handleMapTargetChange_.bind(_this);
            return _this;
          }
          FullScreen.prototype.handleClick_ = function(event) {
            event.preventDefault();
            this.handleFullScreen_();
          };
          FullScreen.prototype.handleFullScreen_ = function() {
            var map = this.getMap();
            if (!map) {
              return;
            }
            var doc = map.getOwnerDocument();
            if (!isFullScreenSupported(doc)) {
              return;
            }
            if (isFullScreen(doc)) {
              exitFullScreen(doc);
            } else {
              var element = void 0;
              if (this.source_) {
                element = typeof this.source_ === "string" ? doc.getElementById(this.source_) : this.source_;
              } else {
                element = map.getTargetElement();
              }
              if (this.keys_) {
                requestFullScreenWithKeys(element);
              } else {
                requestFullScreen(element);
              }
            }
          };
          FullScreen.prototype.handleFullScreenChange_ = function() {
            var map = this.getMap();
            if (!map) {
              return;
            }
            var wasInFullscreen = this.isInFullscreen_;
            this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());
            if (wasInFullscreen !== this.isInFullscreen_) {
              this.setClassName_(this.button_, this.isInFullscreen_);
              if (this.isInFullscreen_) {
                Object(dom["g"])(this.labelActiveNode_, this.labelNode_);
                this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
              } else {
                Object(dom["g"])(this.labelNode_, this.labelActiveNode_);
                this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
              }
              map.updateSize();
            }
          };
          FullScreen.prototype.setClassName_ = function(element, fullscreen) {
            var _a, _b, _c;
            var activeClassName = this.activeClassName_;
            var inactiveClassName = this.inactiveClassName_;
            var nextClassName = fullscreen ? activeClassName : inactiveClassName;
            (_a = element.classList).remove.apply(_a, activeClassName);
            (_b = element.classList).remove.apply(_b, inactiveClassName);
            (_c = element.classList).add.apply(_c, nextClassName);
          };
          FullScreen.prototype.setMap = function(map) {
            var oldMap = this.getMap();
            if (oldMap) {
              oldMap.removeChangeListener(MapProperty.TARGET, this.boundHandleMapTargetChange_);
            }
            _super.prototype.setMap.call(this, map);
            this.handleMapTargetChange_();
            if (map) {
              map.addChangeListener(MapProperty.TARGET, this.boundHandleMapTargetChange_);
            }
          };
          FullScreen.prototype.handleMapTargetChange_ = function() {
            var listeners = this.documentListeners_;
            for (var i = 0, ii = listeners.length; i < ii; ++i) {
              Object(events["c"])(listeners[i]);
            }
            listeners.length = 0;
            var map = this.getMap();
            if (map) {
              var doc = map.getOwnerDocument();
              if (isFullScreenSupported(doc)) {
                this.element.classList.remove(CLASS_UNSUPPORTED);
              } else {
                this.element.classList.add(CLASS_UNSUPPORTED);
              }
              for (var i = 0, ii = FullScreen_events.length; i < ii; ++i) {
                listeners.push(Object(events["a"])(doc, FullScreen_events[i], this.handleFullScreenChange_, this));
              }
              this.handleFullScreenChange_();
            }
          };
          return FullScreen;
        }(Control["default"]);
        function isFullScreenSupported(doc) {
          var body = doc.body;
          return !!(body["webkitRequestFullscreen"] || body["msRequestFullscreen"] && doc["msFullscreenEnabled"] || body.requestFullscreen && doc.fullscreenEnabled);
        }
        function isFullScreen(doc) {
          return !!(doc["webkitIsFullScreen"] || doc["msFullscreenElement"] || doc.fullscreenElement);
        }
        function requestFullScreen(element) {
          if (element.requestFullscreen) {
            element.requestFullscreen();
          } else if (element["msRequestFullscreen"]) {
            element["msRequestFullscreen"]();
          } else if (element["webkitRequestFullscreen"]) {
            element["webkitRequestFullscreen"]();
          }
        }
        function requestFullScreenWithKeys(element) {
          if (element["webkitRequestFullscreen"]) {
            element["webkitRequestFullscreen"]();
          } else {
            requestFullScreen(element);
          }
        }
        function exitFullScreen(doc) {
          if (doc.exitFullscreen) {
            doc.exitFullscreen();
          } else if (doc["msExitFullscreen"]) {
            doc["msExitFullscreen"]();
          } else if (doc["webkitExitFullscreen"]) {
            doc["webkitExitFullscreen"]();
          }
        }
        var control_FullScreen = FullScreen_FullScreen;
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return _arrayLikeToArray(arr);
        }
        var es_array_from = __webpack_require__("a630");
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        var es_array_slice = __webpack_require__("fb6a");
        var es_regexp_test = __webpack_require__("00b4");
        function _unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return _arrayLikeToArray(o, minLen);
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
        }
        var es_array_sort = __webpack_require__("4e82");
        var es_array_find_index = __webpack_require__("c740");
        var es_array_splice = __webpack_require__("a434");
        function useControl(ControlType, props, context) {
          var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
          var controlBar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("controlBar", null);
          var parent = controlBar != null ? controlBar.value : map;
          var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
          var control = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
            return new ControlType(_objectSpread2({}, properties));
          });
          control.value.set("order", context.attrs.order == void 0 ? 0 : context.attrs.order);
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(control, function(newVal, oldVal) {
            if (parent.removeControl) {
              parent.removeControl(oldVal);
              parent.addControl(newVal);
              map.changed();
            }
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
            parent.addControl(control.value);
            if (parent.controls_ != void 0) {
              var sortedControls = _toConsumableArray(parent.controls_);
              sortedControls.sort(function(a, b) {
                return a.get("order") - b.get("order");
              });
              parent.controls_ = [];
              sortedControls.forEach(function(c) {
                parent.addControl(c);
              });
              parent.changed();
            }
            map.changed();
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
            if (parent.removeControl) {
              parent.removeControl(control.value);
            } else {
              var index = parent.controls_.findIndex(function(a) {
                return a == control.value;
              });
              parent.controls_.splice(index, 1);
              control.value.dispose();
            }
            map.changed();
          });
          return {
            map,
            control
          };
        }
        var FullScreenControlvue_type_script_lang_js = {
          name: "ol-fullscreen-control",
          setup: function setup(props, context) {
            var _useControl = useControl(control_FullScreen, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            className: {
              type: String,
              default: "ol-full-screen"
            },
            label: {
              type: String,
              default: "\u2922"
            },
            labelActive: {
              type: String,
              default: "\xD7"
            },
            activeClassName: {
              type: String,
              default: "ol-full-screen-true"
            },
            inactiveClassName: {
              type: String,
              default: "ol-full-screen-false"
            },
            tipLabel: {
              type: String,
              default: "Toggle full-screen"
            },
            keys: {
              type: Boolean,
              default: false
            },
            target: {
              type: Object,
              default: void 0
            },
            source: {
              type: Object,
              default: void 0
            }
          }
        };
        const FullScreenControl_exports_ = exportHelper_default()(FullScreenControlvue_type_script_lang_js, [["render", FullScreenControlvue_type_template_id_2df04c6c_lang_true_render]]);
        var FullScreenControl = FullScreenControl_exports_;
        var MousePositionControlvue_type_template_id_33921f84_lang_true_hoisted_1 = {
          key: 0
        };
        function MousePositionControlvue_type_template_id_33921f84_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var MousePosition_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var PROJECTION = "projection";
        var COORDINATE_FORMAT = "coordinateFormat";
        var MousePosition_MousePosition = function(_super) {
          MousePosition_extends(MousePosition, _super);
          function MousePosition(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var element = document.createElement("div");
            element.className = options.className !== void 0 ? options.className : "ol-mouse-position";
            _this = _super.call(this, {
              element,
              render: options.render,
              target: options.target
            }) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.addChangeListener(PROJECTION, _this.handleProjectionChanged_);
            if (options.coordinateFormat) {
              _this.setCoordinateFormat(options.coordinateFormat);
            }
            if (options.projection) {
              _this.setProjection(options.projection);
            }
            var renderOnMouseOut = true;
            var placeholder = "&#160;";
            if ("undefinedHTML" in options) {
              if (options.undefinedHTML !== void 0) {
                placeholder = options.undefinedHTML;
              }
              renderOnMouseOut = !!placeholder;
            } else if ("placeholder" in options) {
              if (options.placeholder === false) {
                renderOnMouseOut = false;
              } else {
                placeholder = String(options.placeholder);
              }
            }
            _this.placeholder_ = placeholder;
            _this.renderOnMouseOut_ = renderOnMouseOut;
            _this.renderedHTML_ = element.innerHTML;
            _this.mapProjection_ = null;
            _this.transform_ = null;
            return _this;
          }
          MousePosition.prototype.handleProjectionChanged_ = function() {
            this.transform_ = null;
          };
          MousePosition.prototype.getCoordinateFormat = function() {
            return this.get(COORDINATE_FORMAT);
          };
          MousePosition.prototype.getProjection = function() {
            return this.get(PROJECTION);
          };
          MousePosition.prototype.handleMouseMove = function(event) {
            var map = this.getMap();
            this.updateHTML_(map.getEventPixel(event));
          };
          MousePosition.prototype.handleMouseOut = function(event) {
            this.updateHTML_(null);
          };
          MousePosition.prototype.setMap = function(map) {
            _super.prototype.setMap.call(this, map);
            if (map) {
              var viewport = map.getViewport();
              this.listenerKeys.push(Object(events["a"])(viewport, pointer_EventType.POINTERMOVE, this.handleMouseMove, this));
              if (this.renderOnMouseOut_) {
                this.listenerKeys.push(Object(events["a"])(viewport, pointer_EventType.POINTEROUT, this.handleMouseOut, this));
              }
              this.updateHTML_(null);
            }
          };
          MousePosition.prototype.setCoordinateFormat = function(format) {
            this.set(COORDINATE_FORMAT, format);
          };
          MousePosition.prototype.setProjection = function(projection) {
            this.set(PROJECTION, proj_get(projection));
          };
          MousePosition.prototype.updateHTML_ = function(pixel) {
            var html = this.placeholder_;
            if (pixel && this.mapProjection_) {
              if (!this.transform_) {
                var projection = this.getProjection();
                if (projection) {
                  this.transform_ = getTransformFromProjections(this.mapProjection_, projection);
                } else {
                  this.transform_ = identityTransform;
                }
              }
              var map = this.getMap();
              var coordinate = map.getCoordinateFromPixelInternal(pixel);
              if (coordinate) {
                var userProjection = getUserProjection();
                if (userProjection) {
                  this.transform_ = getTransformFromProjections(this.mapProjection_, userProjection);
                }
                this.transform_(coordinate, coordinate);
                var coordinateFormat = this.getCoordinateFormat();
                if (coordinateFormat) {
                  html = coordinateFormat(coordinate);
                } else {
                  html = coordinate.toString();
                }
              }
            }
            if (!this.renderedHTML_ || html !== this.renderedHTML_) {
              this.element.innerHTML = html;
              this.renderedHTML_ = html;
            }
          };
          MousePosition.prototype.render = function(mapEvent) {
            var frameState = mapEvent.frameState;
            if (!frameState) {
              this.mapProjection_ = null;
            } else {
              if (this.mapProjection_ != frameState.viewState.projection) {
                this.mapProjection_ = frameState.viewState.projection;
                this.transform_ = null;
              }
            }
          };
          return MousePosition;
        }(Control["default"]);
        var control_MousePosition = MousePosition_MousePosition;
        var MousePositionControlvue_type_script_lang_js = {
          name: "ol-mouseposition-control",
          setup: function setup(props, context) {
            var _useControl = useControl(control_MousePosition, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            className: {
              type: String,
              default: "ol-mouse-position"
            },
            coordinateFormat: {
              type: [String, Function]
            },
            projection: {
              type: String
            },
            render: {
              type: Function
            },
            target: {
              type: HTMLElement
            },
            undefinedHTML: {
              type: String,
              default: "&#160;"
            }
          }
        };
        const MousePositionControl_exports_ = exportHelper_default()(MousePositionControlvue_type_script_lang_js, [["render", MousePositionControlvue_type_template_id_33921f84_lang_true_render]]);
        var MousePositionControl = MousePositionControl_exports_;
        var AttributionControlvue_type_template_id_1ad411f8_lang_true_hoisted_1 = {
          key: 0
        };
        function AttributionControlvue_type_template_id_1ad411f8_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var AttributionControlvue_type_script_lang_js = {
          name: "ol-attribution-control",
          setup: function setup(props, context) {
            var _useControl = useControl(control_Attribution, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            className: {
              type: String,
              default: "ol-attribution"
            },
            target: {
              type: HTMLElement
            },
            collapsible: {
              type: Boolean
            },
            collapsed: {
              type: Boolean,
              default: true
            },
            tipLabel: {
              type: String,
              default: "Attributions"
            },
            label: {
              type: String,
              default: "i"
            },
            expandClassName: {
              type: String,
              default: "ol-attribution-expand"
            },
            collapseLabel: {
              type: String,
              default: "\xBB"
            },
            collapseClassName: {
              type: String,
              default: "ol-attribution-collapse"
            },
            render: {
              type: Function
            }
          }
        };
        const AttributionControl_exports_ = exportHelper_default()(AttributionControlvue_type_script_lang_js, [["render", AttributionControlvue_type_template_id_1ad411f8_lang_true_render]]);
        var AttributionControl = AttributionControl_exports_;
        function OverviewMapControlvue_type_template_id_fa457348_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var OverviewMap_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var MAX_RATIO = 0.75;
        var MIN_RATIO = 0.1;
        var OverviewMap_ControlledMap = function(_super) {
          OverviewMap_extends(ControlledMap, _super);
          function ControlledMap() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          ControlledMap.prototype.createRenderer = function() {
            return new Composite(this);
          };
          return ControlledMap;
        }(ol_PluggableMap);
        var OverviewMap_OverviewMap = function(_super) {
          OverviewMap_extends(OverviewMap, _super);
          function OverviewMap(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
              element: document.createElement("div"),
              render: options.render,
              target: options.target
            }) || this;
            _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
            _this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
            _this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
            if (!_this.collapsible_) {
              _this.collapsed_ = false;
            }
            _this.rotateWithView_ = options.rotateWithView !== void 0 ? options.rotateWithView : false;
            _this.viewExtent_ = void 0;
            var className = options.className !== void 0 ? options.className : "ol-overviewmap";
            var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Overview map";
            var collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u2039";
            if (typeof collapseLabel === "string") {
              _this.collapseLabel_ = document.createElement("span");
              _this.collapseLabel_.textContent = collapseLabel;
            } else {
              _this.collapseLabel_ = collapseLabel;
            }
            var label = options.label !== void 0 ? options.label : "\u203A";
            if (typeof label === "string") {
              _this.label_ = document.createElement("span");
              _this.label_.textContent = label;
            } else {
              _this.label_ = label;
            }
            var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
            var button = document.createElement("button");
            button.setAttribute("type", "button");
            button.title = tipLabel;
            button.appendChild(activeLabel);
            button.addEventListener(EventType["a"].CLICK, _this.handleClick_.bind(_this), false);
            _this.ovmapDiv_ = document.createElement("div");
            _this.ovmapDiv_.className = "ol-overviewmap-map";
            _this.view_ = options.view;
            _this.ovmap_ = new OverviewMap_ControlledMap({
              view: options.view
            });
            var ovmap = _this.ovmap_;
            if (options.layers) {
              options.layers.forEach(function(layer) {
                ovmap.addLayer(layer);
              });
            }
            var box = document.createElement("div");
            box.className = "ol-overviewmap-box";
            box.style.boxSizing = "border-box";
            _this.boxOverlay_ = new ol_Overlay({
              position: [0, 0],
              positioning: OverlayPositioning.CENTER_CENTER,
              element: box
            });
            _this.ovmap_.addOverlay(_this.boxOverlay_);
            var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (_this.collapsible_ ? "" : " ol-uncollapsible");
            var element = _this.element;
            element.className = cssClasses;
            element.appendChild(_this.ovmapDiv_);
            element.appendChild(button);
            var scope = _this;
            var overlay = _this.boxOverlay_;
            var overlayBox = _this.boxOverlay_.getElement();
            var computeDesiredMousePosition = function(mousePosition) {
              return {
                clientX: mousePosition.clientX,
                clientY: mousePosition.clientY
              };
            };
            var move = function(event) {
              var position = computeDesiredMousePosition(event);
              var coordinates = ovmap.getEventCoordinateInternal(position);
              overlay.setPosition(coordinates);
            };
            var endMoving = function(event) {
              var coordinates = ovmap.getEventCoordinateInternal(event);
              scope.getMap().getView().setCenterInternal(coordinates);
              window.removeEventListener("mousemove", move);
              window.removeEventListener("mouseup", endMoving);
            };
            overlayBox.addEventListener("mousedown", function() {
              window.addEventListener("mousemove", move);
              window.addEventListener("mouseup", endMoving);
            });
            return _this;
          }
          OverviewMap.prototype.setMap = function(map) {
            var oldMap = this.getMap();
            if (map === oldMap) {
              return;
            }
            if (oldMap) {
              var oldView = oldMap.getView();
              if (oldView) {
                this.unbindView_(oldView);
              }
              this.ovmap_.setTarget(null);
            }
            _super.prototype.setMap.call(this, map);
            if (map) {
              this.ovmap_.setTarget(this.ovmapDiv_);
              this.listenerKeys.push(Object(events["a"])(map, ObjectEventType["a"].PROPERTYCHANGE, this.handleMapPropertyChange_, this));
              var view = map.getView();
              if (view) {
                this.bindView_(view);
                if (view.isDef()) {
                  this.ovmap_.updateSize();
                  this.resetExtent_();
                }
              }
              if (!this.ovmap_.isRendered()) {
                this.updateBoxAfterOvmapIsRendered_();
              }
            }
          };
          OverviewMap.prototype.handleMapPropertyChange_ = function(event) {
            if (event.key === MapProperty.VIEW) {
              var oldView = event.oldValue;
              if (oldView) {
                this.unbindView_(oldView);
              }
              var newView = this.getMap().getView();
              this.bindView_(newView);
            } else if (!this.ovmap_.isRendered() && (event.key === MapProperty.TARGET || event.key === MapProperty.SIZE)) {
              this.ovmap_.updateSize();
            }
          };
          OverviewMap.prototype.bindView_ = function(view) {
            if (!this.view_) {
              var newView = new ol_View({
                projection: view.getProjection()
              });
              this.ovmap_.setView(newView);
            }
            view.addChangeListener(ViewProperty.ROTATION, this.boundHandleRotationChanged_);
            this.handleRotationChanged_();
          };
          OverviewMap.prototype.unbindView_ = function(view) {
            view.removeChangeListener(ViewProperty.ROTATION, this.boundHandleRotationChanged_);
          };
          OverviewMap.prototype.handleRotationChanged_ = function() {
            if (this.rotateWithView_) {
              this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
            }
          };
          OverviewMap.prototype.validateExtent_ = function() {
            var map = this.getMap();
            var ovmap = this.ovmap_;
            if (!map.isRendered() || !ovmap.isRendered()) {
              return;
            }
            var mapSize = map.getSize();
            var view = map.getView();
            var extent = view.calculateExtentInternal(mapSize);
            if (this.viewExtent_ && equals(extent, this.viewExtent_)) {
              return;
            }
            this.viewExtent_ = extent;
            var ovmapSize = ovmap.getSize();
            var ovview = ovmap.getView();
            var ovextent = ovview.calculateExtentInternal(ovmapSize);
            var topLeftPixel = ovmap.getPixelFromCoordinateInternal(getTopLeft(extent));
            var bottomRightPixel = ovmap.getPixelFromCoordinateInternal(getBottomRight(extent));
            var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
            var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
            var ovmapWidth = ovmapSize[0];
            var ovmapHeight = ovmapSize[1];
            if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {
              this.resetExtent_();
            } else if (!containsExtent(ovextent, extent)) {
              this.recenter_();
            }
          };
          OverviewMap.prototype.resetExtent_ = function() {
            if (MAX_RATIO === 0 || MIN_RATIO === 0) {
              return;
            }
            var map = this.getMap();
            var ovmap = this.ovmap_;
            var mapSize = map.getSize();
            var view = map.getView();
            var extent = view.calculateExtentInternal(mapSize);
            var ovview = ovmap.getView();
            var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
            var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
            scaleFromCenter(extent, ratio);
            ovview.fitInternal(fromExtent(extent));
          };
          OverviewMap.prototype.recenter_ = function() {
            var map = this.getMap();
            var ovmap = this.ovmap_;
            var view = map.getView();
            var ovview = ovmap.getView();
            ovview.setCenterInternal(view.getCenterInternal());
          };
          OverviewMap.prototype.updateBox_ = function() {
            var map = this.getMap();
            var ovmap = this.ovmap_;
            if (!map.isRendered() || !ovmap.isRendered()) {
              return;
            }
            var mapSize = map.getSize();
            var view = map.getView();
            var ovview = ovmap.getView();
            var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
            var overlay = this.boxOverlay_;
            var box = this.boxOverlay_.getElement();
            var center = view.getCenterInternal();
            var resolution = view.getResolution();
            var ovresolution = ovview.getResolution();
            var width = mapSize[0] * resolution / ovresolution;
            var height = mapSize[1] * resolution / ovresolution;
            overlay.setPosition(center);
            if (box) {
              box.style.width = width + "px";
              box.style.height = height + "px";
              var transform2 = "rotate(" + rotation + "rad)";
              box.style.transform = transform2;
            }
          };
          OverviewMap.prototype.updateBoxAfterOvmapIsRendered_ = function() {
            if (this.ovmapPostrenderKey_) {
              return;
            }
            this.ovmapPostrenderKey_ = Object(events["b"])(this.ovmap_, MapEventType["a"].POSTRENDER, function(event) {
              delete this.ovmapPostrenderKey_;
              this.updateBox_();
            }, this);
          };
          OverviewMap.prototype.handleClick_ = function(event) {
            event.preventDefault();
            this.handleToggle_();
          };
          OverviewMap.prototype.handleToggle_ = function() {
            this.element.classList.toggle(CLASS_COLLAPSED);
            if (this.collapsed_) {
              Object(dom["g"])(this.collapseLabel_, this.label_);
            } else {
              Object(dom["g"])(this.label_, this.collapseLabel_);
            }
            this.collapsed_ = !this.collapsed_;
            var ovmap = this.ovmap_;
            if (!this.collapsed_) {
              if (ovmap.isRendered()) {
                this.viewExtent_ = void 0;
                ovmap.render();
                return;
              }
              ovmap.updateSize();
              this.resetExtent_();
              this.updateBoxAfterOvmapIsRendered_();
            }
          };
          OverviewMap.prototype.getCollapsible = function() {
            return this.collapsible_;
          };
          OverviewMap.prototype.setCollapsible = function(collapsible) {
            if (this.collapsible_ === collapsible) {
              return;
            }
            this.collapsible_ = collapsible;
            this.element.classList.toggle("ol-uncollapsible");
            if (!collapsible && this.collapsed_) {
              this.handleToggle_();
            }
          };
          OverviewMap.prototype.setCollapsed = function(collapsed) {
            if (!this.collapsible_ || this.collapsed_ === collapsed) {
              return;
            }
            this.handleToggle_();
          };
          OverviewMap.prototype.getCollapsed = function() {
            return this.collapsed_;
          };
          OverviewMap.prototype.getRotateWithView = function() {
            return this.rotateWithView_;
          };
          OverviewMap.prototype.setRotateWithView = function(rotateWithView) {
            if (this.rotateWithView_ === rotateWithView) {
              return;
            }
            this.rotateWithView_ = rotateWithView;
            if (this.getMap().getView().getRotation() !== 0) {
              if (this.rotateWithView_) {
                this.handleRotationChanged_();
              } else {
                this.ovmap_.getView().setRotation(0);
              }
              this.viewExtent_ = void 0;
              this.validateExtent_();
              this.updateBox_();
            }
          };
          OverviewMap.prototype.getOverviewMap = function() {
            return this.ovmap_;
          };
          OverviewMap.prototype.render = function(mapEvent) {
            this.validateExtent_();
            this.updateBox_();
          };
          return OverviewMap;
        }(Control["default"]);
        var control_OverviewMap = OverviewMap_OverviewMap;
        var OverviewMapControlvue_type_script_lang_js = {
          name: "ol-overviewmap-control",
          setup: function setup(props, context) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var _useControl = useControl(control_OverviewMap, props, context), control = _useControl.control;
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              control.value.setMap(map);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              control.value.setMap(null);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("overviewMap", control);
            return {
              control
            };
          },
          props: {
            className: {
              type: String,
              default: "ol-overviewmap"
            },
            collapsed: {
              type: Boolean,
              default: true
            },
            collapseLabel: {
              type: String,
              default: "\xAB"
            },
            collapsible: {
              type: Boolean,
              default: true
            },
            label: {
              type: String,
              default: "\xBB"
            },
            render: {
              type: Function
            },
            rotateWithView: {
              type: Boolean,
              default: false
            },
            target: {
              type: HTMLElement
            },
            tipLabel: {
              type: String,
              default: "Overview map"
            }
          }
        };
        const OverviewMapControl_exports_ = exportHelper_default()(OverviewMapControlvue_type_script_lang_js, [["render", OverviewMapControlvue_type_template_id_fa457348_lang_true_render]]);
        var OverviewMapControl = OverviewMapControl_exports_;
        var ScaleLineControlvue_type_template_id_064a324d_lang_true_hoisted_1 = {
          key: 0
        };
        function ScaleLineControlvue_type_template_id_064a324d_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ScaleLine_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var UNITS_PROP = "units";
        var ScaleLine_Units = {
          DEGREES: "degrees",
          IMPERIAL: "imperial",
          NAUTICAL: "nautical",
          METRIC: "metric",
          US: "us"
        };
        var LEADING_DIGITS = [1, 2, 5];
        var DEFAULT_DPI = 25.4 / 0.28;
        var ScaleLine_ScaleLine = function(_super) {
          ScaleLine_extends(ScaleLine, _super);
          function ScaleLine(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var className = options.className !== void 0 ? options.className : options.bar ? "ol-scale-bar" : "ol-scale-line";
            _this = _super.call(this, {
              element: document.createElement("div"),
              render: options.render,
              target: options.target
            }) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.innerElement_ = document.createElement("div");
            _this.innerElement_.className = className + "-inner";
            _this.element.className = className + " " + CLASS_UNSELECTABLE;
            _this.element.appendChild(_this.innerElement_);
            _this.viewState_ = null;
            _this.minWidth_ = options.minWidth !== void 0 ? options.minWidth : 64;
            _this.renderedVisible_ = false;
            _this.renderedWidth_ = void 0;
            _this.renderedHTML_ = "";
            _this.addChangeListener(UNITS_PROP, _this.handleUnitsChanged_);
            _this.setUnits(options.units || ScaleLine_Units.METRIC);
            _this.scaleBar_ = options.bar || false;
            _this.scaleBarSteps_ = options.steps || 4;
            _this.scaleBarText_ = options.text || false;
            _this.dpi_ = options.dpi || void 0;
            return _this;
          }
          ScaleLine.prototype.getUnits = function() {
            return this.get(UNITS_PROP);
          };
          ScaleLine.prototype.handleUnitsChanged_ = function() {
            this.updateElement_();
          };
          ScaleLine.prototype.setUnits = function(units) {
            this.set(UNITS_PROP, units);
          };
          ScaleLine.prototype.setDpi = function(dpi) {
            this.dpi_ = dpi;
          };
          ScaleLine.prototype.updateElement_ = function() {
            var viewState = this.viewState_;
            if (!viewState) {
              if (this.renderedVisible_) {
                this.element.style.display = "none";
                this.renderedVisible_ = false;
              }
              return;
            }
            var center = viewState.center;
            var projection = viewState.projection;
            var units = this.getUnits();
            var pointResolutionUnits = units == ScaleLine_Units.DEGREES ? proj_Units.DEGREES : proj_Units.METERS;
            var pointResolution = getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);
            var minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
            var nominalCount = minWidth * pointResolution;
            var suffix = "";
            if (units == ScaleLine_Units.DEGREES) {
              var metersPerDegree = METERS_PER_UNIT[proj_Units.DEGREES];
              nominalCount *= metersPerDegree;
              if (nominalCount < metersPerDegree / 60) {
                suffix = "\u2033";
                pointResolution *= 3600;
              } else if (nominalCount < metersPerDegree) {
                suffix = "\u2032";
                pointResolution *= 60;
              } else {
                suffix = "\xB0";
              }
            } else if (units == ScaleLine_Units.IMPERIAL) {
              if (nominalCount < 0.9144) {
                suffix = "in";
                pointResolution /= 0.0254;
              } else if (nominalCount < 1609.344) {
                suffix = "ft";
                pointResolution /= 0.3048;
              } else {
                suffix = "mi";
                pointResolution /= 1609.344;
              }
            } else if (units == ScaleLine_Units.NAUTICAL) {
              pointResolution /= 1852;
              suffix = "nm";
            } else if (units == ScaleLine_Units.METRIC) {
              if (nominalCount < 1e-3) {
                suffix = "\u03BCm";
                pointResolution *= 1e6;
              } else if (nominalCount < 1) {
                suffix = "mm";
                pointResolution *= 1e3;
              } else if (nominalCount < 1e3) {
                suffix = "m";
              } else {
                suffix = "km";
                pointResolution /= 1e3;
              }
            } else if (units == ScaleLine_Units.US) {
              if (nominalCount < 0.9144) {
                suffix = "in";
                pointResolution *= 39.37;
              } else if (nominalCount < 1609.344) {
                suffix = "ft";
                pointResolution /= 0.30480061;
              } else {
                suffix = "mi";
                pointResolution /= 1609.3472;
              }
            } else {
              assert2(false, 33);
            }
            var i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
            var count, width, decimalCount;
            while (true) {
              decimalCount = Math.floor(i / 3);
              var decimal = Math.pow(10, decimalCount);
              count = LEADING_DIGITS[(i % 3 + 3) % 3] * decimal;
              width = Math.round(count / pointResolution);
              if (isNaN(width)) {
                this.element.style.display = "none";
                this.renderedVisible_ = false;
                return;
              } else if (width >= minWidth) {
                break;
              }
              ++i;
            }
            var html;
            if (this.scaleBar_) {
              html = this.createScaleBar(width, count, suffix);
            } else {
              html = count.toFixed(decimalCount < 0 ? -decimalCount : 0) + " " + suffix;
            }
            if (this.renderedHTML_ != html) {
              this.innerElement_.innerHTML = html;
              this.renderedHTML_ = html;
            }
            if (this.renderedWidth_ != width) {
              this.innerElement_.style.width = width + "px";
              this.renderedWidth_ = width;
            }
            if (!this.renderedVisible_) {
              this.element.style.display = "";
              this.renderedVisible_ = true;
            }
          };
          ScaleLine.prototype.createScaleBar = function(width, scale, suffix) {
            var mapScale = "1 : " + Math.round(this.getScaleForResolution()).toLocaleString();
            var scaleSteps = [];
            var stepWidth = width / this.scaleBarSteps_;
            var backgroundColor = "#ffffff";
            for (var i = 0; i < this.scaleBarSteps_; i++) {
              if (i === 0) {
                scaleSteps.push(this.createMarker("absolute", i));
              }
              scaleSteps.push('<div><div class="ol-scale-singlebar" style="width: ' + stepWidth + "px;background-color: " + backgroundColor + ';"></div>' + this.createMarker("relative", i) + (i % 2 === 0 || this.scaleBarSteps_ === 2 ? this.createStepText(i, width, false, scale, suffix) : "") + "</div>");
              if (i === this.scaleBarSteps_ - 1) {
                {
                }
                scaleSteps.push(this.createStepText(i + 1, width, true, scale, suffix));
              }
              if (backgroundColor === "#ffffff") {
                backgroundColor = "#000000";
              } else {
                backgroundColor = "#ffffff";
              }
            }
            var scaleBarText;
            if (this.scaleBarText_) {
              scaleBarText = '<div class="ol-scale-text" style="width: ' + width + 'px;">' + mapScale + "</div>";
            } else {
              scaleBarText = "";
            }
            var container = '<div style="display: flex;">' + scaleBarText + scaleSteps.join("") + "</div>";
            return container;
          };
          ScaleLine.prototype.createMarker = function(position, i) {
            var top = position === "absolute" ? 3 : -10;
            return '<div class="ol-scale-step-marker" style="position: ' + position + ";top: " + top + 'px;"></div>';
          };
          ScaleLine.prototype.createStepText = function(i, width, isLast, scale, suffix) {
            var length = i === 0 ? 0 : Math.round(scale / this.scaleBarSteps_ * i * 100) / 100;
            var lengthString = length + (i === 0 ? "" : " " + suffix);
            var margin = i === 0 ? -3 : width / this.scaleBarSteps_ * -1;
            var minWidth = i === 0 ? 0 : width / this.scaleBarSteps_ * 2;
            return '<div class="ol-scale-step-text" style="margin-left: ' + margin + "px;text-align: " + (i === 0 ? "left" : "center") + "; min-width: " + minWidth + "px;left: " + (isLast ? width + "px" : "unset") + ';">' + lengthString + "</div>";
          };
          ScaleLine.prototype.getScaleForResolution = function() {
            var resolution = getPointResolution(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center, proj_Units.METERS);
            var dpi = this.dpi_ || DEFAULT_DPI;
            var inchesPerMeter = 1e3 / 25.4;
            return parseFloat(resolution.toString()) * inchesPerMeter * dpi;
          };
          ScaleLine.prototype.render = function(mapEvent) {
            var frameState = mapEvent.frameState;
            if (!frameState) {
              this.viewState_ = null;
            } else {
              this.viewState_ = frameState.viewState;
            }
            this.updateElement_();
          };
          return ScaleLine;
        }(Control["default"]);
        var control_ScaleLine = ScaleLine_ScaleLine;
        var ScaleLineControlvue_type_script_lang_js = {
          name: "ol-scaleline-control",
          setup: function setup(props, context) {
            var _useControl = useControl(control_ScaleLine, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            className: {
              type: String,
              default: "ol-scale-line"
            },
            minWidth: {
              type: Number,
              default: 64
            },
            render: {
              type: Function
            },
            target: {
              type: HTMLElement
            },
            units: {
              type: String,
              default: "metric"
            },
            bar: {
              type: Boolean,
              default: false
            },
            steps: {
              type: Number,
              default: 4
            },
            text: {
              type: Boolean,
              default: false
            },
            dpi: {
              type: Number,
              default: void 0
            }
          }
        };
        const ScaleLineControl_exports_ = exportHelper_default()(ScaleLineControlvue_type_script_lang_js, [["render", ScaleLineControlvue_type_template_id_064a324d_lang_true_render]]);
        var ScaleLineControl = ScaleLineControl_exports_;
        var ZoomControlvue_type_template_id_0d9eb60d_lang_true_hoisted_1 = {
          key: 0
        };
        function ZoomControlvue_type_template_id_0d9eb60d_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ZoomControlvue_type_script_lang_js = {
          name: "ol-zoom-control",
          setup: function setup(props, context) {
            var _useControl = useControl(control_Zoom, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            duration: {
              type: Number,
              default: 250
            },
            className: {
              type: String,
              default: "ol-zoom"
            },
            zoomInClassName: {
              type: String,
              default: "ol-zoom-in"
            },
            zoomOutClassName: {
              type: String,
              default: "ol-zoom-out"
            },
            zoomInLabel: {
              type: String,
              default: "+"
            },
            zoomOutLabel: {
              type: String,
              default: "-"
            },
            zoomInTipLabel: {
              type: String,
              default: "Zoom in"
            },
            zoomOutTipLabel: {
              type: String,
              default: "Zoom Out"
            },
            delta: {
              type: Number,
              default: 1
            },
            target: {
              type: HTMLElement
            }
          }
        };
        const ZoomControl_exports_ = exportHelper_default()(ZoomControlvue_type_script_lang_js, [["render", ZoomControlvue_type_template_id_0d9eb60d_lang_true_render]]);
        var ZoomControl = ZoomControl_exports_;
        var ZoomSliderControlvue_type_template_id_221f78f4_lang_true_hoisted_1 = {
          key: 0
        };
        function ZoomSliderControlvue_type_template_id_221f78f4_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ZoomSlider_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Direction = {
          VERTICAL: 0,
          HORIZONTAL: 1
        };
        var ZoomSlider_ZoomSlider = function(_super) {
          ZoomSlider_extends(ZoomSlider, _super);
          function ZoomSlider(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
              element: document.createElement("div"),
              render: options.render
            }) || this;
            _this.dragListenerKeys_ = [];
            _this.currentResolution_ = void 0;
            _this.direction_ = Direction.VERTICAL;
            _this.dragging_;
            _this.heightLimit_ = 0;
            _this.widthLimit_ = 0;
            _this.startX_;
            _this.startY_;
            _this.thumbSize_ = null;
            _this.sliderInitialized_ = false;
            _this.duration_ = options.duration !== void 0 ? options.duration : 200;
            var className = options.className !== void 0 ? options.className : "ol-zoomslider";
            var thumbElement = document.createElement("button");
            thumbElement.setAttribute("type", "button");
            thumbElement.className = className + "-thumb " + CLASS_UNSELECTABLE;
            var containerElement = _this.element;
            containerElement.className = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
            containerElement.appendChild(thumbElement);
            containerElement.addEventListener(pointer_EventType.POINTERDOWN, _this.handleDraggerStart_.bind(_this), false);
            containerElement.addEventListener(pointer_EventType.POINTERMOVE, _this.handleDraggerDrag_.bind(_this), false);
            containerElement.addEventListener(pointer_EventType.POINTERUP, _this.handleDraggerEnd_.bind(_this), false);
            containerElement.addEventListener(EventType["a"].CLICK, _this.handleContainerClick_.bind(_this), false);
            thumbElement.addEventListener(EventType["a"].CLICK, events_Event["b"], false);
            return _this;
          }
          ZoomSlider.prototype.setMap = function(map) {
            _super.prototype.setMap.call(this, map);
            if (map) {
              map.render();
            }
          };
          ZoomSlider.prototype.initSlider_ = function() {
            var container = this.element;
            var containerWidth = container.offsetWidth;
            var containerHeight = container.offsetHeight;
            if (containerWidth === 0 && containerHeight === 0) {
              return this.sliderInitialized_ = false;
            }
            var containerStyle = getComputedStyle(container);
            containerWidth -= parseFloat(containerStyle["paddingRight"]) + parseFloat(containerStyle["paddingLeft"]);
            containerHeight -= parseFloat(containerStyle["paddingTop"]) + parseFloat(containerStyle["paddingBottom"]);
            var thumb = container.firstElementChild;
            var thumbStyle = getComputedStyle(thumb);
            var thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle["marginRight"]) + parseFloat(thumbStyle["marginLeft"]);
            var thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle["marginTop"]) + parseFloat(thumbStyle["marginBottom"]);
            this.thumbSize_ = [thumbWidth, thumbHeight];
            if (containerWidth > containerHeight) {
              this.direction_ = Direction.HORIZONTAL;
              this.widthLimit_ = containerWidth - thumbWidth;
            } else {
              this.direction_ = Direction.VERTICAL;
              this.heightLimit_ = containerHeight - thumbHeight;
            }
            return this.sliderInitialized_ = true;
          };
          ZoomSlider.prototype.handleContainerClick_ = function(event) {
            var view = this.getMap().getView();
            var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
            var resolution = this.getResolutionForPosition_(relativePosition);
            var zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
            view.animateInternal({
              zoom,
              duration: this.duration_,
              easing: easeOut
            });
          };
          ZoomSlider.prototype.handleDraggerStart_ = function(event) {
            if (!this.dragging_ && event.target === this.element.firstElementChild) {
              var element = this.element.firstElementChild;
              this.getMap().getView().beginInteraction();
              this.startX_ = event.clientX - parseFloat(element.style.left);
              this.startY_ = event.clientY - parseFloat(element.style.top);
              this.dragging_ = true;
              if (this.dragListenerKeys_.length === 0) {
                var drag = this.handleDraggerDrag_;
                var end = this.handleDraggerEnd_;
                var doc = this.getMap().getOwnerDocument();
                this.dragListenerKeys_.push(Object(events["a"])(doc, pointer_EventType.POINTERMOVE, drag, this), Object(events["a"])(doc, pointer_EventType.POINTERUP, end, this));
              }
            }
          };
          ZoomSlider.prototype.handleDraggerDrag_ = function(event) {
            if (this.dragging_) {
              var deltaX = event.clientX - this.startX_;
              var deltaY = event.clientY - this.startY_;
              var relativePosition = this.getRelativePosition_(deltaX, deltaY);
              this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
              this.getMap().getView().setResolution(this.currentResolution_);
            }
          };
          ZoomSlider.prototype.handleDraggerEnd_ = function(event) {
            if (this.dragging_) {
              var view = this.getMap().getView();
              view.endInteraction();
              this.dragging_ = false;
              this.startX_ = void 0;
              this.startY_ = void 0;
              this.dragListenerKeys_.forEach(events["c"]);
              this.dragListenerKeys_.length = 0;
            }
          };
          ZoomSlider.prototype.setThumbPosition_ = function(res) {
            var position = this.getPositionForResolution_(res);
            var thumb = this.element.firstElementChild;
            if (this.direction_ == Direction.HORIZONTAL) {
              thumb.style.left = this.widthLimit_ * position + "px";
            } else {
              thumb.style.top = this.heightLimit_ * position + "px";
            }
          };
          ZoomSlider.prototype.getRelativePosition_ = function(x, y) {
            var amount;
            if (this.direction_ === Direction.HORIZONTAL) {
              amount = x / this.widthLimit_;
            } else {
              amount = y / this.heightLimit_;
            }
            return clamp(amount, 0, 1);
          };
          ZoomSlider.prototype.getResolutionForPosition_ = function(position) {
            var fn = this.getMap().getView().getResolutionForValueFunction();
            return fn(1 - position);
          };
          ZoomSlider.prototype.getPositionForResolution_ = function(res) {
            var fn = this.getMap().getView().getValueForResolutionFunction();
            return clamp(1 - fn(res), 0, 1);
          };
          ZoomSlider.prototype.render = function(mapEvent) {
            if (!mapEvent.frameState) {
              return;
            }
            if (!this.sliderInitialized_ && !this.initSlider_()) {
              return;
            }
            var res = mapEvent.frameState.viewState.resolution;
            this.currentResolution_ = res;
            this.setThumbPosition_(res);
          };
          return ZoomSlider;
        }(Control["default"]);
        var control_ZoomSlider = ZoomSlider_ZoomSlider;
        var ZoomSliderControlvue_type_script_lang_js = {
          name: "ol-zoomslider-control",
          setup: function setup(props, context) {
            var _useControl = useControl(control_ZoomSlider, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            duration: {
              type: Number,
              default: 200
            },
            className: {
              type: String,
              default: "ol-zoomslider"
            },
            render: {
              type: Function
            }
          }
        };
        const ZoomSliderControl_exports_ = exportHelper_default()(ZoomSliderControlvue_type_script_lang_js, [["render", ZoomSliderControlvue_type_template_id_221f78f4_lang_true_render]]);
        var ZoomSliderControl = ZoomSliderControl_exports_;
        var ZoomToExtentControlvue_type_template_id_3fb3b3c6_lang_true_hoisted_1 = {
          key: 0
        };
        function ZoomToExtentControlvue_type_template_id_3fb3b3c6_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ZoomToExtent_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ZoomToExtent_ZoomToExtent = function(_super) {
          ZoomToExtent_extends(ZoomToExtent, _super);
          function ZoomToExtent(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, {
              element: document.createElement("div"),
              target: options.target
            }) || this;
            _this.extent = options.extent ? options.extent : null;
            var className = options.className !== void 0 ? options.className : "ol-zoom-extent";
            var label = options.label !== void 0 ? options.label : "E";
            var tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Fit to extent";
            var button = document.createElement("button");
            button.setAttribute("type", "button");
            button.title = tipLabel;
            button.appendChild(typeof label === "string" ? document.createTextNode(label) : label);
            button.addEventListener(EventType["a"].CLICK, _this.handleClick_.bind(_this), false);
            var cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
            var element = _this.element;
            element.className = cssClasses;
            element.appendChild(button);
            return _this;
          }
          ZoomToExtent.prototype.handleClick_ = function(event) {
            event.preventDefault();
            this.handleZoomToExtent();
          };
          ZoomToExtent.prototype.handleZoomToExtent = function() {
            var map = this.getMap();
            var view = map.getView();
            var extent = !this.extent ? view.getProjection().getExtent() : this.extent;
            view.fitInternal(fromExtent(extent));
          };
          return ZoomToExtent;
        }(Control["default"]);
        var control_ZoomToExtent = ZoomToExtent_ZoomToExtent;
        var ZoomToExtentControlvue_type_script_lang_js = {
          name: "ol-zoomtoextent-control",
          setup: function setup(props, context) {
            var _useControl = useControl(control_ZoomToExtent, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            className: {
              type: String,
              default: "ol-zoom-extent"
            },
            target: {
              type: HTMLElement
            },
            label: {
              type: String,
              default: "E"
            },
            tipLabel: {
              type: String,
              default: "Fit to extent"
            },
            extent: {
              type: Array
            }
          }
        };
        const ZoomToExtentControl_exports_ = exportHelper_default()(ZoomToExtentControlvue_type_script_lang_js, [["render", ZoomToExtentControlvue_type_template_id_3fb3b3c6_lang_true_render]]);
        var ZoomToExtentControl = ZoomToExtentControl_exports_;
        var RotateControlvue_type_template_id_2b556252_lang_true_hoisted_1 = {
          key: 0
        };
        function RotateControlvue_type_template_id_2b556252_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var RotateControlvue_type_script_lang_js = {
          name: "ol-rotate-control",
          setup: function setup(props, context) {
            var _useControl = useControl(control_Rotate, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            className: {
              type: String,
              default: "ol-rotate"
            },
            label: {
              type: String,
              default: "\u21E7"
            },
            tipLabel: {
              type: String,
              default: "Reset rotation"
            },
            compassClassName: {
              type: String,
              default: "ol-compass"
            },
            duration: {
              type: Number,
              default: 250
            },
            autoHide: {
              type: Boolean,
              default: false
            },
            render: {
              type: Function
            },
            resetNorth: {
              type: Function
            },
            target: {
              type: HTMLElement
            }
          }
        };
        const RotateControl_exports_ = exportHelper_default()(RotateControlvue_type_script_lang_js, [["render", RotateControlvue_type_template_id_2b556252_lang_true_render]]);
        var RotateControl = RotateControl_exports_;
        var ContextMenuControlvue_type_template_id_2ce675b2_lang_true_hoisted_1 = {
          key: 0
        };
        function ContextMenuControlvue_type_template_id_2ce675b2_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ol_contextmenu = __webpack_require__("658f");
        var ol_contextmenu_default = __webpack_require__.n(ol_contextmenu);
        var ContextMenuControlvue_type_script_lang_js = {
          name: "ol-context-menu",
          setup: function setup(props, context) {
            var _useControl = useControl(ol_contextmenu_default.a, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            eventType: {
              type: String,
              default: "contextmenu"
            },
            defaultItems: {
              type: Boolean,
              default: true
            },
            width: {
              type: Number,
              default: 150
            },
            items: {
              type: Array,
              default: function _default() {
                return [];
              }
            }
          }
        };
        const ContextMenuControl_exports_ = exportHelper_default()(ContextMenuControlvue_type_script_lang_js, [["render", ContextMenuControlvue_type_template_id_2ce675b2_lang_true_render]]);
        var ContextMenuControl = ContextMenuControl_exports_;
        var SwipeControlvue_type_template_id_57c47c7c_lang_true_hoisted_1 = {
          key: 0
        };
        function SwipeControlvue_type_template_id_57c47c7c_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ol_control_Swipe = function(options) {
          options = options || {};
          var button = document.createElement("button");
          var element = document.createElement("div");
          element.className = (options.className || "ol-swipe") + " ol-unselectable ol-control";
          element.appendChild(button);
          element.addEventListener("mousedown", this.move.bind(this));
          element.addEventListener("touchstart", this.move.bind(this));
          Control["default"].call(this, {
            element
          });
          this.precomposeRight_ = this.precomposeRight.bind(this);
          this.precomposeLeft_ = this.precomposeLeft.bind(this);
          this.postcompose_ = this.postcompose.bind(this);
          this.layers = [];
          if (options.layers)
            this.addLayer(options.layers, false);
          if (options.rightLayers)
            this.addLayer(options.rightLayers, true);
          this.on("propertychange", function(e) {
            if (this.getMap()) {
              try {
                this.getMap().renderSync();
              } catch (e2) {
              }
            }
            if (this.get("orientation") === "horizontal") {
              this.element.style.top = this.get("position") * 100 + "%";
              this.element.style.left = "";
            } else {
              if (this.get("orientation") !== "vertical")
                this.set("orientation", "vertical");
              this.element.style.left = this.get("position") * 100 + "%";
              this.element.style.top = "";
            }
            if (e.key === "orientation") {
              this.element.classList.remove("horizontal", "vertical");
              this.element.classList.add(this.get("orientation"));
            }
            if (!this.isMoving) {
              this.layers.forEach(function(l) {
                if (l.layer.getImageRatio)
                  l.layer.changed();
              });
            }
          }.bind(this));
          this.set("position", options.position || 0.5);
          this.set("orientation", options.orientation || "vertical");
        };
        util_ext(ol_control_Swipe, Control["default"]);
        ol_control_Swipe.prototype.setMap = function(map) {
          var i;
          var l;
          if (this.getMap()) {
            for (i = 0; i < this.layers.length; i++) {
              l = this.layers[i];
              if (l.right)
                l.layer.un(["precompose", "prerender"], this.precomposeRight_);
              else
                l.layer.un(["precompose", "prerender"], this.precomposeLeft_);
              l.layer.un(["postcompose", "postrender"], this.postcompose_);
            }
            try {
              this.getMap().renderSync();
            } catch (e) {
            }
          }
          Control["default"].prototype.setMap.call(this, map);
          if (map) {
            this._listener = [];
            for (i = 0; i < this.layers.length; i++) {
              l = this.layers[i];
              if (l.right)
                l.layer.on(["precompose", "prerender"], this.precomposeRight_);
              else
                l.layer.on(["precompose", "prerender"], this.precomposeLeft_);
              l.layer.on(["postcompose", "postrender"], this.postcompose_);
            }
            try {
              map.renderSync();
            } catch (e) {
            }
          }
        };
        ol_control_Swipe.prototype.isLayer_ = function(layer) {
          for (var k = 0; k < this.layers.length; k++) {
            if (this.layers[k].layer === layer)
              return k;
          }
          return -1;
        };
        ol_control_Swipe.prototype.addLayer = function(layers, right) {
          if (!(layers instanceof Array))
            layers = [layers];
          for (var i = 0; i < layers.length; i++) {
            var l = layers[i];
            if (this.isLayer_(l) < 0) {
              this.layers.push({ layer: l, right });
              if (this.getMap()) {
                if (right)
                  l.on(["precompose", "prerender"], this.precomposeRight_);
                else
                  l.on(["precompose", "prerender"], this.precomposeLeft_);
                l.on(["postcompose", "postrender"], this.postcompose_);
                try {
                  this.getMap().renderSync();
                } catch (e) {
                }
              }
            }
          }
        };
        ol_control_Swipe.prototype.removeLayers = function() {
          var layers = [];
          this.layers.forEach(function(l) {
            layers.push(l.layer);
          });
          this.removeLayer(layers);
        };
        ol_control_Swipe.prototype.removeLayer = function(layers) {
          if (!(layers instanceof Array))
            layers = [layers];
          for (var i = 0; i < layers.length; i++) {
            var k = this.isLayer_(layers[i]);
            if (k >= 0 && this.getMap()) {
              if (this.layers[k].right)
                layers[i].un(["precompose", "prerender"], this.precomposeRight_);
              else
                layers[i].un(["precompose", "prerender"], this.precomposeLeft_);
              layers[i].un(["postcompose", "postrender"], this.postcompose_);
              this.layers.splice(k, 1);
            }
          }
          if (this.getMap()) {
            try {
              this.getMap().renderSync();
            } catch (e) {
            }
          }
        };
        ol_control_Swipe.prototype.getRectangle = function() {
          var s;
          if (this.get("orientation") === "vertical") {
            s = this.getMap().getSize();
            return [0, 0, s[0] * this.get("position"), s[1]];
          } else {
            s = this.getMap().getSize();
            return [0, 0, s[0], s[1] * this.get("position")];
          }
        };
        ol_control_Swipe.prototype.move = function(e) {
          var self2 = this;
          var l;
          if (!this._movefn)
            this._movefn = this.move.bind(this);
          switch (e.type) {
            case "touchcancel":
            case "touchend":
            case "mouseup": {
              self2.isMoving = false;
              ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach(function(eventName) {
                document.removeEventListener(eventName, self2._movefn);
              });
              this.layers.forEach(function(l2) {
                if (l2.layer.getImageRatio)
                  l2.layer.changed();
              });
              break;
            }
            case "mousedown":
            case "touchstart": {
              self2.isMoving = true;
              ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach(function(eventName) {
                document.addEventListener(eventName, self2._movefn);
              });
            }
            case "mousemove":
            case "touchmove": {
              if (self2.isMoving) {
                if (self2.get("orientation") === "vertical") {
                  var pageX = e.pageX || e.touches && e.touches.length && e.touches[0].pageX || e.changedTouches && e.changedTouches.length && e.changedTouches[0].pageX;
                  if (!pageX)
                    break;
                  pageX -= self2.getMap().getTargetElement().getBoundingClientRect().left + window.pageXOffset - document.documentElement.clientLeft;
                  l = self2.getMap().getSize()[0];
                  var w = l - Math.min(Math.max(0, l - pageX), l);
                  l = w / l;
                  self2.set("position", l);
                  self2.dispatchEvent({ type: "moving", size: [w, self2.getMap().getSize()[1]], position: [l, 0] });
                } else {
                  var pageY = e.pageY || e.touches && e.touches.length && e.touches[0].pageY || e.changedTouches && e.changedTouches.length && e.changedTouches[0].pageY;
                  if (!pageY)
                    break;
                  pageY -= self2.getMap().getTargetElement().getBoundingClientRect().top + window.pageYOffset - document.documentElement.clientTop;
                  l = self2.getMap().getSize()[1];
                  var h = l - Math.min(Math.max(0, l - pageY), l);
                  l = h / l;
                  self2.set("position", l);
                  self2.dispatchEvent({ type: "moving", size: [self2.getMap().getSize()[0], h], position: [0, l] });
                }
              }
              break;
            }
            default:
              break;
          }
        };
        ol_control_Swipe.prototype._transformPt = function(e, pt) {
          var tr = e.inversePixelTransform;
          var x = pt[0];
          var y = pt[1];
          pt[0] = tr[0] * x + tr[2] * y + tr[4];
          pt[1] = tr[1] * x + tr[3] * y + tr[5];
          return pt;
        };
        ol_control_Swipe.prototype._drawRect = function(e, pts) {
          var tr = e.inversePixelTransform;
          if (tr) {
            var r = [
              [pts[0][0], pts[0][1]],
              [pts[0][0], pts[1][1]],
              [pts[1][0], pts[1][1]],
              [pts[1][0], pts[0][1]],
              [pts[0][0], pts[0][1]]
            ];
            e.context.save();
            if (e.target.getImageRatio) {
              var rot = -Math.atan2(e.frameState.pixelToCoordinateTransform[1], e.frameState.pixelToCoordinateTransform[0]);
              e.context.translate(e.frameState.size[0] / 2, e.frameState.size[1] / 2);
              e.context.rotate(rot);
              e.context.translate(-e.frameState.size[0] / 2, -e.frameState.size[1] / 2);
            }
            r.forEach(function(pt, i) {
              pt = [
                pt[0] * tr[0] - pt[1] * tr[1] + tr[4],
                -pt[0] * tr[2] + pt[1] * tr[3] + tr[5]
              ];
              if (!i) {
                e.context.moveTo(pt[0], pt[1]);
              } else {
                e.context.lineTo(pt[0], pt[1]);
              }
            });
            e.context.restore();
          } else {
            var ratio = e.frameState.pixelRatio;
            e.context.rect(pts[0][0] * ratio, pts[0][1] * ratio, pts[1][0] * ratio, pts[1][1] * ratio);
          }
        };
        ol_control_Swipe.prototype.precomposeLeft = function(e) {
          var ctx = e.context;
          if (ctx instanceof WebGLRenderingContext) {
            if (e.type === "prerender") {
              ctx.clearColor(0, 0, 0, 0);
              ctx.clear(ctx.COLOR_BUFFER_BIT);
              ctx.enable(ctx.SCISSOR_TEST);
              var mapSize = this.getMap().getSize();
              var bottomLeft = this._transformPt(e, [0, mapSize[1]]);
              var topRight = this._transformPt(e, [mapSize[0], 0]);
              var width = topRight[0] - bottomLeft[0];
              var height = topRight[1] - bottomLeft[1];
              if (this.get("orientation") === "vertical") {
                width = Math.round(width * this.get("position"));
              } else {
                height = Math.round(height * this.get("position"));
                bottomLeft[1] += mapSize[1] - height;
              }
              ctx.scissor(bottomLeft[0], bottomLeft[1], width, height);
            }
          } else {
            var size = e.frameState.size;
            ctx.save();
            ctx.beginPath();
            var pts = [[0, 0], [size[0], size[1]]];
            if (this.get("orientation") === "vertical") {
              pts[1] = [
                size[0] * 0.5 + this.getMap().getSize()[0] * (this.get("position") - 0.5),
                size[1]
              ];
            } else {
              pts[1] = [
                size[0],
                size[1] * 0.5 + this.getMap().getSize()[1] * (this.get("position") - 0.5)
              ];
            }
            this._drawRect(e, pts);
            ctx.clip();
          }
        };
        ol_control_Swipe.prototype.precomposeRight = function(e) {
          var ctx = e.context;
          if (ctx instanceof WebGLRenderingContext) {
            if (e.type === "prerender") {
              ctx.clearColor(0, 0, 0, 0);
              ctx.clear(ctx.COLOR_BUFFER_BIT);
              ctx.enable(ctx.SCISSOR_TEST);
              var mapSize = this.getMap().getSize();
              var bottomLeft = this._transformPt(e, [0, mapSize[1]]);
              var topRight = this._transformPt(e, [mapSize[0], 0]);
              var width = topRight[0] - bottomLeft[0];
              var height = topRight[1] - bottomLeft[1];
              if (this.get("orientation") === "vertical") {
                width = Math.round(width * (1 - this.get("position")));
                bottomLeft[0] += mapSize[0] - width;
              } else {
                height = Math.round(height * (1 - this.get("position")));
              }
              ctx.scissor(bottomLeft[0], bottomLeft[1], width, height);
            }
          } else {
            var size = e.frameState.size;
            ctx.save();
            ctx.beginPath();
            var pts = [[0, 0], [size[0], size[1]]];
            if (this.get("orientation") === "vertical") {
              pts[0] = [
                size[0] * 0.5 + this.getMap().getSize()[0] * (this.get("position") - 0.5),
                0
              ];
            } else {
              pts[0] = [
                0,
                size[1] * 0.5 + this.getMap().getSize()[1] * (this.get("position") - 0.5)
              ];
            }
            this._drawRect(e, pts);
            ctx.clip();
          }
        };
        ol_control_Swipe.prototype.postcompose = function(e) {
          if (e.context instanceof WebGLRenderingContext) {
            if (e.type === "postrender") {
              var gl = e.context;
              gl.disable(gl.SCISSOR_TEST);
            }
          } else {
            if (e.target.getClassName && e.target.getClassName() !== "ol-layer" && e.target.get("declutter")) {
              setTimeout(function() {
                e.context.restore();
              }, 0);
            } else {
              e.context.restore();
            }
          }
        };
        var Swipe = ol_control_Swipe;
        var SwipeControlvue_type_script_lang_js = {
          name: "ol-swipe-control",
          setup: function setup(props, context) {
            var _useControl = useControl(Swipe, props, context), control = _useControl.control;
            var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props), layerList = _toRefs.layerList;
            layerList.value.forEach(function(layer, index) {
              control.value.addLayer(layer, index == 1 ? true : false);
            });
            return {
              control
            };
          },
          props: {
            layerList: {
              type: Array
            },
            className: {
              type: String,
              default: "ol-swipe"
            },
            position: {
              type: Number,
              default: 0.5
            },
            orientation: {
              type: String,
              default: "vertical"
            }
          }
        };
        const SwipeControl_exports_ = exportHelper_default()(SwipeControlvue_type_script_lang_js, [["render", SwipeControlvue_type_template_id_57c47c7c_lang_true_render]]);
        var SwipeControl = SwipeControl_exports_;
        function ControlBarvue_type_template_id_d4aa5eb2_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var ol_control_Bar = function(options) {
          if (!options)
            options = {};
          var element = document.createElement("div");
          element.classList.add("ol-unselectable", "ol-control", "ol-bar");
          if (options.className) {
            var classes = options.className.split(" ").filter(function(className) {
              return className.length > 0;
            });
            element.classList.add.apply(element.classList, classes);
          }
          if (options.group)
            element.classList.add("ol-group");
          Control["default"].call(this, {
            element,
            target: options.target
          });
          this.set("toggleOne", options.toggleOne);
          this.set("autoDeactivate", options.autoDeactivate);
          this.controls_ = [];
          if (options.controls instanceof Array) {
            for (var i = 0; i < options.controls.length; i++) {
              this.addControl(options.controls[i]);
            }
          }
        };
        util_ext(ol_control_Bar, Control["default"]);
        ol_control_Bar.prototype.setVisible = function(val) {
          if (val)
            this.element.style.display = "";
          else
            this.element.style.display = "none";
        };
        ol_control_Bar.prototype.getVisible = function() {
          return this.element.style.display != "none";
        };
        ol_control_Bar.prototype.setMap = function(map) {
          Control["default"].prototype.setMap.call(this, map);
          for (var i = 0; i < this.controls_.length; i++) {
            var c = this.controls_[i];
            c.setMap(map);
          }
        };
        ol_control_Bar.prototype.getControls = function() {
          return this.controls_;
        };
        ol_control_Bar.prototype.setPosition = function(pos) {
          this.element.classList.remove("ol-left", "ol-top", "ol-bottom", "ol-right");
          pos = pos.split("-");
          for (var i = 0; i < pos.length; i++) {
            switch (pos[i]) {
              case "top":
              case "left":
              case "bottom":
              case "right":
                this.element.classList.add("ol-" + pos[i]);
                break;
              default:
                break;
            }
          }
        };
        ol_control_Bar.prototype.addControl = function(c) {
          this.controls_.push(c);
          c.setTarget(this.element);
          if (this.getMap()) {
            this.getMap().addControl(c);
          }
          c.on("change:active", function(e) {
            this.onActivateControl_(e, c);
          }.bind(this));
          if (c.getActive) {
            this.onActivateControl_({ target: c, active: c.getActive() }, c);
          }
        };
        ol_control_Bar.prototype.deactivateControls = function(except) {
          for (var i = 0; i < this.controls_.length; i++) {
            if (this.controls_[i] !== except && this.controls_[i].setActive) {
              this.controls_[i].setActive(false);
            }
          }
        };
        ol_control_Bar.prototype.getActiveControls = function() {
          var active = [];
          for (var i = 0, c; c = this.controls_[i]; i++) {
            if (c.getActive && c.getActive())
              active.push(c);
          }
          return active;
        };
        ol_control_Bar.prototype.setActive = function(b) {
          if (!b && this.get("autoDeactivate")) {
            this.deactivateControls();
          }
          if (b) {
            var ctrls = this.getControls();
            for (var i = 0, sb; sb = ctrls[i]; i++) {
              if (sb.get("autoActivate"))
                sb.setActive(true);
            }
          }
        };
        ol_control_Bar.prototype.onActivateControl_ = function(e, ctrl) {
          if (this.get("toggleOne")) {
            if (e.active) {
              var n;
              for (n = 0; n < this.controls_.length; n++) {
                if (this.controls_[n] === ctrl)
                  break;
              }
              if (n == this.controls_.length)
                return;
              this.deactivateControls(this.controls_[n]);
            } else {
              if (!this.getActiveControls().length) {
                for (var i = 0, c; c = this.controls_[i]; i++) {
                  if (c.get("autoActivate")) {
                    c.setActive(true);
                    break;
                  }
                }
              }
            }
          }
        };
        ol_control_Bar.prototype.getControlsByName = function(name) {
          var controls = this.getControls();
          return controls.filter(function(control) {
            return control.get("name") === name;
          });
        };
        var Bar = ol_control_Bar;
        var ControlBarvue_type_script_lang_js = {
          name: "ol-control-bar",
          setup: function setup(props, context) {
            var _useControl = useControl(Bar, props, context), control = _useControl.control;
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("controlBar", control);
            return {
              control
            };
          },
          props: {
            toggleOne: {
              type: Boolean,
              default: true
            },
            group: {
              type: Boolean,
              default: true
            }
          }
        };
        const ControlBar_exports_ = exportHelper_default()(ControlBarvue_type_script_lang_js, [["render", ControlBarvue_type_template_id_d4aa5eb2_lang_true_render]]);
        var ControlBar = ControlBar_exports_;
        var ToggleControlvue_type_template_id_1bf37b9d_lang_true_hoisted_1 = {
          key: 0
        };
        function ToggleControlvue_type_template_id_1bf37b9d_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        if (window.ol) {
          ol.ext.input = {};
        }
        var ol_ext_input_Base = function(options) {
          options = options || {};
          ol_Object["a"].call(this);
          var input = this.input = options.input;
          if (!input) {
            input = this.input = document.createElement("INPUT");
            if (options.type)
              input.setAttribute("type", options.type);
            if (options.min !== void 0)
              input.setAttribute("min", options.min);
            if (options.max !== void 0)
              input.setAttribute("max", options.max);
            if (options.step !== void 0)
              input.setAttribute("step", options.step);
            if (options.parent)
              options.parent.appendChild(input);
          }
          if (options.disabled)
            input.disabled = true;
          if (options.checked !== void 0)
            input.checked = !!options.checked;
          if (options.val !== void 0)
            input.value = options.val;
          if (options.hidden)
            input.style.display = "none";
        };
        util_ext(ol_ext_input_Base, ol_Object["a"]);
        ol_ext_input_Base.prototype._listenDrag = function(elt, cback) {
          var handle = function(e) {
            this.moving = true;
            var listen = function(e2) {
              if (e2.type === "pointerup") {
                document.removeEventListener("pointermove", listen);
                document.removeEventListener("pointerup", listen);
                document.removeEventListener("pointercancel", listen);
                setTimeout(function() {
                  this.moving = false;
                }.bind(this));
              }
              if (e2.target === elt)
                cback(e2);
              e2.stopPropagation();
              e2.preventDefault();
            }.bind(this);
            document.addEventListener("pointermove", listen, false);
            document.addEventListener("pointerup", listen, false);
            document.addEventListener("pointercancel", listen, false);
            e.stopPropagation();
            e.preventDefault();
          }.bind(this);
          elt.addEventListener("mousedown", handle, false);
          elt.addEventListener("touchstart", handle, false);
        };
        ol_ext_input_Base.prototype.setValue = function(v) {
          if (v !== void 0)
            this.input.value = v;
          this.input.dispatchEvent(new Event("change"));
        };
        ol_ext_input_Base.prototype.getValue = function() {
          return this.input.value;
        };
        ol_ext_input_Base.prototype.getInputElement = function() {
          return this.input;
        };
        var input_Base = ol_ext_input_Base;
        var ol_ext_input_Checkbox = function(options) {
          options = options || {};
          input_Base.call(this, options);
          var label = this.element = document.createElement("LABEL");
          if (options.html instanceof Element)
            label.appendChild(options.html);
          else if (options.html !== void 0)
            label.innerHTML = options.html;
          label.className = ("ol-ext-check ol-ext-checkbox" + (options.className || "")).trim();
          if (this.input.parentNode)
            this.input.parentNode.insertBefore(label, this.input);
          label.appendChild(this.input);
          label.appendChild(document.createElement("SPAN"));
          if (options.after) {
            label.appendChild(document.createTextNode(options.after));
          }
          this.input.addEventListener("change", function() {
            this.dispatchEvent({ type: "check", checked: this.input.checked, value: this.input.value });
          }.bind(this));
        };
        util_ext(ol_ext_input_Checkbox, input_Base);
        ol_ext_input_Checkbox.prototype.isChecked = function() {
          return this.input.checked;
        };
        var Checkbox = ol_ext_input_Checkbox;
        var ol_ext_input_Switch = function(options) {
          options = options || {};
          Checkbox.call(this, options);
          this.element.className = ("ol-ext-toggle-switch " + (options.className || "")).trim();
        };
        util_ext(ol_ext_input_Switch, Checkbox);
        var Switch = ol_ext_input_Switch;
        var ol_ext_input_Radio = function(input, options) {
          options = options || {};
          Checkbox.call(this, input, options);
          this.element.className = ("ol-ext-check ol-ext-radio" + (options.className || "")).trim();
        };
        util_ext(ol_ext_input_Radio, Checkbox);
        var Radio = ol_ext_input_Radio;
        var ol_ext_element = {};
        ol_ext_element.create = function(tagName, options) {
          options = options || {};
          var elt;
          if (tagName === "TEXT") {
            elt = document.createTextNode(options.html || "");
            if (options.parent)
              options.parent.appendChild(elt);
          } else {
            elt = document.createElement(tagName);
            if (/button/i.test(tagName))
              elt.setAttribute("type", "button");
            for (var attr in options) {
              switch (attr) {
                case "className": {
                  if (options.className && options.className.trim)
                    elt.setAttribute("class", options.className.trim());
                  break;
                }
                case "html": {
                  if (options.html instanceof Element)
                    elt.appendChild(options.html);
                  else if (options.html !== void 0)
                    elt.innerHTML = options.html;
                  break;
                }
                case "parent": {
                  if (options.parent)
                    options.parent.appendChild(elt);
                  break;
                }
                case "options": {
                  if (/select/i.test(tagName)) {
                    for (var i in options.options) {
                      ol_ext_element.create("OPTION", {
                        html: i,
                        value: options.options[i],
                        parent: elt
                      });
                    }
                  }
                  break;
                }
                case "style": {
                  this.setStyle(elt, options.style);
                  break;
                }
                case "change":
                case "click": {
                  ol_ext_element.addListener(elt, attr, options[attr]);
                  break;
                }
                case "on": {
                  for (var e in options.on) {
                    ol_ext_element.addListener(elt, e, options.on[e]);
                  }
                  break;
                }
                case "checked": {
                  elt.checked = !!options.checked;
                  break;
                }
                default: {
                  elt.setAttribute(attr, options[attr]);
                  break;
                }
              }
            }
          }
          return elt;
        };
        ol_ext_element.createSwitch = function(options) {
          var input = ol_ext_element.create("INPUT", {
            type: "checkbox",
            on: options.on,
            click: options.click,
            change: options.change,
            parent: options.parent
          });
          var opt = Object.assign({ input }, options || {});
          new Switch(opt);
          return input;
        };
        ol_ext_element.createCheck = function(options) {
          var input = ol_ext_element.create("INPUT", {
            name: options.name,
            type: options.type === "radio" ? "radio" : "checkbox",
            on: options.on,
            parent: options.parent
          });
          console.log(input);
          var opt = Object.assign({ input }, options || {});
          if (options.type === "radio") {
            new Radio(opt);
          } else {
            new Checkbox(opt);
          }
          return input;
        };
        ol_ext_element.setHTML = function(element, html) {
          if (html instanceof Element)
            element.appendChild(html);
          else if (html !== void 0)
            element.innerHTML = html;
        };
        ol_ext_element.appendText = function(element, text) {
          element.appendChild(document.createTextNode(text || ""));
        };
        ol_ext_element.addListener = function(element, eventType, fn, useCapture) {
          if (typeof eventType === "string")
            eventType = eventType.split(" ");
          eventType.forEach(function(e) {
            element.addEventListener(e, fn, useCapture);
          });
        };
        ol_ext_element.removeListener = function(element, eventType, fn) {
          if (typeof eventType === "string")
            eventType = eventType.split(" ");
          eventType.forEach(function(e) {
            element.removeEventListener(e, fn);
          });
        };
        ol_ext_element.show = function(element) {
          element.style.display = "";
        };
        ol_ext_element.hide = function(element) {
          element.style.display = "none";
        };
        ol_ext_element.hidden = function(element) {
          return ol_ext_element.getStyle(element, "display") === "none";
        };
        ol_ext_element.toggle = function(element) {
          element.style.display = element.style.display === "none" ? "" : "none";
        };
        ol_ext_element.setStyle = function(el, st) {
          for (var s in st) {
            switch (s) {
              case "top":
              case "left":
              case "bottom":
              case "right":
              case "minWidth":
              case "maxWidth":
              case "width":
              case "height": {
                if (typeof st[s] === "number") {
                  el.style[s] = st[s] + "px";
                } else {
                  el.style[s] = st[s];
                }
                break;
              }
              default: {
                el.style[s] = st[s];
              }
            }
          }
        };
        ol_ext_element.getStyle = function(el, styleProp) {
          var value, defaultView = (el.ownerDocument || document).defaultView;
          if (defaultView && defaultView.getComputedStyle) {
            styleProp = styleProp.replace(/([A-Z])/g, "-$1").toLowerCase();
            value = defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
          } else if (el.currentStyle) {
            styleProp = styleProp.replace(/-(\w)/g, function(str, letter) {
              return letter.toUpperCase();
            });
            value = el.currentStyle[styleProp];
            if (/^\d+(em|pt|%|ex)?$/i.test(value)) {
              return function(value2) {
                var oldLeft = el.style.left, oldRsLeft = el.runtimeStyle.left;
                el.runtimeStyle.left = el.currentStyle.left;
                el.style.left = value2 || 0;
                value2 = el.style.pixelLeft + "px";
                el.style.left = oldLeft;
                el.runtimeStyle.left = oldRsLeft;
                return value2;
              }(value);
            }
          }
          if (/px$/.test(value))
            return parseInt(value);
          return value;
        };
        ol_ext_element.outerHeight = function(elt) {
          return elt.offsetHeight + ol_ext_element.getStyle(elt, "marginBottom");
        };
        ol_ext_element.outerWidth = function(elt) {
          return elt.offsetWidth + ol_ext_element.getStyle(elt, "marginLeft");
        };
        ol_ext_element.offsetRect = function(elt) {
          var rect = elt.getBoundingClientRect();
          return {
            top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
            left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0),
            height: rect.height || rect.bottom - rect.top,
            width: rect.width || rect.right - rect.left
          };
        };
        ol_ext_element.getFixedOffset = function(elt) {
          var offset = {
            left: 0,
            top: 0
          };
          var getOffset = function(parent) {
            if (!parent)
              return offset;
            if (ol_ext_element.getStyle(parent, "position") === "absolute" && ol_ext_element.getStyle(parent, "transform") !== "none") {
              var r = parent.getBoundingClientRect();
              offset.left += r.left;
              offset.top += r.top;
              return offset;
            }
            console.log(parent, offset);
            return getOffset(parent.offsetParent);
          };
          return getOffset(elt.offsetParent);
        };
        ol_ext_element.positionRect = function(elt, fixed) {
          var gleft = 0;
          var gtop = 0;
          var getRect = function(parent) {
            if (parent) {
              gleft += parent.offsetLeft;
              gtop += parent.offsetTop;
              return getRect(parent.offsetParent);
            } else {
              var r = {
                top: elt.offsetTop + gtop,
                left: elt.offsetLeft + gleft
              };
              if (fixed) {
                r.top -= window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
                r.left -= window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
              }
              r.bottom = r.top + elt.offsetHeight;
              r.right = r.top + elt.offsetWidth;
              return r;
            }
          };
          return getRect(elt.offsetParent);
        };
        ol_ext_element.scrollDiv = function(elt, options) {
          options = options || {};
          var pos = false;
          var speed = 0;
          var d, dt = 0;
          var onmove = typeof options.onmove === "function" ? options.onmove : function() {
          };
          var page = options.vertical ? "screenY" : "screenX";
          var scroll = options.vertical ? "scrollTop" : "scrollLeft";
          var moving = false;
          var scale, isbar;
          var updateCounter = 0;
          var updateMinibar = function() {
            if (scrollbar) {
              updateCounter++;
              setTimeout(updateMinibarDelay);
            }
          };
          var updateMinibarDelay = function() {
            if (scrollbar) {
              updateCounter--;
              if (updateCounter)
                return;
              var pheight = elt.clientHeight;
              var height = elt.scrollHeight;
              scale = pheight / height;
              scrollbar.style.height = scale * 100 + "%";
              scrollbar.style.top = elt.scrollTop / height * 100 + "%";
              scrollContainer.style.height = pheight + "px";
              if (pheight > height - 0.5)
                scrollContainer.classList.add("ol-100pc");
              else
                scrollContainer.classList.remove("ol-100pc");
            }
          };
          var onPointerDown = function(e) {
            if (e.target.classList.contains("ol-noscroll"))
              return;
            moving = false;
            pos = e[page];
            dt = new Date();
            elt.classList.add("ol-move");
            e.preventDefault();
            window.addEventListener("pointermove", onPointerMove);
            ol_ext_element.addListener(window, ["pointerup", "pointercancel"], onPointerUp);
          };
          var onPointerMove = function(e) {
            moving = true;
            if (pos !== false) {
              var delta = (isbar ? -1 / scale : 1) * (pos - e[page]);
              elt[scroll] += delta;
              d = new Date();
              if (d - dt) {
                speed = (speed + delta / (d - dt)) / 2;
              }
              pos = e[page];
              dt = d;
              if (delta)
                onmove(true);
            }
          };
          var animate = function(to) {
            var step = to > 0 ? Math.min(100, to / 2) : Math.max(-100, to / 2);
            to -= step;
            elt[scroll] += step;
            if (-1 < to && to < 1) {
              if (moving)
                setTimeout(function() {
                  elt.classList.remove("ol-move");
                });
              else
                elt.classList.remove("ol-move");
              moving = false;
              onmove(false);
            } else {
              setTimeout(function() {
                animate(to);
              }, 40);
            }
          };
          var scrollContainer, scrollbar;
          if (options.vertical && options.minibar) {
            var init2 = function(b) {
              elt.removeEventListener("pointermove", init2);
              elt.parentNode.classList.add("ol-miniscroll");
              scrollbar = ol_ext_element.create("DIV");
              scrollContainer = ol_ext_element.create("DIV", {
                className: "ol-scroll",
                html: scrollbar
              });
              elt.parentNode.insertBefore(scrollContainer, elt);
              scrollbar.addEventListener("pointerdown", function(e) {
                isbar = true;
                onPointerDown(e);
              });
              if (options.mousewheel) {
                ol_ext_element.addListener(scrollContainer, ["mousewheel", "DOMMouseScroll", "onmousewheel"], function(e) {
                  onMouseWheel(e);
                });
                ol_ext_element.addListener(scrollbar, ["mousewheel", "DOMMouseScroll", "onmousewheel"], function(e) {
                  onMouseWheel(e);
                });
              }
              elt.parentNode.addEventListener("pointerenter", updateMinibar);
              window.addEventListener("resize", updateMinibar);
              if (b !== false)
                updateMinibar();
            };
            if (elt.parentNode)
              init2(false);
            else
              elt.addEventListener("pointermove", init2);
            elt.addEventListener("scroll", function() {
              updateMinibar();
            });
          }
          elt.style["touch-action"] = "none";
          elt.style["overflow"] = "hidden";
          elt.classList.add("ol-scrolldiv");
          ol_ext_element.addListener(elt, ["pointerdown"], function(e) {
            isbar = false;
            onPointerDown(e);
          });
          elt.addEventListener("click", function(e) {
            if (elt.classList.contains("ol-move")) {
              e.preventDefault();
              e.stopPropagation();
            }
          }, true);
          var onPointerUp = function(e) {
            dt = new Date() - dt;
            if (dt > 100 || isbar) {
              speed = 0;
            } else if (dt > 0) {
              speed = ((speed || 0) + (pos - e[page]) / dt) / 2;
            }
            animate(options.animate === false ? 0 : speed * 200);
            pos = false;
            speed = 0;
            dt = 0;
            if (!elt.classList.contains("ol-move")) {
              elt.classList.add("ol-hasClick");
              setTimeout(function() {
                elt.classList.remove("ol-hasClick");
              }, 500);
            } else {
              elt.classList.remove("ol-hasClick");
            }
            isbar = false;
            window.removeEventListener("pointermove", onPointerMove);
            ol_ext_element.removeListener(window, ["pointerup", "pointercancel"], onPointerUp);
          };
          var onMouseWheel = function(e) {
            var delta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
            elt.classList.add("ol-move");
            elt[scroll] -= delta * 30;
            elt.classList.remove("ol-move");
            return false;
          };
          if (options.mousewheel) {
            ol_ext_element.addListener(elt, ["mousewheel", "DOMMouseScroll", "onmousewheel"], onMouseWheel);
          }
          return {
            refresh: updateMinibar
          };
        };
        ol_ext_element.dispatchEvent = function(eventName, element) {
          var event;
          try {
            event = new CustomEvent(eventName);
          } catch (e) {
            event = document.createEvent("CustomEvent");
            event.initCustomEvent(eventName, true, true, {});
          }
          element.dispatchEvent(event);
        };
        var util_element = ol_ext_element;
        var ol_control_Button = function(options) {
          options = options || {};
          var element = document.createElement("div");
          element.className = (options.className || "") + " ol-button ol-unselectable ol-control";
          var self2 = this;
          var bt = this.button_ = document.createElement(/ol-text-button/.test(options.className) ? "div" : "button");
          bt.type = "button";
          if (options.title)
            bt.title = options.title;
          if (options.name)
            bt.name = options.name;
          if (options.html instanceof Element)
            bt.appendChild(options.html);
          else
            bt.innerHTML = options.html || "";
          var evtFunction = function(e) {
            if (e && e.preventDefault) {
              e.preventDefault();
              e.stopPropagation();
            }
            if (options.handleClick) {
              options.handleClick.call(self2, e);
            }
          };
          bt.addEventListener("click", evtFunction);
          bt.addEventListener("touchstart", evtFunction);
          element.appendChild(bt);
          if (!options.title && bt.firstElementChild) {
            bt.title = bt.firstElementChild.title;
          }
          Control["default"].call(this, {
            element,
            target: options.target
          });
          if (options.title) {
            this.set("title", options.title);
          }
          if (options.title)
            this.set("title", options.title);
          if (options.name)
            this.set("name", options.name);
        };
        util_ext(ol_control_Button, Control["default"]);
        ol_control_Button.prototype.setVisible = function(val) {
          if (val)
            util_element.show(this.element);
          else
            util_element.hide(this.element);
        };
        ol_control_Button.prototype.setTitle = function(title) {
          this.button_.setAttribute("title", title);
        };
        ol_control_Button.prototype.setHtml = function(html) {
          util_element.setHTML(this.button_, html);
        };
        ol_control_Button.prototype.getButtonElement = function() {
          return this.button_;
        };
        var Button = ol_control_Button;
        var ol_control_Toggle = function(options) {
          options = options || {};
          var self2 = this;
          this.interaction_ = options.interaction;
          if (this.interaction_) {
            this.interaction_.setActive(options.active);
            this.interaction_.on("change:active", function() {
              self2.setActive(self2.interaction_.getActive());
            });
          }
          if (options.toggleFn)
            options.onToggle = options.toggleFn;
          options.handleClick = function() {
            self2.toggle();
            if (options.onToggle)
              options.onToggle.call(self2, self2.getActive());
          };
          options.className = (options.className || "") + " ol-toggle";
          Button.call(this, options);
          this.set("title", options.title);
          this.set("autoActivate", options.autoActivate);
          if (options.bar)
            this.setSubBar(options.bar);
          this.setActive(options.active);
          this.setDisable(options.disable);
        };
        util_ext(ol_control_Toggle, Button);
        ol_control_Toggle.prototype.setMap = function(map) {
          if (!map && this.getMap()) {
            if (this.interaction_) {
              this.getMap().removeInteraction(this.interaction_);
            }
            if (this.subbar_)
              this.getMap().removeControl(this.subbar_);
          }
          Button.prototype.setMap.call(this, map);
          if (map) {
            if (this.interaction_)
              map.addInteraction(this.interaction_);
            if (this.subbar_)
              map.addControl(this.subbar_);
          }
        };
        ol_control_Toggle.prototype.getSubBar = function() {
          return this.subbar_;
        };
        ol_control_Toggle.prototype.setSubBar = function(bar) {
          var map = this.getMap();
          if (map && this.subbar_)
            map.removeControl(this.subbar_);
          this.subbar_ = bar;
          if (bar) {
            this.subbar_.setTarget(this.element);
            this.subbar_.element.classList.add("ol-option-bar");
            if (map)
              map.addControl(this.subbar_);
          }
        };
        ol_control_Toggle.prototype.getDisable = function() {
          var button = this.element.querySelector("button");
          return button && button.disabled;
        };
        ol_control_Toggle.prototype.setDisable = function(b) {
          if (this.getDisable() == b)
            return;
          this.element.querySelector("button").disabled = b;
          if (b && this.getActive())
            this.setActive(false);
          this.dispatchEvent({ type: "change:disable", key: "disable", oldValue: !b, disable: b });
        };
        ol_control_Toggle.prototype.getActive = function() {
          return this.element.classList.contains("ol-active");
        };
        ol_control_Toggle.prototype.toggle = function() {
          if (this.getActive())
            this.setActive(false);
          else
            this.setActive(true);
        };
        ol_control_Toggle.prototype.setActive = function(b) {
          if (this.interaction_)
            this.interaction_.setActive(b);
          if (this.subbar_)
            this.subbar_.setActive(b);
          if (this.getActive() === b)
            return;
          if (b)
            this.element.classList.add("ol-active");
          else
            this.element.classList.remove("ol-active");
          this.dispatchEvent({ type: "change:active", key: "active", oldValue: !b, active: b });
        };
        ol_control_Toggle.prototype.setInteraction = function(i) {
          this.interaction_ = i;
        };
        ol_control_Toggle.prototype.getInteraction = function() {
          return this.interaction_;
        };
        var Toggle = ol_control_Toggle;
        var ToggleControlvue_type_script_lang_js = {
          name: "ol-control-toggle",
          setup: function setup(props, context) {
            var _useControl = useControl(Toggle, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            html: {
              type: String
            },
            interaction: {
              type: Object
            },
            className: {
              type: String
            },
            title: {
              type: String
            },
            onToggle: {
              type: Function
            }
          }
        };
        const ToggleControl_exports_ = exportHelper_default()(ToggleControlvue_type_script_lang_js, [["render", ToggleControlvue_type_template_id_1bf37b9d_lang_true_render]]);
        var ToggleControl = ToggleControl_exports_;
        var ButtonControlvue_type_template_id_c81d243a_lang_true_hoisted_1 = {
          key: 0
        };
        function ButtonControlvue_type_template_id_c81d243a_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ButtonControlvue_type_script_lang_js = {
          name: "ol-control-button",
          setup: function setup(props, context) {
            var _useControl = useControl(Button, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            html: {
              type: String
            },
            name: {
              type: String
            },
            className: {
              type: String
            },
            title: {
              type: String
            },
            handleClick: {
              type: Function
            }
          }
        };
        const ButtonControl_exports_ = exportHelper_default()(ButtonControlvue_type_script_lang_js, [["render", ButtonControlvue_type_template_id_c81d243a_lang_true_render]]);
        var ButtonControl = ButtonControl_exports_;
        var PrintDialogvue_type_template_id_639b2b4c_lang_true_hoisted_1 = {
          key: 0
        };
        function PrintDialogvue_type_template_id_639b2b4c_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ol_control_Dialog = function(options) {
          options = options || {};
          if (options.fullscreen)
            options.target = document.body;
          var element = util_element.create("DIV", {
            className: ((options.className || "") + (options.zoom ? " ol-zoom" : "") + " ol-ext-dialog").trim(),
            click: function(e) {
              if (this.get("hideOnBack") && e.target === element)
                this.close();
              if (this.get("hideOnClick"))
                this.close();
            }.bind(this)
          });
          var form = util_element.create("FORM", {
            on: {
              submit: this._onButton("submit")
            },
            parent: element
          });
          util_element.create("H2", {
            parent: form
          });
          util_element.create("DIV", {
            className: "ol-closebox",
            click: this._onButton("cancel"),
            parent: form
          });
          util_element.create("DIV", {
            className: "ol-content",
            parent: form
          });
          this._progress = util_element.create("DIV", {
            style: { display: "none" },
            parent: form
          });
          var bar = util_element.create("DIV", {
            className: "ol-progress-bar",
            parent: this._progress
          });
          this._progressbar = util_element.create("DIV", {
            parent: bar
          });
          this._progressMessage = util_element.create("DIV", {
            className: "ol-progress-message",
            parent: this._progress
          });
          util_element.create("DIV", {
            className: "ol-buttons",
            parent: form
          });
          Control["default"].call(this, {
            element,
            target: options.target
          });
          this.set("closeBox", options.closeBox !== false);
          this.set("zoom", !!options.zoom);
          this.set("hideOnClick", !!options.hideOnClick);
          this.set("hideOnBack", !!options.hideOnBack);
          this.set("className", element.className);
          this.set("closeOnSubmit", options.closeOnSubmit);
          this.set("buttons", options.buttons);
          this.setContent(options);
        };
        util_ext(ol_control_Dialog, Control["default"]);
        ol_control_Dialog.prototype.show = function(options) {
          if (options) {
            if (options instanceof Element || typeof options === "string") {
              options = { content: options };
            }
            this.setContent(options);
          }
          this.element.classList.add("ol-visible");
          var input = this.element.querySelector('input[type="text"],input[type="search"],input[type="number"]');
          if (input)
            input.focus();
          this.dispatchEvent({ type: "show" });
          if (options) {
            if (options.autoclose) {
              var listener = setTimeout(function() {
                this.hide();
              }.bind(this), options.autoclose);
              this.once("hide", function() {
                clearTimeout(listener);
              });
            }
            if (options.hideOnBack) {
              var value = this.get("hideOnBack");
              this.set("hideOnBack", true);
              this.once("hide", function() {
                this.set("hideOnBack", value);
              }.bind(this));
            }
          }
        };
        ol_control_Dialog.prototype.open = function() {
          this.show();
        };
        ol_control_Dialog.prototype.setContentMessage = function(content) {
          if (content !== void 0) {
            var elt = this.getContentElement();
            if (content instanceof Element)
              util_element.setHTML(elt, "");
            util_element.setHTML(elt, content || "");
          }
        };
        ol_control_Dialog.prototype.setTitle = function(title) {
          var form = this.element.querySelector("form");
          form.querySelector("h2").innerText = title || "";
          if (title) {
            form.classList.add("ol-title");
          } else {
            form.classList.remove("ol-title");
          }
        };
        ol_control_Dialog.prototype.setContent = function(options) {
          if (!options)
            return;
          this.element.className = this.get("className");
          if (typeof options === "string")
            options = { content: options };
          options = options || {};
          if (options.max)
            this.setProgress(0, options.max);
          if (options.progress !== void 0)
            this.setProgress(options.progress);
          if (this.get("zoom"))
            this.element.classList.add("ol-zoom");
          else
            this.element.classList.remove("ol-zoom");
          if (options.className) {
            options.className.split(" ").forEach(function() {
              this.element.classList.add(options.className);
            }.bind(this));
          }
          var form = this.element.querySelector("form");
          if (options.content !== void 0) {
            if (options.content instanceof Element)
              util_element.setHTML(form.querySelector(".ol-content"), "");
            util_element.setHTML(form.querySelector(".ol-content"), options.content || "");
          }
          this.setTitle(options.title);
          if (options.closeBox || this.get("closeBox") && options.closeBox !== false) {
            form.classList.add("ol-closebox");
          } else {
            form.classList.remove("ol-closebox");
          }
          var buttons = this.element.querySelector(".ol-buttons");
          buttons.innerHTML = "";
          var btn = options.buttons || this.get("buttons");
          if (btn) {
            form.classList.add("ol-button");
            for (var i in btn) {
              util_element.create("INPUT", {
                type: i === "submit" ? "submit" : "button",
                value: btn[i],
                click: this._onButton(i, options.onButton),
                parent: buttons
              });
            }
          } else {
            form.classList.remove("ol-button");
          }
        };
        ol_control_Dialog.prototype.getContentElement = function() {
          return this.element.querySelector("form .ol-content");
        };
        ol_control_Dialog.prototype.setProgress = function(val, max, message) {
          if (val === false) {
            util_element.setStyle(this._progress, { display: "none" });
            return;
          }
          if (max > 0) {
            this.set("max", Number(max));
          } else {
            max = this.get("max");
          }
          if (!max) {
            util_element.setStyle(this._progress, { display: "none" });
          } else {
            var p = Math.round(val / max * 100);
            util_element.setStyle(this._progress, { display: "" });
            this._progressbar.className = p ? "" : "notransition";
            util_element.setStyle(this._progressbar, { width: p + "%" });
          }
          this._progressMessage.innerHTML = "";
          util_element.setHTML(this._progressMessage, message || "");
        };
        ol_control_Dialog.prototype._onButton = function(button, callback) {
          var fn = function(e) {
            e.preventDefault();
            if (button !== "submit" || this.get("closeOnSubmit") !== false)
              this.hide();
            var inputs = {};
            this.element.querySelectorAll("form input").forEach(function(input) {
              if (input.className)
                inputs[input.className] = input;
            });
            this.dispatchEvent({ type: "button", button, inputs });
            if (typeof callback === "function")
              callback(button, inputs);
          }.bind(this);
          return fn;
        };
        ol_control_Dialog.prototype.hide = function() {
          this.element.classList.remove("ol-visible");
          this.dispatchEvent({ type: "hide" });
        };
        ol_control_Dialog.prototype.close = ol_control_Dialog.prototype.hide;
        ol_control_Dialog.prototype.isOpen = function() {
          return this.element.classList.contains("ol-visible");
        };
        var Dialog = ol_control_Dialog;
        var DEFAULT_FILL_COLOR = "#333";
        var Text_Text = function() {
          function Text(opt_options) {
            var options = opt_options || {};
            this.font_ = options.font;
            this.rotation_ = options.rotation;
            this.rotateWithView_ = options.rotateWithView;
            this.scale_ = options.scale;
            this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
            this.text_ = options.text;
            this.textAlign_ = options.textAlign;
            this.textBaseline_ = options.textBaseline;
            this.fill_ = options.fill !== void 0 ? options.fill : new style_Fill({ color: DEFAULT_FILL_COLOR });
            this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
            this.placement_ = options.placement !== void 0 ? options.placement : TextPlacement.POINT;
            this.overflow_ = !!options.overflow;
            this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
            this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
            this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
            this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
            this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
            this.padding_ = options.padding === void 0 ? null : options.padding;
          }
          Text.prototype.clone = function() {
            var scale = this.getScale();
            return new Text({
              font: this.getFont(),
              placement: this.getPlacement(),
              maxAngle: this.getMaxAngle(),
              overflow: this.getOverflow(),
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              scale: Array.isArray(scale) ? scale.slice() : scale,
              text: this.getText(),
              textAlign: this.getTextAlign(),
              textBaseline: this.getTextBaseline(),
              fill: this.getFill() ? this.getFill().clone() : void 0,
              stroke: this.getStroke() ? this.getStroke().clone() : void 0,
              offsetX: this.getOffsetX(),
              offsetY: this.getOffsetY(),
              backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
              backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
              padding: this.getPadding()
            });
          };
          Text.prototype.getOverflow = function() {
            return this.overflow_;
          };
          Text.prototype.getFont = function() {
            return this.font_;
          };
          Text.prototype.getMaxAngle = function() {
            return this.maxAngle_;
          };
          Text.prototype.getPlacement = function() {
            return this.placement_;
          };
          Text.prototype.getOffsetX = function() {
            return this.offsetX_;
          };
          Text.prototype.getOffsetY = function() {
            return this.offsetY_;
          };
          Text.prototype.getFill = function() {
            return this.fill_;
          };
          Text.prototype.getRotateWithView = function() {
            return this.rotateWithView_;
          };
          Text.prototype.getRotation = function() {
            return this.rotation_;
          };
          Text.prototype.getScale = function() {
            return this.scale_;
          };
          Text.prototype.getScaleArray = function() {
            return this.scaleArray_;
          };
          Text.prototype.getStroke = function() {
            return this.stroke_;
          };
          Text.prototype.getText = function() {
            return this.text_;
          };
          Text.prototype.getTextAlign = function() {
            return this.textAlign_;
          };
          Text.prototype.getTextBaseline = function() {
            return this.textBaseline_;
          };
          Text.prototype.getBackgroundFill = function() {
            return this.backgroundFill_;
          };
          Text.prototype.getBackgroundStroke = function() {
            return this.backgroundStroke_;
          };
          Text.prototype.getPadding = function() {
            return this.padding_;
          };
          Text.prototype.setOverflow = function(overflow) {
            this.overflow_ = overflow;
          };
          Text.prototype.setFont = function(font) {
            this.font_ = font;
          };
          Text.prototype.setMaxAngle = function(maxAngle) {
            this.maxAngle_ = maxAngle;
          };
          Text.prototype.setOffsetX = function(offsetX) {
            this.offsetX_ = offsetX;
          };
          Text.prototype.setOffsetY = function(offsetY) {
            this.offsetY_ = offsetY;
          };
          Text.prototype.setPlacement = function(placement) {
            this.placement_ = placement;
          };
          Text.prototype.setRotateWithView = function(rotateWithView) {
            this.rotateWithView_ = rotateWithView;
          };
          Text.prototype.setFill = function(fill) {
            this.fill_ = fill;
          };
          Text.prototype.setRotation = function(rotation) {
            this.rotation_ = rotation;
          };
          Text.prototype.setScale = function(scale) {
            this.scale_ = scale;
            this.scaleArray_ = toSize(scale !== void 0 ? scale : 1);
          };
          Text.prototype.setStroke = function(stroke) {
            this.stroke_ = stroke;
          };
          Text.prototype.setText = function(text) {
            this.text_ = text;
          };
          Text.prototype.setTextAlign = function(textAlign) {
            this.textAlign_ = textAlign;
          };
          Text.prototype.setTextBaseline = function(textBaseline) {
            this.textBaseline_ = textBaseline;
          };
          Text.prototype.setBackgroundFill = function(fill) {
            this.backgroundFill_ = fill;
          };
          Text.prototype.setBackgroundStroke = function(stroke) {
            this.backgroundStroke_ = stroke;
          };
          Text.prototype.setPadding = function(padding) {
            this.padding_ = padding;
          };
          return Text;
        }();
        var style_Text = Text_Text;
        var ol_ext_getMapCanvas = function(map) {
          if (!map)
            return null;
          var canvas = map.getViewport().getElementsByClassName("ol-fixedoverlay")[0];
          if (!canvas) {
            if (map.getViewport().querySelector(".ol-layers")) {
              canvas = document.createElement("canvas");
              canvas.className = "ol-fixedoverlay";
              map.getViewport().querySelector(".ol-layers").after(canvas);
              map.on("precompose", function(e) {
                canvas.width = map.getSize()[0] * e.frameState.pixelRatio;
                canvas.height = map.getSize()[1] * e.frameState.pixelRatio;
              });
            } else {
              canvas = map.getViewport().querySelector("canvas");
            }
          }
          return canvas;
        };
        var getMapCanvas = ol_ext_getMapCanvas;
        var ol_control_CanvasBase = function(options) {
          if (!options)
            options = {};
          this.setStyle(options.style);
          Control["default"].call(this, options);
        };
        util_ext(ol_control_CanvasBase, Control["default"]);
        ol_control_CanvasBase.prototype.setMap = function(map) {
          this.getCanvas(map);
          var oldmap = this.getMap();
          if (this._listener) {
            Object(Observable["b"])(this._listener);
            this._listener = null;
          }
          Control["default"].prototype.setMap.call(this, map);
          if (oldmap) {
            try {
              oldmap.renderSync();
            } catch (e) {
            }
          }
          if (map) {
            this._listener = map.on("postcompose", this._draw.bind(this));
          }
        };
        ol_control_CanvasBase.prototype.getCanvas = function(map) {
          return getMapCanvas(map);
        };
        ol_control_CanvasBase.prototype.getContext = function(e) {
          var ctx = e.context;
          if (!ctx && this.getMap()) {
            var c = this.getMap().getViewport().getElementsByClassName("ol-fixedoverlay")[0];
            ctx = c ? c.getContext("2d") : null;
          }
          return ctx;
        };
        ol_control_CanvasBase.prototype.setStyle = function(style) {
          this._style = style || new style_Style({});
        };
        ol_control_CanvasBase.prototype.getStyle = function() {
          return this._style;
        };
        ol_control_CanvasBase.prototype.getStroke = function() {
          var t = this._style.getStroke();
          if (!t)
            this._style.setStroke(new style_Stroke({ color: "#000", width: 1.25 }));
          return this._style.getStroke();
        };
        ol_control_CanvasBase.prototype.getFill = function() {
          var t = this._style.getFill();
          if (!t)
            this._style.setFill(new style_Fill({ color: "#fff" }));
          return this._style.getFill();
        };
        ol_control_CanvasBase.prototype.getTextStroke = function() {
          var t = this._style.getText();
          if (!t)
            t = new style_Text({});
          if (!t.getStroke())
            t.setStroke(new style_Stroke({ color: "#fff", width: 3 }));
          return t.getStroke();
        };
        ol_control_CanvasBase.prototype.getTextFill = function() {
          var t = this._style.getText();
          if (!t)
            t = new style_Text({});
          if (!t.getFill())
            t.setFill(new style_Fill({ color: "#fff" }));
          return t.getFill();
        };
        ol_control_CanvasBase.prototype.getTextFont = function() {
          var t = this._style.getText();
          if (!t)
            t = new style_Text({});
          if (!t.getFont())
            t.setFont("12px sans-serif");
          return t.getFont();
        };
        ol_control_CanvasBase.prototype._draw = function() {
          console.warn("[CanvasBase] draw function not implemented.");
        };
        var CanvasBase = ol_control_CanvasBase;
        function toContext(context, opt_options) {
          var canvas = context.canvas;
          var options = opt_options ? opt_options : {};
          var pixelRatio = options.pixelRatio || has["a"];
          var size = options.size;
          if (size) {
            canvas.width = size[0] * pixelRatio;
            canvas.height = size[1] * pixelRatio;
            canvas.style.width = size[0] + "px";
            canvas.style.height = size[1] + "px";
          }
          var extent = [0, 0, canvas.width, canvas.height];
          var transform2 = transform_scale(create(), pixelRatio, pixelRatio);
          return new Immediate(context, pixelRatio, extent, transform2, 0);
        }
        function render_getVectorContext(event) {
          if (!(event.context instanceof CanvasRenderingContext2D)) {
            throw new Error("Only works for render events from Canvas 2D layers");
          }
          var canvasPixelRatio = event.inversePixelTransform[0];
          var frameState = event.frameState;
          var transform2 = multiply(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);
          var squaredTolerance = getSquaredTolerance(frameState.viewState.resolution, canvasPixelRatio);
          var userTransform;
          var userProjection = getUserProjection();
          if (userProjection) {
            userTransform = getTransformFromProjections(userProjection, frameState.viewState.projection);
          }
          return new Immediate(event.context, canvasPixelRatio, frameState.extent, transform2, frameState.viewState.rotation, squaredTolerance, userTransform);
        }
        function getRenderPixel(event, pixel) {
          return apply(event.inversePixelTransform, pixel.slice(0));
        }
        function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
          var o, t;
          var n = (end - offset) / stride;
          if (n === 1) {
            o = offset;
          } else if (n === 2) {
            o = offset;
            t = fraction;
          } else if (n !== 0) {
            var x1 = flatCoordinates[offset];
            var y1 = flatCoordinates[offset + 1];
            var length_1 = 0;
            var cumulativeLengths = [0];
            for (var i = offset + stride; i < end; i += stride) {
              var x2 = flatCoordinates[i];
              var y2 = flatCoordinates[i + 1];
              length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
              cumulativeLengths.push(length_1);
              x1 = x2;
              y1 = y2;
            }
            var target = fraction * length_1;
            var index = Object(ol_array["a"])(cumulativeLengths, target);
            if (index < 0) {
              t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
              o = offset + (-index - 2) * stride;
            } else {
              o = offset + index * stride;
            }
          }
          var dimension = opt_dimension > 1 ? opt_dimension : 2;
          var dest = opt_dest ? opt_dest : new Array(dimension);
          for (var i = 0; i < dimension; ++i) {
            dest[i] = o === void 0 ? NaN : t === void 0 ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
          }
          return dest;
        }
        function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
          if (end == offset) {
            return null;
          }
          var coordinate;
          if (m < flatCoordinates[offset + stride - 1]) {
            if (extrapolate) {
              coordinate = flatCoordinates.slice(offset, offset + stride);
              coordinate[stride - 1] = m;
              return coordinate;
            } else {
              return null;
            }
          } else if (flatCoordinates[end - 1] < m) {
            if (extrapolate) {
              coordinate = flatCoordinates.slice(end - stride, end);
              coordinate[stride - 1] = m;
              return coordinate;
            } else {
              return null;
            }
          }
          if (m == flatCoordinates[offset + stride - 1]) {
            return flatCoordinates.slice(offset, offset + stride);
          }
          var lo = offset / stride;
          var hi = end / stride;
          while (lo < hi) {
            var mid = lo + hi >> 1;
            if (m < flatCoordinates[(mid + 1) * stride - 1]) {
              hi = mid;
            } else {
              lo = mid + 1;
            }
          }
          var m0 = flatCoordinates[lo * stride - 1];
          if (m == m0) {
            return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
          }
          var m1 = flatCoordinates[(lo + 1) * stride - 1];
          var t = (m - m0) / (m1 - m0);
          coordinate = [];
          for (var i = 0; i < stride - 1; ++i) {
            coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
          }
          coordinate.push(m);
          return coordinate;
        }
        function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
          if (interpolate) {
            return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
          }
          var coordinate;
          if (m < flatCoordinates[stride - 1]) {
            if (extrapolate) {
              coordinate = flatCoordinates.slice(0, stride);
              coordinate[stride - 1] = m;
              return coordinate;
            } else {
              return null;
            }
          }
          if (flatCoordinates[flatCoordinates.length - 1] < m) {
            if (extrapolate) {
              coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
              coordinate[stride - 1] = m;
              return coordinate;
            } else {
              return null;
            }
          }
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            if (offset == end) {
              continue;
            }
            if (m < flatCoordinates[offset + stride - 1]) {
              return null;
            } else if (m <= flatCoordinates[end - 1]) {
              return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
            }
            offset = end;
          }
          return null;
        }
        var LineString_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var LineString_LineString = function(_super) {
          LineString_extends(LineString, _super);
          function LineString(coordinates, opt_layout) {
            var _this = _super.call(this) || this;
            _this.flatMidpoint_ = null;
            _this.flatMidpointRevision_ = -1;
            _this.maxDelta_ = -1;
            _this.maxDeltaRevision_ = -1;
            if (opt_layout !== void 0 && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, coordinates);
            } else {
              _this.setCoordinates(coordinates, opt_layout);
            }
            return _this;
          }
          LineString.prototype.appendCoordinate = function(coordinate) {
            if (!this.flatCoordinates) {
              this.flatCoordinates = coordinate.slice();
            } else {
              Object(ol_array["c"])(this.flatCoordinates, coordinate);
            }
            this.changed();
          };
          LineString.prototype.clone = function() {
            var lineString = new LineString(this.flatCoordinates.slice(), this.layout);
            lineString.applyProperties(this);
            return lineString;
          };
          LineString.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
            }
            if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
            }
            return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
          };
          LineString.prototype.forEachSegment = function(callback) {
            return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
          };
          LineString.prototype.getCoordinateAtM = function(m, opt_extrapolate) {
            if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM) {
              return null;
            }
            var extrapolate = opt_extrapolate !== void 0 ? opt_extrapolate : false;
            return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
          };
          LineString.prototype.getCoordinates = function() {
            return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
          };
          LineString.prototype.getCoordinateAt = function(fraction, opt_dest) {
            return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
          };
          LineString.prototype.getLength = function() {
            return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
          };
          LineString.prototype.getFlatMidpoint = function() {
            if (this.flatMidpointRevision_ != this.getRevision()) {
              this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
              this.flatMidpointRevision_ = this.getRevision();
            }
            return this.flatMidpoint_;
          };
          LineString.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
            var simplifiedFlatCoordinates = [];
            simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
            return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);
          };
          LineString.prototype.getType = function() {
            return geom_GeometryType.LINE_STRING;
          };
          LineString.prototype.intersectsExtent = function(extent) {
            return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
          };
          LineString.prototype.setCoordinates = function(coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 1);
            if (!this.flatCoordinates) {
              this.flatCoordinates = [];
            }
            this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
            this.changed();
          };
          return LineString;
        }(geom_SimpleGeometry);
        var geom_LineString = LineString_LineString;
        var ol_legend_Item = function(options) {
          options = options || {};
          ol_Object["a"].call(this, options);
          if (options.feature)
            this.set("feature", options.feature.clone());
        };
        util_ext(ol_legend_Item, ol_Object["a"]);
        ol_legend_Item.prototype.setTitle = function(title) {
          this.set("title", title || "");
          this.changed();
        };
        ol_legend_Item.prototype.getElement = function(size, onclick) {
          var element = util_element.create("LI", {
            className: this.get("className"),
            click: function(e) {
              onclick(false);
              e.stopPropagation();
            },
            style: { height: size[1] + "px" },
            "aria-label": this.get("title")
          });
          util_element.create("DIV", {
            click: function(e) {
              onclick(true);
              e.stopPropagation();
            },
            style: {
              width: size[0] + "px",
              height: size[1] + "px"
            },
            parent: element
          });
          return element;
        };
        var Item = ol_legend_Item;
        if (window.ol && !ol.legend) {
          ol.legend = {};
        }
        var ol_legend_Legend = function(options) {
          options = options || {};
          ol_Object["a"].call(this);
          this._items = new ol_Collection();
          var listeners = [];
          var tout;
          this._items.on("add", function(e) {
            listeners.push({
              item: e.element,
              on: e.element.on("change", function() {
                this.refresh();
              }.bind(this))
            });
            if (tout) {
              clearTimeout(tout);
              tout = null;
            }
            tout = setTimeout(function() {
              this.refresh();
            }.bind(this), 0);
          }.bind(this));
          this._items.on("remove", function(e) {
            for (var i = 0; i < listeners; i++) {
              if (e.element === listeners[i].item) {
                Object(Observable["b"])(listeners[i].on);
                listeners.splice(i, 1);
                break;
              }
            }
            if (tout) {
              clearTimeout(tout);
              tout = null;
            }
            tout = setTimeout(function() {
              this.refresh();
            }.bind(this), 0);
          }.bind(this));
          this._listElement = util_element.create("UL", {
            className: "ol-legend"
          });
          this._canvas = document.createElement("canvas");
          this.set("size", options.size || [40, 25], true);
          this.set("margin", options.margin === 0 ? 0 : options.margin || 10, true);
          this._textStyle = options.textStyle || new style_Text({
            font: "16px sans-serif",
            fill: new style_Fill({
              color: "#333"
            }),
            backgroundFill: new style_Fill({
              color: "rgba(255,255,255,.8)"
            })
          });
          this._title = new Item({ title: options.title || "", className: "ol-title" });
          if (options.titleStyle) {
            this._titleStyle = options.titleStyle;
          } else {
            this._titleStyle = this._textStyle.clone();
            this._titleStyle.setFont("bold " + this._titleStyle.getFont());
          }
          this.setStyle(options.style);
          if (options.items instanceof Array) {
            options.items.forEach(function(item) {
              this.addItem(item);
            }.bind(this));
          }
          this.refresh();
        };
        util_ext(ol_legend_Legend, ol_Object["a"]);
        ol_legend_Legend.prototype.setTitle = function(title) {
          this._title.setTitle(title);
          this.refresh();
        };
        ol_legend_Legend.prototype.getTitle = function() {
          return this._title.get("title");
        };
        ol_legend_Legend.prototype.getTextStyle = function() {
          return this._textStyle;
        };
        ol_legend_Legend.prototype.set = function(key, value, opt_silent) {
          ol_Object["a"].prototype.set.call(this, key, value, opt_silent);
          if (!opt_silent)
            this.refresh();
        };
        ol_legend_Legend.prototype.getListElement = function() {
          return this._listElement;
        };
        ol_legend_Legend.prototype.getCanvas = function() {
          return this._canvas;
        };
        ol_legend_Legend.prototype.setStyle = function(style) {
          this._style = style;
          this.refresh();
        };
        ol_legend_Legend.prototype.addItem = function(item) {
          if (item instanceof Item) {
            this._items.push(item);
          } else {
            this._items.push(new Item(item));
          }
        };
        ol_legend_Legend.prototype.getItems = function() {
          return this._items;
        };
        ol_legend_Legend.prototype._drawText = function(ctx, text, x, y) {
          ctx.save();
          ctx.scale(has["a"], has["a"]);
          text = text || "";
          var txt = text.split("\n");
          if (txt.length === 1) {
            ctx.fillText(text, x, y);
          } else {
            ctx.textBaseline = "bottom";
            ctx.fillText(txt[0], x, y);
            ctx.textBaseline = "top";
            ctx.fillText(txt[1], x, y);
          }
          ctx.restore();
        };
        ol_legend_Legend.prototype._measureText = function(ctx, text) {
          var txt = (text || "").split("\n");
          if (txt.length === 1) {
            return ctx.measureText(text);
          } else {
            var m1 = ctx.measureText(txt[0]);
            var m2 = ctx.measureText(txt[1]);
            return { width: Math.max(m1.width, m2.width), height: m1.height + m2.height };
          }
        };
        ol_legend_Legend.prototype.refresh = function() {
          var table = this._listElement;
          table.innerHTML = "";
          var margin = this.get("margin");
          var width = this.get("size")[0] + 2 * margin;
          var height = this.get("lineHeight") || this.get("size")[1] + 2 * margin;
          var canvas = this.getCanvas();
          var ctx = canvas.getContext("2d");
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          var ratio = has["a"];
          ctx.font = this._titleStyle.getFont();
          var textWidth = this._measureText(ctx, this.getTitle("title")).width;
          this._items.forEach(function(r) {
            if (r.get("feature") || r.get("typeGeom")) {
              ctx.font = r.get("textStyle") ? r.get("textStyle").getFont() : this._textStyle.getFont();
              textWidth = Math.max(textWidth, this._measureText(ctx, r.get("title")).width + width);
            } else {
              ctx.font = r.get("textStyle") ? r.get("textStyle").getFont() : this._titleStyle.getFont();
              textWidth = Math.max(textWidth, this._measureText(ctx, r.get("title")).width);
            }
          }.bind(this));
          canvas.width = (textWidth + 2 * margin) * ratio;
          canvas.height = (this._items.getLength() + 1) * height * ratio;
          canvas.style.height = (this._items.getLength() + 1) * height + "px";
          ctx.textBaseline = "middle";
          ctx.fillStyle = asString(this._textStyle.getFill().getColor());
          if (this.getTitle()) {
            table.appendChild(this._title.getElement([width, height], function(b) {
              this.dispatchEvent({
                type: "select",
                index: -1,
                symbol: b,
                item: this._title
              });
            }.bind(this)));
            ctx.font = this._titleStyle.getFont();
            ctx.textAlign = "center";
            this._drawText(ctx, this.getTitle(), canvas.width / ratio / 2, height / 2);
          }
          this._items.forEach(function(r, i) {
            var index = i + (this.getTitle() ? 1 : 0);
            table.appendChild(r.getElement([width, height], function(b) {
              this.dispatchEvent({
                type: "select",
                index: i,
                symbol: b,
                item: r
              });
            }.bind(this)));
            var item = r.getProperties();
            ctx.textAlign = "left";
            if (item.feature || item.typeGeom) {
              canvas = this.getLegendImage(item, canvas, index);
              ctx.font = r.get("textStyle") ? r.get("textStyle").getFont() : this._textStyle.getFont();
              this._drawText(ctx, r.get("title"), width + margin, (i + 1.5) * height);
            } else {
              ctx.font = r.get("textStyle") ? r.get("textStyle").getFont() : this._titleStyle.getFont();
              if (/\bcenter\b/.test(item.className)) {
                ctx.textAlign = "center";
                this._drawText(ctx, r.get("title"), canvas.width / ratio / 2, (i + 1.5) * height);
              } else {
                this._drawText(ctx, r.get("title"), margin, (i + 1.5) * height);
              }
            }
          }.bind(this));
          this.dispatchEvent({
            type: "refresh",
            width,
            height: (this._items.length + 1) * height
          });
        };
        ol_legend_Legend.prototype.getLegendImage = function(options, canvas, row) {
          options = options || {};
          return ol_legend_Legend.getLegendImage({
            className: options.className,
            feature: options.feature,
            typeGeom: options.typeGeom,
            style: options.style || this._style,
            properties: options.properties,
            margin: options.margin || this.get("margin"),
            size: options.size || this.get("size"),
            lineHeight: options.lineHeight || this.get("lineHeight"),
            onload: function() {
              this.refresh();
            }.bind(this)
          }, canvas, row);
        };
        ol_legend_Legend.getLegendImage = function(item, canvas, row) {
          item = item || {};
          if (typeof item.margin === "undefined")
            item.margin = 10;
          var size = item.size || [40, 25];
          item.onload = item.onload || function() {
            setTimeout(function() {
              ol_legend_Legend.getLegendImage(item, canvas, row);
            }, 100);
          };
          var width = size[0] + 2 * item.margin;
          var height = item.lineHeight || size[1] + 2 * item.margin;
          var ratio = has["a"];
          if (!canvas) {
            row = 0;
            canvas = document.createElement("canvas");
            canvas.width = width * ratio;
            canvas.height = height * ratio;
          }
          var ctx = canvas.getContext("2d");
          ctx.save();
          var vectorContext = toContext(ctx, { pixelRatio: ratio });
          var typeGeom = item.typeGeom;
          var style;
          var feature = item.feature;
          if (!feature && typeGeom) {
            if (/Point/.test(typeGeom))
              feature = new ol_Feature(new geom_Point([0, 0]));
            else if (/LineString/.test(typeGeom))
              feature = new ol_Feature(new geom_LineString([0, 0]));
            else
              feature = new ol_Feature(new geom_Polygon([[0, 0]]));
            if (item.properties)
              feature.setProperties(item.properties);
          }
          if (feature) {
            style = feature.getStyle();
            if (typeof style === "function")
              style = style(feature);
            if (!style) {
              style = typeof item.style === "function" ? item.style(feature) : item.style || [];
            }
            typeGeom = feature.getGeometry().getType();
          } else {
            style = [];
          }
          if (!(style instanceof Array))
            style = [style];
          var cx = width / 2;
          var cy = height / 2;
          var sx = size[0] / 2;
          var sy = size[1] / 2;
          var i, s;
          if (typeGeom === "Point") {
            var extent = null;
            for (i = 0; s = style[i]; i++) {
              var img = s.getImage();
              if (img) {
                var imgElt = img.getImage();
                if (imgElt && imgElt.complete && !imgElt.naturalWidth) {
                  if (typeof item.onload === "function") {
                    imgElt.addEventListener("load", function() {
                      setTimeout(function() {
                        item.onload();
                      }, 100);
                    });
                  }
                  img.load();
                }
                if (img.getAnchor) {
                  var anchor = img.getAnchor();
                  if (anchor) {
                    var si = img.getSize();
                    var dx = anchor[0] - si[0];
                    var dy = anchor[1] - si[1];
                    if (!extent) {
                      extent = [dx, dy, dx + si[0], dy + si[1]];
                    } else {
                      extend2(extent, [dx, dy, dx + si[0], dy + si[1]]);
                    }
                  }
                }
              }
            }
            if (extent) {
              cx = cx + (extent[2] + extent[0]) / 2;
              cy = cy + (extent[3] + extent[1]) / 2;
            }
          }
          cy += row * height || 0;
          for (i = 0; s = style[i]; i++) {
            vectorContext.setStyle(s);
            switch (typeGeom) {
              case geom_Point:
              case "Point":
              case "MultiPoint":
                vectorContext.drawGeometry(new geom_Point([cx, cy]));
                break;
              case geom_LineString:
              case "LineString":
              case "MultiLineString":
                ctx.save();
                ctx.rect(item.margin * ratio, 0, size[0] * ratio, canvas.height);
                ctx.clip();
                vectorContext.drawGeometry(new geom_LineString([[cx - sx, cy], [cx + sx, cy]]));
                ctx.restore();
                break;
              case geom_Polygon:
              case "Polygon":
              case "MultiPolygon":
                vectorContext.drawGeometry(new geom_Polygon([[[cx - sx, cy - sy], [cx + sx, cy - sy], [cx + sx, cy + sy], [cx - sx, cy + sy], [cx - sx, cy - sy]]]));
                break;
            }
          }
          ctx.restore();
          return canvas;
        };
        var Legend = ol_legend_Legend;
        var ol_control_Legend = function(options) {
          options = options || {};
          var element = document.createElement("div");
          if (options.target) {
            element.className = options.className || "ol-legend";
          } else {
            element.className = (options.className || "ol-legend") + " ol-unselectable ol-control" + (options.collapsible === false ? " ol-uncollapsible" : " ol-collapsed");
            var button = document.createElement("button");
            button.setAttribute("type", "button");
            button.addEventListener("click", function() {
              this.toggle();
            }.bind(this));
            element.appendChild(button);
            button = document.createElement("button");
            button.setAttribute("type", "button");
            button.className = "ol-closebox";
            button.addEventListener("click", function() {
              this.toggle();
            }.bind(this));
            element.appendChild(button);
          }
          CanvasBase.call(this, {
            element,
            target: options.target
          });
          this._legend = options.legend;
          this._legend.getCanvas().className = "ol-legendImg";
          element.appendChild(this._legend.getCanvas());
          element.appendChild(this._legend.getListElement());
          if (options.collapsible !== false && options.collapsed === false)
            this.show();
          this._legend.on("select", function(e) {
            this.dispatchEvent(e);
          }.bind(this));
          this._legend.on("refresh", function() {
            if (this._onCanvas && this.getMap()) {
              try {
                this.getMap().renderSync();
              } catch (e) {
              }
            }
          }.bind(this));
        };
        util_ext(ol_control_Legend, CanvasBase);
        ol_control_Legend.prototype.getLegend = function() {
          return this._legend;
        };
        ol_control_Legend.prototype.setCanvas = function(b) {
          this._onCanvas = b;
          this.element.style.visibility = b ? "hidden" : "visible";
          if (this.getMap()) {
            try {
              this.getMap().renderSync();
            } catch (e) {
            }
          }
        };
        ol_control_Legend.prototype.onCanvas = function() {
          return !!this._onCanvas;
        };
        ol_control_Legend.prototype._draw = function(e) {
          if (this._onCanvas && !this.element.classList.contains("ol-collapsed")) {
            var canvas = this._legend.getCanvas();
            var ctx = this.getContext(e);
            var h = ctx.canvas.height - canvas.height;
            ctx.save();
            ctx.rect(0, h, canvas.width, canvas.height);
            var col = "#fff";
            if (this._legend.getTextStyle().getBackgroundFill()) {
              col = asString(this._legend.getTextStyle().getBackgroundFill().getColor());
            }
            ctx.fillStyle = ctx.strokeStyle = col;
            ctx.lineWidth = 10;
            ctx.lineJoin = "round";
            ctx.stroke();
            ctx.clearRect(0, h, canvas.width, canvas.height);
            ctx.fill();
            ctx.drawImage(canvas, 0, h);
            ctx.restore();
          }
        };
        ol_control_Legend.prototype.show = function() {
          if (this.element.classList.contains("ol-collapsed")) {
            this.element.classList.remove("ol-collapsed");
            this.dispatchEvent({ type: "change:collapse", collapsed: false });
            if (this.getMap()) {
              try {
                this.getMap().renderSync();
              } catch (e) {
              }
            }
          }
        };
        ol_control_Legend.prototype.hide = function() {
          if (!this.element.classList.contains("ol-collapsed")) {
            this.element.classList.add("ol-collapsed");
            this.dispatchEvent({ type: "change:collapse", collapsed: true });
            if (this.getMap()) {
              try {
                this.getMap().renderSync();
              } catch (e) {
              }
            }
          }
        };
        ol_control_Legend.prototype.collapse = function(b) {
          if (b === false)
            this.show();
          else
            this.hide();
        };
        ol_control_Legend.prototype.isCollapsed = function() {
          return this.element.classList.contains("ol-collapsed");
        };
        ol_control_Legend.prototype.toggle = function() {
          this.element.classList.toggle("ol-collapsed");
          this.dispatchEvent({ type: "change:collapse", collapsed: this.element.classList.contains("ol-collapsed") });
          if (this.getMap()) {
            try {
              this.getMap().renderSync();
            } catch (e) {
            }
          }
        };
        var control_Legend = ol_control_Legend;
        var ol_control_Print = function(options) {
          if (!options)
            options = {};
          var element = util_element.create("DIV", {
            className: options.className || "ol-print"
          });
          if (!options.target) {
            element.classList.add("ol-unselectable", "ol-control");
            util_element.create("BUTTON", {
              type: "button",
              title: options.title || "Print",
              click: function() {
                this.print();
              }.bind(this),
              parent: element
            });
          }
          Control["default"].call(this, {
            element,
            target: options.target
          });
          this.set("immediate", options.immediate);
          this.set("imageType", options.imageType || "image/jpeg");
          this.set("quality", options.quality || 0.8);
          this.set("orientation", options.orientation);
        };
        util_ext(ol_control_Print, Control["default"]);
        ol_control_Print.prototype.toClipboard = function(e, callback) {
          try {
            e.canvas.toBlob(function(blob) {
              try {
                navigator.clipboard.write([
                  new window.ClipboardItem(Object.defineProperty({}, blob.type, {
                    value: blob,
                    enumerable: true
                  }))
                ]);
                if (typeof callback === "function")
                  callback(true);
              } catch (err) {
                if (typeof callback === "function")
                  callback(false);
              }
            });
          } catch (err) {
            if (typeof callback === "function")
              callback(false);
          }
        };
        ol_control_Print.prototype.copyMap = function(options, callback) {
          this.once("print", function(e) {
            this.toClipboard(e, callback);
          }.bind(this));
          this.print(options);
        };
        ol_control_Print.prototype._getCanvas = function(event, imageType, canvas) {
          var ctx;
          if (event.context) {
            canvas = event.context.canvas;
          } else {
            if (!canvas) {
              canvas = document.createElement("canvas");
              var size = this.getMap().getSize();
              canvas.width = size[0];
              canvas.height = size[1];
              ctx = canvas.getContext("2d");
              if (/jp.*g$/.test(imageType)) {
                ctx.fillStyle = this.get("bgColor") || "white";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
              }
            } else {
              ctx = canvas.getContext("2d");
            }
            this.getMap().getViewport().querySelectorAll(".ol-layers canvas, canvas.ol-fixedoverlay").forEach(function(c) {
              if (c.width) {
                ctx.save();
                if (c.parentNode.style.opacity === "0")
                  return;
                ctx.globalAlpha = parseFloat(c.parentNode.style.opacity) || 1;
                if (util_element.getStyle(c.parentNode, "mix-blend-mode") === "multiply") {
                  ctx.globalCompositeOperation = "multiply";
                }
                var tr = util_element.getStyle(c, "transform") || util_element.getStyle(c, "-webkit-transform");
                if (/^matrix/.test(tr)) {
                  tr = tr.replace(/^matrix\(|\)$/g, "").split(",");
                  tr.forEach(function(t, i) {
                    tr[i] = parseFloat(t);
                  });
                  ctx.transform(tr[0], tr[1], tr[2], tr[3], tr[4], tr[5]);
                  ctx.drawImage(c, 0, 0);
                } else {
                  ctx.drawImage(c, 0, 0, util_element.getStyle(c, "width"), util_element.getStyle(c, "height"));
                }
                ctx.restore();
              }
            }.bind(this));
          }
          return canvas;
        };
        ol_control_Print.prototype.fastPrint = function(options, callback) {
          options = options || {};
          if (this._ol6) {
            requestAnimationFrame(function() {
              callback(this._getCanvas({}, options.imageType, options.canvas));
            }.bind(this));
          } else {
            this.getMap().once("postcompose", function(event) {
              if (!event.context)
                this._ol6 = true;
              callback(this._getCanvas(event, options.imageType, options.canvas));
            }.bind(this));
            this.getMap().render();
          }
        };
        ol_control_Print.prototype.print = function(options) {
          options = options || {};
          var imageType = options.imageType || this.get("imageType");
          var quality = options.quality || this.get("quality");
          if (this.getMap()) {
            if (options.immediate !== "silent") {
              this.dispatchEvent(Object.assign({
                type: "printing"
              }, options));
            }
            if (!options.immediate) {
              setTimeout(function() {
                options = Object.assign({}, options);
                options.immediate = "silent";
                this.print(options);
              }.bind(this), 200);
              return;
            }
            this.getMap().once(this.get("immediate") ? "postcompose" : "rendercomplete", function(event) {
              var canvas = this._getCanvas(event, imageType);
              var size = options.size || [210, 297];
              var format = options.format || "a4";
              var w, h, position;
              var orient = options.orient || this.get("orientation");
              var margin = typeof options.margin === "number" ? options.margin : 10;
              if (canvas) {
                if (orient !== "landscape" && orient !== "portrait") {
                  orient = canvas.width > canvas.height ? "landscape" : "portrait";
                }
                if (orient === "landscape")
                  size = [size[1], size[0]];
                var sc = Math.min((size[0] - 2 * margin) / canvas.width, (size[1] - 2 * margin) / canvas.height);
                w = sc * canvas.width;
                h = sc * canvas.height;
                position = [(size[0] - w) / 2, (size[1] - h) / 2];
              }
              var image;
              try {
                image = canvas ? canvas.toDataURL(imageType, quality) : null;
              } catch (e2) {
                this.dispatchEvent({
                  type: "error",
                  canvas
                });
                return;
              }
              var e = Object.assign({
                type: "print",
                print: {
                  format,
                  orientation: orient,
                  unit: "mm",
                  size,
                  position,
                  imageWidth: w,
                  imageHeight: h
                },
                image,
                imageType,
                quality,
                canvas
              }, options);
              this.dispatchEvent(e);
            }.bind(this));
            this.getMap().render();
          }
        };
        var Print = ol_control_Print;
        var ol_control_CanvasTitle = function(options) {
          if (!options)
            options = {};
          var elt = util_element.create("DIV", {
            className: (options.className || "") + " ol-control-title ol-unselectable",
            style: {
              display: "block",
              visibility: "hidden"
            }
          });
          CanvasBase.call(this, {
            element: elt,
            style: options.style
          });
          this.setTitle(options.title || "");
          this.setVisible(options.visible);
          this.element.style.font = this.getTextFont();
        };
        util_ext(ol_control_CanvasTitle, CanvasBase);
        ol_control_CanvasTitle.prototype.setStyle = function(style) {
          CanvasBase.prototype.setStyle.call(this, style);
          if (this.element) {
            this.element.style.font = this.getTextFont();
          }
          if (this.getMap())
            this.getMap().render();
        };
        ol_control_CanvasTitle.prototype.setTitle = function(title) {
          this.element.textContent = title;
          this.set("title", title);
          if (this.getMap()) {
            try {
              this.getMap().renderSync();
            } catch (e) {
            }
          }
        };
        ol_control_CanvasTitle.prototype.getTitle = function() {
          return this.get("title");
        };
        ol_control_CanvasTitle.prototype.setVisible = function(b) {
          this.element.style.display = b ? "block" : "none";
          if (this.getMap()) {
            try {
              this.getMap().renderSync();
            } catch (e) {
            }
          }
        };
        ol_control_CanvasTitle.prototype.getVisible = function() {
          return this.element.style.display !== "none";
        };
        ol_control_CanvasTitle.prototype._draw = function(e) {
          if (!this.getVisible())
            return;
          var ctx = this.getContext(e);
          if (!ctx)
            return;
          var ratio = e.frameState.pixelRatio;
          ctx.save();
          ctx.scale(ratio, ratio);
          var eltRect = this.element.getBoundingClientRect();
          var mapRect = this.getMap().getViewport().getBoundingClientRect();
          var sc = this.getMap().getSize()[0] / mapRect.width;
          ctx.translate(Math.round((eltRect.left - mapRect.left) * sc), Math.round((eltRect.top - mapRect.top) * sc));
          var h = this.element.clientHeight;
          var w = this.element.clientWidth;
          var left = w / 2;
          ctx.beginPath();
          ctx.fillStyle = asString(this.getFill().getColor());
          ctx.rect(0, 0, w, h);
          ctx.fill();
          ctx.closePath();
          ctx.beginPath();
          ctx.fillStyle = asString(this.getTextFill().getColor());
          ctx.strokeStyle = asString(this.getTextStroke().getColor());
          ctx.lineWidth = this.getTextStroke().getWidth();
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = this.getTextFont();
          if (ctx.lineWidth)
            ctx.strokeText(this.getTitle(), left, h / 2);
          ctx.fillText(this.getTitle(), left, h / 2);
          ctx.closePath();
          ctx.restore();
        };
        var CanvasTitle = ol_control_CanvasTitle;
        var ol_sphere_greatCircleBearing = function(origin, destination) {
          var toRad = Math.PI / 180;
          var ori = [origin[0] * toRad, origin[1] * toRad];
          var dest = [destination[0] * toRad, destination[1] * toRad];
          var bearing = Math.atan2(Math.sin(dest[0] - ori[0]) * Math.cos(dest[1]), Math.cos(ori[1]) * Math.sin(dest[1]) - Math.sin(ori[1]) * Math.cos(dest[1]) * Math.cos(dest[0] - ori[0]));
          return bearing;
        };
        var ol_sphere_computeDestinationPoint = function(origin, distance, bearing, options) {
          options = options || {};
          var toRad = Math.PI / 180;
          var radius = options.radius || 63710088e-1;
          var phi1 = origin[1] * toRad;
          var lambda1 = origin[0] * toRad;
          var delta = distance / radius;
          var phi2 = Math.asin(Math.sin(phi1) * Math.cos(delta) + Math.cos(phi1) * Math.sin(delta) * Math.cos(bearing));
          var lambda2 = lambda1 + Math.atan2(Math.sin(bearing) * Math.sin(delta) * Math.cos(phi1), Math.cos(delta) - Math.sin(phi1) * Math.sin(phi2));
          var lon = lambda2 / toRad;
          if (options.normalize !== false && (lon < -180 || lon > 180)) {
            lon = lon * 540 % 360 - 180;
          }
          return [lon, phi2 / toRad];
        };
        var ol_sphere_greatCircleTrack = function(origin, destination, options) {
          options = options || {};
          var bearing = ol_sphere_greatCircleBearing(origin, destination);
          var dist = getDistance(origin, destination, options.radius);
          var distance = options.distance || 1e3;
          var d = distance;
          var geom = [origin];
          while (d < dist) {
            geom.push(ol_sphere_computeDestinationPoint(origin, d, bearing, { radius: options.radius, normalize: false }));
            d += distance;
          }
          var pt = ol_sphere_computeDestinationPoint(origin, dist, bearing, { radius: options.radius, normalize: false });
          if (Math.abs(pt[0] - destination[0]) > 1) {
            if (pt[0] > destination[0])
              destination[0] += 360;
            else
              destination[0] -= 360;
          }
          geom.push(destination);
          return geom;
        };
        var ol_sphere_getMapScale = function(map, dpi) {
          var view = map.getView();
          var proj = view.getProjection();
          var center = view.getCenter();
          var px = map.getPixelFromCoordinate(center);
          px[1] += 1;
          var coord = map.getCoordinateFromPixel(px);
          var d = getDistance(proj_transform(center, proj, "EPSG:4326"), proj_transform(coord, proj, "EPSG:4326"));
          d *= (dpi || 96) / 0.0254;
          return d;
        };
        var ol_sphere_setMapScale = function(map, scale, dpi) {
          if (map && scale) {
            var fac = scale;
            if (typeof scale === "string") {
              fac = scale.split("/")[1];
              if (!fac)
                fac = scale;
              fac = fac.replace(/[^\d]/g, "");
              fac = parseInt(fac);
            }
            if (!fac)
              return;
            var view = map.getView();
            var proj = view.getProjection();
            var center = view.getCenter();
            var px = map.getPixelFromCoordinate(center);
            px[1] += 1;
            var coord = map.getCoordinateFromPixel(px);
            var d = getDistance(proj_transform(center, proj, "EPSG:4326"), proj_transform(coord, proj, "EPSG:4326"));
            d *= (dpi || 96) / 0.0254;
            view.setResolution(view.getResolution() * fac / d);
            return fac;
          }
        };
        var ol_control_Compass = function(options) {
          if (!options)
            options = {};
          var elt = document.createElement("div");
          elt.className = "ol-control ol-compassctrl ol-unselectable ol-hidden" + (options.className ? " " + options.className : "");
          elt.style.position = "absolute";
          elt.style.visibility = "hidden";
          var style = options.style instanceof style_Stroke ? new style_Style({ stroke: options.style }) : options.style;
          if (!options.style) {
            style = new style_Style({ stroke: new style_Stroke({ width: 0 }) });
          }
          CanvasBase.call(this, {
            element: elt,
            style
          });
          this.set("rotateVithView", options.rotateWithView !== false);
          this.setVisible(options.visible !== false);
          this.setImage(options.image || options.src);
        };
        util_ext(ol_control_Compass, CanvasBase);
        ol_control_Compass.prototype.setImage = function(img) {
          if (img instanceof Image) {
            this.img_ = img;
            this.img_.onload = function() {
              if (this.getMap()) {
                try {
                  this.getMap().renderSync();
                } catch (e) {
                }
              }
            }.bind(this);
          } else if (typeof img === "string") {
            switch (img) {
              case "compact": {
                this.img_ = this.compactCompass_(this.element.clientWidth, this.getStroke().getColor());
                break;
              }
              case "default": {
                this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
                break;
              }
              default: {
                this.img_ = new Image();
                this.img_.onload = function() {
                  if (this.getMap()) {
                    try {
                      this.getMap().renderSync();
                    } catch (e) {
                    }
                  }
                }.bind(this);
                this.img_.src = img;
                break;
              }
            }
          } else {
            this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
          }
        };
        ol_control_Compass.prototype.compactCompass_ = function(s, color) {
          var canvas = document.createElement("canvas");
          var ctx = canvas.getContext("2d");
          s = canvas.width = canvas.height = s || 150;
          var r = s / 2;
          ctx.translate(r, r);
          ctx.fillStyle = color || "#963";
          ctx.lineWidth = 5;
          ctx.lineJoin = ctx.lineCap = "round";
          ctx.font = "bold " + r * 0.4 + "px sans-serif";
          ctx.textBaseline = "bottom";
          ctx.textAlign = "center";
          ctx.strokeStyle = "#fff";
          ctx.globalAlpha = 0.75;
          ctx.strokeText("N", 0, -r / 2);
          ctx.globalAlpha = 1;
          ctx.fillText("N", 0, -r / 2);
          ctx.beginPath();
          ctx.moveTo(0, r / 4);
          ctx.lineTo(r / 3, r / 2);
          ctx.lineTo(0, -r / 2);
          ctx.lineTo(-r / 3, r / 2);
          ctx.lineTo(0, r / 4);
          ctx.lineWidth = 12;
          ctx.fillStyle = "#fff";
          ctx.globalAlpha = 0.75;
          ctx.fill();
          ctx.stroke();
          ctx.globalAlpha = 1;
          ctx.fillStyle = ctx.strokeStyle = color || "#963";
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(0, r / 4);
          ctx.lineTo(0, -r / 2);
          ctx.lineTo(r / 3, r / 2);
          ctx.lineTo(0, r / 4);
          ctx.fill();
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, r / 4);
          ctx.lineTo(0, -r / 2);
          ctx.lineTo(-r / 3, r / 2);
          ctx.lineTo(0, r / 4);
          ctx.stroke();
          return canvas;
        };
        ol_control_Compass.prototype.defaultCompass_ = function(s, color) {
          var canvas = document.createElement("canvas");
          var ctx = canvas.getContext("2d");
          s = canvas.width = canvas.height = s || 150;
          var r = s / 2;
          var r2 = 0.22 * r;
          function draw(r3, r22) {
            ctx.fillStyle = color || "#963";
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(r3, 0);
            ctx.lineTo(r22, r22);
            ctx.moveTo(0, 0);
            ctx.lineTo(-r3, 0);
            ctx.lineTo(-r22, -r22);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, r3);
            ctx.lineTo(-r22, r22);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -r3);
            ctx.lineTo(r22, -r22);
            ctx.moveTo(0, 0);
            ctx.fill();
            ctx.stroke();
          }
          function draw2(r3, r22) {
            ctx.globalCompositeOperation = "destination-out";
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(r3, 0);
            ctx.lineTo(r22, -r22);
            ctx.moveTo(0, 0);
            ctx.lineTo(-r3, 0);
            ctx.lineTo(-r22, r22);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, r3);
            ctx.lineTo(r22, r22);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -r3);
            ctx.lineTo(-r22, -r22);
            ctx.moveTo(0, 0);
            ctx.fill();
            ctx.globalCompositeOperation = "source-over";
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(r3, 0);
            ctx.lineTo(r22, -r22);
            ctx.moveTo(0, 0);
            ctx.lineTo(-r3, 0);
            ctx.lineTo(-r22, r22);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, r3);
            ctx.lineTo(r22, r22);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -r3);
            ctx.lineTo(-r22, -r22);
            ctx.moveTo(0, 0);
            ctx.stroke();
          }
          ctx.translate(r, r);
          ctx.strokeStyle = color || "#963";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(0, 0, s * 0.41, 0, 2 * Math.PI);
          ctx.arc(0, 0, s * 0.44, 0, 2 * Math.PI);
          ctx.stroke();
          ctx.rotate(Math.PI / 4);
          draw(r * 0.9, r2 * 0.8);
          draw2(r * 0.9, r2 * 0.8);
          ctx.rotate(-Math.PI / 4);
          draw(r, r2);
          draw2(r, r2);
          return canvas;
        };
        ol_control_Compass.prototype.getVisible = function() {
          return util_element.getStyle(this.element, "display") === "block";
        };
        ol_control_Compass.prototype.setVisible = function(b) {
          if (b)
            this.element.classList.add("ol-visible");
          else
            this.element.classList.remove("ol-visible");
          if (this.getMap())
            this.getMap().render();
        };
        ol_control_Compass.prototype._draw = function(e) {
          var ctx = this.getContext(e);
          if (!ctx || !this.getVisible())
            return;
          var canvas = ctx.canvas;
          var i, da = [];
          for (i = 0; i < 8; i++)
            da[i] = [Math.cos(Math.PI * i / 8), Math.sin(Math.PI * i / 8)];
          var ratio = e.frameState.pixelRatio;
          ctx.save();
          ctx.scale(ratio, ratio);
          var w = this.element.clientWidth;
          var h = this.element.clientHeight;
          var pos = { left: this.element.offsetLeft, top: this.element.offsetTop };
          var compass = this.img_;
          var rot = e.frameState.viewState.rotation;
          ctx.beginPath();
          ctx.translate(pos.left + w / 2, pos.top + h / 2);
          if (this.get("rotateVithView"))
            ctx.rotate(rot);
          if (this.getStroke().getWidth()) {
            ctx.beginPath();
            ctx.strokeStyle = this.getStroke().getColor();
            ctx.lineWidth = this.getStroke().getWidth();
            var m = Math.max(canvas.width, canvas.height);
            for (i = 0; i < 8; i++) {
              ctx.moveTo(-da[i][0] * m, -da[i][1] * m);
              ctx.lineTo(da[i][0] * m, da[i][1] * m);
            }
            ctx.stroke();
          }
          if (compass.width) {
            ctx.drawImage(compass, -w / 2, -h / 2, w, h);
          }
          ctx.closePath();
          ctx.restore();
        };
        var Compass = ol_control_Compass;
        var ol_control_PrintDialog = function(options) {
          if (!options)
            options = {};
          this._lang = options.lang;
          var element = util_element.create("DIV", {
            className: (options.className || "ol-print") + " ol-unselectable ol-control"
          });
          util_element.create("BUTTON", {
            type: "button",
            title: options.title || "Print",
            click: function() {
              this.print();
            }.bind(this),
            parent: element
          });
          Control["default"].call(this, {
            element
          });
          if (options.openWindow) {
            this.on("print", function(e) {
              if (e.canvas) {
                window.open().document.write('<img src="' + e.canvas.toDataURL() + '"/>');
              }
            });
          }
          options.target = util_element.create("DIV");
          var printCtrl = this._printCtrl = new Print(options);
          printCtrl.on(["print", "error", "printing"], function(e) {
            content.setAttribute("data-status", e.type);
            if (!e.clipboard) {
              this.dispatchEvent(e);
            }
          }.bind(this));
          this._compass = new Compass({
            src: options.northImage || "compact",
            visible: false,
            className: "olext-print-compass",
            style: new style_Stroke({ color: "#333", width: 0 })
          });
          var printDialog = this._printDialog = new Dialog({
            target: document.body,
            closeBox: true,
            className: "ol-ext-print-dialog"
          });
          var content = printDialog.getContentElement();
          this._input = {};
          var param = util_element.create("DIV", {
            className: "ol-print-param",
            parent: content
          });
          this._pages = [util_element.create("DIV", {
            className: "ol-page"
          })];
          var printMap = util_element.create("DIV", {
            className: "ol-map",
            parent: this._pages[0]
          });
          util_element.create("DIV", {
            html: this._pages[0],
            className: "ol-print-map",
            parent: content
          });
          util_element.create("H2", {
            html: this.i18n("title"),
            parent: param
          });
          var ul = util_element.create("UL", { parent: param });
          var li = util_element.create("LI", {
            className: "ol-orientation",
            parent: ul
          });
          this._input.orientation = { list: li };
          var label = util_element.create("LABEL", {
            className: "portrait",
            parent: li
          });
          this._input.orientation.portrait = util_element.create("INPUT", {
            type: "radio",
            name: "ol-print-orientation",
            value: "portrait",
            checked: true,
            on: { change: function(e) {
              this.setOrientation(e.target.value);
            }.bind(this) },
            parent: label
          });
          util_element.create("SPAN", {
            html: this.i18n("portrait"),
            parent: label
          });
          label = util_element.create("LABEL", {
            className: "landscape",
            parent: li
          });
          this._input.orientation.landscape = util_element.create("INPUT", {
            type: "radio",
            name: "ol-print-orientation",
            value: "landscape",
            on: { change: function(e) {
              this.setOrientation(e.target.value);
            }.bind(this) },
            parent: label
          });
          util_element.create("SPAN", {
            html: this.i18n("landscape"),
            parent: label
          });
          var s;
          li = util_element.create("LI", {
            html: util_element.create("LABEL", {
              html: this.i18n("size")
            }),
            className: "ol-size",
            parent: ul
          });
          var size = this._input.size = util_element.create("SELECT", {
            on: { change: function() {
              this.setSize(size.value || originalSize);
            }.bind(this) },
            parent: li
          });
          for (s in this.paperSize) {
            util_element.create("OPTION", {
              html: s + (this.paperSize[s] ? " - " + this.paperSize[s][0] + "x" + this.paperSize[s][1] + " mm" : this.i18n("custom")),
              value: s,
              parent: size
            });
          }
          li = util_element.create("LI", {
            html: util_element.create("LABEL", {
              html: this.i18n("margin")
            }),
            className: "ol-margin",
            parent: ul
          });
          var margin = this._input.margin = util_element.create("SELECT", {
            on: { change: function() {
              this.setMargin(margin.value);
            }.bind(this) },
            parent: li
          });
          for (s in this.marginSize) {
            util_element.create("OPTION", {
              html: s + " - " + this.marginSize[s] + " mm",
              value: this.marginSize[s],
              parent: margin
            });
          }
          li = util_element.create("LI", {
            html: util_element.create("LABEL", {
              html: this.i18n("scale")
            }),
            className: "ol-scale",
            parent: ul
          });
          var scale = this._input.scale = util_element.create("SELECT", {
            on: { change: function() {
              this.setScale(parseInt(scale.value));
            }.bind(this) },
            parent: li
          });
          Object.keys(this.scales).forEach(function(s2) {
            util_element.create("OPTION", {
              html: this.scales[s2],
              value: s2,
              parent: scale
            });
          }.bind(this));
          li = util_element.create("LI", {
            className: "ol-legend",
            parent: ul
          });
          var legend = util_element.createSwitch({
            html: this.i18n("legend"),
            checked: false,
            on: { change: function() {
              extraCtrl.legend.control.setCanvas(legend.checked);
            }.bind(this) },
            parent: li
          });
          li = util_element.create("LI", {
            className: "ol-print-north",
            parent: ul
          });
          var north = this._input.north = util_element.createSwitch({
            html: this.i18n("north"),
            checked: "checked",
            on: { change: function() {
              if (north.checked)
                this._compass.element.classList.add("ol-print-compass");
              else
                this._compass.element.classList.remove("ol-print-compass");
              this.getMap().render();
            }.bind(this) },
            parent: li
          });
          li = util_element.create("LI", {
            className: "ol-print-title",
            parent: ul
          });
          var title = util_element.createSwitch({
            html: this.i18n("mapTitle"),
            checked: false,
            on: { change: function(e) {
              extraCtrl.title.control.setVisible(e.target.checked);
            }.bind(this) },
            parent: li
          });
          var titleText = util_element.create("INPUT", {
            type: "text",
            placeholder: this.i18n("mapTitle"),
            on: {
              keydown: function(e) {
                if (e.keyCode === 13)
                  e.preventDefault();
              },
              keyup: function() {
                extraCtrl.title.control.setTitle(titleText.value);
              },
              change: function() {
                extraCtrl.title.control.setTitle(titleText.value);
              }.bind(this)
            },
            parent: li
          });
          var userElt = util_element.create("DIV", {
            className: "ol-user-param",
            parent: param
          });
          li = util_element.create("LI", {
            className: "ol-saveas",
            parent: ul
          });
          var copied = util_element.create("DIV", {
            html: this.i18n("copied"),
            className: "ol-clipboard-copy",
            parent: li
          });
          var save = util_element.create("SELECT", {
            on: { change: function() {
              if (this.formats[save.value].clipboard) {
                printCtrl.copyMap(this.formats[save.value], function(isok) {
                  if (isok) {
                    copied.classList.add("visible");
                    setTimeout(function() {
                      copied.classList.remove("visible");
                    }, 1e3);
                  }
                });
              } else {
                var format = typeof this.getSize() === "string" ? this.getSize() : null;
                var opt = Object.assign({
                  format,
                  size: format ? this.paperSize[format] : null,
                  orient: this.getOrientation(),
                  margin: this.getMargin()
                }, this.formats[save.value]);
                printCtrl.print(opt);
              }
              save.value = "";
            }.bind(this) },
            parent: li
          });
          util_element.create("OPTION", {
            html: this.i18n("saveas"),
            style: { display: "none" },
            value: "",
            parent: save
          });
          this.formats.forEach(function(format, i) {
            if (format.pdf) {
              if (options.pdf === false)
                return;
            } else if (format.clipboard) {
              if (options.copy === false)
                return;
            } else if (options.save === false) {
              return;
            }
            util_element.create("OPTION", {
              html: format.title,
              value: i,
              parent: save
            });
          });
          li = util_element.create("LI", {
            className: "ol-savelegend",
            parent: ul
          });
          var copylegend = util_element.create("DIV", {
            html: this.i18n("copied"),
            className: "ol-clipboard-copy",
            parent: li
          });
          var saveLegend = util_element.create("SELECT", {
            on: { change: function() {
              var clegend = extraCtrl.legend.control.getLegend().getCanvas();
              var canvas = document.createElement("CANVAS");
              canvas.width = clegend.width;
              canvas.height = clegend.height;
              var ctx = canvas.getContext("2d");
              ctx.fillStyle = "#fff";
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(clegend, 0, 0);
              if (this.formats[saveLegend.value].clipboard) {
                canvas.toBlob(function(blob) {
                  try {
                    navigator.clipboard.write([
                      new window.ClipboardItem(Object.defineProperty({}, blob.type, {
                        value: blob,
                        enumerable: true
                      }))
                    ]);
                    copylegend.classList.add("visible");
                    setTimeout(function() {
                      copylegend.classList.remove("visible");
                    }, 1e3);
                  } catch (err) {
                  }
                }, "image/png");
              } else {
                var image;
                try {
                  image = canvas.toDataURL(this.formats[saveLegend.value].imageType, this.formats[saveLegend.value].quality);
                  var format = typeof this.getSize() === "string" ? this.getSize() : "A4";
                  var w = canvas.width / 96 * 25.4;
                  var h = canvas.height / 96 * 25.4;
                  var size2 = this.paperSize[format];
                  if (this.getOrientation() === "landscape")
                    size2 = [size2[1], size2[0]];
                  var position = [
                    (size2[0] - w) / 2,
                    (size2[1] - h) / 2
                  ];
                  this.dispatchEvent({
                    type: "print",
                    print: {
                      legend: true,
                      format,
                      orientation: this.getOrientation(),
                      unit: "mm",
                      size: this.paperSize[format],
                      position,
                      imageWidth: w,
                      imageHeight: h
                    },
                    image,
                    imageType: this.formats[saveLegend.value].imageType,
                    pdf: this.formats[saveLegend.value].pdf,
                    quality: this.formats[saveLegend.value].quality,
                    canvas
                  });
                } catch (err) {
                }
              }
              saveLegend.value = "";
            }.bind(this) },
            parent: li
          });
          util_element.create("OPTION", {
            html: this.i18n("saveLegend"),
            style: { display: "none" },
            value: "",
            parent: saveLegend
          });
          this.formats.forEach(function(format, i) {
            util_element.create("OPTION", {
              html: format.title,
              value: i,
              parent: saveLegend
            });
          });
          var prButtons = util_element.create("DIV", {
            className: "ol-ext-buttons",
            parent: param
          });
          util_element.create("BUTTON", {
            html: this.i18n("printBt"),
            type: "submit",
            click: function(e) {
              e.preventDefault();
              window.print();
            },
            parent: prButtons
          });
          util_element.create("BUTTON", {
            html: this.i18n("cancel"),
            type: "button",
            click: function() {
              printDialog.hide();
            },
            parent: prButtons
          });
          util_element.create("DIV", {
            html: this.i18n("errorMsg"),
            className: "ol-error",
            parent: param
          });
          var originalTarget;
          var originalSize;
          var scalelistener;
          var extraCtrl = {};
          printDialog.on("show", function() {
            this.dispatchEvent({ type: "show", userElement: userElt, dialog: this._printDialog, page: this.getPage() });
            var map = this.getMap();
            if (!map)
              return;
            document.body.classList.add("ol-print-document");
            originalTarget = map.getTargetElement();
            originalSize = map.getSize();
            if (typeof this.getSize() === "string")
              this.setSize(this.getSize());
            else
              this.setSize(originalSize);
            map.setTarget(printMap);
            if (scalelistener)
              Object(Observable["b"])(scalelistener);
            scalelistener = map.on("moveend", function() {
              this.setScale(ol_sphere_getMapScale(map));
            }.bind(this));
            this.setScale(ol_sphere_getMapScale(map));
            extraCtrl = {};
            this.getMap().getControls().forEach(function(c) {
              if (c instanceof control_Legend) {
                extraCtrl.legend = { control: c };
              }
              if (c instanceof CanvasTitle) {
                extraCtrl.title = { control: c };
              }
              if (c instanceof Compass) {
                if (extraCtrl.compass) {
                  c.element.classList.remove("ol-print-compass");
                } else {
                  if (this._input.north.checked)
                    c.element.classList.add("ol-print-compass");
                  else
                    c.element.classList.remove("ol-print-compass");
                  this._compass = c;
                  extraCtrl.compass = { control: c };
                }
              }
            }.bind(this));
            if (extraCtrl.title) {
              title.checked = extraCtrl.title.isVisible = extraCtrl.title.control.getVisible();
              titleText.value = extraCtrl.title.control.getTitle();
              title.parentNode.parentNode.classList.remove("hidden");
            } else {
              title.parentNode.parentNode.classList.add("hidden");
            }
            if (extraCtrl.legend) {
              extraCtrl.legend.ison = extraCtrl.legend.control.onCanvas();
              extraCtrl.legend.collapsed = extraCtrl.legend.control.isCollapsed();
              extraCtrl.legend.control.collapse(false);
              saveLegend.parentNode.classList.remove("hidden");
              legend.parentNode.parentNode.classList.remove("hidden");
              legend.checked = !extraCtrl.legend.collapsed;
              extraCtrl.legend.control.setCanvas(!extraCtrl.legend.collapsed);
            } else {
              saveLegend.parentNode.classList.add("hidden");
              legend.parentNode.parentNode.classList.add("hidden");
            }
          }.bind(this));
          printDialog.on("hide", function() {
            document.body.classList.remove("ol-print-document");
            if (!originalTarget)
              return;
            this.getMap().setTarget(originalTarget);
            originalTarget = null;
            if (scalelistener)
              Object(Observable["b"])(scalelistener);
            if (extraCtrl.title) {
              extraCtrl.title.control.setVisible(extraCtrl.title.isVisible);
            }
            if (extraCtrl.legend) {
              extraCtrl.legend.control.setCanvas(extraCtrl.legend.ison);
              extraCtrl.legend.control.collapse(extraCtrl.legend.collapsed);
            }
            this.dispatchEvent({ type: "hide" });
          }.bind(this));
          window.addEventListener("resize", function() {
            this.setSize();
          }.bind(this));
          if (options.saveAs) {
            this.on("print", function(e) {
              if (!e.pdf) {
                e.canvas.toBlob(function(blob) {
                  var name = (e.print.legend ? "legend." : "map.") + e.imageType.replace("image/", "");
                  options.saveAs(blob, name);
                }, e.imageType, e.quality);
              }
            });
          }
          if (options.jsPDF) {
            this.on("print", function(e) {
              if (e.pdf) {
                var pdf = new options.jsPDF({
                  orientation: e.print.orientation,
                  unit: e.print.unit,
                  format: e.print.size
                });
                pdf.addImage(e.image, "JPEG", e.print.position[0], e.print.position[0], e.print.imageWidth, e.print.imageHeight);
                pdf.save(e.print.legend ? "legend.pdf" : "map.pdf");
              }
            });
          }
        };
        util_ext(ol_control_PrintDialog, Control["default"]);
        ol_control_PrintDialog.prototype.isOpen = function() {
          return this._printDialog.isOpen();
        };
        ol_control_PrintDialog.addLang = function(lang, labels) {
          ol_control_PrintDialog.prototype._labels[lang] = labels;
        };
        ol_control_PrintDialog.prototype.i18n = function(what) {
          var rep = this._labels.en[what] || "bad param";
          if (this._labels[this._lang] && this._labels[this._lang][what]) {
            rep = this._labels[this._lang][what];
          }
          return rep;
        };
        ol_control_PrintDialog.prototype._labels = {
          en: {
            title: "Print",
            orientation: "Orientation",
            portrait: "Portrait",
            landscape: "Landscape",
            size: "Page size",
            custom: "screen size",
            margin: "Margin",
            scale: "Scale",
            legend: "Legend",
            north: "North arrow",
            mapTitle: "Map title",
            saveas: "Save as...",
            saveLegend: "Save legend...",
            copied: "\u2714 Copied to clipboard",
            errorMsg: "Can't save map canvas...",
            printBt: "Print...",
            cancel: "cancel"
          },
          fr: {
            title: "Imprimer",
            orientation: "Orientation",
            portrait: "Portrait",
            landscape: "Paysage",
            size: "Taille du papier",
            custom: "taille \xE9cran",
            margin: "Marges",
            scale: "Echelle",
            legend: "L\xE9gende",
            north: "Fl\xE8che du nord",
            mapTitle: "Titre de la carte",
            saveas: "Enregistrer sous...",
            saveLegend: "Enregistrer la l\xE9gende...",
            copied: "\u2714 Carte copi\xE9e",
            errorMsg: "Impossible d'enregistrer la carte",
            printBt: "Imprimer",
            cancel: "annuler"
          },
          zh: {
            title: "\u6253\u5370",
            orientation: "\u65B9\u5411",
            portrait: "\u7EB5\u5411",
            landscape: "\u6A2A\u5411",
            size: "\u9875\u9762\u5927\u5C0F",
            custom: "\u5C4F\u5E55\u5927\u5C0F",
            margin: "\u5916\u8FB9\u8DDD",
            scale: "\u5C3A\u5EA6",
            legend: "\u56FE\u4F8B",
            north: "\u6307\u5317\u9488",
            mapTitle: "\u5730\u56FE\u540D\u5B57",
            saveas: "\u4FDD\u5B58\u4E3A...",
            saveLegend: "\u4FDD\u5B58\u56FE\u4F8B\u4E3A...",
            copied: "\u2714 \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
            errorMsg: "\u65E0\u6CD5\u4FDD\u5B58\u5730\u56FE...",
            printBt: "\u6253\u5370...",
            cancel: "\u53D6\u6D88"
          }
        };
        ol_control_PrintDialog.prototype.paperSize = {
          "": null,
          "A0": [841, 1189],
          "A1": [594, 841],
          "A2": [420, 594],
          "A3": [297, 420],
          "A4": [210, 297],
          "A5": [148, 210],
          "B4": [257, 364],
          "B5": [182, 257]
        };
        ol_control_PrintDialog.prototype.marginSize = {
          none: 0,
          small: 5,
          large: 10
        };
        ol_control_PrintDialog.prototype.formats = [
          {
            title: "copy to clipboard",
            imageType: "image/png",
            clipboard: true
          },
          {
            title: "save as jpeg",
            imageType: "image/jpeg",
            quality: 0.8
          },
          {
            title: "save as png",
            imageType: "image/png",
            quality: 0.8
          },
          {
            title: "save as pdf",
            imageType: "image/jpeg",
            pdf: true
          }
        ];
        ol_control_PrintDialog.prototype.scales = {
          " 5000": "1/5.000",
          " 10000": "1/10.000",
          " 25000": "1/25.000",
          " 50000": "1/50.000",
          " 100000": "1/100.000",
          " 250000": "1/250.000",
          " 1000000": "1/1.000.000"
        };
        ol_control_PrintDialog.prototype.getOrientation = function() {
          return this._orientation || "portrait";
        };
        ol_control_PrintDialog.prototype.setOrientation = function(ori) {
          this._orientation = ori === "landscape" ? "landscape" : "portrait";
          this._input.orientation[this._orientation].checked = true;
          this.setSize();
        };
        ol_control_PrintDialog.prototype.getMargin = function() {
          return this._margin || 0;
        };
        ol_control_PrintDialog.prototype.setMargin = function(margin) {
          this._margin = margin;
          this._input.margin.value = margin;
          this.setSize();
        };
        ol_control_PrintDialog.prototype.getSize = function() {
          return this._size;
        };
        ol_control_PrintDialog.prototype.setSize = function(size) {
          this._printDialog.getContentElement().setAttribute("data-status", "");
          if (size)
            this._size = size;
          else
            size = this._size;
          if (!size)
            return;
          if (typeof size === "string") {
            size = size.toLocaleUpperCase();
            if (!this.paperSize[size])
              size = this._size = "A4";
            this._input.size.value = size;
            size = [
              Math.trunc(this.paperSize[size][0] * 96 / 25.4),
              Math.trunc(this.paperSize[size][1] * 96 / 25.4)
            ];
            if (this.getOrientation() === "landscape") {
              size = [size[1], size[0]];
            }
            this.getPage().classList.remove("margin");
          } else {
            this._input.size.value = "";
            this.getPage().classList.add("margin");
          }
          var printElement = this.getPage();
          var s = printElement.parentNode.getBoundingClientRect();
          var scx = (s.width - 40) / size[0];
          var scy = (s.height - 40) / size[1];
          var sc = Math.min(scx, scy, 1);
          printElement.style.width = size[0] + "px";
          printElement.style.height = size[1] + "px";
          printElement.style["-webkit-transform"] = printElement.style.transform = "translate(-50%,-50%) scale(" + sc + ")";
          var px = Math.round(5 / sc);
          printElement.style["-webkit-box-shadow"] = printElement.style["box-shadow"] = px + "px " + px + "px " + px + "px rgba(0,0,0,.6)";
          printElement.style["padding"] = this.getMargin() * 96 / 25.4 + "px";
          if (this.getMap()) {
            this.getMap().updateSize();
          }
          this.dispatchEvent({ type: "dialog:refresh" });
        };
        ol_control_PrintDialog.prototype.getContentElement = function() {
          return this._printDialog.getContentElement();
        };
        ol_control_PrintDialog.prototype.getUserElement = function() {
          return this._printDialog.getContentElement().querySelector(".ol-user-param");
        };
        ol_control_PrintDialog.prototype.getPage = function() {
          return this._pages[0];
        };
        ol_control_PrintDialog.prototype.setMap = function(map) {
          if (this.getMap()) {
            this.getMap().removeControl(this._compass);
            this.getMap().removeControl(this._printCtrl);
            this.getMap().removeControl(this._printDialog);
          }
          Control["default"].prototype.setMap.call(this, map);
          if (this.getMap()) {
            this.getMap().addControl(this._compass);
            this.getMap().addControl(this._printCtrl);
            this.getMap().addControl(this._printDialog);
          }
        };
        ol_control_PrintDialog.prototype.setScale = function(value) {
          ol_sphere_setMapScale(this.getMap(), value);
          this._input.scale.value = " " + Math.round(value / 100) * 100;
        };
        ol_control_PrintDialog.prototype.getScale = function() {
          return ol_sphere_getMapScale(this.getMap());
        };
        ol_control_PrintDialog.prototype.print = function(options) {
          options = options || {};
          if (options.size)
            this.setSize(options.size);
          if (options.scale)
            this.setScale(options.scale);
          if (options.orientation)
            this.setOrientation(options.orientation);
          if (options.margin)
            this.setMargin(options.margin);
          this._printDialog.show();
        };
        ol_control_PrintDialog.prototype.getrintControl = function() {
          return this._printCtrl;
        };
        var PrintDialog = ol_control_PrintDialog;
        var FileSaver_min = __webpack_require__("21a6");
        var jspdf_es_min = __webpack_require__("8baf");
        var PrintDialogvue_type_script_lang_js = {
          name: "ol-control-printdialog",
          setup: function setup(props, context) {
            var _useControl = useControl(PrintDialog, props, context), control = _useControl.control;
            control.value.on(["print", "error"], function(e) {
              if (e.image) {
                if (e.pdf) {
                  var pdf = new jspdf_es_min["a"]({
                    orientation: e.print.orientation,
                    unit: e.print.unit,
                    format: e.print.size
                  });
                  pdf.addImage(e.image, "JPEG", e.print.position[0], e.print.position[0], e.print.imageWidth, e.print.imageHeight);
                  pdf.save(e.print.legend ? "legend.pdf" : "map.pdf");
                } else {
                  e.canvas.toBlob(function(blob) {
                    var name = (e.print.legend ? "legend." : "map.") + e.imageType.replace("image/", "");
                    Object(FileSaver_min["saveAs"])(blob, name);
                  }, e.imageType, e.quality);
                }
              } else {
                console.warn("No canvas to export");
              }
            });
            return {
              control
            };
          },
          props: {
            lang: {
              type: String
            }
          }
        };
        const PrintDialog_exports_ = exportHelper_default()(PrintDialogvue_type_script_lang_js, [["render", PrintDialogvue_type_template_id_639b2b4c_lang_true_render]]);
        var mapControls_PrintDialog = PrintDialog_exports_;
        var VideoRecorderControlvue_type_template_id_30acd28a_lang_true_hoisted_1 = {
          key: 0
        };
        function VideoRecorderControlvue_type_template_id_30acd28a_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ol_control_VideoRecorder = function(options) {
          if (!options)
            options = {};
          var element = util_element.create("DIV", {
            className: (options.className || "ol-videorec") + " ol-unselectable ol-control"
          });
          util_element.create("BUTTON", {
            type: "button",
            className: "ol-start",
            title: "start",
            click: function() {
              this.start();
            }.bind(this),
            parent: element
          });
          util_element.create("BUTTON", {
            type: "button",
            className: "ol-stop",
            title: "stop",
            click: function() {
              this.stop();
            }.bind(this),
            parent: element
          });
          util_element.create("BUTTON", {
            type: "button",
            className: "ol-pause",
            title: "pause",
            click: function() {
              this.pause();
            }.bind(this),
            parent: element
          });
          util_element.create("BUTTON", {
            type: "button",
            className: "ol-resume",
            title: "resume",
            click: function() {
              this.resume();
            }.bind(this),
            parent: element
          });
          Control["default"].call(this, {
            element,
            target: options.target
          });
          this.set("framerate", 30);
          this.set("videoBitsPerSecond", 5e6);
          if (options.videoTarget === "DIALOG") {
            this._dialog = new Dialog({
              className: "ol-fullscreen-dialog",
              target: document.body,
              closeBox: true
            });
            this._videoTarget = this._dialog.getContentElement();
          } else {
            this._videoTarget = options.videoTarget;
          }
          this._printCtrl = new Print({
            target: util_element.create("DIV")
          });
        };
        util_ext(ol_control_VideoRecorder, Control["default"]);
        ol_control_VideoRecorder.prototype.setMap = function(map) {
          if (this.getMap()) {
            this.getMap().removeControl(this._printCtrl);
            if (this._dialog)
              this.getMap().removeControl(this._dialog);
          }
          Control["default"].prototype.setMap.call(this, map);
          if (this.getMap()) {
            this.getMap().addControl(this._printCtrl);
            if (this._dialog)
              this.getMap().addControl(this._dialog);
          }
        };
        ol_control_VideoRecorder.prototype.start = function() {
          var print = this._printCtrl;
          var stop = false;
          function capture(canvas) {
            if (stop)
              return;
            print.fastPrint({
              canvas
            }, capture);
          }
          print.fastPrint({}, function(canvas) {
            var videoStream;
            try {
              videoStream = canvas.captureStream(this.get("framerate") || 30);
            } catch (e) {
              this.dispatchEvent({
                type: "error",
                error: e
              });
              return;
            }
            this._mediaRecorder = new MediaRecorder(videoStream, {
              videoBitsPerSecond: this.get("videoBitsPerSecond") || 5e6
            });
            var chunks = [];
            this._mediaRecorder.ondataavailable = function(e) {
              chunks.push(e.data);
            };
            this._mediaRecorder.onstop = function() {
              stop = true;
              var blob = new Blob(chunks, { "type": "video/mp4" });
              chunks = [];
              if (this._videoTarget instanceof Element) {
                var video;
                if (this._videoTarget.tagName === "VIDEO") {
                  video = this._videoTarget;
                } else {
                  video = this._videoTarget.querySelector("video");
                  if (!video) {
                    video = util_element.create("VIDEO", {
                      controls: "",
                      parent: this._videoTarget
                    });
                  }
                }
                if (this._dialog)
                  this._dialog.show();
                video.src = URL.createObjectURL(blob);
                this.dispatchEvent({ type: "stop", videoURL: video.src });
              } else {
                this.dispatchEvent({ type: "stop", videoURL: URL.createObjectURL(blob) });
              }
            }.bind(this);
            this._mediaRecorder.onpause = function() {
              stop = true;
              this.dispatchEvent({ type: "pause" });
            }.bind(this);
            this._mediaRecorder.onresume = function() {
              stop = false;
              capture(canvas);
              this.dispatchEvent({ type: "resume" });
            }.bind(this);
            this._mediaRecorder.onerror = function(e) {
              this.dispatchEvent({ type: "error", error: e });
            }.bind(this);
            stop = false;
            capture(canvas);
            this._mediaRecorder.start();
            this.dispatchEvent({ type: "start", canvas });
            this.element.setAttribute("data-state", "rec");
          }.bind(this));
        };
        ol_control_VideoRecorder.prototype.stop = function() {
          if (this._mediaRecorder) {
            this._mediaRecorder.stop();
            this._mediaRecorder = null;
            this.element.setAttribute("data-state", "inactive");
          }
        };
        ol_control_VideoRecorder.prototype.pause = function() {
          if (this._mediaRecorder) {
            this._mediaRecorder.pause();
            this.element.setAttribute("data-state", "pause");
          }
        };
        ol_control_VideoRecorder.prototype.resume = function() {
          if (this._mediaRecorder) {
            this._mediaRecorder.resume();
            this.element.setAttribute("data-state", "rec");
          }
        };
        var VideoRecorder = ol_control_VideoRecorder;
        var VideoRecorderControlvue_type_script_lang_js = {
          name: "ol-control-videorecorder",
          emits: ["start", "stop"],
          setup: function setup(props, context) {
            var _useControl = useControl(VideoRecorder, props, context), control = _useControl.control;
            var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props), downloadName = _toRefs.downloadName;
            control.value.on("start", function(event) {
              context.emit("start", event);
            });
            control.value.on("stop", function(event) {
              context.emit("stop", event);
              Object(FileSaver_min["saveAs"])(event.videoURL, downloadName.value);
            });
            return {
              control
            };
          },
          props: {
            className: {
              type: String
            },
            framerate: {
              type: Number,
              default: 30
            },
            videoBitsPerSecond: {
              type: Number,
              default: 5e6
            },
            videoTarget: {
              type: String
            },
            downloadName: {
              type: String,
              default: "mapVideo.mp4"
            }
          }
        };
        const VideoRecorderControl_exports_ = exportHelper_default()(VideoRecorderControlvue_type_script_lang_js, [["render", VideoRecorderControlvue_type_template_id_30acd28a_lang_true_render]]);
        var VideoRecorderControl = VideoRecorderControl_exports_;
        var LayerSwitcherControlvue_type_template_id_05258056_lang_true_hoisted_1 = {
          key: 0
        };
        function LayerSwitcherControlvue_type_template_id_05258056_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var VectorTileRenderType = {
          IMAGE: "image",
          HYBRID: "hybrid",
          VECTOR: "vector"
        };
        var VectorTileLayer_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var IMAGE_REPLAYS = {
          "image": [
            BuilderType.POLYGON,
            BuilderType.CIRCLE,
            BuilderType.LINE_STRING,
            BuilderType.IMAGE,
            BuilderType.TEXT
          ],
          "hybrid": [BuilderType.POLYGON, BuilderType.LINE_STRING],
          "vector": []
        };
        var VECTOR_REPLAYS = {
          "hybrid": [BuilderType.IMAGE, BuilderType.TEXT, BuilderType.DEFAULT],
          "vector": [
            BuilderType.POLYGON,
            BuilderType.CIRCLE,
            BuilderType.LINE_STRING,
            BuilderType.IMAGE,
            BuilderType.TEXT,
            BuilderType.DEFAULT
          ]
        };
        var VectorTileLayer_CanvasVectorTileLayerRenderer = function(_super) {
          VectorTileLayer_extends(CanvasVectorTileLayerRenderer, _super);
          function CanvasVectorTileLayerRenderer(layer) {
            var _this = _super.call(this, layer) || this;
            _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
            _this.dirty_ = false;
            _this.renderedLayerRevision_;
            _this.renderedPixelToCoordinateTransform_ = null;
            _this.renderedRotation_;
            _this.tmpTransform_ = create();
            return _this;
          }
          CanvasVectorTileLayerRenderer.prototype.prepareTile = function(tile, pixelRatio, projection) {
            var render;
            var state = tile.getState();
            if (state === TileState.LOADED || state === TileState.ERROR) {
              this.updateExecutorGroup_(tile, pixelRatio, projection);
              if (this.tileImageNeedsRender_(tile)) {
                render = true;
              }
            }
            return render;
          };
          CanvasVectorTileLayerRenderer.prototype.getTile = function(z, x, y, frameState) {
            var pixelRatio = frameState.pixelRatio;
            var viewState = frameState.viewState;
            var resolution = viewState.resolution;
            var projection = viewState.projection;
            var layer = this.getLayer();
            var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);
            var viewHints = frameState.viewHints;
            var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
            if (hifi || !tile.wantedResolution) {
              tile.wantedResolution = resolution;
            }
            var render = this.prepareTile(tile, pixelRatio, projection);
            if (render && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== VectorTileRenderType.VECTOR) {
              this.renderTileImage_(tile, frameState);
            }
            return _super.prototype.getTile.call(this, z, x, y, frameState);
          };
          CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function(tile) {
            var layer = this.getLayer();
            return _super.prototype.isDrawableTile.call(this, tile) && (layer.getRenderMode() === VectorTileRenderType.VECTOR ? Object(util["c"])(layer) in tile.executorGroups : tile.hasContext(layer));
          };
          CanvasVectorTileLayerRenderer.prototype.getTileImage = function(tile) {
            return tile.getImage(this.getLayer());
          };
          CanvasVectorTileLayerRenderer.prototype.prepareFrame = function(frameState) {
            var layerRevision = this.getLayer().getRevision();
            if (this.renderedLayerRevision_ != layerRevision) {
              this.renderedTiles.length = 0;
            }
            this.renderedLayerRevision_ = layerRevision;
            return _super.prototype.prepareFrame.call(this, frameState);
          };
          CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function(tile, pixelRatio, projection) {
            var layer = this.getLayer();
            var revision = layer.getRevision();
            var renderOrder = layer.getRenderOrder() || null;
            var resolution = tile.wantedResolution;
            var builderState = tile.getReplayState(layer);
            if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {
              return;
            }
            var source = layer.getSource();
            var declutter = layer.getDeclutter();
            var sourceTileGrid = source.getTileGrid();
            var tileGrid = source.getTileGridForProjection(projection);
            var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
            var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);
            var layerUid = Object(util["c"])(layer);
            delete tile.hitDetectionImageData[layerUid];
            tile.executorGroups[layerUid] = [];
            if (declutter) {
              tile.declutterExecutorGroups[layerUid] = [];
            }
            var _loop_1 = function(t2, tt2) {
              var sourceTile = sourceTiles[t2];
              if (sourceTile.getState() != TileState.LOADED) {
                return "continue";
              }
              var sourceTileCoord = sourceTile.tileCoord;
              var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
              var sharedExtent = getIntersection(tileExtent, sourceTileExtent);
              var builderExtent = extent_buffer(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);
              var bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : builderExtent;
              builderState.dirty = false;
              var builderGroup = new canvas_BuilderGroup(0, builderExtent, resolution, pixelRatio);
              var declutterBuilderGroup = declutter ? new canvas_BuilderGroup(0, sharedExtent, resolution, pixelRatio) : void 0;
              var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
              var render = function(feature2) {
                var styles;
                var styleFunction = feature2.getStyleFunction() || layer.getStyleFunction();
                if (styleFunction) {
                  styles = styleFunction(feature2, resolution);
                }
                if (styles) {
                  var dirty = this.renderFeature(feature2, squaredTolerance, styles, builderGroup, declutterBuilderGroup);
                  this.dirty_ = this.dirty_ || dirty;
                  builderState.dirty = builderState.dirty || dirty;
                }
              };
              var features = sourceTile.getFeatures();
              if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {
                features.sort(renderOrder);
              }
              for (var i = 0, ii = features.length; i < ii; ++i) {
                var feature = features[i];
                if (!bufferedExtent || extent_intersects(bufferedExtent, feature.getGeometry().getExtent())) {
                  render.call(this_1, feature);
                }
              }
              var executorGroupInstructions = builderGroup.finish();
              var replayExtent = layer.getRenderMode() !== VectorTileRenderType.VECTOR && declutter && sourceTiles.length === 1 ? null : sharedExtent;
              var renderingReplayGroup = new canvas_ExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());
              tile.executorGroups[layerUid].push(renderingReplayGroup);
              if (declutterBuilderGroup) {
                var declutterExecutorGroup = new canvas_ExecutorGroup(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());
                tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);
              }
            };
            var this_1 = this;
            for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {
              _loop_1(t, tt);
            }
            builderState.renderedRevision = revision;
            builderState.renderedRenderOrder = renderOrder;
            builderState.renderedResolution = resolution;
          };
          CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
            var resolution = frameState.viewState.resolution;
            var rotation = frameState.viewState.rotation;
            hitTolerance = hitTolerance == void 0 ? 0 : hitTolerance;
            var layer = this.getLayer();
            var source = layer.getSource();
            var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
            var hitExtent = boundingExtent([coordinate]);
            extent_buffer(hitExtent, resolution * hitTolerance, hitExtent);
            var features = {};
            var featureCallback = function(feature, geometry, distanceSq) {
              var key = feature.getId();
              if (key === void 0) {
                key = Object(util["c"])(feature);
              }
              var match = features[key];
              if (!match) {
                if (distanceSq === 0) {
                  features[key] = true;
                  return callback(feature, layer, geometry);
                }
                matches.push(features[key] = {
                  feature,
                  layer,
                  geometry,
                  distanceSq,
                  callback
                });
              } else if (match !== true && distanceSq < match.distanceSq) {
                if (distanceSq === 0) {
                  features[key] = true;
                  matches.splice(matches.lastIndexOf(match), 1);
                  return callback(feature, layer, geometry);
                }
                match.geometry = geometry;
                match.distanceSq = distanceSq;
              }
              return void 0;
            };
            var renderedTiles = this.renderedTiles;
            var found;
            var _loop_2 = function(i2, ii2) {
              var tile = renderedTiles[i2];
              var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
              if (!extent_intersects(tileExtent, hitExtent)) {
                return "continue";
              }
              var layerUid = Object(util["c"])(layer);
              var executorGroups = [tile.executorGroups[layerUid]];
              var declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];
              if (declutterExecutorGroups) {
                executorGroups.push(declutterExecutorGroups);
              }
              executorGroups.some(function(executorGroups2) {
                var declutteredFeatures = executorGroups2 === declutterExecutorGroups ? frameState.declutterTree.all().map(function(item) {
                  return item.value;
                }) : null;
                for (var t = 0, tt = executorGroups2.length; t < tt; ++t) {
                  var executorGroup = executorGroups2[t];
                  found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);
                  if (found) {
                    return true;
                  }
                }
              });
            };
            for (var i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {
              _loop_2(i, ii);
            }
            return found;
          };
          CanvasVectorTileLayerRenderer.prototype.getFeatures = function(pixel) {
            return new Promise(function(resolve, reject) {
              var layer = this.getLayer();
              var layerUid = Object(util["c"])(layer);
              var source = layer.getSource();
              var projection = this.renderedProjection;
              var projectionExtent = projection.getExtent();
              var resolution = this.renderedResolution;
              var tileGrid = source.getTileGridForProjection(projection);
              var coordinate = apply(this.renderedPixelToCoordinateTransform_, pixel.slice());
              var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
              var tile;
              for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {
                if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {
                  tile = this.renderedTiles[i];
                  if (tile.getState() === TileState.LOADED) {
                    var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);
                    if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent_1)) {
                      coordinate_wrapX(coordinate, projection);
                    }
                    break;
                  }
                  tile = void 0;
                }
              }
              if (!tile || tile.loadingSourceTiles > 0) {
                resolve([]);
                return;
              }
              var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
              var corner = getTopLeft(extent);
              var tilePixel = [
                (coordinate[0] - corner[0]) / resolution,
                (corner[1] - coordinate[1]) / resolution
              ];
              var features = tile.getSourceTiles().reduce(function(accumulator, sourceTile) {
                return accumulator.concat(sourceTile.getFeatures());
              }, []);
              var hitDetectionImageData = tile.hitDetectionImageData[layerUid];
              if (!hitDetectionImageData && !this.animatingOrInteracting_) {
                var tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));
                var rotation = this.renderedRotation_;
                var transforms = [
                  this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0)
                ];
                hitDetectionImageData = createHitDetectionImageData(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);
                tile.hitDetectionImageData[layerUid] = hitDetectionImageData;
              }
              resolve(hitDetect(tilePixel, features, hitDetectionImageData));
            }.bind(this));
          };
          CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function() {
            var layer = this.getLayer();
            if (layer.getVisible() && this.renderedLayerRevision_ !== void 0) {
              layer.changed();
            }
          };
          CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function(event) {
            this.renderIfReadyAndVisible();
          };
          CanvasVectorTileLayerRenderer.prototype.renderDeclutter = function(frameState) {
            var context = this.context;
            var alpha = context.globalAlpha;
            context.globalAlpha = this.getLayer().getOpacity();
            var viewHints = frameState.viewHints;
            var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
            var tiles = this.renderedTiles;
            for (var i = 0, ii = tiles.length; i < ii; ++i) {
              var tile = tiles[i];
              var declutterExecutorGroups = tile.declutterExecutorGroups[Object(util["c"])(this.getLayer())];
              if (declutterExecutorGroups) {
                for (var j = declutterExecutorGroups.length - 1; j >= 0; --j) {
                  declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, void 0, frameState.declutterTree);
                }
              }
            }
            context.globalAlpha = alpha;
          };
          CanvasVectorTileLayerRenderer.prototype.getTileRenderTransform = function(tile, frameState) {
            var pixelRatio = frameState.pixelRatio;
            var viewState = frameState.viewState;
            var center = viewState.center;
            var resolution = viewState.resolution;
            var rotation = viewState.rotation;
            var size = frameState.size;
            var width = Math.round(size[0] * pixelRatio);
            var height = Math.round(size[1] * pixelRatio);
            var source = this.getLayer().getSource();
            var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
            var tileCoord = tile.tileCoord;
            var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
            var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];
            var transform2 = multiply(transform_scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));
            return transform2;
          };
          CanvasVectorTileLayerRenderer.prototype.renderFrame = function(frameState, target) {
            var viewHints = frameState.viewHints;
            var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
            _super.prototype.renderFrame.call(this, frameState, target);
            this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
            this.renderedRotation_ = frameState.viewState.rotation;
            var layer = this.getLayer();
            var renderMode = layer.getRenderMode();
            var context = this.context;
            var alpha = context.globalAlpha;
            context.globalAlpha = layer.getOpacity();
            var replayTypes = VECTOR_REPLAYS[renderMode];
            var viewState = frameState.viewState;
            var rotation = viewState.rotation;
            var tiles = this.renderedTiles;
            var clips = [];
            var clipZs = [];
            for (var i = tiles.length - 1; i >= 0; --i) {
              var tile = tiles[i];
              var transform2 = this.getTileRenderTransform(tile, frameState);
              var executorGroups = tile.executorGroups[Object(util["c"])(layer)];
              var clipped = false;
              for (var t = 0, tt = executorGroups.length; t < tt; ++t) {
                var executorGroup = executorGroups[t];
                if (!executorGroup.hasExecutors(replayTypes)) {
                  continue;
                }
                var currentZ = tile.tileCoord[0];
                var currentClip = void 0;
                if (!clipped) {
                  currentClip = executorGroup.getClipCoords(transform2);
                  if (currentClip) {
                    context.save();
                    for (var j = 0, jj = clips.length; j < jj; ++j) {
                      var clip = clips[j];
                      if (currentZ < clipZs[j]) {
                        context.beginPath();
                        context.moveTo(currentClip[0], currentClip[1]);
                        context.lineTo(currentClip[2], currentClip[3]);
                        context.lineTo(currentClip[4], currentClip[5]);
                        context.lineTo(currentClip[6], currentClip[7]);
                        context.moveTo(clip[6], clip[7]);
                        context.lineTo(clip[4], clip[5]);
                        context.lineTo(clip[2], clip[3]);
                        context.lineTo(clip[0], clip[1]);
                        context.clip();
                      }
                    }
                  }
                }
                executorGroup.execute(context, 1, transform2, rotation, hifi, replayTypes);
                if (!clipped && currentClip) {
                  context.restore();
                  clips.push(currentClip);
                  clipZs.push(currentZ);
                  clipped = true;
                }
              }
            }
            context.globalAlpha = alpha;
            return this.container;
          };
          CanvasVectorTileLayerRenderer.prototype.renderFeature = function(feature, squaredTolerance, styles, builderGroup, opt_declutterBuilderGroup) {
            if (!styles) {
              return false;
            }
            var loading = false;
            if (Array.isArray(styles)) {
              for (var i = 0, ii = styles.length; i < ii; ++i) {
                loading = renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, void 0, opt_declutterBuilderGroup) || loading;
              }
            } else {
              loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, void 0, opt_declutterBuilderGroup);
            }
            return loading;
          };
          CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function(tile) {
            var layer = this.getLayer();
            if (layer.getRenderMode() === VectorTileRenderType.VECTOR) {
              return false;
            }
            var replayState = tile.getReplayState(layer);
            var revision = layer.getRevision();
            var resolution = tile.wantedResolution;
            return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;
          };
          CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function(tile, frameState) {
            var layer = this.getLayer();
            var replayState = tile.getReplayState(layer);
            var revision = layer.getRevision();
            var executorGroups = tile.executorGroups[Object(util["c"])(layer)];
            replayState.renderedTileRevision = revision;
            var tileCoord = tile.wrappedTileCoord;
            var z = tileCoord[0];
            var source = layer.getSource();
            var pixelRatio = frameState.pixelRatio;
            var viewState = frameState.viewState;
            var projection = viewState.projection;
            var tileGrid = source.getTileGridForProjection(projection);
            var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);
            var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;
            var resolution = tileGrid.getResolution(z);
            var context = tile.getContext(layer);
            pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));
            var size = source.getTilePixelSize(z, pixelRatio, projection);
            context.canvas.width = size[0];
            context.canvas.height = size[1];
            var renderScale = pixelRatio / renderPixelRatio;
            if (renderScale !== 1) {
              var canvasTransform = transform_reset(this.tmpTransform_);
              transform_scale(canvasTransform, renderScale, renderScale);
              context.setTransform.apply(context, canvasTransform);
            }
            var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
            var pixelScale = renderPixelRatio / resolution;
            var transform2 = transform_reset(this.tmpTransform_);
            transform_scale(transform2, pixelScale, -pixelScale);
            transform_translate(transform2, -tileExtent[0], -tileExtent[3]);
            for (var i = 0, ii = executorGroups.length; i < ii; ++i) {
              var executorGroup = executorGroups[i];
              executorGroup.execute(context, renderScale, transform2, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);
            }
            replayState.renderedTileResolution = tile.wantedResolution;
          };
          return CanvasVectorTileLayerRenderer;
        }(canvas_TileLayer);
        var canvas_VectorTileLayer = VectorTileLayer_CanvasVectorTileLayerRenderer;
        var VectorTile_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var VectorTile_VectorTileLayer = function(_super) {
          VectorTile_extends(VectorTileLayer, _super);
          function VectorTileLayer(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var baseOptions = Object(ol_obj["a"])({}, options);
            delete baseOptions.preload;
            delete baseOptions.useInterimTilesOnError;
            _this = _super.call(this, baseOptions) || this;
            _this.on;
            _this.once;
            _this.un;
            if (options.renderMode === VectorTileRenderType.IMAGE) {
              console.warn('renderMode: "image" is deprecated. Option ignored.');
              options.renderMode = void 0;
            }
            var renderMode = options.renderMode || VectorTileRenderType.HYBRID;
            assert2(renderMode == VectorTileRenderType.HYBRID || renderMode == VectorTileRenderType.VECTOR, 28);
            _this.renderMode_ = renderMode;
            _this.setPreload(options.preload ? options.preload : 0);
            _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);
            _this.getBackground;
            _this.setBackground;
            return _this;
          }
          VectorTileLayer.prototype.createRenderer = function() {
            return new canvas_VectorTileLayer(this);
          };
          VectorTileLayer.prototype.getFeatures = function(pixel) {
            return _super.prototype.getFeatures.call(this, pixel);
          };
          VectorTileLayer.prototype.getRenderMode = function() {
            return this.renderMode_;
          };
          VectorTileLayer.prototype.getPreload = function() {
            return this.get(TileProperty.PRELOAD);
          };
          VectorTileLayer.prototype.getUseInterimTilesOnError = function() {
            return this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR);
          };
          VectorTileLayer.prototype.setPreload = function(preload) {
            this.set(TileProperty.PRELOAD, preload);
          };
          VectorTileLayer.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
            this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
          };
          return VectorTileLayer;
        }(BaseVector);
        var VectorTile = VectorTile_VectorTileLayer;
        var ARRAY_BUFFER = 34962;
        var ELEMENT_ARRAY_BUFFER = 34963;
        var STREAM_DRAW = 35040;
        var STATIC_DRAW = 35044;
        var DYNAMIC_DRAW = 35048;
        var UNSIGNED_BYTE = 5121;
        var UNSIGNED_SHORT = 5123;
        var UNSIGNED_INT = 5125;
        var FLOAT = 5126;
        var CONTEXT_IDS = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
        function getContext(canvas, opt_attributes) {
          var attributes = Object(ol_obj["a"])({ preserveDrawingBuffer: true }, opt_attributes);
          var ii = CONTEXT_IDS.length;
          for (var i = 0; i < ii; ++i) {
            try {
              var context = canvas.getContext(CONTEXT_IDS[i], attributes);
              if (context) {
                return context;
              }
            } catch (e) {
            }
          }
          return null;
        }
        var supportedExtensions;
        function getSupportedExtensions() {
          if (!supportedExtensions) {
            var canvas = document.createElement("canvas");
            var gl = getContext(canvas);
            if (gl) {
              supportedExtensions = gl.getSupportedExtensions();
            }
          }
          return supportedExtensions;
        }
        var BufferUsage = {
          STATIC_DRAW,
          STREAM_DRAW,
          DYNAMIC_DRAW
        };
        var Buffer_WebGLArrayBuffer = function() {
          function WebGLArrayBuffer(type, opt_usage) {
            this.array = null;
            this.type = type;
            assert2(type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER, 62);
            this.usage = opt_usage !== void 0 ? opt_usage : BufferUsage.STATIC_DRAW;
          }
          WebGLArrayBuffer.prototype.ofSize = function(size) {
            this.array = new (getArrayClassForType(this.type))(size);
          };
          WebGLArrayBuffer.prototype.fromArray = function(array) {
            var arrayClass = getArrayClassForType(this.type);
            this.array = arrayClass.from ? arrayClass.from(array) : new arrayClass(array);
          };
          WebGLArrayBuffer.prototype.fromArrayBuffer = function(buffer) {
            this.array = new (getArrayClassForType(this.type))(buffer);
          };
          WebGLArrayBuffer.prototype.getType = function() {
            return this.type;
          };
          WebGLArrayBuffer.prototype.getArray = function() {
            return this.array;
          };
          WebGLArrayBuffer.prototype.getUsage = function() {
            return this.usage;
          };
          WebGLArrayBuffer.prototype.getSize = function() {
            return this.array ? this.array.length : 0;
          };
          return WebGLArrayBuffer;
        }();
        function getArrayClassForType(type) {
          switch (type) {
            case ARRAY_BUFFER:
              return Float32Array;
            case ELEMENT_ARRAY_BUFFER:
              return Uint32Array;
            default:
              return Float32Array;
          }
        }
        var Buffer = Buffer_WebGLArrayBuffer;
        var ContextEventType = {
          LOST: "webglcontextlost",
          RESTORED: "webglcontextrestored"
        };
        var DEFAULT_VERTEX_SHADER = "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n";
        var DEFAULT_FRAGMENT_SHADER = "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n";
        var PostProcessingPass_WebGLPostProcessingPass = function() {
          function WebGLPostProcessingPass(options) {
            this.gl_ = options.webGlContext;
            var gl = this.gl_;
            this.scaleRatio_ = options.scaleRatio || 1;
            this.renderTargetTexture_ = gl.createTexture();
            this.renderTargetTextureSize_ = null;
            this.frameBuffer_ = gl.createFramebuffer();
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
            gl.compileShader(vertexShader);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
            gl.compileShader(fragmentShader);
            this.renderTargetProgram_ = gl.createProgram();
            gl.attachShader(this.renderTargetProgram_, vertexShader);
            gl.attachShader(this.renderTargetProgram_, fragmentShader);
            gl.linkProgram(this.renderTargetProgram_);
            this.renderTargetVerticesBuffer_ = gl.createBuffer();
            var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
            gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
            this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, "a_position");
            this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_screenSize");
            this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_opacity");
            this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, "u_image");
            this.uniforms_ = [];
            options.uniforms && Object.keys(options.uniforms).forEach(function(name) {
              this.uniforms_.push({
                value: options.uniforms[name],
                location: gl.getUniformLocation(this.renderTargetProgram_, name)
              });
            }.bind(this));
          }
          WebGLPostProcessingPass.prototype.getGL = function() {
            return this.gl_;
          };
          WebGLPostProcessingPass.prototype.init = function(frameState) {
            var gl = this.getGL();
            var textureSize = [
              gl.drawingBufferWidth * this.scaleRatio_,
              gl.drawingBufferHeight * this.scaleRatio_
            ];
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
            gl.viewport(0, 0, textureSize[0], textureSize[1]);
            if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
              this.renderTargetTextureSize_ = textureSize;
              var level = 0;
              var internalFormat = gl.RGBA;
              var border = 0;
              var format = gl.RGBA;
              var type = gl.UNSIGNED_BYTE;
              var data = null;
              gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
              gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
            }
          };
          WebGLPostProcessingPass.prototype.apply = function(frameState, nextPass, preCompose, postCompose) {
            var gl = this.getGL();
            var size = frameState.size;
            gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
            if (!nextPass) {
              var canvasId = Object(util["c"])(gl.canvas);
              if (!frameState.renderTargets[canvasId]) {
                var attributes = gl.getContextAttributes();
                if (attributes && attributes.preserveDrawingBuffer) {
                  gl.clearColor(0, 0, 0, 0);
                  gl.clear(gl.COLOR_BUFFER_BIT);
                }
                frameState.renderTargets[canvasId] = true;
              }
            }
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
            gl.useProgram(this.renderTargetProgram_);
            gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
            gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
            gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
            gl.uniform1i(this.renderTargetTextureLocation_, 0);
            var opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;
            gl.uniform1f(this.renderTargetOpacityLocation_, opacity);
            this.applyUniforms(frameState);
            if (preCompose) {
              preCompose(gl, frameState);
            }
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            if (postCompose) {
              postCompose(gl, frameState);
            }
          };
          WebGLPostProcessingPass.prototype.getFrameBuffer = function() {
            return this.frameBuffer_;
          };
          WebGLPostProcessingPass.prototype.applyUniforms = function(frameState) {
            var gl = this.getGL();
            var value;
            var textureSlot = 1;
            this.uniforms_.forEach(function(uniform) {
              value = typeof uniform.value === "function" ? uniform.value(frameState) : uniform.value;
              if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
                if (!uniform.texture) {
                  uniform.texture = gl.createTexture();
                }
                gl.activeTexture(gl["TEXTURE" + textureSlot]);
                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                if (value instanceof ImageData) {
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
                } else {
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
                }
                gl.uniform1i(uniform.location, textureSlot++);
              } else if (Array.isArray(value)) {
                switch (value.length) {
                  case 2:
                    gl.uniform2f(uniform.location, value[0], value[1]);
                    return;
                  case 3:
                    gl.uniform3f(uniform.location, value[0], value[1], value[2]);
                    return;
                  case 4:
                    gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
                    return;
                  default:
                    return;
                }
              } else if (typeof value === "number") {
                gl.uniform1f(uniform.location, value);
              }
            });
          };
          return WebGLPostProcessingPass;
        }();
        var PostProcessingPass = PostProcessingPass_WebGLPostProcessingPass;
        function mat4_create() {
          return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }
        function fromTransform(mat4, transform2) {
          mat4[0] = transform2[0];
          mat4[1] = transform2[1];
          mat4[4] = transform2[2];
          mat4[5] = transform2[3];
          mat4[12] = transform2[4];
          mat4[13] = transform2[5];
          return mat4;
        }
        var Helper_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ShaderType = {
          FRAGMENT_SHADER: 35632,
          VERTEX_SHADER: 35633
        };
        var DefaultUniform = {
          PROJECTION_MATRIX: "u_projectionMatrix",
          OFFSET_SCALE_MATRIX: "u_offsetScaleMatrix",
          OFFSET_ROTATION_MATRIX: "u_offsetRotateMatrix",
          TIME: "u_time",
          ZOOM: "u_zoom",
          RESOLUTION: "u_resolution"
        };
        var AttributeType = {
          UNSIGNED_BYTE,
          UNSIGNED_SHORT,
          UNSIGNED_INT,
          FLOAT
        };
        var canvasCache = {};
        function getSharedCanvasCacheKey(key) {
          return "shared/" + key;
        }
        var uniqueCanvasCacheKeyCount = 0;
        function getUniqueCanvasCacheKey() {
          var key = "unique/" + uniqueCanvasCacheKeyCount;
          uniqueCanvasCacheKeyCount += 1;
          return key;
        }
        function getCanvas(key) {
          var cacheItem = canvasCache[key];
          if (!cacheItem) {
            var canvas = document.createElement("canvas");
            canvas.style.position = "absolute";
            canvas.style.left = "0";
            cacheItem = { users: 0, canvas };
            canvasCache[key] = cacheItem;
          }
          cacheItem.users += 1;
          return cacheItem.canvas;
        }
        function releaseCanvas(key) {
          var cacheItem = canvasCache[key];
          if (!cacheItem) {
            return;
          }
          cacheItem.users -= 1;
          if (cacheItem.users > 0) {
            return;
          }
          var canvas = cacheItem.canvas;
          var gl = getContext(canvas);
          var extension = gl.getExtension("WEBGL_lose_context");
          if (extension) {
            extension.loseContext();
          }
          delete canvasCache[key];
        }
        var Helper_WebGLHelper = function(_super) {
          Helper_extends(WebGLHelper, _super);
          function WebGLHelper(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options || {};
            _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);
            _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_this);
            _this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();
            _this.canvas_ = getCanvas(_this.canvasCacheKey_);
            _this.gl_ = getContext(_this.canvas_);
            _this.bufferCache_ = {};
            _this.extensionCache_ = {};
            _this.currentProgram_ = null;
            _this.canvas_.addEventListener(ContextEventType.LOST, _this.boundHandleWebGLContextLost_);
            _this.canvas_.addEventListener(ContextEventType.RESTORED, _this.boundHandleWebGLContextRestored_);
            _this.offsetRotateMatrix_ = create();
            _this.offsetScaleMatrix_ = create();
            _this.tmpMat4_ = mat4_create();
            _this.uniformLocations_ = {};
            _this.attribLocations_ = {};
            _this.uniforms_ = [];
            if (options.uniforms) {
              _this.setUniforms(options.uniforms);
            }
            var gl = _this.getGL();
            _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function(options2) {
              return new PostProcessingPass({
                webGlContext: gl,
                scaleRatio: options2.scaleRatio,
                vertexShader: options2.vertexShader,
                fragmentShader: options2.fragmentShader,
                uniforms: options2.uniforms
              });
            }) : [new PostProcessingPass({ webGlContext: gl })];
            _this.shaderCompileErrors_ = null;
            _this.startTime_ = Date.now();
            return _this;
          }
          WebGLHelper.prototype.setUniforms = function(uniforms) {
            this.uniforms_ = [];
            for (var name_1 in uniforms) {
              this.uniforms_.push({
                name: name_1,
                value: uniforms[name_1]
              });
            }
            this.uniformLocations_ = {};
          };
          WebGLHelper.prototype.canvasCacheKeyMatches = function(canvasCacheKey) {
            return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
          };
          WebGLHelper.prototype.getExtension = function(name) {
            if (name in this.extensionCache_) {
              return this.extensionCache_[name];
            }
            var extension = this.gl_.getExtension(name);
            this.extensionCache_[name] = extension;
            return extension;
          };
          WebGLHelper.prototype.bindBuffer = function(buffer) {
            var gl = this.getGL();
            var bufferKey = Object(util["c"])(buffer);
            var bufferCache = this.bufferCache_[bufferKey];
            if (!bufferCache) {
              var webGlBuffer = gl.createBuffer();
              bufferCache = {
                buffer,
                webGlBuffer
              };
              this.bufferCache_[bufferKey] = bufferCache;
            }
            gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);
          };
          WebGLHelper.prototype.flushBufferData = function(buffer) {
            var gl = this.getGL();
            this.bindBuffer(buffer);
            gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());
          };
          WebGLHelper.prototype.deleteBuffer = function(buf) {
            var gl = this.getGL();
            var bufferKey = Object(util["c"])(buf);
            var bufferCacheEntry = this.bufferCache_[bufferKey];
            if (bufferCacheEntry && !gl.isContextLost()) {
              gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
            }
            delete this.bufferCache_[bufferKey];
          };
          WebGLHelper.prototype.disposeInternal = function() {
            this.canvas_.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);
            this.canvas_.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);
            releaseCanvas(this.canvasCacheKey_);
            delete this.gl_;
            delete this.canvas_;
          };
          WebGLHelper.prototype.prepareDraw = function(frameState, opt_disableAlphaBlend) {
            var gl = this.getGL();
            var canvas = this.getCanvas();
            var size = frameState.size;
            var pixelRatio = frameState.pixelRatio;
            canvas.width = size[0] * pixelRatio;
            canvas.height = size[1] * pixelRatio;
            canvas.style.width = size[0] + "px";
            canvas.style.height = size[1] + "px";
            gl.useProgram(this.currentProgram_);
            for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {
              this.postProcessPasses_[i].init(frameState);
            }
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
            gl.useProgram(this.currentProgram_);
            this.applyFrameState(frameState);
            this.applyUniforms(frameState);
          };
          WebGLHelper.prototype.prepareDrawToRenderTarget = function(frameState, renderTarget, opt_disableAlphaBlend) {
            var gl = this.getGL();
            var size = renderTarget.getSize();
            gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
            gl.viewport(0, 0, size[0], size[1]);
            gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
            gl.useProgram(this.currentProgram_);
            this.applyFrameState(frameState);
            this.applyUniforms(frameState);
          };
          WebGLHelper.prototype.drawElements = function(start, end) {
            var gl = this.getGL();
            this.getExtension("OES_element_index_uint");
            var elementType = gl.UNSIGNED_INT;
            var elementSize = 4;
            var numItems = end - start;
            var offsetInBytes = start * elementSize;
            gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
          };
          WebGLHelper.prototype.finalizeDraw = function(frameState, preCompose, postCompose) {
            for (var i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {
              if (i === ii - 1) {
                this.postProcessPasses_[i].apply(frameState, null, preCompose, postCompose);
              } else {
                this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1]);
              }
            }
          };
          WebGLHelper.prototype.getCanvas = function() {
            return this.canvas_;
          };
          WebGLHelper.prototype.getGL = function() {
            return this.gl_;
          };
          WebGLHelper.prototype.applyFrameState = function(frameState) {
            var size = frameState.size;
            var rotation = frameState.viewState.rotation;
            var offsetScaleMatrix = transform_reset(this.offsetScaleMatrix_);
            transform_scale(offsetScaleMatrix, 2 / size[0], 2 / size[1]);
            var offsetRotateMatrix = transform_reset(this.offsetRotateMatrix_);
            if (rotation !== 0) {
              rotate(offsetRotateMatrix, -rotation);
            }
            this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));
            this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));
            this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 1e-3);
            this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
            this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
          };
          WebGLHelper.prototype.applyUniforms = function(frameState) {
            var gl = this.getGL();
            var value;
            var textureSlot = 0;
            this.uniforms_.forEach(function(uniform) {
              value = typeof uniform.value === "function" ? uniform.value(frameState) : uniform.value;
              if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
                if (!uniform.texture) {
                  uniform.prevValue = void 0;
                  uniform.texture = gl.createTexture();
                }
                gl.activeTexture(gl["TEXTURE" + textureSlot]);
                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                var imageReady = !(value instanceof HTMLImageElement) || value.complete;
                if (imageReady && uniform.prevValue !== value) {
                  uniform.prevValue = value;
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
                }
                gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);
              } else if (Array.isArray(value) && value.length === 6) {
                this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));
              } else if (Array.isArray(value) && value.length <= 4) {
                switch (value.length) {
                  case 2:
                    gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);
                    return;
                  case 3:
                    gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);
                    return;
                  case 4:
                    gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
                    return;
                  default:
                    return;
                }
              } else if (typeof value === "number") {
                gl.uniform1f(this.getUniformLocation(uniform.name), value);
              }
            }.bind(this));
          };
          WebGLHelper.prototype.useProgram = function(program) {
            if (program == this.currentProgram_) {
              return false;
            } else {
              var gl = this.getGL();
              gl.useProgram(program);
              this.currentProgram_ = program;
              this.uniformLocations_ = {};
              this.attribLocations_ = {};
              return true;
            }
          };
          WebGLHelper.prototype.compileShader = function(source, type) {
            var gl = this.getGL();
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
          };
          WebGLHelper.prototype.getProgram = function(fragmentShaderSource, vertexShaderSource) {
            var gl = this.getGL();
            var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
            var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            var program = gl.createProgram();
            gl.attachShader(program, fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.linkProgram(program);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
              var message = "Fragment shader compliation failed: " + gl.getShaderInfoLog(fragmentShader);
              throw new Error(message);
            }
            gl.deleteShader(fragmentShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
              var message = "Vertex shader compilation failed: " + gl.getShaderInfoLog(vertexShader);
              throw new Error(message);
            }
            gl.deleteShader(vertexShader);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
              var message = "GL program linking failed: " + gl.getShaderInfoLog(vertexShader);
              throw new Error(message);
            }
            return program;
          };
          WebGLHelper.prototype.getUniformLocation = function(name) {
            if (this.uniformLocations_[name] === void 0) {
              this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);
            }
            return this.uniformLocations_[name];
          };
          WebGLHelper.prototype.getAttributeLocation = function(name) {
            if (this.attribLocations_[name] === void 0) {
              this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);
            }
            return this.attribLocations_[name];
          };
          WebGLHelper.prototype.makeProjectionTransform = function(frameState, transform2) {
            var size = frameState.size;
            var rotation = frameState.viewState.rotation;
            var resolution = frameState.viewState.resolution;
            var center = frameState.viewState.center;
            transform_reset(transform2);
            compose(transform2, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
            return transform2;
          };
          WebGLHelper.prototype.setUniformFloatValue = function(uniform, value) {
            this.getGL().uniform1f(this.getUniformLocation(uniform), value);
          };
          WebGLHelper.prototype.setUniformMatrixValue = function(uniform, value) {
            this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
          };
          WebGLHelper.prototype.enableAttributeArray_ = function(attribName, size, type, stride, offset) {
            var location2 = this.getAttributeLocation(attribName);
            if (location2 < 0) {
              return;
            }
            this.getGL().enableVertexAttribArray(location2);
            this.getGL().vertexAttribPointer(location2, size, type, false, stride, offset);
          };
          WebGLHelper.prototype.enableAttributes = function(attributes) {
            var stride = computeAttributesStride(attributes);
            var offset = 0;
            for (var i = 0; i < attributes.length; i++) {
              var attr = attributes[i];
              this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset);
              offset += attr.size * getByteSizeFromType(attr.type);
            }
          };
          WebGLHelper.prototype.handleWebGLContextLost = function() {
            Object(ol_obj["b"])(this.bufferCache_);
            this.currentProgram_ = null;
          };
          WebGLHelper.prototype.handleWebGLContextRestored = function() {
          };
          WebGLHelper.prototype.createTexture = function(size, opt_data, opt_texture) {
            var gl = this.getGL();
            var texture = opt_texture || gl.createTexture();
            var level = 0;
            var internalFormat = gl.RGBA;
            var border = 0;
            var format = gl.RGBA;
            var type = gl.UNSIGNED_BYTE;
            gl.bindTexture(gl.TEXTURE_2D, texture);
            if (opt_data) {
              gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, opt_data);
            } else {
              gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);
            }
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return texture;
          };
          return WebGLHelper;
        }(Disposable["a"]);
        function computeAttributesStride(attributes) {
          var stride = 0;
          for (var i = 0; i < attributes.length; i++) {
            var attr = attributes[i];
            stride += attr.size * getByteSizeFromType(attr.type);
          }
          return stride;
        }
        function getByteSizeFromType(type) {
          switch (type) {
            case AttributeType.UNSIGNED_BYTE:
              return Uint8Array.BYTES_PER_ELEMENT;
            case AttributeType.UNSIGNED_SHORT:
              return Uint16Array.BYTES_PER_ELEMENT;
            case AttributeType.UNSIGNED_INT:
              return Uint32Array.BYTES_PER_ELEMENT;
            case AttributeType.FLOAT:
            default:
              return Float32Array.BYTES_PER_ELEMENT;
          }
        }
        var Helper = Helper_WebGLHelper;
        var webgl_Layer_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var WebGLWorkerMessageType = {
          GENERATE_BUFFERS: "GENERATE_BUFFERS"
        };
        var Layer_WebGLLayerRenderer = function(_super) {
          webgl_Layer_extends(WebGLLayerRenderer, _super);
          function WebGLLayerRenderer(layer, opt_options) {
            var _this = _super.call(this, layer) || this;
            var options = opt_options || {};
            _this.inversePixelTransform_ = create();
            _this.pixelContext_ = null;
            _this.postProcesses_ = options.postProcesses;
            _this.uniforms_ = options.uniforms;
            _this.helper;
            layer.addChangeListener(Property.MAP, _this.removeHelper_.bind(_this));
            _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);
            _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);
            return _this;
          }
          WebGLLayerRenderer.prototype.dispatchPreComposeEvent = function(context, frameState) {
            var layer = this.getLayer();
            if (layer.hasListener(render_EventType.PRECOMPOSE)) {
              var event_1 = new render_Event(render_EventType.PRECOMPOSE, void 0, frameState, context);
              layer.dispatchEvent(event_1);
            }
          };
          WebGLLayerRenderer.prototype.dispatchPostComposeEvent = function(context, frameState) {
            var layer = this.getLayer();
            if (layer.hasListener(render_EventType.POSTCOMPOSE)) {
              var event_2 = new render_Event(render_EventType.POSTCOMPOSE, void 0, frameState, context);
              layer.dispatchEvent(event_2);
            }
          };
          WebGLLayerRenderer.prototype.reset = function(options) {
            this.uniforms_ = options.uniforms;
            if (this.helper) {
              this.helper.setUniforms(this.uniforms_);
            }
          };
          WebGLLayerRenderer.prototype.removeHelper_ = function() {
            if (this.helper) {
              this.helper.dispose();
              delete this.helper;
            }
          };
          WebGLLayerRenderer.prototype.prepareFrame = function(frameState) {
            if (this.getLayer().getSource()) {
              var incrementGroup = true;
              var groupNumber = -1;
              var className = void 0;
              for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {
                var layer = frameState.layerStatesArray[i].layer;
                var renderer = layer.getRenderer();
                if (!(renderer instanceof WebGLLayerRenderer)) {
                  incrementGroup = true;
                  continue;
                }
                var layerClassName = layer.getClassName();
                if (incrementGroup || layerClassName !== className) {
                  groupNumber += 1;
                  incrementGroup = false;
                }
                className = layerClassName;
                if (renderer === this) {
                  break;
                }
              }
              var canvasCacheKey = "map/" + frameState.mapId + "/group/" + groupNumber;
              if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {
                if (this.helper) {
                  this.helper.dispose();
                }
                this.helper = new Helper({
                  postProcesses: this.postProcesses_,
                  uniforms: this.uniforms_,
                  canvasCacheKey
                });
                if (className) {
                  this.helper.getCanvas().className = className;
                }
                this.afterHelperCreated();
              }
            }
            return this.prepareFrameInternal(frameState);
          };
          WebGLLayerRenderer.prototype.afterHelperCreated = function() {
          };
          WebGLLayerRenderer.prototype.prepareFrameInternal = function(frameState) {
            return true;
          };
          WebGLLayerRenderer.prototype.disposeInternal = function() {
            this.removeHelper_();
            _super.prototype.disposeInternal.call(this);
          };
          WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function(type, context, frameState) {
            var layer = this.getLayer();
            if (layer.hasListener(type)) {
              compose(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);
              var event_3 = new render_Event(type, this.inversePixelTransform_, frameState, context);
              layer.dispatchEvent(event_3);
            }
          };
          WebGLLayerRenderer.prototype.preRender = function(context, frameState) {
            this.dispatchRenderEvent_(render_EventType.PRERENDER, context, frameState);
          };
          WebGLLayerRenderer.prototype.postRender = function(context, frameState) {
            this.dispatchRenderEvent_(render_EventType.POSTRENDER, context, frameState);
          };
          WebGLLayerRenderer.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
            var renderPixel = apply([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());
            var gl = this.helper.getGL();
            if (!gl) {
              return null;
            }
            var layer = this.getLayer();
            var layerExtent = layer.getExtent();
            if (layerExtent) {
              var renderCoordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
              if (!containsCoordinate(layerExtent, renderCoordinate)) {
                return null;
              }
            }
            var attributes = gl.getContextAttributes();
            if (!attributes || !attributes.preserveDrawingBuffer) {
              return new Uint8Array();
            }
            var x = Math.round(renderPixel[0]);
            var y = Math.round(renderPixel[1]);
            var pixelContext = this.pixelContext_;
            if (!pixelContext) {
              var pixelCanvas = document.createElement("canvas");
              pixelCanvas.width = 1;
              pixelCanvas.height = 1;
              pixelContext = pixelCanvas.getContext("2d");
              this.pixelContext_ = pixelContext;
            }
            pixelContext.clearRect(0, 0, 1, 1);
            var data;
            try {
              pixelContext.drawImage(gl.canvas, x, y, 1, 1, 0, 0, 1, 1);
              data = pixelContext.getImageData(0, 0, 1, 1).data;
            } catch (err) {
              return data;
            }
            if (data[3] === 0) {
              return null;
            }
            return data;
          };
          return WebGLLayerRenderer;
        }(renderer_Layer);
        var tmpArray_ = [];
        var bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };
        function writePointVertex(buffer, pos, x, y, index) {
          buffer[pos + 0] = x;
          buffer[pos + 1] = y;
          buffer[pos + 2] = index;
        }
        function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {
          var baseVertexAttrsCount = 3;
          var baseInstructionsCount = 2;
          var stride = baseVertexAttrsCount + customAttributesCount;
          var x = instructions[elementIndex + 0];
          var y = instructions[elementIndex + 1];
          var customAttrs = tmpArray_;
          customAttrs.length = customAttributesCount;
          for (var i = 0; i < customAttrs.length; i++) {
            customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];
          }
          var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;
          var iPos = bufferPositions ? bufferPositions.indexPosition : 0;
          var baseIndex = vPos / stride;
          writePointVertex(vertexBuffer, vPos, x, y, 0);
          customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
          vPos += stride;
          writePointVertex(vertexBuffer, vPos, x, y, 1);
          customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
          vPos += stride;
          writePointVertex(vertexBuffer, vPos, x, y, 2);
          customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
          vPos += stride;
          writePointVertex(vertexBuffer, vPos, x, y, 3);
          customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
          vPos += stride;
          indexBuffer[iPos++] = baseIndex;
          indexBuffer[iPos++] = baseIndex + 1;
          indexBuffer[iPos++] = baseIndex + 3;
          indexBuffer[iPos++] = baseIndex + 1;
          indexBuffer[iPos++] = baseIndex + 2;
          indexBuffer[iPos++] = baseIndex + 3;
          bufferPositions_.vertexPosition = vPos;
          bufferPositions_.indexPosition = iPos;
          return bufferPositions_;
        }
        function getBlankImageData() {
          var canvas = document.createElement("canvas");
          var image = canvas.getContext("2d").createImageData(1, 1);
          image.data[0] = 255;
          image.data[1] = 255;
          image.data[2] = 255;
          image.data[3] = 255;
          return image;
        }
        function colorEncodeId(id, opt_array) {
          var array = opt_array || [];
          var radix = 256;
          var divide = radix - 1;
          array[0] = Math.floor(id / radix / radix / radix) / divide;
          array[1] = Math.floor(id / radix / radix) % radix / divide;
          array[2] = Math.floor(id / radix) % radix / divide;
          array[3] = id % radix / divide;
          return array;
        }
        function colorDecodeId(color) {
          var id = 0;
          var radix = 256;
          var mult = radix - 1;
          id += Math.round(color[0] * radix * radix * radix * mult);
          id += Math.round(color[1] * radix * radix * mult);
          id += Math.round(color[2] * radix * mult);
          id += Math.round(color[3] * mult);
          return id;
        }
        var webgl_Layer = Layer_WebGLLayerRenderer;
        var tmpArray4 = new Uint8Array(4);
        var RenderTarget_WebGLRenderTarget = function() {
          function WebGLRenderTarget(helper, opt_size) {
            this.helper_ = helper;
            var gl = helper.getGL();
            this.texture_ = gl.createTexture();
            this.framebuffer_ = gl.createFramebuffer();
            this.size_ = opt_size || [1, 1];
            this.data_ = new Uint8Array(0);
            this.dataCacheDirty_ = true;
            this.updateSize_();
          }
          WebGLRenderTarget.prototype.setSize = function(size) {
            if (Object(ol_array["b"])(size, this.size_)) {
              return;
            }
            this.size_[0] = size[0];
            this.size_[1] = size[1];
            this.updateSize_();
          };
          WebGLRenderTarget.prototype.getSize = function() {
            return this.size_;
          };
          WebGLRenderTarget.prototype.clearCachedData = function() {
            this.dataCacheDirty_ = true;
          };
          WebGLRenderTarget.prototype.readAll = function() {
            if (this.dataCacheDirty_) {
              var size = this.size_;
              var gl = this.helper_.getGL();
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
              gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);
              this.dataCacheDirty_ = false;
            }
            return this.data_;
          };
          WebGLRenderTarget.prototype.readPixel = function(x, y) {
            if (x < 0 || y < 0 || x > this.size_[0] || y >= this.size_[1]) {
              tmpArray4[0] = 0;
              tmpArray4[1] = 0;
              tmpArray4[2] = 0;
              tmpArray4[3] = 0;
              return tmpArray4;
            }
            this.readAll();
            var index = Math.floor(x) + (this.size_[1] - Math.floor(y) - 1) * this.size_[0];
            tmpArray4[0] = this.data_[index * 4];
            tmpArray4[1] = this.data_[index * 4 + 1];
            tmpArray4[2] = this.data_[index * 4 + 2];
            tmpArray4[3] = this.data_[index * 4 + 3];
            return tmpArray4;
          };
          WebGLRenderTarget.prototype.getTexture = function() {
            return this.texture_;
          };
          WebGLRenderTarget.prototype.getFramebuffer = function() {
            return this.framebuffer_;
          };
          WebGLRenderTarget.prototype.updateSize_ = function() {
            var size = this.size_;
            var gl = this.helper_.getGL();
            this.texture_ = this.helper_.createTexture(size, null, this.texture_);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
            gl.viewport(0, 0, size[0], size[1]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);
            this.data_ = new Uint8Array(size[0] * size[1] * 4);
          };
          return WebGLRenderTarget;
        }();
        var RenderTarget = RenderTarget_WebGLRenderTarget;
        var webgl = __webpack_require__("7fd1");
        var PointsLayer_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var PointsLayer_WebGLPointsLayerRenderer = function(_super) {
          PointsLayer_extends(WebGLPointsLayerRenderer, _super);
          function WebGLPointsLayerRenderer(layer, options) {
            var _this = this;
            var uniforms = options.uniforms || {};
            var projectionMatrixTransform = create();
            uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;
            _this = _super.call(this, layer, {
              uniforms,
              postProcesses: options.postProcesses
            }) || this;
            _this.sourceRevision_ = -1;
            _this.verticesBuffer_ = new Buffer(ARRAY_BUFFER, DYNAMIC_DRAW);
            _this.hitVerticesBuffer_ = new Buffer(ARRAY_BUFFER, DYNAMIC_DRAW);
            _this.indicesBuffer_ = new Buffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);
            _this.vertexShader_ = options.vertexShader;
            _this.fragmentShader_ = options.fragmentShader;
            _this.program_;
            _this.hitDetectionEnabled_ = options.hitFragmentShader && options.hitVertexShader ? true : false;
            _this.hitVertexShader_ = options.hitVertexShader;
            _this.hitFragmentShader_ = options.hitFragmentShader;
            _this.hitProgram_;
            var customAttributes = options.attributes ? options.attributes.map(function(attribute) {
              return {
                name: "a_" + attribute.name,
                size: 1,
                type: AttributeType.FLOAT
              };
            }) : [];
            _this.attributes = [
              {
                name: "a_position",
                size: 2,
                type: AttributeType.FLOAT
              },
              {
                name: "a_index",
                size: 1,
                type: AttributeType.FLOAT
              }
            ].concat(customAttributes);
            _this.hitDetectionAttributes = [
              {
                name: "a_position",
                size: 2,
                type: AttributeType.FLOAT
              },
              {
                name: "a_index",
                size: 1,
                type: AttributeType.FLOAT
              },
              {
                name: "a_hitColor",
                size: 4,
                type: AttributeType.FLOAT
              },
              {
                name: "a_featureUid",
                size: 1,
                type: AttributeType.FLOAT
              }
            ].concat(customAttributes);
            _this.customAttributes = options.attributes ? options.attributes : [];
            _this.previousExtent_ = createEmpty();
            _this.currentTransform_ = projectionMatrixTransform;
            _this.renderTransform_ = create();
            _this.invertRenderTransform_ = create();
            _this.renderInstructions_ = new Float32Array(0);
            _this.hitRenderInstructions_ = new Float32Array(0);
            _this.hitRenderTarget_;
            _this.worker_ = Object(webgl["a"])();
            _this.worker_.addEventListener("message", function(event) {
              var received = event.data;
              if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {
                var projectionTransform = received.projectionTransform;
                if (received.hitDetection) {
                  this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);
                  this.helper.flushBufferData(this.hitVerticesBuffer_);
                } else {
                  this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);
                  this.helper.flushBufferData(this.verticesBuffer_);
                }
                this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);
                this.helper.flushBufferData(this.indicesBuffer_);
                this.renderTransform_ = projectionTransform;
                makeInverse(this.invertRenderTransform_, this.renderTransform_);
                if (received.hitDetection) {
                  this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);
                } else {
                  this.renderInstructions_ = new Float32Array(event.data.renderInstructions);
                }
                this.getLayer().changed();
              }
            }.bind(_this));
            _this.featureCache_ = {};
            _this.featureCount_ = 0;
            var source = _this.getLayer().getSource();
            _this.sourceListenKeys_ = [
              Object(events["a"])(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),
              Object(events["a"])(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),
              Object(events["a"])(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),
              Object(events["a"])(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this)
            ];
            source.forEachFeature(function(feature) {
              this.featureCache_[Object(util["c"])(feature)] = {
                feature,
                properties: feature.getProperties(),
                geometry: feature.getGeometry()
              };
              this.featureCount_++;
            }.bind(_this));
            return _this;
          }
          WebGLPointsLayerRenderer.prototype.afterHelperCreated = function() {
            this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
            if (this.hitDetectionEnabled_) {
              this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);
              this.hitRenderTarget_ = new RenderTarget(this.helper);
            }
          };
          WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function(event) {
            var feature = event.feature;
            this.featureCache_[Object(util["c"])(feature)] = {
              feature,
              properties: feature.getProperties(),
              geometry: feature.getGeometry()
            };
            this.featureCount_++;
          };
          WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function(event) {
            var feature = event.feature;
            this.featureCache_[Object(util["c"])(feature)] = {
              feature,
              properties: feature.getProperties(),
              geometry: feature.getGeometry()
            };
          };
          WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function(event) {
            var feature = event.feature;
            delete this.featureCache_[Object(util["c"])(feature)];
            this.featureCount_--;
          };
          WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function() {
            this.featureCache_ = {};
            this.featureCount_ = 0;
          };
          WebGLPointsLayerRenderer.prototype.renderFrame = function(frameState) {
            var gl = this.helper.getGL();
            this.preRender(gl, frameState);
            var renderCount = this.indicesBuffer_.getSize();
            this.helper.drawElements(0, renderCount);
            this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
            var canvas = this.helper.getCanvas();
            if (this.hitDetectionEnabled_) {
              this.renderHitDetection(frameState);
              this.hitRenderTarget_.clearCachedData();
            }
            this.postRender(gl, frameState);
            return canvas;
          };
          WebGLPointsLayerRenderer.prototype.prepareFrameInternal = function(frameState) {
            var layer = this.getLayer();
            var vectorSource = layer.getSource();
            var viewState = frameState.viewState;
            var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING];
            var extentChanged = !equals(this.previousExtent_, frameState.extent);
            var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();
            if (sourceChanged) {
              this.sourceRevision_ = vectorSource.getRevision();
            }
            if (viewNotMoving && (extentChanged || sourceChanged)) {
              var projection = viewState.projection;
              var resolution = viewState.resolution;
              var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;
              var extent = extent_buffer(frameState.extent, renderBuffer * resolution);
              vectorSource.loadFeatures(extent, resolution, projection);
              this.rebuildBuffers_(frameState);
              this.previousExtent_ = frameState.extent.slice();
            }
            this.helper.makeProjectionTransform(frameState, this.currentTransform_);
            multiply(this.currentTransform_, this.invertRenderTransform_);
            this.helper.useProgram(this.program_);
            this.helper.prepareDraw(frameState);
            this.helper.bindBuffer(this.verticesBuffer_);
            this.helper.bindBuffer(this.indicesBuffer_);
            this.helper.enableAttributes(this.attributes);
            return true;
          };
          WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function(frameState) {
            var projectionTransform = create();
            this.helper.makeProjectionTransform(frameState, projectionTransform);
            var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;
            if (!this.renderInstructions_ || this.renderInstructions_.length !== totalInstructionsCount) {
              this.renderInstructions_ = new Float32Array(totalInstructionsCount);
            }
            if (this.hitDetectionEnabled_) {
              var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;
              if (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== totalHitInstructionsCount) {
                this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);
              }
            }
            var featureCache, geometry;
            var tmpCoords = [];
            var tmpColor = [];
            var renderIndex = 0;
            var hitIndex = 0;
            var hitColor;
            for (var featureUid in this.featureCache_) {
              featureCache = this.featureCache_[featureUid];
              geometry = featureCache.geometry;
              if (!geometry || geometry.getType() !== geom_GeometryType.POINT) {
                continue;
              }
              tmpCoords[0] = geometry.getFlatCoordinates()[0];
              tmpCoords[1] = geometry.getFlatCoordinates()[1];
              apply(projectionTransform, tmpCoords);
              hitColor = colorEncodeId(hitIndex + 6, tmpColor);
              this.renderInstructions_[renderIndex++] = tmpCoords[0];
              this.renderInstructions_[renderIndex++] = tmpCoords[1];
              if (this.hitDetectionEnabled_) {
                this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];
                this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];
                this.hitRenderInstructions_[hitIndex++] = hitColor[0];
                this.hitRenderInstructions_[hitIndex++] = hitColor[1];
                this.hitRenderInstructions_[hitIndex++] = hitColor[2];
                this.hitRenderInstructions_[hitIndex++] = hitColor[3];
                this.hitRenderInstructions_[hitIndex++] = Number(featureUid);
              }
              var value = void 0;
              for (var j = 0; j < this.customAttributes.length; j++) {
                value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);
                this.renderInstructions_[renderIndex++] = value;
                if (this.hitDetectionEnabled_) {
                  this.hitRenderInstructions_[hitIndex++] = value;
                }
              }
            }
            var message = {
              type: WebGLWorkerMessageType.GENERATE_BUFFERS,
              renderInstructions: this.renderInstructions_.buffer,
              customAttributesCount: this.customAttributes.length
            };
            message["projectionTransform"] = projectionTransform;
            this.worker_.postMessage(message, [this.renderInstructions_.buffer]);
            this.renderInstructions_ = null;
            if (this.hitDetectionEnabled_) {
              var hitMessage = {
                type: WebGLWorkerMessageType.GENERATE_BUFFERS,
                renderInstructions: this.hitRenderInstructions_.buffer,
                customAttributesCount: 5 + this.customAttributes.length
              };
              hitMessage["projectionTransform"] = projectionTransform;
              hitMessage["hitDetection"] = true;
              this.worker_.postMessage(hitMessage, [
                this.hitRenderInstructions_.buffer
              ]);
              this.hitRenderInstructions_ = null;
            }
          };
          WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
            assert2(this.hitDetectionEnabled_, 66);
            if (!this.hitRenderInstructions_) {
              return void 0;
            }
            var pixel = apply(frameState.coordinateToPixelTransform, coordinate.slice());
            var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);
            var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];
            var index = colorDecodeId(color);
            var opacity = this.hitRenderInstructions_[index];
            var uid = Math.floor(opacity).toString();
            var source = this.getLayer().getSource();
            var feature = source.getFeatureByUid(uid);
            if (feature) {
              return callback(feature, this.getLayer(), null);
            }
            return void 0;
          };
          WebGLPointsLayerRenderer.prototype.renderHitDetection = function(frameState) {
            if (!this.hitVerticesBuffer_.getSize()) {
              return;
            }
            this.hitRenderTarget_.setSize([
              Math.floor(frameState.size[0] / 2),
              Math.floor(frameState.size[1] / 2)
            ]);
            this.helper.useProgram(this.hitProgram_);
            this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);
            this.helper.bindBuffer(this.hitVerticesBuffer_);
            this.helper.bindBuffer(this.indicesBuffer_);
            this.helper.enableAttributes(this.hitDetectionAttributes);
            var renderCount = this.indicesBuffer_.getSize();
            this.helper.drawElements(0, renderCount);
          };
          WebGLPointsLayerRenderer.prototype.disposeInternal = function() {
            this.worker_.terminate();
            this.layer_ = null;
            this.sourceListenKeys_.forEach(function(key) {
              Object(events["c"])(key);
            });
            this.sourceListenKeys_ = null;
            _super.prototype.disposeInternal.call(this);
          };
          return WebGLPointsLayerRenderer;
        }(webgl_Layer);
        var PointsLayer = PointsLayer_WebGLPointsLayerRenderer;
        var Heatmap_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Heatmap_Property = {
          BLUR: "blur",
          GRADIENT: "gradient",
          RADIUS: "radius"
        };
        var DEFAULT_GRADIENT = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
        var Heatmap_Heatmap = function(_super) {
          Heatmap_extends(Heatmap, _super);
          function Heatmap(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var baseOptions = Object(ol_obj["a"])({}, options);
            delete baseOptions.gradient;
            delete baseOptions.radius;
            delete baseOptions.blur;
            delete baseOptions.weight;
            _this = _super.call(this, baseOptions) || this;
            _this.gradient_ = null;
            _this.addChangeListener(Heatmap_Property.GRADIENT, _this.handleGradientChanged_);
            _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);
            _this.setBlur(options.blur !== void 0 ? options.blur : 15);
            _this.setRadius(options.radius !== void 0 ? options.radius : 8);
            var weight = options.weight ? options.weight : "weight";
            if (typeof weight === "string") {
              _this.weightFunction_ = function(feature) {
                return feature.get(weight);
              };
            } else {
              _this.weightFunction_ = weight;
            }
            _this.setRenderOrder(null);
            return _this;
          }
          Heatmap.prototype.getBlur = function() {
            return this.get(Heatmap_Property.BLUR);
          };
          Heatmap.prototype.getGradient = function() {
            return this.get(Heatmap_Property.GRADIENT);
          };
          Heatmap.prototype.getRadius = function() {
            return this.get(Heatmap_Property.RADIUS);
          };
          Heatmap.prototype.handleGradientChanged_ = function() {
            this.gradient_ = createGradient(this.getGradient());
          };
          Heatmap.prototype.setBlur = function(blur) {
            this.set(Heatmap_Property.BLUR, blur);
          };
          Heatmap.prototype.setGradient = function(colors) {
            this.set(Heatmap_Property.GRADIENT, colors);
          };
          Heatmap.prototype.setRadius = function(radius) {
            this.set(Heatmap_Property.RADIUS, radius);
          };
          Heatmap.prototype.createRenderer = function() {
            return new PointsLayer(this, {
              className: this.getClassName(),
              attributes: [
                {
                  name: "weight",
                  callback: function(feature) {
                    var weight = this.weightFunction_(feature);
                    return weight !== void 0 ? clamp(weight, 0, 1) : 1;
                  }.bind(this)
                }
              ],
              vertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }",
              fragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }",
              hitVertexShader: "\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }",
              hitFragmentShader: "\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }",
              uniforms: {
                u_size: function() {
                  return (this.get(Heatmap_Property.RADIUS) + this.get(Heatmap_Property.BLUR)) * 2;
                }.bind(this),
                u_blurSlope: function() {
                  return this.get(Heatmap_Property.RADIUS) / Math.max(1, this.get(Heatmap_Property.BLUR));
                }.bind(this)
              },
              postProcesses: [
                {
                  fragmentShader: "\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }",
                  uniforms: {
                    u_gradientTexture: function() {
                      return this.gradient_;
                    }.bind(this),
                    u_opacity: function() {
                      return this.getOpacity();
                    }.bind(this)
                  }
                }
              ]
            });
          };
          Heatmap.prototype.renderDeclutter = function() {
          };
          return Heatmap;
        }(BaseVector);
        function createGradient(colors) {
          var width = 1;
          var height = 256;
          var context = Object(dom["a"])(width, height);
          var gradient = context.createLinearGradient(0, 0, width, height);
          var step = 1 / (colors.length - 1);
          for (var i = 0, ii = colors.length; i < ii; ++i) {
            gradient.addColorStop(i * step, colors[i]);
          }
          context.fillStyle = gradient;
          context.fillRect(0, 0, width, height);
          return context.canvas;
        }
        var layer_Heatmap = Heatmap_Heatmap;
        var ol_control_LayerSwitcher = function(options) {
          options = options || {};
          var self2 = this;
          this.dcount = 0;
          this.show_progress = options.show_progress;
          this.oninfo = typeof options.oninfo == "function" ? options.oninfo : null;
          this.onextent = typeof options.onextent == "function" ? options.onextent : null;
          this.hasextent = options.extent || options.onextent;
          this.hastrash = options.trash;
          this.reordering = options.reordering !== false;
          this._layers = [];
          this._layerGroup = options.layerGroup && options.layerGroup.getLayers ? options.layerGroup : null;
          this.onchangeCheck = typeof options.onchangeCheck == "function" ? options.onchangeCheck : null;
          if (typeof options.displayInLayerSwitcher === "function") {
            this.displayInLayerSwitcher = options.displayInLayerSwitcher;
          }
          var element;
          if (options.target) {
            element = util_element.create("DIV", {
              className: options.switcherClass || "ol-layerswitcher"
            });
          } else {
            element = util_element.create("DIV", {
              className: (options.switcherClass || "ol-layerswitcher") + " ol-unselectable ol-control"
            });
            if (options.collapsed !== false)
              element.classList.add("ol-collapsed");
            else
              element.classList.add("ol-forceopen");
            this.button = util_element.create("BUTTON", {
              type: "button",
              parent: element
            });
            this.button.addEventListener("touchstart", function(e) {
              element.classList.toggle("ol-forceopen");
              element.classList.add("ol-collapsed");
              self2.dispatchEvent({ type: "toggle", collapsed: element.classList.contains("ol-collapsed") });
              e.preventDefault();
              self2.overflow();
            });
            this.button.addEventListener("click", function() {
              element.classList.toggle("ol-forceopen");
              element.classList.add("ol-collapsed");
              self2.dispatchEvent({ type: "toggle", collapsed: !element.classList.contains("ol-forceopen") });
              self2.overflow();
            });
            if (options.mouseover) {
              element.addEventListener("mouseleave", function() {
                element.classList.add("ol-collapsed");
                self2.dispatchEvent({ type: "toggle", collapsed: true });
              });
              element.addEventListener("mouseover", function() {
                element.classList.remove("ol-collapsed");
                self2.dispatchEvent({ type: "toggle", collapsed: false });
              });
            }
            if (options.minibar)
              options.noScroll = true;
            if (!options.noScroll) {
              this.topv = util_element.create("DIV", {
                className: "ol-switchertopdiv",
                parent: element,
                click: function() {
                  self2.overflow("+50%");
                }
              });
              this.botv = util_element.create("DIV", {
                className: "ol-switcherbottomdiv",
                parent: element,
                click: function() {
                  self2.overflow("-50%");
                }
              });
            }
            this._noScroll = options.noScroll;
          }
          this.panel_ = util_element.create("UL", {
            className: "panel"
          });
          this.panelContainer_ = util_element.create("DIV", {
            className: "panel-container",
            html: this.panel_,
            parent: element
          });
          if (!options.target && !options.noScroll) {
            util_element.addListener(this.panel_, "mousewheel DOMMouseScroll onmousewheel", function(e) {
              if (self2.overflow(Math.max(-1, Math.min(1, e.wheelDelta || -e.detail)))) {
                e.stopPropagation();
                e.preventDefault();
              }
            });
          }
          this.header_ = util_element.create("LI", {
            className: "ol-header",
            parent: this.panel_
          });
          Control["default"].call(this, {
            element,
            target: options.target
          });
          this.set("drawDelay", options.drawDelay || 0);
          this.set("selection", options.selection);
          if (options.minibar) {
            setTimeout(function() {
              var mbar = util_element.scrollDiv(this.panelContainer_, {
                mousewheel: true,
                vertical: true,
                minibar: true
              });
              this.on(["drawlist", "toggle"], function() {
                mbar.refresh();
              });
            }.bind(this));
          }
        };
        util_ext(ol_control_LayerSwitcher, Control["default"]);
        ol_control_LayerSwitcher.prototype.tip = {
          up: "up/down",
          down: "down",
          info: "informations...",
          extent: "zoom to extent",
          trash: "remove layer",
          plus: "expand/shrink"
        };
        ol_control_LayerSwitcher.prototype.displayInLayerSwitcher = function(layer) {
          return layer.get("displayInLayerSwitcher") !== false;
        };
        ol_control_LayerSwitcher.prototype.setMap = function(map) {
          Control["default"].prototype.setMap.call(this, map);
          this.drawPanel();
          if (this._listener) {
            for (var i in this._listener)
              Object(Observable["b"])(this._listener[i]);
          }
          this._listener = null;
          if (map) {
            this._listener = {
              moveend: map.on("moveend", this.viewChange.bind(this)),
              size: map.on("change:size", this.overflow.bind(this))
            };
            if (this._layerGroup) {
              this._listener.change = this._layerGroup.getLayers().on("change:length", this.drawPanel.bind(this));
            } else {
              this._listener.change = map.getLayerGroup().getLayers().on("change:length", this.drawPanel.bind(this));
            }
          }
        };
        ol_control_LayerSwitcher.prototype.show = function() {
          this.element.classList.add("ol-forceopen");
          this.overflow();
          self.dispatchEvent({ type: "toggle", collapsed: false });
        };
        ol_control_LayerSwitcher.prototype.hide = function() {
          this.element.classList.remove("ol-forceopen");
          this.overflow();
          self.dispatchEvent({ type: "toggle", collapsed: true });
        };
        ol_control_LayerSwitcher.prototype.toggle = function() {
          this.element.classList.toggle("ol-forceopen");
          this.overflow();
        };
        ol_control_LayerSwitcher.prototype.isOpen = function() {
          return this.element.classList.contains("ol-forceopen");
        };
        ol_control_LayerSwitcher.prototype.setHeader = function(html) {
          util_element.setHTML(this.header_, html);
        };
        ol_control_LayerSwitcher.prototype.overflow = function(dir) {
          if (this.button && !this._noScroll) {
            if (util_element.hidden(this.panel_)) {
              util_element.setStyle(this.element, { height: "auto" });
              return;
            }
            var h = util_element.outerHeight(this.element);
            var hp = util_element.outerHeight(this.panel_);
            var dh = this.button.offsetTop + util_element.outerHeight(this.button);
            var top = this.panel_.offsetTop - dh;
            if (hp > h - dh) {
              util_element.setStyle(this.element, { height: "100%" });
              var li = this.panel_.querySelectorAll("li.visible .li-content")[0];
              var lh = li ? 2 * util_element.getStyle(li, "height") : 0;
              switch (dir) {
                case 1:
                  top += lh;
                  break;
                case -1:
                  top -= lh;
                  break;
                case "+50%":
                  top += Math.round(h / 2);
                  break;
                case "-50%":
                  top -= Math.round(h / 2);
                  break;
                default:
                  break;
              }
              if (top + hp <= h - 3 * dh / 2) {
                top = h - 3 * dh / 2 - hp;
                util_element.hide(this.botv);
              } else {
                util_element.show(this.botv);
              }
              if (top >= 0) {
                top = 0;
                util_element.hide(this.topv);
              } else {
                util_element.show(this.topv);
              }
              util_element.setStyle(this.panel_, { top: top + "px" });
              return true;
            } else {
              util_element.setStyle(this.element, { height: "auto" });
              util_element.setStyle(this.panel_, { top: 0 });
              util_element.hide(this.botv);
              util_element.hide(this.topv);
              return false;
            }
          } else
            return false;
        };
        ol_control_LayerSwitcher.prototype._setLayerForLI = function(li, layer) {
          var listeners = [];
          if (layer.getLayers) {
            listeners.push(layer.getLayers().on("change:length", this.drawPanel.bind(this)));
          }
          if (li) {
            listeners.push(layer.on("change:opacity", function() {
              this.setLayerOpacity(layer, li);
            }.bind(this)));
            listeners.push(layer.on("change:visible", function() {
              this.setLayerVisibility(layer, li);
            }.bind(this)));
          }
          listeners.push(layer.on("propertychange", function(e) {
            if (e.key === "displayInLayerSwitcher" || e.key === "openInLayerSwitcher") {
              this.drawPanel(e);
            }
          }.bind(this)));
          this._layers.push({ li, layer, listeners });
        };
        ol_control_LayerSwitcher.prototype.setLayerOpacity = function(layer, li) {
          var i = li.querySelector(".layerswitcher-opacity-cursor");
          if (i)
            i.style.left = layer.getOpacity() * 100 + "%";
          this.dispatchEvent({ type: "layer:opacity", layer });
        };
        ol_control_LayerSwitcher.prototype.setLayerVisibility = function(layer, li) {
          var i = li.querySelector(".ol-visibility");
          if (i)
            i.checked = layer.getVisible();
          if (layer.getVisible())
            li.classList.add("ol-visible");
          else
            li.classList.remove("ol-visible");
          this.dispatchEvent({ type: "layer:visible", layer });
        };
        ol_control_LayerSwitcher.prototype._clearLayerForLI = function() {
          this._layers.forEach(function(li) {
            li.listeners.forEach(function(l) {
              Object(Observable["b"])(l);
            });
          });
          this._layers = [];
        };
        ol_control_LayerSwitcher.prototype._getLayerForLI = function(li) {
          for (var i = 0, l; l = this._layers[i]; i++) {
            if (l.li === li)
              return l.layer;
          }
          return null;
        };
        ol_control_LayerSwitcher.prototype.viewChange = function() {
          this.panel_.querySelectorAll("li").forEach(function(li) {
            var l = this._getLayerForLI(li);
            if (l) {
              if (this.testLayerVisibility(l))
                li.classList.remove("ol-layer-hidden");
              else
                li.classList.add("ol-layer-hidden");
            }
          }.bind(this));
        };
        ol_control_LayerSwitcher.prototype.getPanel = function() {
          return this.panelContainer_;
        };
        ol_control_LayerSwitcher.prototype.drawPanel = function() {
          if (!this.getMap())
            return;
          var self2 = this;
          this.dcount++;
          setTimeout(function() {
            self2.drawPanel_();
          }, this.get("drawDelay") || 0);
        };
        ol_control_LayerSwitcher.prototype.drawPanel_ = function() {
          if (--this.dcount || this.dragging_)
            return;
          var scrollTop = this.panelContainer_.scrollTop;
          this._clearLayerForLI();
          this.panel_.querySelectorAll("li").forEach(function(li) {
            if (!li.classList.contains("ol-header"))
              li.remove();
          }.bind(this));
          if (this._layerGroup)
            this.drawList(this.panel_, this._layerGroup.getLayers());
          else if (this.getMap())
            this.drawList(this.panel_, this.getMap().getLayers());
          this.panelContainer_.scrollTop = scrollTop;
        };
        ol_control_LayerSwitcher.prototype.switchLayerVisibility = function(l, layers) {
          if (!l.get("baseLayer")) {
            l.setVisible(!l.getVisible());
          } else {
            if (!l.getVisible())
              l.setVisible(true);
            layers.forEach(function(li) {
              if (l !== li && li.get("baseLayer") && li.getVisible())
                li.setVisible(false);
            });
          }
        };
        ol_control_LayerSwitcher.prototype.testLayerVisibility = function(layer) {
          if (!this.getMap())
            return true;
          var res = this.getMap().getView().getResolution();
          var zoom = this.getMap().getView().getZoom();
          if (layer.getMaxResolution() <= res || layer.getMinResolution() >= res) {
            return false;
          } else if (layer.getMinZoom && (layer.getMinZoom() >= zoom || layer.getMaxZoom() < zoom)) {
            return false;
          } else {
            var ex0 = layer.getExtent();
            if (ex0) {
              var ex = this.getMap().getView().calculateExtent(this.getMap().getSize());
              return extent_intersects(ex, ex0);
            }
            return true;
          }
        };
        ol_control_LayerSwitcher.prototype.dragOrdering_ = function(e) {
          e.stopPropagation();
          e.preventDefault();
          var self2 = this;
          var elt = e.currentTarget.parentNode.parentNode;
          var start = true;
          var panel = this.panel_;
          var pageY;
          var pageY0 = e.pageY || e.touches && e.touches.length && e.touches[0].pageY || e.changedTouches && e.changedTouches.length && e.changedTouches[0].pageY;
          var target, dragElt;
          var layer, group;
          elt.parentNode.classList.add("drag");
          function stop() {
            if (target) {
              var drop = layer;
              var isSelected = self2.getSelection() === drop;
              if (drop && target) {
                var collection;
                if (group)
                  collection = group.getLayers();
                else
                  collection = self2._layerGroup ? self2._layerGroup.getLayers() : self2.getMap().getLayers();
                var layers = collection.getArray();
                for (var i = 0; i < layers.length; i++) {
                  if (layers[i] == drop) {
                    collection.removeAt(i);
                    break;
                  }
                }
                for (var j = 0; j < layers.length; j++) {
                  if (layers[j] === target) {
                    if (i > j)
                      collection.insertAt(j, drop);
                    else
                      collection.insertAt(j + 1, drop);
                    break;
                  }
                }
              }
              if (isSelected)
                self2.selectLayer(drop);
              self2.dispatchEvent({ type: "reorder-end", layer: drop, group });
            }
            elt.parentNode.querySelectorAll("li").forEach(function(li) {
              li.classList.remove("dropover");
              li.classList.remove("dropover-after");
              li.classList.remove("dropover-before");
            });
            elt.classList.remove("drag");
            elt.parentNode.classList.remove("drag");
            self2.element.classList.remove("drag");
            if (dragElt)
              dragElt.remove();
            util_element.removeListener(document, "mousemove touchmove", move);
            util_element.removeListener(document, "mouseup touchend touchcancel", stop);
          }
          function move(e2) {
            pageY = e2.pageY || e2.touches && e2.touches.length && e2.touches[0].pageY || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageY;
            if (start && Math.abs(pageY0 - pageY) > 2) {
              start = false;
              elt.classList.add("drag");
              layer = self2._getLayerForLI(elt);
              target = false;
              group = self2._getLayerForLI(elt.parentNode.parentNode);
              dragElt = util_element.create("LI", {
                className: "ol-dragover",
                html: elt.innerHTML,
                style: {
                  position: "absolute",
                  "z-index": 1e4,
                  left: elt.offsetLeft,
                  opacity: 0.5,
                  width: util_element.outerWidth(elt),
                  height: util_element.getStyle(elt, "height")
                },
                parent: panel
              });
              self2.element.classList.add("drag");
              self2.dispatchEvent({ type: "reorder-start", layer, group });
            }
            if (!start) {
              e2.preventDefault();
              e2.stopPropagation();
              util_element.setStyle(dragElt, { top: pageY - util_element.offsetRect(panel).top + panel.scrollTop + 5 });
              var li;
              if (!e2.touches) {
                li = e2.target;
              } else {
                li = document.elementFromPoint(e2.touches[0].clientX, e2.touches[0].clientY);
              }
              if (li.classList.contains("ol-switcherbottomdiv")) {
                self2.overflow(-1);
              } else if (li.classList.contains("ol-switchertopdiv")) {
                self2.overflow(1);
              }
              while (li && li.tagName !== "LI") {
                li = li.parentNode;
              }
              if (!li || !li.classList.contains("dropover")) {
                elt.parentNode.querySelectorAll("li").forEach(function(li2) {
                  li2.classList.remove("dropover");
                  li2.classList.remove("dropover-after");
                  li2.classList.remove("dropover-before");
                });
              }
              if (li && li.parentNode.classList.contains("drag") && li !== elt) {
                target = self2._getLayerForLI(li);
                if (target && !target.get("allwaysOnTop") == !layer.get("allwaysOnTop")) {
                  li.classList.add("dropover");
                  li.classList.add(elt.offsetTop < li.offsetTop ? "dropover-after" : "dropover-before");
                } else {
                  target = false;
                }
                util_element.show(dragElt);
              } else {
                target = false;
                if (li === elt)
                  util_element.hide(dragElt);
                else
                  util_element.show(dragElt);
              }
              if (!target)
                dragElt.classList.add("forbidden");
              else
                dragElt.classList.remove("forbidden");
            }
          }
          util_element.addListener(document, "mousemove touchmove", move);
          util_element.addListener(document, "mouseup touchend touchcancel", stop);
        };
        ol_control_LayerSwitcher.prototype.dragOpacity_ = function(e) {
          e.stopPropagation();
          e.preventDefault();
          var self2 = this;
          var elt = e.target;
          var layer = this._getLayerForLI(elt.parentNode.parentNode.parentNode);
          if (!layer)
            return;
          var x = e.pageX || e.touches && e.touches.length && e.touches[0].pageX || e.changedTouches && e.changedTouches.length && e.changedTouches[0].pageX;
          var start = util_element.getStyle(elt, "left") - x;
          self2.dragging_ = true;
          function stop() {
            util_element.removeListener(document, "mouseup touchend touchcancel", stop);
            util_element.removeListener(document, "mousemove touchmove", move);
            self2.dragging_ = false;
          }
          function move(e2) {
            var x2 = e2.pageX || e2.touches && e2.touches.length && e2.touches[0].pageX || e2.changedTouches && e2.changedTouches.length && e2.changedTouches[0].pageX;
            var delta = (start + x2) / util_element.getStyle(elt.parentNode, "width");
            var opacity = Math.max(0, Math.min(1, delta));
            util_element.setStyle(elt, { left: opacity * 100 + "%" });
            elt.parentNode.nextElementSibling.innerHTML = Math.round(opacity * 100);
            layer.setOpacity(opacity);
          }
          util_element.addListener(document, "mouseup touchend touchcancel", stop);
          util_element.addListener(document, "mousemove touchmove", move);
        };
        ol_control_LayerSwitcher.prototype.drawList = function(ul, collection) {
          var self2 = this;
          var layers = collection.getArray();
          var setVisibility = function(e) {
            e.stopPropagation();
            e.preventDefault();
            var l = self2._getLayerForLI(this.parentNode.parentNode);
            self2.switchLayerVisibility(l, collection);
            if (self2.get("selection") && l.getVisible()) {
              self2.selectLayer(l);
            }
            if (self2.onchangeCheck) {
              self2.onchangeCheck(l);
            }
          };
          function onInfo(e) {
            e.stopPropagation();
            e.preventDefault();
            var l = self2._getLayerForLI(this.parentNode.parentNode);
            self2.oninfo(l);
            self2.dispatchEvent({ type: "info", layer: l });
          }
          function zoomExtent(e) {
            e.stopPropagation();
            e.preventDefault();
            var l = self2._getLayerForLI(this.parentNode.parentNode);
            if (self2.onextent)
              self2.onextent(l);
            else
              self2.getMap().getView().fit(l.getExtent(), self2.getMap().getSize());
            self2.dispatchEvent({ type: "extent", layer: l });
          }
          function removeLayer(e) {
            e.stopPropagation();
            e.preventDefault();
            var li = this.parentNode.parentNode.parentNode.parentNode;
            var layer, group = self2._getLayerForLI(li);
            if (group) {
              layer = self2._getLayerForLI(this.parentNode.parentNode);
              group.getLayers().remove(layer);
              if (group.getLayers().getLength() == 0 && !group.get("noSwitcherDelete")) {
                removeLayer.call(li.querySelectorAll(".layerTrash")[0], e);
              }
            } else {
              li = this.parentNode.parentNode;
              self2.getMap().removeLayer(self2._getLayerForLI(li));
            }
          }
          function createLi(layer) {
            if (!this.displayInLayerSwitcher(layer)) {
              this._setLayerForLI(null, layer);
              return;
            }
            var li = util_element.create("LI", {
              className: (layer.getVisible() ? "visible " : " ") + (layer.get("baseLayer") ? "baselayer" : ""),
              parent: ul
            });
            this._setLayerForLI(li, layer);
            if (this._selectedLayer === layer) {
              li.classList.add("ol-layer-select");
            }
            var layer_buttons = util_element.create("DIV", {
              className: "ol-layerswitcher-buttons",
              parent: li
            });
            var d = util_element.create("DIV", {
              className: "li-content",
              parent: li
            });
            util_element.create("INPUT", {
              type: layer.get("baseLayer") ? "radio" : "checkbox",
              className: "ol-visibility",
              checked: layer.getVisible(),
              click: setVisibility,
              parent: d
            });
            var label = util_element.create("LABEL", {
              title: layer.get("title") || layer.get("name"),
              click: setVisibility,
              unselectable: "on",
              style: {
                userSelect: "none"
              },
              parent: d
            });
            label.addEventListener("selectstart", function() {
              return false;
            });
            util_element.create("SPAN", {
              html: layer.get("title") || layer.get("name"),
              click: function(e) {
                if (this.get("selection")) {
                  e.stopPropagation();
                  this.selectLayer(layer);
                }
              }.bind(this),
              parent: label
            });
            if (this.reordering) {
              if (i < layers.length - 1 && (layer.get("allwaysOnTop") || !layers[i + 1].get("allwaysOnTop")) || i > 0 && (!layer.get("allwaysOnTop") || layers[i - 1].get("allwaysOnTop"))) {
                util_element.create("DIV", {
                  className: "layerup ol-noscroll",
                  title: this.tip.up,
                  on: { "mousedown touchstart": function(e) {
                    self2.dragOrdering_(e);
                  } },
                  parent: layer_buttons
                });
              }
            }
            if (layer.getLayers) {
              var nb = 0;
              layer.getLayers().forEach(function(l) {
                if (self2.displayInLayerSwitcher(l))
                  nb++;
              });
              if (nb) {
                util_element.create("DIV", {
                  className: layer.get("openInLayerSwitcher") ? "collapse-layers" : "expend-layers",
                  title: this.tip.plus,
                  click: function() {
                    var l = self2._getLayerForLI(this.parentNode.parentNode);
                    l.set("openInLayerSwitcher", !l.get("openInLayerSwitcher"));
                  },
                  parent: layer_buttons
                });
              }
            }
            if (this.oninfo) {
              util_element.create("DIV", {
                className: "layerInfo",
                title: this.tip.info,
                click: onInfo,
                parent: layer_buttons
              });
            }
            if (this.hastrash && !layer.get("noSwitcherDelete")) {
              util_element.create("DIV", {
                className: "layerTrash",
                title: this.tip.trash,
                click: removeLayer,
                parent: layer_buttons
              });
            }
            if (this.hasextent && layers[i].getExtent()) {
              var ex = layers[i].getExtent();
              if (ex.length == 4 && ex[0] < ex[2] && ex[1] < ex[3]) {
                util_element.create("DIV", {
                  className: "layerExtent",
                  title: this.tip.extent,
                  click: zoomExtent,
                  parent: layer_buttons
                });
              }
            }
            if (this.show_progress && layer instanceof layer_Tile) {
              var p = util_element.create("DIV", {
                className: "layerswitcher-progress",
                parent: d
              });
              this.setprogress_(layer);
              layer.layerswitcher_progress = util_element.create("DIV", { parent: p });
            }
            var opacity = util_element.create("DIV", {
              className: "layerswitcher-opacity",
              click: function(e) {
                if (e.target !== this)
                  return;
                e.stopPropagation();
                e.preventDefault();
                var op = Math.max(0, Math.min(1, e.offsetX / util_element.getStyle(this, "width")));
                self2._getLayerForLI(this.parentNode.parentNode).setOpacity(op);
              },
              parent: d
            });
            util_element.create("DIV", {
              className: "layerswitcher-opacity-cursor ol-noscroll",
              style: { left: layer.getOpacity() * 100 + "%" },
              on: {
                "mousedown touchstart": function(e) {
                  self2.dragOpacity_(e);
                }
              },
              parent: opacity
            });
            util_element.create("DIV", {
              className: "layerswitcher-opacity-label",
              html: Math.round(layer.getOpacity() * 100),
              parent: d
            });
            if (layer.getLayers) {
              li.classList.add("ol-layer-group");
              if (layer.get("openInLayerSwitcher") === true) {
                var ul2 = util_element.create("UL", {
                  parent: li
                });
                this.drawList(ul2, layer.getLayers());
              }
            }
            li.classList.add(this.getLayerClass(layer));
            this.dispatchEvent({ type: "drawlist", layer, li });
          }
          for (var i = layers.length - 1; i >= 0; i--) {
            createLi.call(this, layers[i]);
          }
          this.viewChange();
          if (ul === this.panel_)
            this.overflow();
        };
        ol_control_LayerSwitcher.prototype.getLayerClass = function(layer) {
          if (!layer)
            return "none";
          if (layer.getLayers)
            return "ol-layer-group";
          if (layer instanceof Vector)
            return "ol-layer-vector";
          if (layer instanceof VectorTile)
            return "ol-layer-vectortile";
          if (layer instanceof layer_Tile)
            return "ol-layer-tile";
          if (layer instanceof layer_Image)
            return "ol-layer-image";
          if (layer instanceof layer_Heatmap)
            return "ol-layer-heatmap";
          if (layer.getFeatures)
            return "ol-layer-vectorimage";
          return "unknown";
        };
        ol_control_LayerSwitcher.prototype.selectLayer = function(layer, silent) {
          if (!layer) {
            if (!this.getMap())
              return;
            layer = this.getMap().getLayers().item(this.getMap().getLayers().getLength() - 1);
          }
          this._selectedLayer = layer;
          this.drawPanel();
          if (!silent)
            this.dispatchEvent({ type: "select", layer });
        };
        ol_control_LayerSwitcher.prototype.getSelection = function() {
          return this._selectedLayer;
        };
        ol_control_LayerSwitcher.prototype.setprogress_ = function(layer) {
          if (!layer.layerswitcher_progress) {
            var loaded = 0;
            var loading = 0;
            var draw = function() {
              if (loading === loaded) {
                loading = loaded = 0;
                util_element.setStyle(layer.layerswitcher_progress, { width: 0 });
              } else {
                util_element.setStyle(layer.layerswitcher_progress, { width: (loaded / loading * 100).toFixed(1) + "%" });
              }
            };
            layer.getSource().on("tileloadstart", function() {
              loading++;
              draw();
            });
            layer.getSource().on("tileloadend", function() {
              loaded++;
              draw();
            });
            layer.getSource().on("tileloaderror", function() {
              loaded++;
              draw();
            });
          }
        };
        var LayerSwitcher = ol_control_LayerSwitcher;
        var LayerSwitcherControlvue_type_script_lang_js = {
          name: "ol-layerswitcher-control",
          setup: function setup(props, context) {
            var _useControl = useControl(LayerSwitcher, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            selection: {
              type: Boolean
            },
            displayInLayerSwitcher: {
              type: Function
            },
            show_progress: {
              type: Boolean,
              default: false
            },
            mouseover: {
              type: Boolean,
              default: false
            },
            reordering: {
              type: Boolean,
              default: true
            },
            trash: {
              type: Boolean,
              default: false
            },
            oninfo: {
              type: Function
            },
            extent: {
              type: Boolean
            },
            onextent: {
              type: Function
            },
            drawDelay: {
              type: Number
            },
            collapsed: {
              type: Boolean,
              default: true
            },
            layerGroup: {
              type: Object
            },
            noScroll: {
              type: Boolean,
              default: false
            }
          }
        };
        const LayerSwitcherControl_exports_ = exportHelper_default()(LayerSwitcherControlvue_type_script_lang_js, [["render", LayerSwitcherControlvue_type_template_id_05258056_lang_true_render]]);
        var LayerSwitcherControl = LayerSwitcherControl_exports_;
        var LayerSwitcherImageControlvue_type_template_id_1141daaa_lang_true_hoisted_1 = {
          key: 0
        };
        function LayerSwitcherImageControlvue_type_template_id_1141daaa_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var TileWMS_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var TileWMS_TileWMS = function(_super) {
          TileWMS_extends(TileWMS, _super);
          function TileWMS(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var interpolate = options.imageSmoothing !== void 0 ? options.imageSmoothing : true;
            if (options.interpolate !== void 0) {
              interpolate = options.interpolate;
            }
            var params = options.params || {};
            var transparent = "TRANSPARENT" in params ? params["TRANSPARENT"] : true;
            _this = _super.call(this, {
              attributions: options.attributions,
              attributionsCollapsible: options.attributionsCollapsible,
              cacheSize: options.cacheSize,
              crossOrigin: options.crossOrigin,
              interpolate,
              opaque: !transparent,
              projection: options.projection,
              reprojectionErrorThreshold: options.reprojectionErrorThreshold,
              tileClass: options.tileClass,
              tileGrid: options.tileGrid,
              tileLoadFunction: options.tileLoadFunction,
              url: options.url,
              urls: options.urls,
              wrapX: options.wrapX !== void 0 ? options.wrapX : true,
              transition: options.transition,
              zDirection: options.zDirection
            }) || this;
            _this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
            _this.params_ = params;
            _this.v13_ = true;
            _this.serverType_ = options.serverType;
            _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
            _this.tmpExtent_ = createEmpty();
            _this.updateV13_();
            _this.setKey(_this.getKeyForParams_());
            return _this;
          }
          TileWMS.prototype.getFeatureInfoUrl = function(coordinate, resolution, projection, params) {
            var projectionObj = proj_get(projection);
            var sourceProjectionObj = this.getProjection();
            var tileGrid = this.getTileGrid();
            if (!tileGrid) {
              tileGrid = this.getTileGridForProjection(projectionObj);
            }
            var z = tileGrid.getZForResolution(resolution, this.zDirection);
            var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
            if (tileGrid.getResolutions().length <= tileCoord[0]) {
              return void 0;
            }
            var tileResolution = tileGrid.getResolution(tileCoord[0]);
            var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
            var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
            var gutter = this.gutter_;
            if (gutter !== 0) {
              tileSize = size_buffer(tileSize, gutter, this.tmpSize);
              tileExtent = extent_buffer(tileExtent, tileResolution * gutter, tileExtent);
            }
            if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
              tileResolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);
              tileExtent = transformExtent(tileExtent, projectionObj, sourceProjectionObj);
              coordinate = proj_transform(coordinate, projectionObj, sourceProjectionObj);
            }
            var baseParams = {
              "SERVICE": "WMS",
              "VERSION": DEFAULT_WMS_VERSION,
              "REQUEST": "GetFeatureInfo",
              "FORMAT": "image/png",
              "TRANSPARENT": true,
              "QUERY_LAYERS": this.params_["LAYERS"]
            };
            Object(ol_obj["a"])(baseParams, this.params_, params);
            var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
            var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
            baseParams[this.v13_ ? "I" : "X"] = x;
            baseParams[this.v13_ ? "J" : "Y"] = y;
            return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
          };
          TileWMS.prototype.getLegendUrl = function(resolution, params) {
            if (this.urls[0] === void 0) {
              return void 0;
            }
            var baseParams = {
              "SERVICE": "WMS",
              "VERSION": DEFAULT_WMS_VERSION,
              "REQUEST": "GetLegendGraphic",
              "FORMAT": "image/png"
            };
            if (params === void 0 || params["LAYER"] === void 0) {
              var layers = this.params_.LAYERS;
              var isSingleLayer = !Array.isArray(layers) || layers.length === 1;
              if (!isSingleLayer) {
                return void 0;
              }
              baseParams["LAYER"] = layers;
            }
            if (resolution !== void 0) {
              var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
              var pixelSize = 28e-5;
              baseParams["SCALE"] = resolution * mpu / pixelSize;
            }
            Object(ol_obj["a"])(baseParams, params);
            return appendParams(this.urls[0], baseParams);
          };
          TileWMS.prototype.getGutter = function() {
            return this.gutter_;
          };
          TileWMS.prototype.getParams = function() {
            return this.params_;
          };
          TileWMS.prototype.getRequestUrl_ = function(tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
            var urls = this.urls;
            if (!urls) {
              return void 0;
            }
            params["WIDTH"] = tileSize[0];
            params["HEIGHT"] = tileSize[1];
            params[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
            if (!("STYLES" in this.params_)) {
              params["STYLES"] = "";
            }
            if (pixelRatio != 1) {
              switch (this.serverType_) {
                case WMSServerType.GEOSERVER:
                  var dpi = 90 * pixelRatio + 0.5 | 0;
                  if ("FORMAT_OPTIONS" in params) {
                    params["FORMAT_OPTIONS"] += ";dpi:" + dpi;
                  } else {
                    params["FORMAT_OPTIONS"] = "dpi:" + dpi;
                  }
                  break;
                case WMSServerType.MAPSERVER:
                  params["MAP_RESOLUTION"] = 90 * pixelRatio;
                  break;
                case WMSServerType.CARMENTA_SERVER:
                case WMSServerType.QGIS:
                  params["DPI"] = 90 * pixelRatio;
                  break;
                default:
                  assert2(false, 52);
                  break;
              }
            }
            var axisOrientation = projection.getAxisOrientation();
            var bbox = tileExtent;
            if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
              var tmp = void 0;
              tmp = tileExtent[0];
              bbox[0] = tileExtent[1];
              bbox[1] = tmp;
              tmp = tileExtent[2];
              bbox[2] = tileExtent[3];
              bbox[3] = tmp;
            }
            params["BBOX"] = bbox.join(",");
            var url;
            if (urls.length == 1) {
              url = urls[0];
            } else {
              var index = modulo(hash(tileCoord), urls.length);
              url = urls[index];
            }
            return appendParams(url, params);
          };
          TileWMS.prototype.getTilePixelRatio = function(pixelRatio) {
            return !this.hidpi_ || this.serverType_ === void 0 ? 1 : pixelRatio;
          };
          TileWMS.prototype.getKeyForParams_ = function() {
            var i = 0;
            var res = [];
            for (var key in this.params_) {
              res[i++] = key + "-" + this.params_[key];
            }
            return res.join("/");
          };
          TileWMS.prototype.updateParams = function(params) {
            Object(ol_obj["a"])(this.params_, params);
            this.updateV13_();
            this.setKey(this.getKeyForParams_());
          };
          TileWMS.prototype.updateV13_ = function() {
            var version = this.params_["VERSION"] || DEFAULT_WMS_VERSION;
            this.v13_ = compareVersions(version, "1.3") >= 0;
          };
          TileWMS.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {
            var tileGrid = this.getTileGrid();
            if (!tileGrid) {
              tileGrid = this.getTileGridForProjection(projection);
            }
            if (tileGrid.getResolutions().length <= tileCoord[0]) {
              return void 0;
            }
            if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
              pixelRatio = 1;
            }
            var tileResolution = tileGrid.getResolution(tileCoord[0]);
            var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
            var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
            var gutter = this.gutter_;
            if (gutter !== 0) {
              tileSize = size_buffer(tileSize, gutter, this.tmpSize);
              tileExtent = extent_buffer(tileExtent, tileResolution * gutter, tileExtent);
            }
            if (pixelRatio != 1) {
              tileSize = size_scale(tileSize, pixelRatio, this.tmpSize);
            }
            var baseParams = {
              "SERVICE": "WMS",
              "VERSION": DEFAULT_WMS_VERSION,
              "REQUEST": "GetMap",
              "FORMAT": "image/png",
              "TRANSPARENT": true
            };
            Object(ol_obj["a"])(baseParams, this.params_);
            return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
          };
          return TileWMS;
        }(source_TileImage);
        var source_TileWMS = TileWMS_TileWMS;
        source_Source.prototype.getPreview = function() {
          return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAk6QAAJOkBUCTn+AAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANeSURBVHic7ZpPiE1RHMc/780MBhkik79JSUlIUbOxI+wkI2yRhYSUlJLNpJF/xcpiJBmZGBZsNM1CkmhKITGkGbH0/BuPmXnP4rxbb/TOn3fvOffeec6nfqvb/b7f93fveeec37ng8Xg8Ho/nf6Uu4d+fDswFssCvhHOJhaXAMeApMAQUyyIPPAdOAiuTStAVy4EHjDWsix5gdRLJ2mY34ulWYz6IEeA4kIk9awtkgTOEM/5vdAKT4k0/Ou3YMR/ELcbRm9AKFLBbgCJwNE4TYZkJfMG++SIwDCyLz0o4bI17WdyJz0r1TAZ+oDcxCBwAFgIzEIuhvcBbg3sLwOK4DFXLFvQGniCGSSUagS4DjUPOHESkA3XiOWCORqMR6Nfo9DjI3QqPUSd+ylBnv0Zn0GrWFvmIOvGNhjqrNDp/EAutyFgRKUM2tgO+Gur81FxvAKYZaimxXYBvmuuLDHWWaK4X0RfJCNsF6NdcbzXU2a65PohYFKWOc+jn8PUajbWIXaBKp9NB7lZYh34OzwFbFfd/NtDYYSth27urLGIm0M31AL3APWAAmIooymaDnPIl/Vz4NN1yHrd7gcvxWQnHAuA3bsyPop8hUsE13BSgK04TUViBeFo2zedJ8S6wElexW4D2eNOPTjNi6WvD/DtEr8E6tk6GGoAmxFY2iFHE9NZiQf8gogiB9gTEH23izAZuE77vHyU+ANucO1QwD3hD/MbLowAcdm20EmkwXx4n3NodS9rMB2HabYpEWs0HcRqHp0fNwAvJD+eBTZr7p6BvmQVxUaEzEbiruNfJekH15L8jtrEm7JJolEcOmKXRqQOuKDQuY7HZY8s8iNfzkSLxIuI43FTrkkLnOlBfRW4VsWk+oAX5weknxFAxJQNckGgVgZuIRVoomoGXEmGTMa+iQ6K7M4SW7k24QYgiuDQPYinbhugiF4H3RGtzZYCzyIvQXfpNI1ybLyeLpf5+iTbkRbiP2EcocTHm4+YI8iI8RFHwWjAfsA95Q+YZFU6wasl8wB7kReijtNbIILa0vcg/PRlGfPQwHmlCviDqAzaA+OREtzqr1ejOIDorxlNEjTGUBV4nnUWCvAJxGDlA8q9j3DEArAn2zvXAfOwfl6eVAmJrPpJ0Ih6Px+PxeJLjLwPul3vj5d0eAAAAAElFTkSuQmCC";
        };
        source_Tile.prototype.getPreview = function(lonlat, resolution) {
          if (!lonlat)
            lonlat = [21020, 6355964];
          if (!resolution)
            resolution = 150;
          var coord = this.getTileGrid().getTileCoordForCoordAndResolution(lonlat, resolution);
          var fn = this.getTileUrlFunction();
          return fn.call(this, coord, this.getProjection());
        };
        source_TileWMS.prototype.getPreview = function(lonlat, resolution) {
          if (!lonlat)
            lonlat = [21020, 6355964];
          if (!resolution)
            resolution = 150;
          var fn = this.getTileUrlFunction();
          if (fn) {
            var tileGrid = this.getTileGrid() || this.getTileGridForProjection(this.getProjection());
            var coord = tileGrid.getTileCoordForCoordAndResolution(lonlat, resolution);
            return fn.call(this, coord, 1, this.getProjection());
          }
          var url = this.getGetFeatureInfoUrl ? this.getGetFeatureInfoUrl(lonlat, resolution, this.getProjection() || "EPSG:3857", {}) : this.getFeatureInfoUrl(lonlat, resolution, this.getProjection() || "EPSG:3857", {});
          url = url.replace(/getfeatureinfo/i, "GetMap");
          return url;
        };
        layer_Layer.prototype.getPreview = function(lonlat, resolution, projection) {
          if (this.get("preview"))
            return [this.get("preview")];
          if (!resolution)
            resolution = 150;
          if (resolution < this.getMinResolution() || resolution > this.getMaxResolution()) {
            var rmin = this.getMinResolution(), rmax = this.getMaxResolution();
            if (rmax > 1e5)
              rmax = 156543;
            if (rmin < 0.15)
              rmin = 0.15;
            resolution = rmax;
            while (rmax > rmin) {
              rmin *= 2;
              rmax /= 2;
              resolution = rmin;
            }
          }
          var e = this.getExtent();
          if (!lonlat)
            lonlat = [21020, 6355964];
          if (e && !containsCoordinate(e, lonlat))
            lonlat = [(e[0] + e[2]) / 2, (e[1] + e[3]) / 2];
          if (projection)
            lonlat = proj_transform(lonlat, projection, this.getSource().getProjection());
          if (this.getSource && this.getSource()) {
            return [this.getSource().getPreview(lonlat, resolution)];
          }
          return [];
        };
        Group.prototype.getPreview = function(lonlat, resolution) {
          if (this.get("preview"))
            return [this.get("preview")];
          var t = [];
          if (this.getLayers) {
            var l = this.getLayers().getArray();
            for (var i = 0; i < l.length; i++) {
              t = t.concat(l[i].getPreview(lonlat, resolution));
            }
          }
          return t;
        };
        var ol_control_LayerSwitcherImage = function(options) {
          options = options || {};
          options.switcherClass = "ol-layerswitcher-image";
          if (options.mouseover !== false)
            options.mouseover = true;
          LayerSwitcher.call(this, options);
        };
        util_ext(ol_control_LayerSwitcherImage, LayerSwitcher);
        ol_control_LayerSwitcherImage.prototype.drawList = function(ul, layers) {
          var self2 = this;
          var setVisibility = function(e) {
            e.preventDefault();
            var l = self2._getLayerForLI(this);
            self2.switchLayerVisibility(l, layers);
            if (e.type == "touchstart")
              self2.element.classList.add("ol-collapsed");
          };
          util_element.setStyle(ul, { height: "auto" });
          layers.forEach(function(layer) {
            if (self2.displayInLayerSwitcher(layer)) {
              var preview = layer.getPreview ? layer.getPreview() : ["none"];
              var d = util_element.create("LI", {
                className: "ol-imgcontainer" + (layer.getVisible() ? " ol-visible" : ""),
                on: { "touchstart click": setVisibility },
                parent: ul
              });
              self2._setLayerForLI(d, layer);
              preview.forEach(function(img) {
                util_element.create("IMG", {
                  src: img,
                  parent: d
                });
              });
              util_element.create("p", {
                html: layer.get("title") || layer.get("name"),
                parent: d
              });
              if (self2.testLayerVisibility(layer))
                d.classList.add("ol-layer-hidden");
            }
          });
        };
        ol_control_LayerSwitcherImage.prototype.overflow = function() {
        };
        var LayerSwitcherImage = ol_control_LayerSwitcherImage;
        var LayerSwitcherImageControlvue_type_script_lang_js = {
          name: "ol-layerswitcherimage-control",
          extends: LayerSwitcherControl,
          setup: function setup(props, context) {
            var _useControl = useControl(LayerSwitcherImage, props, context), control = _useControl.control;
            return {
              control
            };
          }
        };
        const LayerSwitcherImageControl_exports_ = exportHelper_default()(LayerSwitcherImageControlvue_type_script_lang_js, [["render", LayerSwitcherImageControlvue_type_template_id_1141daaa_lang_true_render]]);
        var LayerSwitcherImageControl = LayerSwitcherImageControl_exports_;
        var ZoneControlvue_type_template_id_0494975a_lang_true_hoisted_1 = {
          key: 0
        };
        function ZoneControlvue_type_template_id_0494975a_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var ol_control_MapZone = function(options) {
          if (!options)
            options = {};
          var element = document.createElement("div");
          if (options.target) {
            element = util_element.create("DIV", {
              className: options.className || "ol-mapzone"
            });
          } else {
            element = util_element.create("DIV", {
              className: (options.className || "ol-mapzone") + " ol-unselectable ol-control ol-collapsed"
            });
            var bt = util_element.create("BUTTON", {
              type: "button",
              on: {
                "click": function() {
                  element.classList.toggle("ol-collapsed");
                  maps.forEach(function(m) {
                    m.updateSize();
                  });
                }.bind(this)
              },
              parent: element
            });
            util_element.create("I", {
              parent: bt
            });
          }
          Control["default"].call(this, {
            element,
            target: options.target
          });
          this.set("centerOnClick", options.centerOnClick);
          var maps = this._maps = [];
          this._projection = options.projection;
          this._layer = options.layer;
          options.zones.forEach(this.addZone.bind(this));
          setTimeout(function() {
            maps.forEach(function(m) {
              m.updateSize();
            });
          });
        };
        ol_ext_inherits(ol_control_MapZone, Control["default"]);
        ol_control_MapZone.prototype.setCollapsed = function(b) {
          if (b) {
            this.element.classList.remove("ol-collapsed");
            this.getMaps().forEach(function(m) {
              m.updateSize();
            });
          } else {
            this.element.classList.add("ol-collapsed");
          }
        };
        ol_control_MapZone.prototype.getCollapsed = function() {
          return this.element.classList.contains("ol-collapsed");
        };
        ol_control_MapZone.prototype.setVisible = ol_control_MapZone.prototype.setCollapsed;
        ol_control_MapZone.prototype.getMaps = function() {
          return this._maps;
        };
        ol_control_MapZone.prototype.getLength = function() {
          return this._maps.length;
        };
        ol_control_MapZone.prototype.addZone = function(z) {
          var view = new ol_View({ zoom: 6, center: [0, 0], projection: this._projection });
          var extent;
          if (z.map) {
            extent = transformExtent(z.map.getView().calculateExtent(), z.map.getView().getProjection(), view.getProjection());
          } else {
            extent = transformExtent(z.extent, "EPSG:4326", view.getProjection());
          }
          var div = util_element.create("DIV", {
            className: "ol-mapzonezone",
            parent: this.element,
            click: function() {
              var index = -1;
              this._maps.forEach(function(m, i) {
                if (m.get("zone") === z) {
                  index = i;
                }
              });
              this.dispatchEvent({
                type: "select",
                zone: z,
                index,
                coordinate: extent_getCenter(extent),
                extent
              });
              if (this.get("centerOnClick") !== false) {
                this.getMap().getView().fit(extent);
              }
              this.setVisible(false);
            }.bind(this)
          });
          var layer;
          if (z.layer) {
            layer = z.layer;
          } else if (typeof this._layer === "function") {
            layer = this._layer(z);
          } else {
            layer = new this._layer.constructor({
              source: this._layer.getSource()
            });
          }
          var map = new ol_Map({
            target: div,
            view,
            controls: [],
            interactions: [],
            layers: [layer]
          });
          map.set("zone", z);
          this._maps.push(map);
          view.fit(extent);
          util_element.create("P", {
            html: z.title,
            parent: div
          });
        };
        ol_control_MapZone.prototype.removeZone = function(index) {
          var z = this.element.querySelectorAll(".ol-mapzonezone")[index];
          if (z) {
            z.remove();
            this._maps.splice(index, 1);
          }
        };
        ol_control_MapZone.zones = {};
        ol_control_MapZone.zones.DOM = [{
          "title": "Guadeloupe",
          "extent": [-61.898594315312444, 15.75623038647845, -60.957887532935324, 16.575317670979473]
        }, {
          "title": "Guyane",
          "extent": [-54.72525931072715, 2.1603763430019, -51.528236062921344, 5.7984307809552575]
        }, {
          "title": "Martinique",
          "extent": [-61.257556528564756, 14.387506317407514, -60.76934912110432, 14.895067461729951]
        }, {
          "title": "Mayotte",
          "extent": [44.959844536967815, -13.01674138212816, 45.35328866510648, -12.65521942207829]
        }, {
          "title": "La r\xE9union",
          "extent": [55.17059012967656, -21.407680069231688, 55.88195702001797, -20.85560221637526]
        }];
        ol_control_MapZone.zones.TOM = [{
          "title": "Polyn\xE9sie Fran\xE7aise",
          "extent": [206.23664226630862, -22.189040615809787, 221.85920743981987, -10.835039595040698]
        }, {
          "title": "Nouvelle Cal\xE9donie",
          "extent": [163.76420580160925, -22.581641092751838, 167.66984709498706, -19.816411635668445]
        }, {
          "title": "St-Pierre et Miquelon",
          "extent": [-56.453698765748676, 46.74449858188555, -56.0980198121544, 47.14669874229787]
        }, {
          "title": "Wallis et Futuna",
          "extent": [181.7588623143665, -14.7341169873267, 183.95612353301715, -13.134720799175085]
        }, {
          "title": "St-Martin St-Barth\xE9lemy",
          "extent": [-63.1726389501678, 17.806097291313506, -62.7606535945649, 18.13267688837938]
        }];
        ol_control_MapZone.zones.DOMTOM = [{
          title: "M\xE9tropole",
          extent: [-5.318421740712579, 41.16082274292913, 9.73284186155716, 51.21957336557702]
        }].concat(ol_control_MapZone.zones.DOM, ol_control_MapZone.zones.TOM);
        var MapZone = ol_control_MapZone;
        var ZoneControlvue_type_script_lang_js = {
          name: "ol-zone-control",
          setup: function setup(props, context) {
            var _useControl = useControl(MapZone, props, context), control = _useControl.control;
            return {
              control
            };
          },
          props: {
            className: {
              type: String
            },
            zones: {
              type: Array
            },
            layer: {
              type: [Object, Function]
            },
            projection: {
              type: String,
              default: "EPSG:3857"
            },
            centerOnClick: {
              type: Boolean,
              default: true
            }
          }
        };
        const ZoneControl_exports_ = exportHelper_default()(ZoneControlvue_type_script_lang_js, [["render", ZoneControlvue_type_template_id_0494975a_lang_true_render]]);
        var ZoneControl = ZoneControl_exports_;
        function mapControls_install(app) {
          if (mapControls_install.installed) {
            return;
          }
          mapControls_install.installed = true;
          app.component(FullScreenControl.name, FullScreenControl);
          app.component(MousePositionControl.name, MousePositionControl);
          app.component(AttributionControl.name, AttributionControl);
          app.component(OverviewMapControl.name, OverviewMapControl);
          app.component(ScaleLineControl.name, ScaleLineControl);
          app.component(ZoomControl.name, ZoomControl);
          app.component(ZoomSliderControl.name, ZoomSliderControl);
          app.component(ZoomToExtentControl.name, ZoomToExtentControl);
          app.component(RotateControl.name, RotateControl);
          app.component(ContextMenuControl.name, ContextMenuControl);
          app.component(SwipeControl.name, SwipeControl);
          app.component(ControlBar.name, ControlBar);
          app.component(ToggleControl.name, ToggleControl);
          app.component(ButtonControl.name, ButtonControl);
          app.component(mapControls_PrintDialog.name, mapControls_PrintDialog);
          app.component(VideoRecorderControl.name, VideoRecorderControl);
          app.component(LayerSwitcherControl.name, LayerSwitcherControl);
          app.component(LayerSwitcherImageControl.name, LayerSwitcherImageControl);
          app.component(ZoneControl.name, ZoneControl);
        }
        var mapControls = mapControls_install;
        var Pointvue_type_template_id_143d56c0_lang_true_hoisted_1 = {
          key: 0
        };
        function Pointvue_type_template_id_143d56c0_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        function construct_construct(Parent, args, Class) {
          if (_isNativeReflectConstruct()) {
            construct_construct = Reflect.construct;
          } else {
            construct_construct = function _construct(Parent2, args2, Class2) {
              var a = [null];
              a.push.apply(a, args2);
              var Constructor = Function.bind.apply(Parent2, a);
              var instance = new Constructor();
              if (Class2)
                _setPrototypeOf(instance, Class2.prototype);
              return instance;
            };
          }
          return construct_construct.apply(null, arguments);
        }
        var es_object_values = __webpack_require__("07ac");
        function useGeometry(GeometryType, props) {
          var feature = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("feature");
          var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
          var geometry = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
            return construct_construct(GeometryType, _toConsumableArray(Object.values(properties)));
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
            feature.value.setGeometry(geometry.value);
            feature.value.changed();
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(feature, function() {
            feature.value.setGeometry(geometry.value);
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
            feature.value.setGeometry(geometry.value);
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
            feature.value.setGeometry(null);
          });
          return {
            geometry
          };
        }
        var Pointvue_type_script_lang_js = {
          name: "ol-geom-point",
          setup: function setup(props) {
            var _useGeometry = useGeometry(geom_Point, props), geometry = _useGeometry.geometry;
            return {
              geometry
            };
          },
          props: {
            coordinates: {
              type: Array
            },
            opt_layout: {
              type: String,
              default: "XY"
            }
          }
        };
        const Point_exports_ = exportHelper_default()(Pointvue_type_script_lang_js, [["render", Pointvue_type_template_id_143d56c0_lang_true_render]]);
        var geometries_Point = Point_exports_;
        var LineStringvue_type_template_id_f9d04fd0_lang_true_hoisted_1 = {
          key: 0
        };
        function LineStringvue_type_template_id_f9d04fd0_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var LineStringvue_type_script_lang_js = {
          name: "ol-geom-line-string",
          setup: function setup(props) {
            var _useGeometry = useGeometry(geom_LineString, props), geometry = _useGeometry.geometry;
            return {
              geometry
            };
          },
          props: {
            coordinates: {
              type: Array
            },
            opt_layout: {
              type: String,
              default: "XY"
            }
          }
        };
        const LineString_exports_ = exportHelper_default()(LineStringvue_type_script_lang_js, [["render", LineStringvue_type_template_id_f9d04fd0_lang_true_render]]);
        var geometries_LineString = LineString_exports_;
        var Polygonvue_type_template_id_ae08142c_lang_true_hoisted_1 = {
          key: 0
        };
        function Polygonvue_type_template_id_ae08142c_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var Polygonvue_type_script_lang_js = {
          name: "ol-geom-polygon",
          setup: function setup(props) {
            var _useGeometry = useGeometry(geom_Polygon, props), geometry = _useGeometry.geometry;
            return {
              geometry
            };
          },
          props: {
            coordinates: {
              type: Array
            },
            opt_layout: {
              type: String,
              default: "XY"
            }
          }
        };
        const Polygon_exports_ = exportHelper_default()(Polygonvue_type_script_lang_js, [["render", Polygonvue_type_template_id_ae08142c_lang_true_render]]);
        var geometries_Polygon = Polygon_exports_;
        var MultiPointvue_type_template_id_5f21b834_lang_true_hoisted_1 = {
          key: 0
        };
        function MultiPointvue_type_template_id_5f21b834_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var MultiPoint_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var MultiPoint_MultiPoint = function(_super) {
          MultiPoint_extends(MultiPoint, _super);
          function MultiPoint(coordinates, opt_layout) {
            var _this = _super.call(this) || this;
            if (opt_layout && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, coordinates);
            } else {
              _this.setCoordinates(coordinates, opt_layout);
            }
            return _this;
          }
          MultiPoint.prototype.appendPoint = function(point) {
            if (!this.flatCoordinates) {
              this.flatCoordinates = point.getFlatCoordinates().slice();
            } else {
              Object(ol_array["c"])(this.flatCoordinates, point.getFlatCoordinates());
            }
            this.changed();
          };
          MultiPoint.prototype.clone = function() {
            var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
            multiPoint.applyProperties(this);
            return multiPoint;
          };
          MultiPoint.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
            }
            var flatCoordinates = this.flatCoordinates;
            var stride = this.stride;
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var squaredDistance = math_squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
              if (squaredDistance < minSquaredDistance) {
                minSquaredDistance = squaredDistance;
                for (var j = 0; j < stride; ++j) {
                  closestPoint[j] = flatCoordinates[i + j];
                }
                closestPoint.length = stride;
              }
            }
            return minSquaredDistance;
          };
          MultiPoint.prototype.getCoordinates = function() {
            return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
          };
          MultiPoint.prototype.getPoint = function(index) {
            var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
            if (index < 0 || n <= index) {
              return null;
            }
            return new geom_Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
          };
          MultiPoint.prototype.getPoints = function() {
            var flatCoordinates = this.flatCoordinates;
            var layout = this.layout;
            var stride = this.stride;
            var points = [];
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var point = new geom_Point(flatCoordinates.slice(i, i + stride), layout);
              points.push(point);
            }
            return points;
          };
          MultiPoint.prototype.getType = function() {
            return geom_GeometryType.MULTI_POINT;
          };
          MultiPoint.prototype.intersectsExtent = function(extent) {
            var flatCoordinates = this.flatCoordinates;
            var stride = this.stride;
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var x = flatCoordinates[i];
              var y = flatCoordinates[i + 1];
              if (containsXY(extent, x, y)) {
                return true;
              }
            }
            return false;
          };
          MultiPoint.prototype.setCoordinates = function(coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 1);
            if (!this.flatCoordinates) {
              this.flatCoordinates = [];
            }
            this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
            this.changed();
          };
          return MultiPoint;
        }(geom_SimpleGeometry);
        var geom_MultiPoint = MultiPoint_MultiPoint;
        var MultiPointvue_type_script_lang_js = {
          name: "ol-geom-multi-point",
          setup: function setup(props) {
            var _useGeometry = useGeometry(geom_MultiPoint, props), geometry = _useGeometry.geometry;
            return {
              geometry
            };
          },
          props: {
            coordinates: {
              type: Array
            },
            opt_layout: {
              type: String,
              default: "XY"
            }
          }
        };
        const MultiPoint_exports_ = exportHelper_default()(MultiPointvue_type_script_lang_js, [["render", MultiPointvue_type_template_id_5f21b834_lang_true_render]]);
        var geometries_MultiPoint = MultiPoint_exports_;
        var MultiLineStringvue_type_template_id_2c3e6a36_lang_true_hoisted_1 = {
          key: 0
        };
        function MultiLineStringvue_type_template_id_2c3e6a36_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var MultiLineString_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var MultiLineString_MultiLineString = function(_super) {
          MultiLineString_extends(MultiLineString, _super);
          function MultiLineString(coordinates, opt_layout, opt_ends) {
            var _this = _super.call(this) || this;
            _this.ends_ = [];
            _this.maxDelta_ = -1;
            _this.maxDeltaRevision_ = -1;
            if (Array.isArray(coordinates[0])) {
              _this.setCoordinates(coordinates, opt_layout);
            } else if (opt_layout !== void 0 && opt_ends) {
              _this.setFlatCoordinates(opt_layout, coordinates);
              _this.ends_ = opt_ends;
            } else {
              var layout = _this.getLayout();
              var lineStrings = coordinates;
              var flatCoordinates = [];
              var ends = [];
              for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
                var lineString = lineStrings[i];
                if (i === 0) {
                  layout = lineString.getLayout();
                }
                Object(ol_array["c"])(flatCoordinates, lineString.getFlatCoordinates());
                ends.push(flatCoordinates.length);
              }
              _this.setFlatCoordinates(layout, flatCoordinates);
              _this.ends_ = ends;
            }
            return _this;
          }
          MultiLineString.prototype.appendLineString = function(lineString) {
            if (!this.flatCoordinates) {
              this.flatCoordinates = lineString.getFlatCoordinates().slice();
            } else {
              Object(ol_array["c"])(this.flatCoordinates, lineString.getFlatCoordinates().slice());
            }
            this.ends_.push(this.flatCoordinates.length);
            this.changed();
          };
          MultiLineString.prototype.clone = function() {
            var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
            multiLineString.applyProperties(this);
            return multiLineString;
          };
          MultiLineString.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
            }
            if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
            }
            return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
          };
          MultiLineString.prototype.getCoordinateAtM = function(m, opt_extrapolate, opt_interpolate) {
            if (this.layout != GeometryLayout.XYM && this.layout != GeometryLayout.XYZM || this.flatCoordinates.length === 0) {
              return null;
            }
            var extrapolate = opt_extrapolate !== void 0 ? opt_extrapolate : false;
            var interpolate = opt_interpolate !== void 0 ? opt_interpolate : false;
            return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
          };
          MultiLineString.prototype.getCoordinates = function() {
            return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);
          };
          MultiLineString.prototype.getEnds = function() {
            return this.ends_;
          };
          MultiLineString.prototype.getLineString = function(index) {
            if (index < 0 || this.ends_.length <= index) {
              return null;
            }
            return new geom_LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
          };
          MultiLineString.prototype.getLineStrings = function() {
            var flatCoordinates = this.flatCoordinates;
            var ends = this.ends_;
            var layout = this.layout;
            var lineStrings = [];
            var offset = 0;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var lineString = new geom_LineString(flatCoordinates.slice(offset, end), layout);
              lineStrings.push(lineString);
              offset = end;
            }
            return lineStrings;
          };
          MultiLineString.prototype.getFlatMidpoints = function() {
            var midpoints = [];
            var flatCoordinates = this.flatCoordinates;
            var offset = 0;
            var ends = this.ends_;
            var stride = this.stride;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);
              Object(ol_array["c"])(midpoints, midpoint);
              offset = end;
            }
            return midpoints;
          };
          MultiLineString.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
            var simplifiedFlatCoordinates = [];
            var simplifiedEnds = [];
            simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
            return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
          };
          MultiLineString.prototype.getType = function() {
            return geom_GeometryType.MULTI_LINE_STRING;
          };
          MultiLineString.prototype.intersectsExtent = function(extent) {
            return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);
          };
          MultiLineString.prototype.setCoordinates = function(coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 2);
            if (!this.flatCoordinates) {
              this.flatCoordinates = [];
            }
            var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
            this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
            this.changed();
          };
          return MultiLineString;
        }(geom_SimpleGeometry);
        var geom_MultiLineString = MultiLineString_MultiLineString;
        var MultiLineStringvue_type_script_lang_js = {
          name: "ol-geom-multi-line-string",
          setup: function setup(props) {
            var _useGeometry = useGeometry(geom_MultiLineString, props), geometry = _useGeometry.geometry;
            return {
              geometry
            };
          },
          props: {
            coordinates: {
              type: Array
            },
            opt_layout: {
              type: String,
              default: "XY"
            }
          }
        };
        const MultiLineString_exports_ = exportHelper_default()(MultiLineStringvue_type_script_lang_js, [["render", MultiLineStringvue_type_template_id_2c3e6a36_lang_true_render]]);
        var geometries_MultiLineString = MultiLineString_exports_;
        var MultiPolygonvue_type_template_id_abbb2b88_lang_true_hoisted_1 = {
          key: 0
        };
        function MultiPolygonvue_type_template_id_abbb2b88_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        function center_linearRingss(flatCoordinates, offset, endss, stride) {
          var flatCenters = [];
          var extent = createEmpty();
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
            flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
            offset = ends[ends.length - 1];
          }
          return flatCenters;
        }
        var MultiPolygon_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var MultiPolygon_MultiPolygon = function(_super) {
          MultiPolygon_extends(MultiPolygon, _super);
          function MultiPolygon(coordinates, opt_layout, opt_endss) {
            var _this = _super.call(this) || this;
            _this.endss_ = [];
            _this.flatInteriorPointsRevision_ = -1;
            _this.flatInteriorPoints_ = null;
            _this.maxDelta_ = -1;
            _this.maxDeltaRevision_ = -1;
            _this.orientedRevision_ = -1;
            _this.orientedFlatCoordinates_ = null;
            if (!opt_endss && !Array.isArray(coordinates[0])) {
              var layout = _this.getLayout();
              var polygons = coordinates;
              var flatCoordinates = [];
              var endss = [];
              for (var i = 0, ii = polygons.length; i < ii; ++i) {
                var polygon = polygons[i];
                if (i === 0) {
                  layout = polygon.getLayout();
                }
                var offset = flatCoordinates.length;
                var ends = polygon.getEnds();
                for (var j = 0, jj = ends.length; j < jj; ++j) {
                  ends[j] += offset;
                }
                Object(ol_array["c"])(flatCoordinates, polygon.getFlatCoordinates());
                endss.push(ends);
              }
              opt_layout = layout;
              coordinates = flatCoordinates;
              opt_endss = endss;
            }
            if (opt_layout !== void 0 && opt_endss) {
              _this.setFlatCoordinates(opt_layout, coordinates);
              _this.endss_ = opt_endss;
            } else {
              _this.setCoordinates(coordinates, opt_layout);
            }
            return _this;
          }
          MultiPolygon.prototype.appendPolygon = function(polygon) {
            var ends;
            if (!this.flatCoordinates) {
              this.flatCoordinates = polygon.getFlatCoordinates().slice();
              ends = polygon.getEnds().slice();
              this.endss_.push();
            } else {
              var offset = this.flatCoordinates.length;
              Object(ol_array["c"])(this.flatCoordinates, polygon.getFlatCoordinates());
              ends = polygon.getEnds().slice();
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                ends[i] += offset;
              }
            }
            this.endss_.push(ends);
            this.changed();
          };
          MultiPolygon.prototype.clone = function() {
            var len = this.endss_.length;
            var newEndss = new Array(len);
            for (var i = 0; i < len; ++i) {
              newEndss[i] = this.endss_[i].slice();
            }
            var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
            multiPolygon.applyProperties(this);
            return multiPolygon;
          };
          MultiPolygon.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
            }
            if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
            }
            return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
          };
          MultiPolygon.prototype.containsXY = function(x, y) {
            return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
          };
          MultiPolygon.prototype.getArea = function() {
            return linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
          };
          MultiPolygon.prototype.getCoordinates = function(opt_right) {
            var flatCoordinates;
            if (opt_right !== void 0) {
              flatCoordinates = this.getOrientedFlatCoordinates().slice();
              orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);
            } else {
              flatCoordinates = this.flatCoordinates;
            }
            return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);
          };
          MultiPolygon.prototype.getEndss = function() {
            return this.endss_;
          };
          MultiPolygon.prototype.getFlatInteriorPoints = function() {
            if (this.flatInteriorPointsRevision_ != this.getRevision()) {
              var flatCenters = center_linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
              this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
              this.flatInteriorPointsRevision_ = this.getRevision();
            }
            return this.flatInteriorPoints_;
          };
          MultiPolygon.prototype.getInteriorPoints = function() {
            return new geom_MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);
          };
          MultiPolygon.prototype.getOrientedFlatCoordinates = function() {
            if (this.orientedRevision_ != this.getRevision()) {
              var flatCoordinates = this.flatCoordinates;
              if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
                this.orientedFlatCoordinates_ = flatCoordinates;
              } else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
              }
              this.orientedRevision_ = this.getRevision();
            }
            return this.orientedFlatCoordinates_;
          };
          MultiPolygon.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
            var simplifiedFlatCoordinates = [];
            var simplifiedEndss = [];
            simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
            return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);
          };
          MultiPolygon.prototype.getPolygon = function(index) {
            if (index < 0 || this.endss_.length <= index) {
              return null;
            }
            var offset;
            if (index === 0) {
              offset = 0;
            } else {
              var prevEnds = this.endss_[index - 1];
              offset = prevEnds[prevEnds.length - 1];
            }
            var ends = this.endss_[index].slice();
            var end = ends[ends.length - 1];
            if (offset !== 0) {
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                ends[i] -= offset;
              }
            }
            return new geom_Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);
          };
          MultiPolygon.prototype.getPolygons = function() {
            var layout = this.layout;
            var flatCoordinates = this.flatCoordinates;
            var endss = this.endss_;
            var polygons = [];
            var offset = 0;
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i].slice();
              var end = ends[ends.length - 1];
              if (offset !== 0) {
                for (var j = 0, jj = ends.length; j < jj; ++j) {
                  ends[j] -= offset;
                }
              }
              var polygon = new geom_Polygon(flatCoordinates.slice(offset, end), layout, ends);
              polygons.push(polygon);
              offset = end;
            }
            return polygons;
          };
          MultiPolygon.prototype.getType = function() {
            return geom_GeometryType.MULTI_POLYGON;
          };
          MultiPolygon.prototype.intersectsExtent = function(extent) {
            return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
          };
          MultiPolygon.prototype.setCoordinates = function(coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 3);
            if (!this.flatCoordinates) {
              this.flatCoordinates = [];
            }
            var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
            if (endss.length === 0) {
              this.flatCoordinates.length = 0;
            } else {
              var lastEnds = endss[endss.length - 1];
              this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
            }
            this.changed();
          };
          return MultiPolygon;
        }(geom_SimpleGeometry);
        var geom_MultiPolygon = MultiPolygon_MultiPolygon;
        var MultiPolygonvue_type_script_lang_js = {
          name: "ol-geom-multi-polygon",
          setup: function setup(props) {
            var _useGeometry = useGeometry(geom_MultiPolygon, props), geometry = _useGeometry.geometry;
            return {
              geometry
            };
          },
          props: {
            coordinates: {
              type: Array
            },
            opt_layout: {
              type: String,
              default: "XY"
            }
          }
        };
        const MultiPolygon_exports_ = exportHelper_default()(MultiPolygonvue_type_script_lang_js, [["render", MultiPolygonvue_type_template_id_abbb2b88_lang_true_render]]);
        var geometries_MultiPolygon = MultiPolygon_exports_;
        function geometries_install(app) {
          if (geometries_install.installed) {
            return;
          }
          geometries_install.installed = true;
          app.component(geometries_Point.name, geometries_Point);
          app.component(geometries_LineString.name, geometries_LineString);
          app.component(geometries_Polygon.name, geometries_Polygon);
          app.component(geometries_MultiPoint.name, geometries_MultiPoint);
          app.component(geometries_MultiLineString.name, geometries_MultiLineString);
          app.component(geometries_MultiPolygon.name, geometries_MultiPolygon);
        }
        var components_geometries = geometries_install;
        function Stylevue_type_template_id_0040721c_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var geom_Circle_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Circle_Circle = function(_super) {
          geom_Circle_extends(Circle, _super);
          function Circle(center, opt_radius, opt_layout) {
            var _this = _super.call(this) || this;
            if (opt_layout !== void 0 && opt_radius === void 0) {
              _this.setFlatCoordinates(opt_layout, center);
            } else {
              var radius = opt_radius ? opt_radius : 0;
              _this.setCenterAndRadius(center, radius, opt_layout);
            }
            return _this;
          }
          Circle.prototype.clone = function() {
            var circle = new Circle(this.flatCoordinates.slice(), void 0, this.layout);
            circle.applyProperties(this);
            return circle;
          };
          Circle.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            var flatCoordinates = this.flatCoordinates;
            var dx = x - flatCoordinates[0];
            var dy = y - flatCoordinates[1];
            var squaredDistance = dx * dx + dy * dy;
            if (squaredDistance < minSquaredDistance) {
              if (squaredDistance === 0) {
                for (var i = 0; i < this.stride; ++i) {
                  closestPoint[i] = flatCoordinates[i];
                }
              } else {
                var delta = this.getRadius() / Math.sqrt(squaredDistance);
                closestPoint[0] = flatCoordinates[0] + delta * dx;
                closestPoint[1] = flatCoordinates[1] + delta * dy;
                for (var i = 2; i < this.stride; ++i) {
                  closestPoint[i] = flatCoordinates[i];
                }
              }
              closestPoint.length = this.stride;
              return squaredDistance;
            } else {
              return minSquaredDistance;
            }
          };
          Circle.prototype.containsXY = function(x, y) {
            var flatCoordinates = this.flatCoordinates;
            var dx = x - flatCoordinates[0];
            var dy = y - flatCoordinates[1];
            return dx * dx + dy * dy <= this.getRadiusSquared_();
          };
          Circle.prototype.getCenter = function() {
            return this.flatCoordinates.slice(0, this.stride);
          };
          Circle.prototype.computeExtent = function(extent) {
            var flatCoordinates = this.flatCoordinates;
            var radius = flatCoordinates[this.stride] - flatCoordinates[0];
            return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
          };
          Circle.prototype.getRadius = function() {
            return Math.sqrt(this.getRadiusSquared_());
          };
          Circle.prototype.getRadiusSquared_ = function() {
            var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
            var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
            return dx * dx + dy * dy;
          };
          Circle.prototype.getType = function() {
            return geom_GeometryType.CIRCLE;
          };
          Circle.prototype.intersectsExtent = function(extent) {
            var circleExtent = this.getExtent();
            if (extent_intersects(extent, circleExtent)) {
              var center = this.getCenter();
              if (extent[0] <= center[0] && extent[2] >= center[0]) {
                return true;
              }
              if (extent[1] <= center[1] && extent[3] >= center[1]) {
                return true;
              }
              return forEachCorner(extent, this.intersectsCoordinate.bind(this));
            }
            return false;
          };
          Circle.prototype.setCenter = function(center) {
            var stride = this.stride;
            var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
            var flatCoordinates = center.slice();
            flatCoordinates[stride] = flatCoordinates[0] + radius;
            for (var i = 1; i < stride; ++i) {
              flatCoordinates[stride + i] = center[i];
            }
            this.setFlatCoordinates(this.layout, flatCoordinates);
            this.changed();
          };
          Circle.prototype.setCenterAndRadius = function(center, radius, opt_layout) {
            this.setLayout(opt_layout, center, 0);
            if (!this.flatCoordinates) {
              this.flatCoordinates = [];
            }
            var flatCoordinates = this.flatCoordinates;
            var offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);
            flatCoordinates[offset++] = flatCoordinates[0] + radius;
            for (var i = 1, ii = this.stride; i < ii; ++i) {
              flatCoordinates[offset++] = flatCoordinates[i];
            }
            flatCoordinates.length = offset;
            this.changed();
          };
          Circle.prototype.getCoordinates = function() {
            return null;
          };
          Circle.prototype.setCoordinates = function(coordinates, opt_layout) {
          };
          Circle.prototype.setRadius = function(radius) {
            this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
            this.changed();
          };
          Circle.prototype.rotate = function(angle, anchor) {
            var center = this.getCenter();
            var stride = this.getStride();
            this.setCenter(transform_rotate(center, 0, center.length, stride, angle, anchor, center));
            this.changed();
          };
          Circle.prototype.translate = function(deltaX, deltaY) {
            var center = this.getCenter();
            var stride = this.getStride();
            this.setCenter(flat_transform_translate(center, 0, center.length, stride, deltaX, deltaY, center));
            this.changed();
          };
          return Circle;
        }(geom_SimpleGeometry);
        Circle_Circle.prototype.transform;
        var geom_Circle = Circle_Circle;
        var Draw_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Draw_Mode = {
          POINT: "Point",
          LINE_STRING: "LineString",
          POLYGON: "Polygon",
          CIRCLE: "Circle"
        };
        var DrawEventType = {
          DRAWSTART: "drawstart",
          DRAWEND: "drawend",
          DRAWABORT: "drawabort"
        };
        var DrawEvent = function(_super) {
          Draw_extends(DrawEvent2, _super);
          function DrawEvent2(type, feature) {
            var _this = _super.call(this, type) || this;
            _this.feature = feature;
            return _this;
          }
          return DrawEvent2;
        }(events_Event["a"]);
        var Draw_Draw = function(_super) {
          Draw_extends(Draw, _super);
          function Draw(options) {
            var _this = this;
            var pointerOptions = options;
            if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = functions["a"];
            }
            _this = _super.call(this, pointerOptions) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.shouldHandle_ = false;
            _this.downPx_ = null;
            _this.downTimeout_;
            _this.lastDragTime_;
            _this.pointerType_;
            _this.freehand_ = false;
            _this.source_ = options.source ? options.source : null;
            _this.features_ = options.features ? options.features : null;
            _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
            _this.type_ = options.type;
            _this.mode_ = getMode(_this.type_);
            _this.stopClick_ = !!options.stopClick;
            _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Draw_Mode.POLYGON ? 3 : 2;
            _this.maxPoints_ = _this.mode_ === Draw_Mode.CIRCLE ? 2 : options.maxPoints ? options.maxPoints : Infinity;
            _this.finishCondition_ = options.finishCondition ? options.finishCondition : functions["b"];
            var geometryFunction = options.geometryFunction;
            if (!geometryFunction) {
              var mode_1 = _this.mode_;
              if (mode_1 === Draw_Mode.CIRCLE) {
                geometryFunction = function(coordinates, geometry, projection) {
                  var circle = geometry ? geometry : new geom_Circle([NaN, NaN]);
                  var center = fromUserCoordinate(coordinates[0], projection);
                  var squaredLength = coordinate_squaredDistance(center, fromUserCoordinate(coordinates[coordinates.length - 1], projection));
                  circle.setCenterAndRadius(center, Math.sqrt(squaredLength));
                  var userProjection = getUserProjection();
                  if (userProjection) {
                    circle.transform(projection, userProjection);
                  }
                  return circle;
                };
              } else {
                var Constructor_1;
                if (mode_1 === Draw_Mode.POINT) {
                  Constructor_1 = geom_Point;
                } else if (mode_1 === Draw_Mode.LINE_STRING) {
                  Constructor_1 = geom_LineString;
                } else if (mode_1 === Draw_Mode.POLYGON) {
                  Constructor_1 = geom_Polygon;
                }
                geometryFunction = function(coordinates, geometry, projection) {
                  if (geometry) {
                    if (mode_1 === Draw_Mode.POLYGON) {
                      if (coordinates[0].length) {
                        geometry.setCoordinates([
                          coordinates[0].concat([coordinates[0][0]])
                        ]);
                      } else {
                        geometry.setCoordinates([]);
                      }
                    } else {
                      geometry.setCoordinates(coordinates);
                    }
                  } else {
                    geometry = new Constructor_1(coordinates);
                  }
                  return geometry;
                };
              }
            }
            _this.geometryFunction_ = geometryFunction;
            _this.dragVertexDelay_ = options.dragVertexDelay !== void 0 ? options.dragVertexDelay : 500;
            _this.finishCoordinate_ = null;
            _this.sketchFeature_ = null;
            _this.sketchPoint_ = null;
            _this.sketchCoords_ = null;
            _this.sketchLine_ = null;
            _this.sketchLineCoords_ = null;
            _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
            _this.overlay_ = new Vector({
              source: new source_Vector({
                useSpatialIndex: false,
                wrapX: options.wrapX ? options.wrapX : false
              }),
              style: options.style ? options.style : getDefaultStyleFunction(),
              updateWhileInteracting: true
            });
            _this.geometryName_ = options.geometryName;
            _this.condition_ = options.condition ? options.condition : noModifierKeys;
            _this.freehandCondition_;
            if (options.freehand) {
              _this.freehandCondition_ = always;
            } else {
              _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : shiftKeyOnly;
            }
            _this.addChangeListener(interaction_Property.ACTIVE, _this.updateState_);
            return _this;
          }
          Draw.prototype.setMap = function(map) {
            _super.prototype.setMap.call(this, map);
            this.updateState_();
          };
          Draw.prototype.getOverlay = function() {
            return this.overlay_;
          };
          Draw.prototype.handleEvent = function(event) {
            if (event.originalEvent.type === EventType["a"].CONTEXTMENU) {
              event.originalEvent.preventDefault();
            }
            this.freehand_ = this.mode_ !== Draw_Mode.POINT && this.freehandCondition_(event);
            var move = event.type === MapBrowserEventType.POINTERMOVE;
            var pass = true;
            if (!this.freehand_ && this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {
              var now = Date.now();
              if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
                this.downPx_ = event.pixel;
                this.shouldHandle_ = !this.freehand_;
                move = true;
              } else {
                this.lastDragTime_ = void 0;
              }
              if (this.shouldHandle_ && this.downTimeout_ !== void 0) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = void 0;
              }
            }
            if (this.freehand_ && event.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {
              this.addToDrawing_(event.coordinate);
              pass = false;
            } else if (this.freehand_ && event.type === MapBrowserEventType.POINTERDOWN) {
              pass = false;
            } else if (move && this.getPointerCount() < 2) {
              pass = event.type === MapBrowserEventType.POINTERMOVE;
              if (pass && this.freehand_) {
                this.handlePointerMove_(event);
                if (this.shouldHandle_) {
                  event.originalEvent.preventDefault();
                }
              } else if (event.originalEvent.pointerType === "mouse" || event.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === void 0) {
                this.handlePointerMove_(event);
              }
            } else if (event.type === MapBrowserEventType.DBLCLICK) {
              pass = false;
            }
            return _super.prototype.handleEvent.call(this, event) && pass;
          };
          Draw.prototype.handleDownEvent = function(event) {
            this.shouldHandle_ = !this.freehand_;
            if (this.freehand_) {
              this.downPx_ = event.pixel;
              if (!this.finishCoordinate_) {
                this.startDrawing_(event.coordinate);
              }
              return true;
            } else if (this.condition_(event)) {
              this.lastDragTime_ = Date.now();
              this.downTimeout_ = setTimeout(function() {
                this.handlePointerMove_(new ol_MapBrowserEvent(MapBrowserEventType.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
              }.bind(this), this.dragVertexDelay_);
              this.downPx_ = event.pixel;
              return true;
            } else {
              this.lastDragTime_ = void 0;
              return false;
            }
          };
          Draw.prototype.handleUpEvent = function(event) {
            var pass = true;
            if (this.getPointerCount() === 0) {
              if (this.downTimeout_) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = void 0;
              }
              this.handlePointerMove_(event);
              if (this.shouldHandle_) {
                var startingToDraw = !this.finishCoordinate_;
                if (startingToDraw) {
                  this.startDrawing_(event.coordinate);
                }
                if (!startingToDraw && this.freehand_) {
                  this.finishDrawing();
                } else if (!this.freehand_ && (!startingToDraw || this.mode_ === Draw_Mode.POINT)) {
                  if (this.atFinish_(event.pixel)) {
                    if (this.finishCondition_(event)) {
                      this.finishDrawing();
                    }
                  } else {
                    this.addToDrawing_(event.coordinate);
                  }
                }
                pass = false;
              } else if (this.freehand_) {
                this.abortDrawing();
              }
            }
            if (!pass && this.stopClick_) {
              event.preventDefault();
            }
            return pass;
          };
          Draw.prototype.handlePointerMove_ = function(event) {
            this.pointerType_ = event.originalEvent.pointerType;
            if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
              var downPx = this.downPx_;
              var clickPx = event.pixel;
              var dx = downPx[0] - clickPx[0];
              var dy = downPx[1] - clickPx[1];
              var squaredDistance = dx * dx + dy * dy;
              this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;
              if (!this.shouldHandle_) {
                return;
              }
            }
            if (this.finishCoordinate_) {
              this.modifyDrawing_(event.coordinate);
            } else {
              this.createOrUpdateSketchPoint_(event.coordinate.slice());
            }
          };
          Draw.prototype.atFinish_ = function(pixel) {
            var at = false;
            if (this.sketchFeature_) {
              var potentiallyDone = false;
              var potentiallyFinishCoordinates = [this.finishCoordinate_];
              var mode = this.mode_;
              if (mode === Draw_Mode.POINT) {
                at = true;
              } else if (mode === Draw_Mode.CIRCLE) {
                at = this.sketchCoords_.length === 2;
              } else if (mode === Draw_Mode.LINE_STRING) {
                potentiallyDone = this.sketchCoords_.length > this.minPoints_;
              } else if (mode === Draw_Mode.POLYGON) {
                var sketchCoords = this.sketchCoords_;
                potentiallyDone = sketchCoords[0].length > this.minPoints_;
                potentiallyFinishCoordinates = [
                  sketchCoords[0][0],
                  sketchCoords[0][sketchCoords[0].length - 2]
                ];
              }
              if (potentiallyDone) {
                var map = this.getMap();
                for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
                  var finishCoordinate = potentiallyFinishCoordinates[i];
                  var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
                  var dx = pixel[0] - finishPixel[0];
                  var dy = pixel[1] - finishPixel[1];
                  var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
                  at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
                  if (at) {
                    this.finishCoordinate_ = finishCoordinate;
                    break;
                  }
                }
              }
            }
            return at;
          };
          Draw.prototype.createOrUpdateSketchPoint_ = function(coordinates) {
            if (!this.sketchPoint_) {
              this.sketchPoint_ = new ol_Feature(new geom_Point(coordinates));
              this.updateSketchFeatures_();
            } else {
              var sketchPointGeom = this.sketchPoint_.getGeometry();
              sketchPointGeom.setCoordinates(coordinates);
            }
          };
          Draw.prototype.createOrUpdateCustomSketchLine_ = function(geometry) {
            if (!this.sketchLine_) {
              this.sketchLine_ = new ol_Feature();
            }
            var ring = geometry.getLinearRing(0);
            var sketchLineGeom = this.sketchLine_.getGeometry();
            if (!sketchLineGeom) {
              sketchLineGeom = new geom_LineString(ring.getFlatCoordinates(), ring.getLayout());
              this.sketchLine_.setGeometry(sketchLineGeom);
            } else {
              sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
              sketchLineGeom.changed();
            }
          };
          Draw.prototype.startDrawing_ = function(start) {
            var projection = this.getMap().getView().getProjection();
            this.finishCoordinate_ = start;
            if (this.mode_ === Draw_Mode.POINT) {
              this.sketchCoords_ = start.slice();
            } else if (this.mode_ === Draw_Mode.POLYGON) {
              this.sketchCoords_ = [[start.slice(), start.slice()]];
              this.sketchLineCoords_ = this.sketchCoords_[0];
            } else {
              this.sketchCoords_ = [start.slice(), start.slice()];
            }
            if (this.sketchLineCoords_) {
              this.sketchLine_ = new ol_Feature(new geom_LineString(this.sketchLineCoords_));
            }
            var geometry = this.geometryFunction_(this.sketchCoords_, void 0, projection);
            this.sketchFeature_ = new ol_Feature();
            if (this.geometryName_) {
              this.sketchFeature_.setGeometryName(this.geometryName_);
            }
            this.sketchFeature_.setGeometry(geometry);
            this.updateSketchFeatures_();
            this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
          };
          Draw.prototype.modifyDrawing_ = function(coordinate) {
            var map = this.getMap();
            var geometry = this.sketchFeature_.getGeometry();
            var projection = map.getView().getProjection();
            var coordinates, last2;
            if (this.mode_ === Draw_Mode.POINT) {
              last2 = this.sketchCoords_;
            } else if (this.mode_ === Draw_Mode.POLYGON) {
              coordinates = this.sketchCoords_[0];
              last2 = coordinates[coordinates.length - 1];
              if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
                coordinate = this.finishCoordinate_.slice();
              }
            } else {
              coordinates = this.sketchCoords_;
              last2 = coordinates[coordinates.length - 1];
            }
            last2[0] = coordinate[0];
            last2[1] = coordinate[1];
            this.geometryFunction_(this.sketchCoords_, geometry, projection);
            if (this.sketchPoint_) {
              var sketchPointGeom = this.sketchPoint_.getGeometry();
              sketchPointGeom.setCoordinates(coordinate);
            }
            if (geometry.getType() === geom_GeometryType.POLYGON && this.mode_ !== Draw_Mode.POLYGON) {
              this.createOrUpdateCustomSketchLine_(geometry);
            } else if (this.sketchLineCoords_) {
              var sketchLineGeom = this.sketchLine_.getGeometry();
              sketchLineGeom.setCoordinates(this.sketchLineCoords_);
            }
            this.updateSketchFeatures_();
          };
          Draw.prototype.addToDrawing_ = function(coordinate) {
            var geometry = this.sketchFeature_.getGeometry();
            var projection = this.getMap().getView().getProjection();
            var done;
            var coordinates;
            var mode = this.mode_;
            if (mode === Draw_Mode.LINE_STRING || mode === Draw_Mode.CIRCLE) {
              this.finishCoordinate_ = coordinate.slice();
              coordinates = this.sketchCoords_;
              if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) {
                  coordinates.pop();
                } else {
                  done = true;
                }
              }
              coordinates.push(coordinate.slice());
              this.geometryFunction_(coordinates, geometry, projection);
            } else if (mode === Draw_Mode.POLYGON) {
              coordinates = this.sketchCoords_[0];
              if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) {
                  coordinates.pop();
                } else {
                  done = true;
                }
              }
              coordinates.push(coordinate.slice());
              if (done) {
                this.finishCoordinate_ = coordinates[0];
              }
              this.geometryFunction_(this.sketchCoords_, geometry, projection);
            }
            this.createOrUpdateSketchPoint_(coordinate.slice());
            this.updateSketchFeatures_();
            if (done) {
              this.finishDrawing();
            }
          };
          Draw.prototype.removeLastPoint = function() {
            if (!this.sketchFeature_) {
              return;
            }
            var geometry = this.sketchFeature_.getGeometry();
            var projection = this.getMap().getView().getProjection();
            var coordinates;
            var mode = this.mode_;
            if (mode === Draw_Mode.LINE_STRING || mode === Draw_Mode.CIRCLE) {
              coordinates = this.sketchCoords_;
              coordinates.splice(-2, 1);
              if (coordinates.length >= 2) {
                this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
                var finishCoordinate = this.finishCoordinate_.slice();
                coordinates[coordinates.length - 1] = finishCoordinate;
                this.createOrUpdateSketchPoint_(finishCoordinate);
              }
              this.geometryFunction_(coordinates, geometry, projection);
              if (geometry.getType() === geom_GeometryType.POLYGON && this.sketchLine_) {
                this.createOrUpdateCustomSketchLine_(geometry);
              }
            } else if (mode === Draw_Mode.POLYGON) {
              coordinates = this.sketchCoords_[0];
              coordinates.splice(-2, 1);
              var sketchLineGeom = this.sketchLine_.getGeometry();
              if (coordinates.length >= 2) {
                var finishCoordinate = coordinates[coordinates.length - 2].slice();
                coordinates[coordinates.length - 1] = finishCoordinate;
                this.createOrUpdateSketchPoint_(finishCoordinate);
              }
              sketchLineGeom.setCoordinates(coordinates);
              this.geometryFunction_(this.sketchCoords_, geometry, projection);
            }
            if (coordinates.length === 1) {
              this.abortDrawing();
            }
            this.updateSketchFeatures_();
          };
          Draw.prototype.finishDrawing = function() {
            var sketchFeature = this.abortDrawing_();
            if (!sketchFeature) {
              return;
            }
            var coordinates = this.sketchCoords_;
            var geometry = sketchFeature.getGeometry();
            var projection = this.getMap().getView().getProjection();
            if (this.mode_ === Draw_Mode.LINE_STRING) {
              coordinates.pop();
              this.geometryFunction_(coordinates, geometry, projection);
            } else if (this.mode_ === Draw_Mode.POLYGON) {
              coordinates[0].pop();
              this.geometryFunction_(coordinates, geometry, projection);
              coordinates = geometry.getCoordinates();
            }
            if (this.type_ === geom_GeometryType.MULTI_POINT) {
              sketchFeature.setGeometry(new geom_MultiPoint([coordinates]));
            } else if (this.type_ === geom_GeometryType.MULTI_LINE_STRING) {
              sketchFeature.setGeometry(new geom_MultiLineString([coordinates]));
            } else if (this.type_ === geom_GeometryType.MULTI_POLYGON) {
              sketchFeature.setGeometry(new geom_MultiPolygon([coordinates]));
            }
            this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));
            if (this.features_) {
              this.features_.push(sketchFeature);
            }
            if (this.source_) {
              this.source_.addFeature(sketchFeature);
            }
          };
          Draw.prototype.abortDrawing_ = function() {
            this.finishCoordinate_ = null;
            var sketchFeature = this.sketchFeature_;
            this.sketchFeature_ = null;
            this.sketchPoint_ = null;
            this.sketchLine_ = null;
            this.overlay_.getSource().clear(true);
            return sketchFeature;
          };
          Draw.prototype.abortDrawing = function() {
            var sketchFeature = this.abortDrawing_();
            if (sketchFeature) {
              this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
            }
          };
          Draw.prototype.appendCoordinates = function(coordinates) {
            var mode = this.mode_;
            var newDrawing = !this.sketchFeature_;
            if (newDrawing) {
              this.startDrawing_(coordinates[0]);
            }
            var sketchCoords;
            if (mode === Draw_Mode.LINE_STRING || mode === Draw_Mode.CIRCLE) {
              sketchCoords = this.sketchCoords_;
            } else if (mode === Draw_Mode.POLYGON) {
              sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : [];
            } else {
              return;
            }
            if (newDrawing) {
              sketchCoords.shift();
            }
            sketchCoords.pop();
            for (var i = 0; i < coordinates.length; i++) {
              this.addToDrawing_(coordinates[i]);
            }
            var ending = coordinates[coordinates.length - 1];
            this.addToDrawing_(ending);
            this.modifyDrawing_(ending);
          };
          Draw.prototype.extend = function(feature) {
            var geometry = feature.getGeometry();
            var lineString = geometry;
            this.sketchFeature_ = feature;
            this.sketchCoords_ = lineString.getCoordinates();
            var last2 = this.sketchCoords_[this.sketchCoords_.length - 1];
            this.finishCoordinate_ = last2.slice();
            this.sketchCoords_.push(last2.slice());
            this.sketchPoint_ = new ol_Feature(new geom_Point(last2));
            this.updateSketchFeatures_();
            this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
          };
          Draw.prototype.updateSketchFeatures_ = function() {
            var sketchFeatures = [];
            if (this.sketchFeature_) {
              sketchFeatures.push(this.sketchFeature_);
            }
            if (this.sketchLine_) {
              sketchFeatures.push(this.sketchLine_);
            }
            if (this.sketchPoint_) {
              sketchFeatures.push(this.sketchPoint_);
            }
            var overlaySource = this.overlay_.getSource();
            overlaySource.clear(true);
            overlaySource.addFeatures(sketchFeatures);
          };
          Draw.prototype.updateState_ = function() {
            var map = this.getMap();
            var active = this.getActive();
            if (!map || !active) {
              this.abortDrawing();
            }
            this.overlay_.setMap(active ? map : null);
          };
          return Draw;
        }(Pointer);
        function getDefaultStyleFunction() {
          var styles = createEditingStyle();
          return function(feature, resolution) {
            return styles[feature.getGeometry().getType()];
          };
        }
        function createRegularPolygon(opt_sides, opt_angle) {
          return function(coordinates, opt_geometry, projection) {
            var center = fromUserCoordinate(coordinates[0], projection);
            var end = fromUserCoordinate(coordinates[coordinates.length - 1], projection);
            var radius = Math.sqrt(coordinate_squaredDistance(center, end));
            var geometry = opt_geometry ? opt_geometry : fromCircle(new geom_Circle(center), opt_sides);
            var angle = opt_angle;
            if (!opt_angle && opt_angle !== 0) {
              var x = end[0] - center[0];
              var y = end[1] - center[1];
              angle = Math.atan2(y, x);
            }
            makeRegular(geometry, center, radius, angle);
            var userProjection = getUserProjection();
            if (userProjection) {
              geometry.transform(projection, userProjection);
            }
            return geometry;
          };
        }
        function createBox() {
          return function(coordinates, opt_geometry, projection) {
            var extent = boundingExtent([
              coordinates[0],
              coordinates[coordinates.length - 1]
            ].map(function(coordinate) {
              return fromUserCoordinate(coordinate, projection);
            }));
            var boxCoordinates = [
              [
                getBottomLeft(extent),
                getBottomRight(extent),
                getTopRight(extent),
                getTopLeft(extent),
                getBottomLeft(extent)
              ]
            ];
            var geometry = opt_geometry;
            if (geometry) {
              geometry.setCoordinates(boxCoordinates);
            } else {
              geometry = new geom_Polygon(boxCoordinates);
            }
            var userProjection = getUserProjection();
            if (userProjection) {
              geometry.transform(projection, userProjection);
            }
            return geometry;
          };
        }
        function getMode(type) {
          switch (type) {
            case geom_GeometryType.POINT:
            case geom_GeometryType.MULTI_POINT:
              return Draw_Mode.POINT;
            case geom_GeometryType.LINE_STRING:
            case geom_GeometryType.MULTI_LINE_STRING:
              return Draw_Mode.LINE_STRING;
            case geom_GeometryType.POLYGON:
            case geom_GeometryType.MULTI_POLYGON:
              return Draw_Mode.POLYGON;
            case geom_GeometryType.CIRCLE:
              return Draw_Mode.CIRCLE;
            default:
              throw new Error("Invalid type: " + type);
          }
        }
        var interaction_Draw = Draw_Draw;
        var Modify_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var CIRCLE_CENTER_INDEX = 0;
        var CIRCLE_CIRCUMFERENCE_INDEX = 1;
        var tempExtent = [0, 0, 0, 0];
        var tempSegment = [];
        var ModifyEventType = {
          MODIFYSTART: "modifystart",
          MODIFYEND: "modifyend"
        };
        var ModifyEvent = function(_super) {
          Modify_extends(ModifyEvent2, _super);
          function ModifyEvent2(type, features, MapBrowserEvent2) {
            var _this = _super.call(this, type) || this;
            _this.features = features;
            _this.mapBrowserEvent = MapBrowserEvent2;
            return _this;
          }
          return ModifyEvent2;
        }(events_Event["a"]);
        var Modify_Modify = function(_super) {
          Modify_extends(Modify, _super);
          function Modify(options) {
            var _this = _super.call(this, options) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);
            _this.condition_ = options.condition ? options.condition : primaryAction;
            _this.defaultDeleteCondition_ = function(mapBrowserEvent) {
              return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);
            };
            _this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : _this.defaultDeleteCondition_;
            _this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : always;
            _this.vertexFeature_ = null;
            _this.vertexSegments_ = null;
            _this.lastPixel_ = [0, 0];
            _this.ignoreNextSingleClick_ = false;
            _this.featuresBeingModified_ = null;
            _this.rBush_ = new structs_RBush();
            _this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;
            _this.snappedToVertex_ = false;
            _this.changingFeature_ = false;
            _this.dragSegments_ = [];
            _this.overlay_ = new Vector({
              source: new source_Vector({
                useSpatialIndex: false,
                wrapX: !!options.wrapX
              }),
              style: options.style ? options.style : Modify_getDefaultStyleFunction(),
              updateWhileAnimating: true,
              updateWhileInteracting: true
            });
            _this.SEGMENT_WRITERS_ = {
              "Point": _this.writePointGeometry_.bind(_this),
              "LineString": _this.writeLineStringGeometry_.bind(_this),
              "LinearRing": _this.writeLineStringGeometry_.bind(_this),
              "Polygon": _this.writePolygonGeometry_.bind(_this),
              "MultiPoint": _this.writeMultiPointGeometry_.bind(_this),
              "MultiLineString": _this.writeMultiLineStringGeometry_.bind(_this),
              "MultiPolygon": _this.writeMultiPolygonGeometry_.bind(_this),
              "Circle": _this.writeCircleGeometry_.bind(_this),
              "GeometryCollection": _this.writeGeometryCollectionGeometry_.bind(_this)
            };
            _this.source_ = null;
            _this.hitDetection_ = null;
            var features;
            if (options.features) {
              features = options.features;
            } else if (options.source) {
              _this.source_ = options.source;
              features = new ol_Collection(_this.source_.getFeatures());
              _this.source_.addEventListener(VectorEventType.ADDFEATURE, _this.handleSourceAdd_.bind(_this));
              _this.source_.addEventListener(VectorEventType.REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));
            }
            if (!features) {
              throw new Error("The modify interaction requires features, a source or a layer");
            }
            if (options.hitDetection) {
              _this.hitDetection_ = options.hitDetection;
            }
            _this.features_ = features;
            _this.features_.forEach(_this.addFeature_.bind(_this));
            _this.features_.addEventListener(CollectionEventType.ADD, _this.handleFeatureAdd_.bind(_this));
            _this.features_.addEventListener(CollectionEventType.REMOVE, _this.handleFeatureRemove_.bind(_this));
            _this.lastPointerEvent_ = null;
            _this.delta_ = [0, 0];
            _this.snapToPointer_ = options.snapToPointer === void 0 ? !_this.hitDetection_ : options.snapToPointer;
            return _this;
          }
          Modify.prototype.addFeature_ = function(feature) {
            var geometry = feature.getGeometry();
            if (geometry) {
              var writer = this.SEGMENT_WRITERS_[geometry.getType()];
              if (writer) {
                writer(feature, geometry);
              }
            }
            var map = this.getMap();
            if (map && map.isRendered() && this.getActive()) {
              this.handlePointerAtPixel_(this.lastPixel_, map);
            }
            feature.addEventListener(EventType["a"].CHANGE, this.boundHandleFeatureChange_);
          };
          Modify.prototype.willModifyFeatures_ = function(evt, segments) {
            if (!this.featuresBeingModified_) {
              this.featuresBeingModified_ = new ol_Collection();
              var features = this.featuresBeingModified_.getArray();
              for (var i = 0, ii = segments.length; i < ii; ++i) {
                var segment = segments[i];
                for (var s = 0, ss = segment.length; s < ss; ++s) {
                  var feature = segment[s].feature;
                  if (feature && features.indexOf(feature) === -1) {
                    this.featuresBeingModified_.push(feature);
                  }
                }
              }
              if (this.featuresBeingModified_.getLength() === 0) {
                this.featuresBeingModified_ = null;
              } else {
                this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
              }
            }
          };
          Modify.prototype.removeFeature_ = function(feature) {
            this.removeFeatureSegmentData_(feature);
            if (this.vertexFeature_ && this.features_.getLength() === 0) {
              this.overlay_.getSource().removeFeature(this.vertexFeature_);
              this.vertexFeature_ = null;
            }
            feature.removeEventListener(EventType["a"].CHANGE, this.boundHandleFeatureChange_);
          };
          Modify.prototype.removeFeatureSegmentData_ = function(feature) {
            var rBush = this.rBush_;
            var nodesToRemove = [];
            rBush.forEach(function(node) {
              if (feature === node.feature) {
                nodesToRemove.push(node);
              }
            });
            for (var i = nodesToRemove.length - 1; i >= 0; --i) {
              var nodeToRemove = nodesToRemove[i];
              for (var j = this.dragSegments_.length - 1; j >= 0; --j) {
                if (this.dragSegments_[j][0] === nodeToRemove) {
                  this.dragSegments_.splice(j, 1);
                }
              }
              rBush.remove(nodeToRemove);
            }
          };
          Modify.prototype.setActive = function(active) {
            if (this.vertexFeature_ && !active) {
              this.overlay_.getSource().removeFeature(this.vertexFeature_);
              this.vertexFeature_ = null;
            }
            _super.prototype.setActive.call(this, active);
          };
          Modify.prototype.setMap = function(map) {
            this.overlay_.setMap(map);
            _super.prototype.setMap.call(this, map);
          };
          Modify.prototype.getOverlay = function() {
            return this.overlay_;
          };
          Modify.prototype.handleSourceAdd_ = function(event) {
            if (event.feature) {
              this.features_.push(event.feature);
            }
          };
          Modify.prototype.handleSourceRemove_ = function(event) {
            if (event.feature) {
              this.features_.remove(event.feature);
            }
          };
          Modify.prototype.handleFeatureAdd_ = function(evt) {
            this.addFeature_(evt.element);
          };
          Modify.prototype.handleFeatureChange_ = function(evt) {
            if (!this.changingFeature_) {
              var feature = evt.target;
              this.removeFeature_(feature);
              this.addFeature_(feature);
            }
          };
          Modify.prototype.handleFeatureRemove_ = function(evt) {
            var feature = evt.element;
            this.removeFeature_(feature);
          };
          Modify.prototype.writePointGeometry_ = function(feature, geometry) {
            var coordinates = geometry.getCoordinates();
            var segmentData = {
              feature,
              geometry,
              segment: [coordinates, coordinates]
            };
            this.rBush_.insert(geometry.getExtent(), segmentData);
          };
          Modify.prototype.writeMultiPointGeometry_ = function(feature, geometry) {
            var points = geometry.getCoordinates();
            for (var i = 0, ii = points.length; i < ii; ++i) {
              var coordinates = points[i];
              var segmentData = {
                feature,
                geometry,
                depth: [i],
                index: i,
                segment: [coordinates, coordinates]
              };
              this.rBush_.insert(geometry.getExtent(), segmentData);
            }
          };
          Modify.prototype.writeLineStringGeometry_ = function(feature, geometry) {
            var coordinates = geometry.getCoordinates();
            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
              var segment = coordinates.slice(i, i + 2);
              var segmentData = {
                feature,
                geometry,
                index: i,
                segment
              };
              this.rBush_.insert(boundingExtent(segment), segmentData);
            }
          };
          Modify.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {
            var lines = geometry.getCoordinates();
            for (var j = 0, jj = lines.length; j < jj; ++j) {
              var coordinates = lines[j];
              for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                var segment = coordinates.slice(i, i + 2);
                var segmentData = {
                  feature,
                  geometry,
                  depth: [j],
                  index: i,
                  segment
                };
                this.rBush_.insert(boundingExtent(segment), segmentData);
              }
            }
          };
          Modify.prototype.writePolygonGeometry_ = function(feature, geometry) {
            var rings = geometry.getCoordinates();
            for (var j = 0, jj = rings.length; j < jj; ++j) {
              var coordinates = rings[j];
              for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                var segment = coordinates.slice(i, i + 2);
                var segmentData = {
                  feature,
                  geometry,
                  depth: [j],
                  index: i,
                  segment
                };
                this.rBush_.insert(boundingExtent(segment), segmentData);
              }
            }
          };
          Modify.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {
            var polygons = geometry.getCoordinates();
            for (var k = 0, kk = polygons.length; k < kk; ++k) {
              var rings = polygons[k];
              for (var j = 0, jj = rings.length; j < jj; ++j) {
                var coordinates = rings[j];
                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                  var segment = coordinates.slice(i, i + 2);
                  var segmentData = {
                    feature,
                    geometry,
                    depth: [j, k],
                    index: i,
                    segment
                  };
                  this.rBush_.insert(boundingExtent(segment), segmentData);
                }
              }
            }
          };
          Modify.prototype.writeCircleGeometry_ = function(feature, geometry) {
            var coordinates = geometry.getCenter();
            var centerSegmentData = {
              feature,
              geometry,
              index: CIRCLE_CENTER_INDEX,
              segment: [coordinates, coordinates]
            };
            var circumferenceSegmentData = {
              feature,
              geometry,
              index: CIRCLE_CIRCUMFERENCE_INDEX,
              segment: [coordinates, coordinates]
            };
            var featureSegments = [centerSegmentData, circumferenceSegmentData];
            centerSegmentData.featureSegments = featureSegments;
            circumferenceSegmentData.featureSegments = featureSegments;
            this.rBush_.insert(createOrUpdateFromCoordinate(coordinates), centerSegmentData);
            var circleGeometry = geometry;
            var userProjection = getUserProjection();
            if (userProjection && this.getMap()) {
              var projection = this.getMap().getView().getProjection();
              circleGeometry = circleGeometry.clone().transform(userProjection, projection);
              circleGeometry = fromCircle(circleGeometry).transform(projection, userProjection);
            }
            this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
          };
          Modify.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {
            var geometries = geometry.getGeometriesArray();
            for (var i = 0; i < geometries.length; ++i) {
              var geometry_1 = geometries[i];
              var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];
              writer(feature, geometry_1);
            }
          };
          Modify.prototype.createOrUpdateVertexFeature_ = function(coordinates, features, geometries) {
            var vertexFeature = this.vertexFeature_;
            if (!vertexFeature) {
              vertexFeature = new ol_Feature(new geom_Point(coordinates));
              this.vertexFeature_ = vertexFeature;
              this.overlay_.getSource().addFeature(vertexFeature);
            } else {
              var geometry = vertexFeature.getGeometry();
              geometry.setCoordinates(coordinates);
            }
            vertexFeature.set("features", features);
            vertexFeature.set("geometries", geometries);
            return vertexFeature;
          };
          Modify.prototype.handleEvent = function(mapBrowserEvent) {
            if (!mapBrowserEvent.originalEvent) {
              return true;
            }
            this.lastPointerEvent_ = mapBrowserEvent;
            var handled;
            if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {
              this.handlePointerMove_(mapBrowserEvent);
            }
            if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
              if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {
                handled = this.removePoint();
              } else {
                handled = true;
              }
            }
            if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {
              this.ignoreNextSingleClick_ = false;
            }
            return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
          };
          Modify.prototype.handleDragEvent = function(evt) {
            this.ignoreNextSingleClick_ = false;
            this.willModifyFeatures_(evt, this.dragSegments_);
            var vertex = [
              evt.coordinate[0] + this.delta_[0],
              evt.coordinate[1] + this.delta_[1]
            ];
            var features = [];
            var geometries = [];
            for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
              var dragSegment = this.dragSegments_[i];
              var segmentData = dragSegment[0];
              var feature = segmentData.feature;
              if (features.indexOf(feature) === -1) {
                features.push(feature);
              }
              var geometry = segmentData.geometry;
              if (geometries.indexOf(geometry) === -1) {
                geometries.push(geometry);
              }
              var depth = segmentData.depth;
              var coordinates = void 0;
              var segment = segmentData.segment;
              var index = dragSegment[1];
              while (vertex.length < geometry.getStride()) {
                vertex.push(segment[index][vertex.length]);
              }
              switch (geometry.getType()) {
                case geom_GeometryType.POINT:
                  coordinates = vertex;
                  segment[0] = vertex;
                  segment[1] = vertex;
                  break;
                case geom_GeometryType.MULTI_POINT:
                  coordinates = geometry.getCoordinates();
                  coordinates[segmentData.index] = vertex;
                  segment[0] = vertex;
                  segment[1] = vertex;
                  break;
                case geom_GeometryType.LINE_STRING:
                  coordinates = geometry.getCoordinates();
                  coordinates[segmentData.index + index] = vertex;
                  segment[index] = vertex;
                  break;
                case geom_GeometryType.MULTI_LINE_STRING:
                  coordinates = geometry.getCoordinates();
                  coordinates[depth[0]][segmentData.index + index] = vertex;
                  segment[index] = vertex;
                  break;
                case geom_GeometryType.POLYGON:
                  coordinates = geometry.getCoordinates();
                  coordinates[depth[0]][segmentData.index + index] = vertex;
                  segment[index] = vertex;
                  break;
                case geom_GeometryType.MULTI_POLYGON:
                  coordinates = geometry.getCoordinates();
                  coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
                  segment[index] = vertex;
                  break;
                case geom_GeometryType.CIRCLE:
                  segment[0] = vertex;
                  segment[1] = vertex;
                  if (segmentData.index === CIRCLE_CENTER_INDEX) {
                    this.changingFeature_ = true;
                    geometry.setCenter(vertex);
                    this.changingFeature_ = false;
                  } else {
                    this.changingFeature_ = true;
                    var projection = evt.map.getView().getProjection();
                    var radius = coordinate_distance(fromUserCoordinate(geometry.getCenter(), projection), fromUserCoordinate(vertex, projection));
                    var userProjection = getUserProjection();
                    if (userProjection) {
                      var circleGeometry = geometry.clone().transform(userProjection, projection);
                      circleGeometry.setRadius(radius);
                      radius = circleGeometry.transform(projection, userProjection).getRadius();
                    }
                    geometry.setRadius(radius);
                    this.changingFeature_ = false;
                  }
                  break;
                default:
              }
              if (coordinates) {
                this.setGeometryCoordinates_(geometry, coordinates);
              }
            }
            this.createOrUpdateVertexFeature_(vertex, features, geometries);
          };
          Modify.prototype.handleDownEvent = function(evt) {
            if (!this.condition_(evt)) {
              return false;
            }
            var pixelCoordinate = evt.coordinate;
            this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
            this.dragSegments_.length = 0;
            this.featuresBeingModified_ = null;
            var vertexFeature = this.vertexFeature_;
            if (vertexFeature) {
              var projection = evt.map.getView().getProjection();
              var insertVertices = [];
              var vertex = vertexFeature.getGeometry().getCoordinates();
              var vertexExtent = boundingExtent([vertex]);
              var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
              var componentSegments = {};
              segmentDataMatches.sort(compareIndexes);
              for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
                var segmentDataMatch = segmentDataMatches[i];
                var segment = segmentDataMatch.segment;
                var uid = Object(util["c"])(segmentDataMatch.geometry);
                var depth = segmentDataMatch.depth;
                if (depth) {
                  uid += "-" + depth.join("-");
                }
                if (!componentSegments[uid]) {
                  componentSegments[uid] = new Array(2);
                }
                if (segmentDataMatch.geometry.getType() === geom_GeometryType.CIRCLE && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                  var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);
                  if (coordinate_equals(closestVertex, vertex) && !componentSegments[uid][0]) {
                    this.dragSegments_.push([segmentDataMatch, 0]);
                    componentSegments[uid][0] = segmentDataMatch;
                  }
                  continue;
                }
                if (coordinate_equals(segment[0], vertex) && !componentSegments[uid][0]) {
                  this.dragSegments_.push([segmentDataMatch, 0]);
                  componentSegments[uid][0] = segmentDataMatch;
                  continue;
                }
                if (coordinate_equals(segment[1], vertex) && !componentSegments[uid][1]) {
                  if ((segmentDataMatch.geometry.getType() === geom_GeometryType.LINE_STRING || segmentDataMatch.geometry.getType() === geom_GeometryType.MULTI_LINE_STRING) && componentSegments[uid][0] && componentSegments[uid][0].index === 0) {
                    continue;
                  }
                  this.dragSegments_.push([segmentDataMatch, 1]);
                  componentSegments[uid][1] = segmentDataMatch;
                  continue;
                }
                if (Object(util["c"])(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1] && this.insertVertexCondition_(evt)) {
                  insertVertices.push(segmentDataMatch);
                }
              }
              if (insertVertices.length) {
                this.willModifyFeatures_(evt, [insertVertices]);
              }
              for (var j = insertVertices.length - 1; j >= 0; --j) {
                this.insertVertex_(insertVertices[j], vertex);
              }
            }
            return !!this.vertexFeature_;
          };
          Modify.prototype.handleUpEvent = function(evt) {
            for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
              var segmentData = this.dragSegments_[i][0];
              var geometry = segmentData.geometry;
              if (geometry.getType() === geom_GeometryType.CIRCLE) {
                var coordinates = geometry.getCenter();
                var centerSegmentData = segmentData.featureSegments[0];
                var circumferenceSegmentData = segmentData.featureSegments[1];
                centerSegmentData.segment[0] = coordinates;
                centerSegmentData.segment[1] = coordinates;
                circumferenceSegmentData.segment[0] = coordinates;
                circumferenceSegmentData.segment[1] = coordinates;
                this.rBush_.update(createOrUpdateFromCoordinate(coordinates), centerSegmentData);
                var circleGeometry = geometry;
                var userProjection = getUserProjection();
                if (userProjection) {
                  var projection = evt.map.getView().getProjection();
                  circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                  circleGeometry = fromCircle(circleGeometry).transform(projection, userProjection);
                }
                this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
              } else {
                this.rBush_.update(boundingExtent(segmentData.segment), segmentData);
              }
            }
            if (this.featuresBeingModified_) {
              this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
              this.featuresBeingModified_ = null;
            }
            return false;
          };
          Modify.prototype.handlePointerMove_ = function(evt) {
            this.lastPixel_ = evt.pixel;
            this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
          };
          Modify.prototype.handlePointerAtPixel_ = function(pixel, map, opt_coordinate) {
            var _this = this;
            var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);
            var projection = map.getView().getProjection();
            var sortByDistance = function(a, b) {
              return projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection);
            };
            var nodes;
            var hitPointGeometry;
            if (this.hitDetection_) {
              var layerFilter = typeof this.hitDetection_ === "object" ? function(layer) {
                return layer === _this.hitDetection_;
              } : void 0;
              map.forEachFeatureAtPixel(pixel, function(feature, layer, geometry) {
                geometry = geometry || feature.getGeometry();
                if (geometry.getType() === geom_GeometryType.POINT && Object(ol_array["f"])(_this.features_.getArray(), feature)) {
                  hitPointGeometry = geometry;
                  var coordinate = geometry.getFlatCoordinates().slice(0, 2);
                  nodes = [
                    {
                      feature,
                      geometry,
                      segment: [coordinate, coordinate]
                    }
                  ];
                }
                return true;
              }, { layerFilter });
            }
            if (!nodes) {
              var viewExtent = fromUserExtent(createOrUpdateFromCoordinate(pixelCoordinate, tempExtent), projection);
              var buffer = map.getView().getResolution() * this.pixelTolerance_;
              var box = toUserExtent(extent_buffer(viewExtent, buffer, tempExtent), projection);
              nodes = this.rBush_.getInExtent(box);
            }
            if (nodes && nodes.length > 0) {
              var node = nodes.sort(sortByDistance)[0];
              var closestSegment = node.segment;
              var vertex = closestOnSegmentData(pixelCoordinate, node, projection);
              var vertexPixel = map.getPixelFromCoordinate(vertex);
              var dist = coordinate_distance(pixel, vertexPixel);
              if (hitPointGeometry || dist <= this.pixelTolerance_) {
                var vertexSegments = {};
                vertexSegments[Object(util["c"])(closestSegment)] = true;
                if (!this.snapToPointer_) {
                  this.delta_[0] = vertex[0] - pixelCoordinate[0];
                  this.delta_[1] = vertex[1] - pixelCoordinate[1];
                }
                if (node.geometry.getType() === geom_GeometryType.CIRCLE && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                  this.snappedToVertex_ = true;
                  this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
                } else {
                  var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                  var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                  var squaredDist1 = coordinate_squaredDistance(vertexPixel, pixel1);
                  var squaredDist2 = coordinate_squaredDistance(vertexPixel, pixel2);
                  dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                  this.snappedToVertex_ = dist <= this.pixelTolerance_;
                  if (this.snappedToVertex_) {
                    vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                  }
                  this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
                  var geometries = {};
                  geometries[Object(util["c"])(node.geometry)] = true;
                  for (var i = 1, ii = nodes.length; i < ii; ++i) {
                    var segment = nodes[i].segment;
                    if (coordinate_equals(closestSegment[0], segment[0]) && coordinate_equals(closestSegment[1], segment[1]) || coordinate_equals(closestSegment[0], segment[1]) && coordinate_equals(closestSegment[1], segment[0])) {
                      var geometryUid = Object(util["c"])(nodes[i].geometry);
                      if (!(geometryUid in geometries)) {
                        geometries[geometryUid] = true;
                        vertexSegments[Object(util["c"])(segment)] = true;
                      }
                    } else {
                      break;
                    }
                  }
                }
                this.vertexSegments_ = vertexSegments;
                return;
              }
            }
            if (this.vertexFeature_) {
              this.overlay_.getSource().removeFeature(this.vertexFeature_);
              this.vertexFeature_ = null;
            }
          };
          Modify.prototype.insertVertex_ = function(segmentData, vertex) {
            var segment = segmentData.segment;
            var feature = segmentData.feature;
            var geometry = segmentData.geometry;
            var depth = segmentData.depth;
            var index = segmentData.index;
            var coordinates;
            while (vertex.length < geometry.getStride()) {
              vertex.push(0);
            }
            switch (geometry.getType()) {
              case geom_GeometryType.MULTI_LINE_STRING:
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
              case geom_GeometryType.POLYGON:
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
              case geom_GeometryType.MULTI_POLYGON:
                coordinates = geometry.getCoordinates();
                coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
                break;
              case geom_GeometryType.LINE_STRING:
                coordinates = geometry.getCoordinates();
                coordinates.splice(index + 1, 0, vertex);
                break;
              default:
                return;
            }
            this.setGeometryCoordinates_(geometry, coordinates);
            var rTree = this.rBush_;
            rTree.remove(segmentData);
            this.updateSegmentIndices_(geometry, index, depth, 1);
            var newSegmentData = {
              segment: [segment[0], vertex],
              feature,
              geometry,
              depth,
              index
            };
            rTree.insert(boundingExtent(newSegmentData.segment), newSegmentData);
            this.dragSegments_.push([newSegmentData, 1]);
            var newSegmentData2 = {
              segment: [vertex, segment[1]],
              feature,
              geometry,
              depth,
              index: index + 1
            };
            rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);
            this.dragSegments_.push([newSegmentData2, 0]);
            this.ignoreNextSingleClick_ = true;
          };
          Modify.prototype.removePoint = function() {
            if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {
              var evt = this.lastPointerEvent_;
              this.willModifyFeatures_(evt, this.dragSegments_);
              var removed = this.removeVertex_();
              if (this.featuresBeingModified_) {
                this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
              }
              this.featuresBeingModified_ = null;
              return removed;
            }
            return false;
          };
          Modify.prototype.removeVertex_ = function() {
            var dragSegments = this.dragSegments_;
            var segmentsByFeature = {};
            var deleted = false;
            var component, coordinates, dragSegment, geometry, i, index, left;
            var newIndex, right, segmentData, uid;
            for (i = dragSegments.length - 1; i >= 0; --i) {
              dragSegment = dragSegments[i];
              segmentData = dragSegment[0];
              uid = Object(util["c"])(segmentData.feature);
              if (segmentData.depth) {
                uid += "-" + segmentData.depth.join("-");
              }
              if (!(uid in segmentsByFeature)) {
                segmentsByFeature[uid] = {};
              }
              if (dragSegment[1] === 0) {
                segmentsByFeature[uid].right = segmentData;
                segmentsByFeature[uid].index = segmentData.index;
              } else if (dragSegment[1] == 1) {
                segmentsByFeature[uid].left = segmentData;
                segmentsByFeature[uid].index = segmentData.index + 1;
              }
            }
            for (uid in segmentsByFeature) {
              right = segmentsByFeature[uid].right;
              left = segmentsByFeature[uid].left;
              index = segmentsByFeature[uid].index;
              newIndex = index - 1;
              if (left !== void 0) {
                segmentData = left;
              } else {
                segmentData = right;
              }
              if (newIndex < 0) {
                newIndex = 0;
              }
              geometry = segmentData.geometry;
              coordinates = geometry.getCoordinates();
              component = coordinates;
              deleted = false;
              switch (geometry.getType()) {
                case geom_GeometryType.MULTI_LINE_STRING:
                  if (coordinates[segmentData.depth[0]].length > 2) {
                    coordinates[segmentData.depth[0]].splice(index, 1);
                    deleted = true;
                  }
                  break;
                case geom_GeometryType.LINE_STRING:
                  if (coordinates.length > 2) {
                    coordinates.splice(index, 1);
                    deleted = true;
                  }
                  break;
                case geom_GeometryType.MULTI_POLYGON:
                  component = component[segmentData.depth[1]];
                case geom_GeometryType.POLYGON:
                  component = component[segmentData.depth[0]];
                  if (component.length > 4) {
                    if (index == component.length - 1) {
                      index = 0;
                    }
                    component.splice(index, 1);
                    deleted = true;
                    if (index === 0) {
                      component.pop();
                      component.push(component[0]);
                      newIndex = component.length - 1;
                    }
                  }
                  break;
                default:
              }
              if (deleted) {
                this.setGeometryCoordinates_(geometry, coordinates);
                var segments = [];
                if (left !== void 0) {
                  this.rBush_.remove(left);
                  segments.push(left.segment[0]);
                }
                if (right !== void 0) {
                  this.rBush_.remove(right);
                  segments.push(right.segment[1]);
                }
                if (left !== void 0 && right !== void 0) {
                  var newSegmentData = {
                    depth: segmentData.depth,
                    feature: segmentData.feature,
                    geometry: segmentData.geometry,
                    index: newIndex,
                    segment: segments
                  };
                  this.rBush_.insert(boundingExtent(newSegmentData.segment), newSegmentData);
                }
                this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
                if (this.vertexFeature_) {
                  this.overlay_.getSource().removeFeature(this.vertexFeature_);
                  this.vertexFeature_ = null;
                }
                dragSegments.length = 0;
              }
            }
            return deleted;
          };
          Modify.prototype.setGeometryCoordinates_ = function(geometry, coordinates) {
            this.changingFeature_ = true;
            geometry.setCoordinates(coordinates);
            this.changingFeature_ = false;
          };
          Modify.prototype.updateSegmentIndices_ = function(geometry, index, depth, delta) {
            this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
              if (segmentDataMatch.geometry === geometry && (depth === void 0 || segmentDataMatch.depth === void 0 || Object(ol_array["b"])(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) {
                segmentDataMatch.index += delta;
              }
            });
          };
          return Modify;
        }(Pointer);
        function compareIndexes(a, b) {
          return a.index - b.index;
        }
        function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
          var geometry = segmentData.geometry;
          if (geometry.getType() === geom_GeometryType.CIRCLE) {
            var circleGeometry = geometry;
            if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
              var userProjection = getUserProjection();
              if (userProjection) {
                circleGeometry = circleGeometry.clone().transform(userProjection, projection);
              }
              var distanceToCenterSquared = coordinate_squaredDistance(circleGeometry.getCenter(), fromUserCoordinate(pointCoordinates, projection));
              var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
              return distanceToCircumference * distanceToCircumference;
            }
          }
          var coordinate = fromUserCoordinate(pointCoordinates, projection);
          tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);
          tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);
          return squaredDistanceToSegment(coordinate, tempSegment);
        }
        function closestOnSegmentData(pointCoordinates, segmentData, projection) {
          var geometry = segmentData.geometry;
          if (geometry.getType() === geom_GeometryType.CIRCLE && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
            var circleGeometry = geometry;
            var userProjection = getUserProjection();
            if (userProjection) {
              circleGeometry = circleGeometry.clone().transform(userProjection, projection);
            }
            return toUserCoordinate(circleGeometry.getClosestPoint(fromUserCoordinate(pointCoordinates, projection)), projection);
          }
          var coordinate = fromUserCoordinate(pointCoordinates, projection);
          tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);
          tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);
          return toUserCoordinate(closestOnSegment(coordinate, tempSegment), projection);
        }
        function Modify_getDefaultStyleFunction() {
          var style = createEditingStyle();
          return function(feature, resolution) {
            return style[geom_GeometryType.POINT];
          };
        }
        var interaction_Modify = Modify_Modify;
        var Stylevue_type_script_lang_js = {
          name: "ol-style",
          setup: function setup(props) {
            var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("stylable", null);
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new style_Style(properties);
            });
            var setStyle = function setStyle2(val) {
              if (styledObj instanceof interaction_Draw || styledObj instanceof interaction_Modify) {
                styledObj.getOverlay().setStyle(val);
                styledObj.value.dispatchEvent("styleChanged");
                return;
              }
              try {
                styledObj.value.setStyle(val);
                styledObj.value.changed();
                styledObj.value.dispatchEvent("styleChanged");
              } catch (error) {
                styledObj.value.style_ = val;
                styledObj.value.values_.style = val;
                styledObj.value.changed();
                styledObj.value.dispatchEvent("styleChanged");
              }
            };
            var styleFunc = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return function(feature) {
                if (properties.overrideStyleFunction != null) {
                  properties.overrideStyleFunction(feature, style.value);
                }
                return style.value;
              };
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              if (properties.overrideStyleFunction == null) {
                setStyle(style.value);
              } else {
                setStyle(styleFunc.value);
              }
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              if (properties.overrideStyleFunction == null) {
                setStyle(style.value);
              } else {
                setStyle(styleFunc.value);
              }
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              setStyle(null);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("style", style);
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("styledObj", styledObj);
            return {
              style
            };
          },
          props: {
            zIndex: {
              type: Number
            },
            overrideStyleFunction: {
              type: Function
            }
          }
        };
        const Style_exports_ = exportHelper_default()(Stylevue_type_script_lang_js, [["render", Stylevue_type_template_id_0040721c_render]]);
        var styles_Style = Style_exports_;
        function Circlevue_type_template_id_022256d8_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var Circlevue_type_script_lang_js = {
          name: "ol-style-circle",
          setup: function setup(props) {
            var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("style", null);
            var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("styledObj", null);
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var createCircleStyle = function createCircleStyle2(properties2) {
              return new style_Circle(_objectSpread2(_objectSpread2({}, properties2), {}, {
                fill: new style_Fill(),
                stroke: new style_Stroke()
              }));
            };
            var circle = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return createCircleStyle(properties);
            });
            var applyStyle = function applyStyle2() {
              style.value.setImage(null);
              style.value.setImage(circle.value);
              styledObj.value.changed();
            };
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              applyStyle();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(style, function() {
              applyStyle();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              style.value.setImage(circle.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              style.value.setImage(null);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("circle", circle);
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("styledObj", styledObj);
          },
          props: {
            radius: {
              type: Number
            },
            scale: {
              type: Number
            }
          }
        };
        const Circle_exports_ = exportHelper_default()(Circlevue_type_script_lang_js, [["render", Circlevue_type_template_id_022256d8_render]]);
        var styles_Circle = Circle_exports_;
        var Strokevue_type_template_id_6c3eb840_hoisted_1 = {
          key: 0
        };
        function Strokevue_type_template_id_6c3eb840_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var Strokevue_type_script_lang_js = {
          name: "ol-style-stroke",
          setup: function setup(props) {
            var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("style", null);
            var circle = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("circle", null);
            var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("styledObj", null);
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            if (style != null && circle == null) {
              var stroke = new style_Stroke(properties);
              style.value.setStroke(stroke);
              var applyStroke = function applyStroke2() {
                style.value.setStroke(null);
                stroke = new style_Stroke(properties);
                style.value.setStroke(stroke);
              };
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                applyStroke();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(style, function() {
                applyStroke();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                style.value.setStroke(stroke);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                style.value.setStroke(null);
              });
            } else if (circle != null) {
              var applyStroketoCircle = function applyStroketoCircle2(properties2) {
                circle.value.getStroke().setColor(properties2.color);
                circle.value.getStroke().setLineCap(properties2.lineCap);
                circle.value.getStroke().setLineDash(properties2.lineDash);
                circle.value.getStroke().setLineDashOffset(properties2.lineDashOffset);
                circle.value.getStroke().setLineJoin(properties2.lineJoin);
                circle.value.getStroke().setMiterLimit(properties2.miterLimit);
                circle.value.getStroke().setWidth(properties2.width);
                circle.value.setRadius(circle.value.getRadius());
                try {
                  styledObj.value.changed();
                } catch (error) {
                  styledObj.changed();
                }
              };
              applyStroketoCircle(properties);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function(newVal) {
                applyStroketoCircle(newVal);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(circle, function() {
                applyStroketoCircle(properties);
              });
            }
          },
          props: {
            color: {
              type: String
            },
            lineCap: {
              type: String,
              default: "round"
            },
            lineJoin: {
              type: String,
              default: "round"
            },
            lineDash: {
              type: Array
            },
            lineDashOffset: {
              type: Number,
              default: 0
            },
            miterLimit: {
              type: Number,
              default: 10
            },
            width: {
              type: Number,
              default: 1
            }
          }
        };
        const Stroke_exports_ = exportHelper_default()(Strokevue_type_script_lang_js, [["render", Strokevue_type_template_id_6c3eb840_render]]);
        var styles_Stroke = Stroke_exports_;
        var Fillvue_type_template_id_e0c8222c_hoisted_1 = {
          key: 0
        };
        function Fillvue_type_template_id_e0c8222c_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var Fillvue_type_script_lang_js = {
          name: "ol-style-fill",
          setup: function setup(props) {
            var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("style", null);
            var circle = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("circle", null);
            var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("styledObj", null);
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            if (style != null && circle == null) {
              var fill = new style_Fill(properties);
              style.value.setFill(fill);
              var applyFill = function applyFill2() {
                style.value.setFill(null);
                fill = new style_Fill(properties);
                style.value.setFill(fill);
              };
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                applyFill();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(style, function() {
                applyFill();
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
                style.value.setFill(fill);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
                style.value.setFill(null);
              });
            } else if (circle != null) {
              var applyFilltoCircle = function applyFilltoCircle2(color) {
                circle.value.getFill().setColor(color);
                circle.value.setRadius(circle.value.getRadius());
                try {
                  styledObj.value.changed();
                } catch (error) {
                  styledObj.changed();
                }
              };
              applyFilltoCircle(properties.color);
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
                applyFilltoCircle(properties.color);
              });
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(circle, function() {
                applyFilltoCircle(properties.color);
              });
            }
          },
          props: {
            color: {
              type: String
            }
          }
        };
        const Fill_exports_ = exportHelper_default()(Fillvue_type_script_lang_js, [["render", Fillvue_type_template_id_e0c8222c_render]]);
        var styles_Fill = Fill_exports_;
        var Iconvue_type_template_id_9ead9dc2_hoisted_1 = {
          key: 0
        };
        function Iconvue_type_template_id_9ead9dc2_render(_ctx, _cache, $props, $setup, $data, $options) {
          return false ? void 0 : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createCommentVNode"])("", true);
        }
        var Iconvue_type_script_lang_js = {
          name: "ol-style-icon",
          setup: function setup(props) {
            var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("style", null);
            var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("styledObj", null);
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var icon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var ic = new style_Icon(properties);
              ic.load();
              return ic;
            });
            var applyStyle = function applyStyle2() {
              style.value.setImage(null);
              style.value.setImage(icon.value);
              styledObj.value.changed();
            };
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              applyStyle();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(style, function() {
              applyStyle();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              style.value.setImage(icon.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              style.value.setImage(null);
            });
          },
          props: {
            anchor: {
              type: Array
            },
            anchorOrigin: {
              type: String,
              default: "top-left"
            },
            anchorXUnits: {
              type: String,
              default: "fraction"
            },
            color: {
              type: String
            },
            crossOrigin: {
              type: String
            },
            img: {
              type: [HTMLImageElement, HTMLCanvasElement]
            },
            offset: {
              type: Array,
              default: function _default() {
                return [0, 0];
              }
            },
            displacement: {
              type: Array,
              default: function _default() {
                return [0, 0];
              }
            },
            offsetOrigin: {
              type: String,
              default: "top-left"
            },
            opacity: {
              type: Number,
              default: 1
            },
            scale: {
              type: Number,
              default: 1
            },
            rotateWithView: {
              type: Boolean,
              default: false
            },
            rotation: {
              type: Number,
              default: 0
            },
            size: {
              type: Array
            },
            imgSize: {
              type: Array
            },
            src: {
              type: String
            }
          }
        };
        const Icon_exports_ = exportHelper_default()(Iconvue_type_script_lang_js, [["render", Iconvue_type_template_id_9ead9dc2_render]]);
        var styles_Icon = Icon_exports_;
        function Textvue_type_template_id_3350a60e_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var Textvue_type_script_lang_js = {
          name: "ol-style-text",
          setup: function setup(props) {
            var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("style", null);
            var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("styledObj", null);
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var createText = function createText2(properties2) {
              return new style_Text(_objectSpread2(_objectSpread2({}, properties2), {}, {
                fill: new style_Fill(),
                stroke: new style_Stroke()
              }));
            };
            var text = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return createText(properties);
            });
            var applyStyle = function applyStyle2() {
              style.value.setText(null);
              style.value.setText(text.value);
              styledObj.value.changed();
            };
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              applyStyle();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(style, function() {
              applyStyle();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              style.value.setText(text.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              style.value.setText(null);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("style", text);
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("styledObj", styledObj);
          },
          props: {
            font: {
              type: String
            },
            maxAngle: {
              type: Number,
              default: Math.PI / 4
            },
            offsetX: {
              type: Number,
              default: 0
            },
            offsetY: {
              type: Number,
              default: 0
            },
            overflow: {
              type: Boolean,
              default: false
            },
            placement: {
              type: String,
              default: "point"
            },
            scale: {
              type: Number
            },
            rotateWithView: {
              type: Boolean,
              default: false
            },
            rotation: {
              type: Number,
              default: 0
            },
            text: {
              type: String
            },
            textAlign: {
              type: String
            },
            textBaseline: {
              type: String,
              default: "middle"
            },
            padding: {
              type: Array,
              default: function _default() {
                return [0, 0, 0, 0];
              }
            }
          }
        };
        const Text_exports_ = exportHelper_default()(Textvue_type_script_lang_js, [["render", Textvue_type_template_id_3350a60e_render]]);
        var styles_Text = Text_exports_;
        function FlowLinevue_type_template_id_31abb0eb_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["openBlock"])(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createElementBlock"])("div", null, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default")]);
        }
        var ol_coordinate_dist2d = function(p1, p2) {
          var dx = p1[0] - p2[0];
          var dy = p1[1] - p2[1];
          return Math.sqrt(dx * dx + dy * dy);
        };
        var ol_coordinate_equal = function(p1, p2) {
          return p1[0] == p2[0] && p1[1] == p2[1];
        };
        var ol_coordinate_getFeatureCenter = function(f) {
          return ol_coordinate_getGeomCenter(f.getGeometry());
        };
        var ol_coordinate_getGeomCenter = function(geom) {
          switch (geom.getType()) {
            case "Point":
              return geom.getCoordinates();
            case "MultiPolygon":
              geom = geom.getPolygon(0);
            case "Polygon":
              return geom.getInteriorPoint().getCoordinates();
            default:
              return geom.getClosestPoint(extent_getCenter(geom.getExtent()));
          }
        };
        var ol_coordinate_offsetCoords = function(coords, offset) {
          var path = [];
          var N = coords.length - 1;
          var max = N;
          var mi, mi1, li, li1, ri, ri1, si, si1, Xi1, Yi1;
          var p0, p1, p2;
          var isClosed = ol_coordinate_equal(coords[0], coords[N]);
          if (!isClosed) {
            p0 = coords[0];
            p1 = coords[1];
            p2 = [
              p0[0] + (p1[1] - p0[1]) / ol_coordinate_dist2d(p0, p1) * offset,
              p0[1] - (p1[0] - p0[0]) / ol_coordinate_dist2d(p0, p1) * offset
            ];
            path.push(p2);
            coords.push(coords[N]);
            N++;
            max--;
          }
          for (var i = 0; i < max; i++) {
            p0 = coords[i];
            p1 = coords[(i + 1) % N];
            p2 = coords[(i + 2) % N];
            mi = (p1[1] - p0[1]) / (p1[0] - p0[0]);
            mi1 = (p2[1] - p1[1]) / (p2[0] - p1[0]);
            if (Math.abs(mi - mi1) > 1e-10) {
              li = Math.sqrt((p1[0] - p0[0]) * (p1[0] - p0[0]) + (p1[1] - p0[1]) * (p1[1] - p0[1]));
              li1 = Math.sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]));
              ri = p0[0] + offset * (p1[1] - p0[1]) / li;
              ri1 = p1[0] + offset * (p2[1] - p1[1]) / li1;
              si = p0[1] - offset * (p1[0] - p0[0]) / li;
              si1 = p1[1] - offset * (p2[0] - p1[0]) / li1;
              Xi1 = (mi1 * ri1 - mi * ri + si - si1) / (mi1 - mi);
              Yi1 = (mi * mi1 * (ri1 - ri) + mi1 * si - mi * si1) / (mi1 - mi);
              if (p1[0] - p0[0] == 0) {
                Xi1 = p1[0] + offset * (p1[1] - p0[1]) / Math.abs(p1[1] - p0[1]);
                Yi1 = mi1 * Xi1 - mi1 * ri1 + si1;
              }
              if (p2[0] - p1[0] == 0) {
                Xi1 = p2[0] + offset * (p2[1] - p1[1]) / Math.abs(p2[1] - p1[1]);
                Yi1 = mi * Xi1 - mi * ri + si;
              }
              path.push([Xi1, Yi1]);
            }
          }
          if (isClosed) {
            path.push(path[0]);
          } else {
            coords.pop();
            p0 = coords[coords.length - 1];
            p1 = coords[coords.length - 2];
            p2 = [
              p0[0] - (p1[1] - p0[1]) / ol_coordinate_dist2d(p0, p1) * offset,
              p0[1] + (p1[0] - p0[0]) / ol_coordinate_dist2d(p0, p1) * offset
            ];
            path.push(p2);
          }
          return path;
        };
        var ol_coordinate_findSegment = function(pt, coords) {
          for (var i = 0; i < coords.length - 1; i++) {
            var p0 = coords[i];
            var p1 = coords[i + 1];
            if (ol_coordinate_equal(pt, p0) || ol_coordinate_equal(pt, p1)) {
              return { index: 1, segment: [p0, p1] };
            } else {
              var d0 = ol_coordinate_dist2d(p0, p1);
              var v0 = [(p1[0] - p0[0]) / d0, (p1[1] - p0[1]) / d0];
              var d1 = ol_coordinate_dist2d(p0, pt);
              var v1 = [(pt[0] - p0[0]) / d1, (pt[1] - p0[1]) / d1];
              if (Math.abs(v0[0] * v1[1] - v0[1] * v1[0]) < 1e-10) {
                return { index: 1, segment: [p0, p1] };
              }
            }
          }
          return { index: -1 };
        };
        var ol_coordinate_splitH = function(geom, y, n) {
          var x, abs;
          var list = [];
          for (var i = 0; i < geom.length - 1; i++) {
            if (!geom[i].length || !geom[i + 1].length)
              continue;
            if (geom[i][1] <= y && geom[i + 1][1] > y || geom[i][1] >= y && geom[i + 1][1] < y) {
              abs = (y - geom[i][1]) / (geom[i + 1][1] - geom[i][1]);
              x = abs * (geom[i + 1][0] - geom[i][0]) + geom[i][0];
              list.push({ contour: n, index: i, pt: [x, y], abs });
            }
          }
          list.sort(function(a, b) {
            return a.pt[0] - b.pt[0];
          });
          var result = [];
          for (var j = 0; j < list.length - 1; j += 2) {
            result.push([list[j], list[j + 1]]);
          }
          return result;
        };
        var ol_geom_createFromType = function(type, coordinates) {
          switch (type) {
            case "LineString":
              return new geom_LineString(coordinates);
            case "LinearRing":
              return new geom_LinearRing(coordinates);
            case "MultiLineString":
              return new geom_MultiLineString(coordinates);
            case "MultiPoint":
              return new geom_MultiPoint(coordinates);
            case "MultiPolygon":
              return new geom_MultiPolygon(coordinates);
            case "Point":
              return new geom_Point(coordinates);
            case "Polygon":
              return new geom_Polygon(coordinates);
            default:
              console.error("[createFromType] Unsupported type: " + type);
              return null;
          }
        };
        var ol_coordinate_getIntersectionPoint = function(d1, d2) {
          var d1x = d1[1][0] - d1[0][0];
          var d1y = d1[1][1] - d1[0][1];
          var d2x = d2[1][0] - d2[0][0];
          var d2y = d2[1][1] - d2[0][1];
          var det = d1x * d2y - d1y * d2x;
          if (det != 0) {
            var k = (d1x * d1[0][1] - d1x * d2[0][1] - d1y * d1[0][0] + d1y * d2[0][0]) / det;
            return [d2[0][0] + k * d2x, d2[0][1] + k * d2y];
          } else {
            return false;
          }
        };
        var ol_extent_intersection;
        (function() {
          function splitX(pts, x) {
            var pt;
            for (let i = pts.length - 1; i > 0; i--) {
              if (pts[i][0] > x && pts[i - 1][0] < x || pts[i][0] < x && pts[i - 1][0] > x) {
                pt = [x, (x - pts[i][0]) / (pts[i - 1][0] - pts[i][0]) * (pts[i - 1][1] - pts[i][1]) + pts[i][1]];
                pts.splice(i, 0, pt);
              }
            }
          }
          function splitY(pts, y) {
            var pt;
            for (let i = pts.length - 1; i > 0; i--) {
              if (pts[i][1] > y && pts[i - 1][1] < y || pts[i][1] < y && pts[i - 1][1] > y) {
                pt = [(y - pts[i][1]) / (pts[i - 1][1] - pts[i][1]) * (pts[i - 1][0] - pts[i][0]) + pts[i][0], y];
                pts.splice(i, 0, pt);
              }
            }
          }
          ol_extent_intersection = function(extent, polygon) {
            var poly = polygon.getType() === "Polygon";
            if (!poly && polygon.getType() !== "MultiPolygon")
              return null;
            var geom = polygon.getCoordinates();
            if (poly)
              geom = [geom];
            geom.forEach(function(g) {
              g.forEach(function(c) {
                splitX(c, extent[0]);
                splitX(c, extent[2]);
                splitY(c, extent[1]);
                splitY(c, extent[3]);
              });
            });
            geom.forEach(function(g) {
              g.forEach(function(c) {
                c.forEach(function(p) {
                  if (p[0] < extent[0])
                    p[0] = extent[0];
                  else if (p[0] > extent[2])
                    p[0] = extent[2];
                  if (p[1] < extent[1])
                    p[1] = extent[1];
                  else if (p[1] > extent[3])
                    p[1] = extent[3];
                });
              });
            });
            if (poly) {
              return new geom_Polygon(geom[0]);
            } else {
              return new geom_MultiPolygon(geom);
            }
          };
        })();
        var ol_coordinate_sampleAt = function(p1, p2, d, start) {
          var pts = [];
          if (start !== false)
            pts.push(p1);
          var dl = ol_coordinate_dist2d(p1, p2);
          if (dl) {
            var nb = Math.round(dl / d);
            if (nb > 1) {
              var dx = (p2[0] - p1[0]) / nb;
              var dy = (p2[1] - p1[1]) / nb;
              for (var i = 1; i < nb; i++) {
                pts.push([p1[0] + dx * i, p1[1] + dy * i]);
              }
            }
          }
          pts.push(p2);
          return pts;
        };
        geom_Polygon.prototype.sampleAt = function(res) {
          var poly = this.getCoordinates();
          var result = [];
          poly.forEach(function(p) {
            var l = [];
            for (var i = 1; i < p.length; i++) {
              l = l.concat(ol_coordinate_sampleAt(p[i - 1], p[i], res, i === 1));
            }
            result.push(l);
          });
          return new geom_Polygon(result);
        };
        geom_MultiPolygon.prototype.sampleAt = function(res) {
          var mpoly = this.getCoordinates();
          var result = [];
          mpoly.forEach(function(poly) {
            var a = [];
            result.push(a);
            poly.forEach(function(p) {
              var l = [];
              for (var i = 1; i < p.length; i++) {
                l = l.concat(ol_coordinate_sampleAt(p[i - 1], p[i], res, i === 1));
              }
              a.push(l);
            });
          });
          return new geom_MultiPolygon(result);
        };
        geom_Circle.prototype.intersection = function(geom, resolution) {
          if (geom.sampleAt) {
            var ext = extent_buffer(this.getCenter().concat(this.getCenter()), this.getRadius());
            geom = ol_extent_intersection(ext, geom);
            geom = geom.simplify(resolution);
            var c = this.getCenter();
            var r = this.getRadius();
            var g = geom.sampleAt(resolution).getCoordinates();
            switch (geom.getType()) {
              case "Polygon":
                g = [g];
              case "MultiPolygon": {
                var hasout = false;
                var result = [];
                g.forEach(function(poly) {
                  var a = [];
                  result.push(a);
                  poly.forEach(function(ring) {
                    var l = [];
                    a.push(l);
                    ring.forEach(function(p) {
                      var d = ol_coordinate_dist2d(c, p);
                      if (d > r) {
                        hasout = true;
                        l.push([
                          c[0] + r / d * (p[0] - c[0]),
                          c[1] + r / d * (p[1] - c[1])
                        ]);
                      } else {
                        l.push(p);
                      }
                    });
                  });
                });
                if (!hasout)
                  return geom;
                if (geom.getType() === "Polygon") {
                  return new geom_Polygon(result[0]);
                } else {
                  return new geom_MultiPolygon(result);
                }
              }
            }
          } else {
            console.warn("[ol/geom/Circle~intersection] Unsupported geometry type: " + geom.getType());
          }
          return geom;
        };
        geom_LineString.prototype.splitAt = function(pt, tol) {
          var i;
          if (!pt)
            return [this];
          if (!tol)
            tol = 1e-10;
          if (pt.length && pt[0].length) {
            var result = [this];
            for (i = 0; i < pt.length; i++) {
              var r = [];
              for (var k = 0; k < result.length; k++) {
                var ri = result[k].splitAt(pt[i], tol);
                r = r.concat(ri);
              }
              result = r;
            }
            return result;
          }
          if (ol_coordinate_equal(pt, this.getFirstCoordinate()) || ol_coordinate_equal(pt, this.getLastCoordinate())) {
            return [this];
          }
          var c0 = this.getCoordinates();
          var ci = [c0[0]];
          var c = [];
          for (i = 0; i < c0.length - 1; i++) {
            if (ol_coordinate_equal(c0[i], c0[i + 1]))
              continue;
            if (ol_coordinate_equal(pt, c0[i + 1])) {
              ci.push(c0[i + 1]);
              c.push(new geom_LineString(ci));
              ci = [];
            } else if (!ol_coordinate_equal(pt, c0[i])) {
              var d1, d2, split = false;
              if (c0[i][0] == c0[i + 1][0]) {
                d1 = (c0[i][1] - pt[1]) / (c0[i][1] - c0[i + 1][1]);
                split = c0[i][0] == pt[0] && (0 < d1 && d1 <= 1);
              } else if (c0[i][1] == c0[i + 1][1]) {
                d1 = (c0[i][0] - pt[0]) / (c0[i][0] - c0[i + 1][0]);
                split = c0[i][1] == pt[1] && (0 < d1 && d1 <= 1);
              } else {
                d1 = (c0[i][0] - pt[0]) / (c0[i][0] - c0[i + 1][0]);
                d2 = (c0[i][1] - pt[1]) / (c0[i][1] - c0[i + 1][1]);
                split = Math.abs(d1 - d2) <= tol && 0 < d1 && d1 <= 1;
              }
              if (split) {
                ci.push(pt);
                c.push(new geom_LineString(ci));
                ci = [pt];
              }
            }
            ci.push(c0[i + 1]);
          }
          if (ci.length > 1)
            c.push(new geom_LineString(ci));
          if (c.length)
            return c;
          else
            return [this];
        };
        var ol_style_FlowLine = function(options) {
          if (!options)
            options = {};
          style_Style.call(this, {
            renderer: this._render.bind(this),
            stroke: options.stroke,
            text: options.text,
            zIndex: options.zIndex,
            geometry: options.geometry
          });
          this._visible = options.visible !== false;
          if (typeof options.width === "function") {
            this._widthFn = options.width;
          } else {
            this.setWidth(options.width);
          }
          this.setWidth2(options.width2);
          if (typeof options.color === "function") {
            this._colorFn = options.color;
          } else {
            this.setColor(options.color);
          }
          this.setColor2(options.color2);
          this.setLineCap(options.lineCap);
          this.setArrow(options.arrow);
          this.setArrowSize(options.arrowSize);
          this.setArrowColor(options.arrowColor);
          this._offset = [0, 0];
          this.setOffset(options.offset0, 0);
          this.setOffset(options.offset1, 1);
          this._noOverlap = options.noOverlap;
        };
        util_ext(ol_style_FlowLine, style_Style);
        ol_style_FlowLine.prototype.setWidth = function(width) {
          this._width = width || 0;
        };
        ol_style_FlowLine.prototype.setWidth2 = function(width) {
          this._width2 = width;
        };
        ol_style_FlowLine.prototype.getOffset = function(where) {
          return this._offset[where];
        };
        ol_style_FlowLine.prototype.setOffset = function(width, where) {
          width = Math.max(0, parseFloat(width));
          switch (where) {
            case 0: {
              this._offset[0] = width;
              break;
            }
            case 1: {
              this._offset[1] = width;
              break;
            }
          }
        };
        ol_style_FlowLine.prototype.setLineCap = function(cap) {
          this._lineCap = cap === "round" ? "round" : "butt";
        };
        ol_style_FlowLine.prototype.getWidth = function(feature, step) {
          if (this._widthFn)
            return this._widthFn(feature, step);
          var w2 = typeof this._width2 === "number" ? this._width2 : this._width;
          return this._width + (w2 - this._width) * step;
        };
        ol_style_FlowLine.prototype.setColor = function(color) {
          try {
            this._color = asArray(color);
          } catch (e) {
            this._color = [0, 0, 0, 1];
          }
        };
        ol_style_FlowLine.prototype.setColor2 = function(color) {
          try {
            this._color2 = asArray(color);
          } catch (e) {
            this._color2 = null;
          }
        };
        ol_style_FlowLine.prototype.setArrowColor = function(color) {
          try {
            this._acolor = asString(color);
          } catch (e) {
            this._acolor = null;
          }
        };
        ol_style_FlowLine.prototype.getColor = function(feature, step) {
          if (this._colorFn)
            return asString(this._colorFn(feature, step));
          var color = this._color;
          var color2 = this._color2 || this._color;
          return "rgba(" + +Math.round(color[0] + (color2[0] - color[0]) * step) + "," + Math.round(color[1] + (color2[1] - color[1]) * step) + "," + Math.round(color[2] + (color2[2] - color[2]) * step) + "," + (color[3] + (color2[3] - color[3]) * step) + ")";
        };
        ol_style_FlowLine.prototype.getArrow = function() {
          return this._arrow;
        };
        ol_style_FlowLine.prototype.setArrow = function(n) {
          this._arrow = parseInt(n);
          if (this._arrow < -1 || this._arrow > 2)
            this._arrow = 0;
        };
        ol_style_FlowLine.prototype.getArrowSize = function() {
          return this._arrowSize || [16, 16];
        };
        ol_style_FlowLine.prototype.setArrowSize = function(size) {
          if (Array.isArray(size))
            this._arrowSize = size;
          else if (typeof size === "number")
            this._arrowSize = [size, size];
        };
        ol_style_FlowLine.prototype.drawArrow = function(ctx, p0, p1, width, ratio) {
          var asize = this.getArrowSize()[0] * ratio;
          var l = ol_coordinate_dist2d(p0, p1);
          var dx = (p0[0] - p1[0]) / l;
          var dy = (p0[1] - p1[1]) / l;
          width = Math.max(this.getArrowSize()[1] / 2, width / 2) * ratio;
          ctx.beginPath();
          ctx.moveTo(p0[0], p0[1]);
          ctx.lineTo(p0[0] - asize * dx + width * dy, p0[1] - asize * dy - width * dx);
          ctx.lineTo(p0[0] - asize * dx - width * dy, p0[1] - asize * dy + width * dx);
          ctx.lineTo(p0[0], p0[1]);
          ctx.fill();
        };
        ol_style_FlowLine.prototype._render = function(geom, e) {
          if (e.geometry.getType() === "LineString") {
            var i, g, p, ctx = e.context;
            if (!this._visible) {
              var a = e.pixelRatio / e.resolution;
              var cos = Math.cos(e.rotation);
              var sin = Math.sin(e.rotation);
              g = e.geometry.getCoordinates();
              var dx = geom[0][0] - g[0][0] * a * cos - g[0][1] * a * sin;
              var dy = geom[0][1] - g[0][0] * a * sin + g[0][1] * a * cos;
              geom = [];
              for (i = 0; p = g[i]; i++) {
                geom[i] = [
                  dx + p[0] * a * cos + p[1] * a * sin,
                  dy + p[0] * a * sin - p[1] * a * cos,
                  p[2]
                ];
              }
            }
            var asize = this.getArrowSize()[0] * e.pixelRatio;
            ctx.save();
            if (this.getOffset(0))
              this._splitAsize(geom, this.getOffset(0) * e.pixelRatio);
            if (this.getOffset(1))
              this._splitAsize(geom, this.getOffset(1) * e.pixelRatio, true);
            if (geom.length > 1 && (this.getArrow() === -1 || this.getArrow() === 2)) {
              p = this._splitAsize(geom, asize);
              if (this._acolor)
                ctx.fillStyle = this._acolor;
              else
                ctx.fillStyle = this.getColor(e.feature, 0);
              this.drawArrow(ctx, p[0], p[1], this.getWidth(e.feature, 0), e.pixelRatio);
            }
            if (geom.length > 1 && this.getArrow() > 0) {
              p = this._splitAsize(geom, asize, true);
              if (this._acolor)
                ctx.fillStyle = this._acolor;
              else
                ctx.fillStyle = this.getColor(e.feature, 1);
              this.drawArrow(ctx, p[0], p[1], this.getWidth(e.feature, 1), e.pixelRatio);
            }
            var geoms = this._splitInto(geom, 255, 2);
            var k = 0;
            var nb = geoms.length;
            ctx.lineJoin = "round";
            ctx.lineCap = this._lineCap || "butt";
            if (geoms.length > 1) {
              for (k = 0; k < geoms.length; k++) {
                var step = k / nb;
                g = geoms[k];
                ctx.lineWidth = this.getWidth(e.feature, step) * e.pixelRatio;
                ctx.strokeStyle = this.getColor(e.feature, step);
                ctx.beginPath();
                ctx.moveTo(g[0][0], g[0][1]);
                for (i = 1; p = g[i]; i++) {
                  ctx.lineTo(p[0], p[1]);
                }
                ctx.stroke();
              }
            }
            ctx.restore();
          }
        };
        ol_style_FlowLine.prototype._splitAsize = function(geom, asize, end) {
          var p, p1, p0;
          var dl, d = 0;
          if (end)
            p0 = geom.pop();
          else
            p0 = geom.shift();
          p = p0;
          while (geom.length) {
            if (end)
              p1 = geom.pop();
            else
              p1 = geom.shift();
            dl = ol_coordinate_dist2d(p, p1);
            if (d + dl > asize) {
              p = [p[0] + (p1[0] - p[0]) * (asize - d) / dl, p[1] + (p1[1] - p[1]) * (asize - d) / dl];
              dl = ol_coordinate_dist2d(p, p0);
              if (end) {
                geom.push(p1);
                geom.push(p);
                geom.push([p[0] + (p0[0] - p[0]) / dl, p[1] + (p0[1] - p[1]) / dl]);
              } else {
                geom.unshift(p1);
                geom.unshift(p);
                geom.unshift([p[0] + (p0[0] - p[0]) / dl, p[1] + (p0[1] - p[1]) / dl]);
              }
              break;
            }
            d += dl;
            p = p1;
          }
          return [p0, p];
        };
        ol_style_FlowLine.prototype._splitInto = function(geom, nb, min) {
          var i, p;
          var dt = this._noOverlap ? 1 : 0.9;
          var geoms = [];
          var dl, l = 0;
          for (i = 1; p = geom[i]; i++) {
            l += ol_coordinate_dist2d(geom[i - 1], p);
          }
          var length = Math.max(min || 2, l / (nb || 255));
          var p0 = geom[0];
          l = 0;
          var g = [p0];
          i = 1;
          p = geom[1];
          while (i < geom.length) {
            var dx = p[0] - p0[0];
            var dy = p[1] - p0[1];
            dl = Math.sqrt(dx * dx + dy * dy);
            if (l + dl > length) {
              var d = (length - l) / dl;
              g.push([
                p0[0] + dx * d,
                p0[1] + dy * d
              ]);
              geoms.push(g);
              p0 = [
                p0[0] + dx * d * dt,
                p0[1] + dy * d * dt
              ];
              g = [p0];
              l = 0;
            } else {
              l += dl;
              p0 = p;
              g.push(p0);
              i++;
              p = geom[i];
            }
          }
          geoms.push(g);
          return geoms;
        };
        var FlowLine = ol_style_FlowLine;
        var FlowLinevue_type_script_lang_js = {
          name: "ol-style-flowline",
          setup: function setup(props) {
            var styledObj = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("stylable", null);
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var style = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return new FlowLine(properties);
            });
            var setStyle = function setStyle2(val) {
              if (styledObj instanceof interaction_Draw || styledObj instanceof interaction_Modify) {
                styledObj.getOverlay().setStyle(val);
                styledObj.value.dispatchEvent("styleChanged");
                return;
              }
              try {
                styledObj.value.setStyle(val);
                styledObj.value.changed();
                styledObj.value.dispatchEvent("styleChanged");
              } catch (error) {
                styledObj.value.style_ = val;
                styledObj.value.values_.style = val;
                styledObj.value.changed();
                styledObj.value.dispatchEvent("styleChanged");
              }
            };
            var styleFunc = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              return function(feature) {
                if (properties.overrideStyleFunction != null) {
                  properties.overrideStyleFunction(feature, style.value);
                }
                return style.value;
              };
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              if (properties.overrideStyleFunction == null) {
                setStyle(style.value);
              } else {
                setStyle(styleFunc.value);
              }
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              if (properties.overrideStyleFunction == null) {
                setStyle(style.value);
              } else {
                setStyle(styleFunc.value);
              }
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              setStyle(null);
            });
            return {
              style
            };
          },
          props: {
            color: {
              type: [String, Function]
            },
            color2: {
              type: String
            },
            width: {
              type: [Number, Function]
            },
            width2: {
              type: Number
            },
            arrow: {
              type: Number
            },
            arrowColor: {
              type: String
            }
          }
        };
        const FlowLine_exports_ = exportHelper_default()(FlowLinevue_type_script_lang_js, [["render", FlowLinevue_type_template_id_31abb0eb_render]]);
        var styles_FlowLine = FlowLine_exports_;
        function styles_install(app) {
          if (styles_install.installed) {
            return;
          }
          styles_install.installed = true;
          app.component(styles_Style.name, styles_Style);
          app.component(styles_Circle.name, styles_Circle);
          app.component(styles_Stroke.name, styles_Stroke);
          app.component(styles_Fill.name, styles_Fill);
          app.component(styles_Icon.name, styles_Icon);
          app.component(styles_Text.name, styles_Text);
          app.component(styles_FlowLine.name, styles_FlowLine);
        }
        var components_styles = styles_install;
        function SelectInteractionvue_type_template_id_7a0923bf_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var Select_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var SelectEventType = {
          SELECT: "select"
        };
        var SelectEvent = function(_super) {
          Select_extends(SelectEvent2, _super);
          function SelectEvent2(type, selected, deselected, mapBrowserEvent) {
            var _this = _super.call(this, type) || this;
            _this.selected = selected;
            _this.deselected = deselected;
            _this.mapBrowserEvent = mapBrowserEvent;
            return _this;
          }
          return SelectEvent2;
        }(events_Event["a"]);
        var originalFeatureStyles = {};
        var Select_Select = function(_super) {
          Select_extends(Select, _super);
          function Select(opt_options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            var options = opt_options ? opt_options : {};
            _this.boundAddFeature_ = _this.addFeature_.bind(_this);
            _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);
            _this.condition_ = options.condition ? options.condition : singleClick;
            _this.addCondition_ = options.addCondition ? options.addCondition : never;
            _this.removeCondition_ = options.removeCondition ? options.removeCondition : never;
            _this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : shiftKeyOnly;
            _this.multi_ = options.multi ? options.multi : false;
            _this.filter_ = options.filter ? options.filter : functions["b"];
            _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
            _this.style_ = options.style !== void 0 ? options.style : Select_getDefaultStyleFunction();
            _this.features_ = options.features || new ol_Collection();
            var layerFilter;
            if (options.layers) {
              if (typeof options.layers === "function") {
                layerFilter = options.layers;
              } else {
                var layers_1 = options.layers;
                layerFilter = function(layer) {
                  return Object(ol_array["f"])(layers_1, layer);
                };
              }
            } else {
              layerFilter = functions["b"];
            }
            _this.layerFilter_ = layerFilter;
            _this.featureLayerAssociation_ = {};
            return _this;
          }
          Select.prototype.addFeatureLayerAssociation_ = function(feature, layer) {
            this.featureLayerAssociation_[Object(util["c"])(feature)] = layer;
          };
          Select.prototype.getFeatures = function() {
            return this.features_;
          };
          Select.prototype.getHitTolerance = function() {
            return this.hitTolerance_;
          };
          Select.prototype.getLayer = function(feature) {
            return this.featureLayerAssociation_[Object(util["c"])(feature)];
          };
          Select.prototype.setHitTolerance = function(hitTolerance) {
            this.hitTolerance_ = hitTolerance;
          };
          Select.prototype.setMap = function(map) {
            var currentMap = this.getMap();
            if (currentMap && this.style_) {
              this.features_.forEach(this.restorePreviousStyle_.bind(this));
            }
            _super.prototype.setMap.call(this, map);
            if (map) {
              this.features_.addEventListener(CollectionEventType.ADD, this.boundAddFeature_);
              this.features_.addEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
              if (this.style_) {
                this.features_.forEach(this.applySelectedStyle_.bind(this));
              }
            } else {
              this.features_.removeEventListener(CollectionEventType.ADD, this.boundAddFeature_);
              this.features_.removeEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
            }
          };
          Select.prototype.addFeature_ = function(evt) {
            var feature = evt.element;
            if (this.style_) {
              this.applySelectedStyle_(feature);
            }
            if (!this.getLayer(feature)) {
              var layer = this.getMap().getAllLayers().find(function(layer2) {
                if (layer2 instanceof Vector && layer2.getSource() && layer2.getSource().hasFeature(feature)) {
                  return layer2;
                }
              });
              if (layer) {
                this.addFeatureLayerAssociation_(feature, layer);
              }
            }
          };
          Select.prototype.removeFeature_ = function(evt) {
            var feature = evt.element;
            if (this.style_) {
              this.restorePreviousStyle_(feature);
            }
          };
          Select.prototype.getStyle = function() {
            return this.style_;
          };
          Select.prototype.applySelectedStyle_ = function(feature) {
            var key = Object(util["c"])(feature);
            if (!(key in originalFeatureStyles)) {
              originalFeatureStyles[key] = feature.getStyle();
            }
            feature.setStyle(this.style_);
          };
          Select.prototype.restorePreviousStyle_ = function(feature) {
            var interactions = this.getMap().getInteractions().getArray();
            for (var i = interactions.length - 1; i >= 0; --i) {
              var interaction = interactions[i];
              if (interaction !== this && interaction instanceof Select && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature) !== -1) {
                feature.setStyle(interaction.getStyle());
                return;
              }
            }
            var key = Object(util["c"])(feature);
            feature.setStyle(originalFeatureStyles[key]);
            delete originalFeatureStyles[key];
          };
          Select.prototype.removeFeatureLayerAssociation_ = function(feature) {
            delete this.featureLayerAssociation_[Object(util["c"])(feature)];
          };
          Select.prototype.handleEvent = function(mapBrowserEvent) {
            if (!this.condition_(mapBrowserEvent)) {
              return true;
            }
            var add = this.addCondition_(mapBrowserEvent);
            var remove = this.removeCondition_(mapBrowserEvent);
            var toggle = this.toggleCondition_(mapBrowserEvent);
            var set = !add && !remove && !toggle;
            var map = mapBrowserEvent.map;
            var features = this.getFeatures();
            var deselected = [];
            var selected = [];
            if (set) {
              Object(ol_obj["b"])(this.featureLayerAssociation_);
              map.forEachFeatureAtPixel(mapBrowserEvent.pixel, function(feature2, layer) {
                if (this.filter_(feature2, layer)) {
                  this.addFeatureLayerAssociation_(feature2, layer);
                  selected.push(feature2);
                  return !this.multi_;
                }
              }.bind(this), {
                layerFilter: this.layerFilter_,
                hitTolerance: this.hitTolerance_
              });
              for (var i = features.getLength() - 1; i >= 0; --i) {
                var feature = features.item(i);
                var index = selected.indexOf(feature);
                if (index > -1) {
                  selected.splice(index, 1);
                } else {
                  features.remove(feature);
                  deselected.push(feature);
                }
              }
              if (selected.length !== 0) {
                features.extend(selected);
              }
            } else {
              map.forEachFeatureAtPixel(mapBrowserEvent.pixel, function(feature2, layer) {
                if (this.filter_(feature2, layer)) {
                  if ((add || toggle) && !Object(ol_array["f"])(features.getArray(), feature2)) {
                    this.addFeatureLayerAssociation_(feature2, layer);
                    selected.push(feature2);
                  } else if ((remove || toggle) && Object(ol_array["f"])(features.getArray(), feature2)) {
                    deselected.push(feature2);
                    this.removeFeatureLayerAssociation_(feature2);
                  }
                  return !this.multi_;
                }
              }.bind(this), {
                layerFilter: this.layerFilter_,
                hitTolerance: this.hitTolerance_
              });
              for (var j = deselected.length - 1; j >= 0; --j) {
                features.remove(deselected[j]);
              }
              features.extend(selected);
            }
            if (selected.length > 0 || deselected.length > 0) {
              this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
            }
            return true;
          };
          return Select;
        }(interaction_Interaction);
        function Select_getDefaultStyleFunction() {
          var styles = createEditingStyle();
          Object(ol_array["c"])(styles[geom_GeometryType.POLYGON], styles[geom_GeometryType.LINE_STRING]);
          Object(ol_array["c"])(styles[geom_GeometryType.GEOMETRY_COLLECTION], styles[geom_GeometryType.LINE_STRING]);
          return function(feature) {
            if (!feature.getGeometry()) {
              return null;
            }
            return styles[feature.getGeometry().getType()];
          };
        }
        var interaction_Select = Select_Select;
        var SelectInteractionvue_type_script_lang_js = {
          name: "ol-interaction-select",
          emits: ["select"],
          setup: function setup(props, _ref) {
            var emit = _ref.emit;
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var select = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var s = new interaction_Select(_objectSpread2(_objectSpread2({}, properties), {}, {
                style: new style_Style()
              }));
              s.on("select", function(event) {
                emit("select", event);
              });
              return s;
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(select, function(newVal, oldVal) {
              map.removeInteraction(oldVal);
              map.addInteraction(newVal);
              map.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addInteraction(select.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeInteraction(select.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", select);
          },
          props: {
            multi: {
              type: Boolean,
              default: false
            },
            condition: {
              type: Function
            },
            filter: {
              type: Function
            },
            features: {
              type: [ol_Collection, Object]
            }
          }
        };
        const SelectInteraction_exports_ = exportHelper_default()(SelectInteractionvue_type_script_lang_js, [["render", SelectInteractionvue_type_template_id_7a0923bf_lang_true_render]]);
        var SelectInteraction = SelectInteraction_exports_;
        function ClusterSelectInteractionvue_type_template_id_52363d25_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var ol_interaction_SelectCluster = function(options) {
          options = options || {};
          this.pointRadius = options.pointRadius || 12;
          this.circleMaxObjects = options.circleMaxObjects || 10;
          this.maxObjects = options.maxObjects || 60;
          this.spiral = options.spiral !== false;
          this.animate = options.animate;
          this.animationDuration = options.animationDuration || 500;
          this.selectCluster_ = options.selectCluster !== false;
          this._autoClose = options.autoClose !== false;
          var overlay = this.overlayLayer_ = new Vector({
            source: new source_Vector({
              features: new ol_Collection(),
              wrapX: options.wrapX,
              useSpatialIndex: true
            }),
            name: "Cluster overlay",
            updateWhileAnimating: true,
            updateWhileInteracting: true,
            displayInLayerSwitcher: false,
            style: options.featureStyle
          });
          if (options.layers) {
            if (typeof options.layers == "function") {
              var fnLayers = options.layers;
              options.layers = function(layer) {
                return layer === overlay || fnLayers(layer);
              };
            } else if (options.layers.push) {
              options.layers.push(this.overlayLayer_);
            }
          }
          if (options.filter) {
            var fnFilter = options.filter;
            options.filter = function(f, l) {
              if (!l && f.get("selectclusterlink"))
                return false;
              else
                return fnFilter(f, l);
            };
          } else
            options.filter = function(f, l) {
              if (!l && f.get("selectclusterlink"))
                return false;
              else
                return true;
            };
          this.filter_ = options.filter;
          if (!this._autoClose && !options.toggleCondition) {
            options.toggleCondition = singleClick;
          }
          interaction_Select.call(this, options);
          this.on("select", this.selectCluster.bind(this));
        };
        util_ext(ol_interaction_SelectCluster, interaction_Select);
        ol_interaction_SelectCluster.prototype.setMap = function(map) {
          if (this.getMap()) {
            this.getMap().removeLayer(this.overlayLayer_);
          }
          if (this._listener)
            Object(Observable["b"])(this._listener);
          this._listener = null;
          interaction_Select.prototype.setMap.call(this, map);
          this.overlayLayer_.setMap(map);
          if (map && map.getView()) {
            this._listener = map.getView().on("change:resolution", this.clear.bind(this));
          }
        };
        ol_interaction_SelectCluster.prototype.clear = function() {
          this.getFeatures().clear();
          this.overlayLayer_.getSource().clear();
        };
        ol_interaction_SelectCluster.prototype.getLayer = function() {
          return this.overlayLayer_;
        };
        ol_interaction_SelectCluster.prototype.selectCluster = function(e) {
          if (e instanceof ol_Feature) {
            e = { selected: [e] };
          }
          if (!e.selected.length) {
            if (this._autoClose) {
              this.clear();
            } else {
              const deselectedFeatures = e.deselected;
              deselectedFeatures.forEach((deselectedFeature) => {
                const selectClusterFeatures = deselectedFeature.get("selectcluserfeatures");
                selectClusterFeatures.forEach((selectClusterFeature) => {
                  this.overlayLayer_.getSource().removeFeature(selectClusterFeature);
                });
              });
            }
            return;
          }
          var feature = e.selected[0];
          if (feature.get("selectclusterfeature"))
            return;
          var source = this.overlayLayer_.getSource();
          if (this._autoClose) {
            source.clear();
          }
          var cluster = feature.get("features");
          if (!cluster || cluster.length == 1)
            return;
          if (!this.selectCluster_)
            this.getFeatures().clear();
          var center = feature.getGeometry().getCoordinates();
          var pix = this.getMap().getView().getResolution();
          var r, a, i, max;
          var p, cf, lk;
          var features = [];
          if (!this.spiral || cluster.length <= this.circleMaxObjects) {
            max = Math.min(cluster.length, this.circleMaxObjects);
            r = pix * this.pointRadius * (0.5 + max / 4);
            for (i = 0; i < max; i++) {
              a = 2 * Math.PI * i / max;
              if (max == 2 || max == 4)
                a += Math.PI / 4;
              p = [center[0] + r * Math.sin(a), center[1] + r * Math.cos(a)];
              cf = new ol_Feature({ "selectclusterfeature": true, "features": [cluster[i]], geometry: new geom_Point(p) });
              cf.setStyle(cluster[i].getStyle());
              features.push(cf);
              lk = new ol_Feature({ "selectclusterlink": true, geometry: new geom_LineString([center, p]) });
              features.push(lk);
            }
          } else {
            a = 0;
            var d = 2 * this.pointRadius;
            max = Math.min(this.maxObjects, cluster.length);
            for (i = 0; i < max; i++) {
              r = d / 2 + d * a / (2 * Math.PI);
              a = a + (d + 0.1) / r;
              var dx = pix * r * Math.sin(a);
              var dy = pix * r * Math.cos(a);
              p = [center[0] + dx, center[1] + dy];
              cf = new ol_Feature({ "selectclusterfeature": true, "features": [cluster[i]], geometry: new geom_Point(p) });
              cf.setStyle(cluster[i].getStyle());
              features.push(cf);
              lk = new ol_Feature({ "selectclusterlink": true, geometry: new geom_LineString([center, p]) });
              features.push(lk);
            }
          }
          feature.set("selectcluserfeatures", features);
          if (this.animate) {
            this.animateCluster_(center, features);
          } else {
            source.addFeatures(features);
          }
        };
        ol_interaction_SelectCluster.prototype.animateCluster_ = function(center, features) {
          if (this.listenerKey_) {
            Object(Observable["b"])(this.listenerKey_);
          }
          if (!features.length)
            return;
          var style = this.overlayLayer_.getStyle();
          var stylefn = typeof style == "function" ? style : style.length ? function() {
            return style;
          } : function() {
            return [style];
          };
          var duration = this.animationDuration || 500;
          var start = new Date().getTime();
          function animate(event) {
            var vectorContext = event.vectorContext || util_getVectorContext(event);
            var ratio = event.frameState.pixelRatio;
            var res = this.getMap().getView().getResolution();
            var e = easeOut((event.frameState.time - start) / duration);
            for (var i = 0, feature2; feature2 = features[i]; i++)
              if (feature2.get("features")) {
                var pt = feature2.getGeometry().getCoordinates();
                pt[0] = center[0] + e * (pt[0] - center[0]);
                pt[1] = center[1] + e * (pt[1] - center[1]);
                var geo = new geom_Point(pt);
                var st = stylefn(feature2, res);
                for (var s = 0; s < st.length; s++) {
                  var sc;
                  var imgs = ol_Map.prototype.getFeaturesAtPixel ? false : st[s].getImage();
                  if (imgs) {
                    sc = imgs.getScale();
                    imgs.setScale(ratio);
                  }
                  if (vectorContext.setStyle) {
                    vectorContext.setStyle(st[s]);
                    vectorContext.drawGeometry(geo);
                  } else {
                    vectorContext.setImageStyle(imgs);
                    vectorContext.drawPointGeometry(geo);
                  }
                  if (imgs)
                    imgs.setScale(sc);
                }
              }
            if (e > 1) {
              Object(Observable["b"])(this.listenerKey_);
              this.overlayLayer_.getSource().addFeatures(features);
              this.overlayLayer_.changed();
              return;
            }
            event.frameState.animate = true;
          }
          this.listenerKey_ = this.overlayLayer_.on(["postcompose", "postrender"], animate.bind(this));
          var feature = new ol_Feature(new geom_Point(this.getMap().getView().getCenter()));
          feature.setStyle(new style_Style({ image: new style_Circle({}) }));
          this.overlayLayer_.getSource().addFeature(feature);
        };
        ol_interaction_SelectCluster.prototype.getClusterExtent = function(feature) {
          if (!feature.get("features"))
            return null;
          var extent = createEmpty();
          feature.get("features").forEach(function(f) {
            extent = extend2(extent, f.getGeometry().getExtent());
          });
          if (extent[0] === extent[2] && extent[1] === extent[3])
            return null;
          return extent;
        };
        var SelectCluster = ol_interaction_SelectCluster;
        var ClusterSelectInteractionvue_type_script_lang_js = {
          name: "ol-interaction-clusterselect",
          emits: ["select"],
          setup: function setup(props, _ref) {
            var emit = _ref.emit;
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var select = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var s = new SelectCluster(_objectSpread2(_objectSpread2({}, properties), {}, {
                style: new style_Style()
              }));
              s.on("select", function(event) {
                emit("select", event);
              });
              return s;
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(select, function(newVal, oldVal) {
              map.removeInteraction(oldVal);
              map.addInteraction(newVal);
              map.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addInteraction(select.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeInteraction(select.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", select);
          },
          props: {
            multi: {
              type: Boolean,
              default: false
            },
            condition: {
              type: Function
            },
            filter: {
              type: Function
            },
            pointRadius: {
              type: Number,
              default: 7
            },
            animate: {
              type: Boolean,
              default: true
            },
            featureStyle: {
              type: Function
            },
            style: {
              type: Function
            }
          }
        };
        const ClusterSelectInteraction_exports_ = exportHelper_default()(ClusterSelectInteractionvue_type_script_lang_js, [["render", ClusterSelectInteractionvue_type_template_id_52363d25_lang_true_render]]);
        var ClusterSelectInteraction = ClusterSelectInteraction_exports_;
        function DrawInteractionvue_type_template_id_403e40bc_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var DrawInteractionvue_type_script_lang_js = {
          name: "ol-interaction-draw",
          emits: ["drawstart", "drawend"],
          setup: function setup(props, _ref) {
            var emit = _ref.emit;
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorSource");
            var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props), type = _toRefs.type, clickTolerance = _toRefs.clickTolerance, dragVertexDelay = _toRefs.dragVertexDelay, snapTolerance = _toRefs.snapTolerance, stopClick = _toRefs.stopClick, maxPoints = _toRefs.maxPoints, minPoints = _toRefs.minPoints, finishCondition = _toRefs.finishCondition, geometryFunction = _toRefs.geometryFunction, geometryName = _toRefs.geometryName, condition = _toRefs.condition, freehand = _toRefs.freehand, freehandCondition = _toRefs.freehandCondition, wrapX = _toRefs.wrapX;
            var createDraw = function createDraw2() {
              var draw2 = new interaction_Draw({
                source: source.value,
                type: type.value,
                clickTolerance: clickTolerance.value,
                dragVertexDelay: dragVertexDelay.value,
                snapTolerance: snapTolerance.value,
                stopClick: stopClick.value,
                maxPoints: maxPoints.value,
                minPoints: minPoints.value,
                finishCondition: finishCondition.value,
                geometryFunction: geometryFunction.value,
                geometryName: geometryName.value,
                condition: condition.value,
                freehand: freehand.value,
                freehandCondition: freehandCondition.value,
                wrapX: wrapX.value
              });
              draw2.on("drawstart", function(event) {
                emit("drawstart", event);
              });
              draw2.on("drawend", function(event) {
                emit("drawend", event);
              });
              return draw2;
            };
            var draw = createDraw();
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])([type, clickTolerance, dragVertexDelay, snapTolerance, stopClick, maxPoints, minPoints, finishCondition, geometryFunction, geometryName, condition, freehand, freehandCondition, wrapX], function() {
              map.removeInteraction(draw);
              draw = createDraw();
              map.addInteraction(draw);
              draw.changed();
              map.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addInteraction(draw);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeInteraction(draw);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", draw);
          },
          props: {
            type: {
              type: String,
              required: true
            },
            clickTolerance: {
              type: Number,
              default: 6
            },
            dragVertexDelay: {
              type: Number,
              default: 500
            },
            snapTolerance: {
              type: Number,
              default: 12
            },
            stopClick: {
              type: Boolean,
              default: false
            },
            maxPoints: {
              type: Number
            },
            minPoints: {
              type: Number
            },
            finishCondition: {
              type: Function
            },
            geometryFunction: {
              type: Function
            },
            geometryName: {
              type: String
            },
            condition: {
              type: Function
            },
            freehand: {
              type: Boolean,
              default: false
            },
            freehandCondition: {
              type: Function
            },
            wrapX: {
              type: Boolean,
              default: false
            }
          }
        };
        const DrawInteraction_exports_ = exportHelper_default()(DrawInteractionvue_type_script_lang_js, [["render", DrawInteractionvue_type_template_id_403e40bc_lang_true_render]]);
        var DrawInteraction = DrawInteraction_exports_;
        function SnapInteractionvue_type_template_id_0e672858_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var Snap_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        function getFeatureFromEvent(evt) {
          if (evt.feature) {
            return evt.feature;
          } else if (evt.element) {
            return evt.element;
          }
        }
        var Snap_tempSegment = [];
        var Snap_Snap = function(_super) {
          Snap_extends(Snap, _super);
          function Snap(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var pointerOptions = options;
            if (!pointerOptions.handleDownEvent) {
              pointerOptions.handleDownEvent = functions["b"];
            }
            if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = functions["a"];
            }
            _this = _super.call(this, pointerOptions) || this;
            _this.source_ = options.source ? options.source : null;
            _this.vertex_ = options.vertex !== void 0 ? options.vertex : true;
            _this.edge_ = options.edge !== void 0 ? options.edge : true;
            _this.features_ = options.features ? options.features : null;
            _this.featuresListenerKeys_ = [];
            _this.featureChangeListenerKeys_ = {};
            _this.indexedFeaturesExtents_ = {};
            _this.pendingFeatures_ = {};
            _this.pixelTolerance_ = options.pixelTolerance !== void 0 ? options.pixelTolerance : 10;
            _this.rBush_ = new structs_RBush();
            _this.SEGMENT_WRITERS_ = {
              "Point": _this.writePointGeometry_.bind(_this),
              "LineString": _this.writeLineStringGeometry_.bind(_this),
              "LinearRing": _this.writeLineStringGeometry_.bind(_this),
              "Polygon": _this.writePolygonGeometry_.bind(_this),
              "MultiPoint": _this.writeMultiPointGeometry_.bind(_this),
              "MultiLineString": _this.writeMultiLineStringGeometry_.bind(_this),
              "MultiPolygon": _this.writeMultiPolygonGeometry_.bind(_this),
              "GeometryCollection": _this.writeGeometryCollectionGeometry_.bind(_this),
              "Circle": _this.writeCircleGeometry_.bind(_this)
            };
            return _this;
          }
          Snap.prototype.addFeature = function(feature, opt_listen) {
            var register = opt_listen !== void 0 ? opt_listen : true;
            var feature_uid = Object(util["c"])(feature);
            var geometry = feature.getGeometry();
            if (geometry) {
              var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];
              if (segmentWriter) {
                this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());
                segmentWriter(feature, geometry);
              }
            }
            if (register) {
              this.featureChangeListenerKeys_[feature_uid] = Object(events["a"])(feature, EventType["a"].CHANGE, this.handleFeatureChange_, this);
            }
          };
          Snap.prototype.forEachFeatureAdd_ = function(feature) {
            this.addFeature(feature);
          };
          Snap.prototype.forEachFeatureRemove_ = function(feature) {
            this.removeFeature(feature);
          };
          Snap.prototype.getFeatures_ = function() {
            var features;
            if (this.features_) {
              features = this.features_;
            } else if (this.source_) {
              features = this.source_.getFeatures();
            }
            return features;
          };
          Snap.prototype.handleEvent = function(evt) {
            var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
            if (result.snapped) {
              evt.coordinate = result.vertex.slice(0, 2);
              evt.pixel = result.vertexPixel;
            }
            return _super.prototype.handleEvent.call(this, evt);
          };
          Snap.prototype.handleFeatureAdd_ = function(evt) {
            var feature = getFeatureFromEvent(evt);
            this.addFeature(feature);
          };
          Snap.prototype.handleFeatureRemove_ = function(evt) {
            var feature = getFeatureFromEvent(evt);
            this.removeFeature(feature);
          };
          Snap.prototype.handleFeatureChange_ = function(evt) {
            var feature = evt.target;
            if (this.handlingDownUpSequence) {
              var uid = Object(util["c"])(feature);
              if (!(uid in this.pendingFeatures_)) {
                this.pendingFeatures_[uid] = feature;
              }
            } else {
              this.updateFeature_(feature);
            }
          };
          Snap.prototype.handleUpEvent = function(evt) {
            var featuresToUpdate = Object(ol_obj["c"])(this.pendingFeatures_);
            if (featuresToUpdate.length) {
              featuresToUpdate.forEach(this.updateFeature_.bind(this));
              this.pendingFeatures_ = {};
            }
            return false;
          };
          Snap.prototype.removeFeature = function(feature, opt_unlisten) {
            var unregister = opt_unlisten !== void 0 ? opt_unlisten : true;
            var feature_uid = Object(util["c"])(feature);
            var extent = this.indexedFeaturesExtents_[feature_uid];
            if (extent) {
              var rBush = this.rBush_;
              var nodesToRemove_1 = [];
              rBush.forEachInExtent(extent, function(node) {
                if (feature === node.feature) {
                  nodesToRemove_1.push(node);
                }
              });
              for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {
                rBush.remove(nodesToRemove_1[i]);
              }
            }
            if (unregister) {
              Object(events["c"])(this.featureChangeListenerKeys_[feature_uid]);
              delete this.featureChangeListenerKeys_[feature_uid];
            }
          };
          Snap.prototype.setMap = function(map) {
            var currentMap = this.getMap();
            var keys = this.featuresListenerKeys_;
            var features = this.getFeatures_();
            if (currentMap) {
              keys.forEach(events["c"]);
              keys.length = 0;
              features.forEach(this.forEachFeatureRemove_.bind(this));
            }
            _super.prototype.setMap.call(this, map);
            if (map) {
              if (this.features_) {
                keys.push(Object(events["a"])(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), Object(events["a"])(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));
              } else if (this.source_) {
                keys.push(Object(events["a"])(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), Object(events["a"])(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));
              }
              features.forEach(this.forEachFeatureAdd_.bind(this));
            }
          };
          Snap.prototype.snapTo = function(pixel, pixelCoordinate, map) {
            var lowerLeft = map.getCoordinateFromPixel([
              pixel[0] - this.pixelTolerance_,
              pixel[1] + this.pixelTolerance_
            ]);
            var upperRight = map.getCoordinateFromPixel([
              pixel[0] + this.pixelTolerance_,
              pixel[1] - this.pixelTolerance_
            ]);
            var box = boundingExtent([lowerLeft, upperRight]);
            var segments = this.rBush_.getInExtent(box);
            if (this.vertex_ && !this.edge_) {
              segments = segments.filter(function(segment) {
                return segment.feature.getGeometry().getType() !== geom_GeometryType.CIRCLE;
              });
            }
            var snapped = false;
            var vertex = null;
            var vertexPixel = null;
            if (segments.length === 0) {
              return {
                snapped,
                vertex,
                vertexPixel
              };
            }
            var projection = map.getView().getProjection();
            var projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);
            var closestSegmentData;
            var minSquaredDistance = Infinity;
            for (var i = 0; i < segments.length; ++i) {
              var segmentData = segments[i];
              Snap_tempSegment[0] = fromUserCoordinate(segmentData.segment[0], projection);
              Snap_tempSegment[1] = fromUserCoordinate(segmentData.segment[1], projection);
              var delta = squaredDistanceToSegment(projectedCoordinate, Snap_tempSegment);
              if (delta < minSquaredDistance) {
                closestSegmentData = segmentData;
                minSquaredDistance = delta;
              }
            }
            var closestSegment = closestSegmentData.segment;
            if (this.vertex_ && !this.edge_) {
              var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
              var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
              var squaredDist1 = coordinate_squaredDistance(pixel, pixel1);
              var squaredDist2 = coordinate_squaredDistance(pixel, pixel2);
              var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
              if (dist <= this.pixelTolerance_) {
                snapped = true;
                vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                vertexPixel = map.getPixelFromCoordinate(vertex);
              }
            } else if (this.edge_) {
              var isCircle = closestSegmentData.feature.getGeometry().getType() === geom_GeometryType.CIRCLE;
              if (isCircle) {
                var circleGeometry = closestSegmentData.feature.getGeometry();
                var userProjection = getUserProjection();
                if (userProjection) {
                  circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                }
                vertex = toUserCoordinate(closestOnCircle(projectedCoordinate, circleGeometry), projection);
              } else {
                Snap_tempSegment[0] = fromUserCoordinate(closestSegment[0], projection);
                Snap_tempSegment[1] = fromUserCoordinate(closestSegment[1], projection);
                vertex = toUserCoordinate(closestOnSegment(projectedCoordinate, Snap_tempSegment), projection);
              }
              vertexPixel = map.getPixelFromCoordinate(vertex);
              if (coordinate_distance(pixel, vertexPixel) <= this.pixelTolerance_) {
                snapped = true;
                if (this.vertex_ && !isCircle) {
                  var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                  var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                  var squaredDist1 = coordinate_squaredDistance(vertexPixel, pixel1);
                  var squaredDist2 = coordinate_squaredDistance(vertexPixel, pixel2);
                  var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                  if (dist <= this.pixelTolerance_) {
                    vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                    vertexPixel = map.getPixelFromCoordinate(vertex);
                  }
                }
              }
            }
            if (snapped) {
              vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
            }
            return {
              snapped,
              vertex,
              vertexPixel
            };
          };
          Snap.prototype.updateFeature_ = function(feature) {
            this.removeFeature(feature, false);
            this.addFeature(feature, false);
          };
          Snap.prototype.writeCircleGeometry_ = function(feature, geometry) {
            var projection = this.getMap().getView().getProjection();
            var circleGeometry = geometry;
            var userProjection = getUserProjection();
            if (userProjection) {
              circleGeometry = circleGeometry.clone().transform(userProjection, projection);
            }
            var polygon = fromCircle(circleGeometry);
            if (userProjection) {
              polygon.transform(projection, userProjection);
            }
            var coordinates = polygon.getCoordinates()[0];
            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
              var segment = coordinates.slice(i, i + 2);
              var segmentData = {
                feature,
                segment
              };
              this.rBush_.insert(boundingExtent(segment), segmentData);
            }
          };
          Snap.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {
            var geometries = geometry.getGeometriesArray();
            for (var i = 0; i < geometries.length; ++i) {
              var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];
              if (segmentWriter) {
                segmentWriter(feature, geometries[i]);
              }
            }
          };
          Snap.prototype.writeLineStringGeometry_ = function(feature, geometry) {
            var coordinates = geometry.getCoordinates();
            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
              var segment = coordinates.slice(i, i + 2);
              var segmentData = {
                feature,
                segment
              };
              this.rBush_.insert(boundingExtent(segment), segmentData);
            }
          };
          Snap.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {
            var lines = geometry.getCoordinates();
            for (var j = 0, jj = lines.length; j < jj; ++j) {
              var coordinates = lines[j];
              for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                var segment = coordinates.slice(i, i + 2);
                var segmentData = {
                  feature,
                  segment
                };
                this.rBush_.insert(boundingExtent(segment), segmentData);
              }
            }
          };
          Snap.prototype.writeMultiPointGeometry_ = function(feature, geometry) {
            var points = geometry.getCoordinates();
            for (var i = 0, ii = points.length; i < ii; ++i) {
              var coordinates = points[i];
              var segmentData = {
                feature,
                segment: [coordinates, coordinates]
              };
              this.rBush_.insert(geometry.getExtent(), segmentData);
            }
          };
          Snap.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {
            var polygons = geometry.getCoordinates();
            for (var k = 0, kk = polygons.length; k < kk; ++k) {
              var rings = polygons[k];
              for (var j = 0, jj = rings.length; j < jj; ++j) {
                var coordinates = rings[j];
                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                  var segment = coordinates.slice(i, i + 2);
                  var segmentData = {
                    feature,
                    segment
                  };
                  this.rBush_.insert(boundingExtent(segment), segmentData);
                }
              }
            }
          };
          Snap.prototype.writePointGeometry_ = function(feature, geometry) {
            var coordinates = geometry.getCoordinates();
            var segmentData = {
              feature,
              segment: [coordinates, coordinates]
            };
            this.rBush_.insert(geometry.getExtent(), segmentData);
          };
          Snap.prototype.writePolygonGeometry_ = function(feature, geometry) {
            var rings = geometry.getCoordinates();
            for (var j = 0, jj = rings.length; j < jj; ++j) {
              var coordinates = rings[j];
              for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                var segment = coordinates.slice(i, i + 2);
                var segmentData = {
                  feature,
                  segment
                };
                this.rBush_.insert(boundingExtent(segment), segmentData);
              }
            }
          };
          return Snap;
        }(Pointer);
        var interaction_Snap = Snap_Snap;
        var SnapInteractionvue_type_script_lang_js = {
          name: "ol-interaction-snap",
          setup: function setup(props) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorSource");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var createSnap = function createSnap2() {
              var s = new interaction_Snap(_objectSpread2(_objectSpread2({}, properties), {}, {
                source: source.value
              }));
              return s;
            };
            var snap = createSnap();
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(properties, function() {
              map.removeInteraction(snap);
              snap = createSnap();
              map.addInteraction(snap);
              map.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addInteraction(snap);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeInteraction(snap);
            });
          },
          props: {
            vertex: {
              type: Boolean,
              default: true
            },
            edge: {
              type: Boolean,
              default: true
            },
            pixelTolerance: {
              type: Number,
              default: 10
            }
          }
        };
        const SnapInteraction_exports_ = exportHelper_default()(SnapInteractionvue_type_script_lang_js, [["render", SnapInteractionvue_type_template_id_0e672858_lang_true_render]]);
        var SnapInteraction = SnapInteraction_exports_;
        function ModifyInteractionvue_type_template_id_13ac86b6_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var ModifyInteractionvue_type_script_lang_js = {
          name: "ol-interaction-modify",
          emits: ["modifystart", "modifyend"],
          setup: function setup(props, _ref) {
            var emit = _ref.emit;
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var source = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorSource");
            var _toRefs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props), features = _toRefs.features, condition = _toRefs.condition, deleteCondition = _toRefs.deleteCondition, insertVertexCondition = _toRefs.insertVertexCondition, pixelTolerance = _toRefs.pixelTolerance, wrapX = _toRefs.wrapX, hitDetection = _toRefs.hitDetection;
            var createModify = function createModify2() {
              var modify2 = new interaction_Modify({
                source: source.value,
                features: features.value,
                condition: condition.value,
                deleteCondition: deleteCondition.value,
                insertVertexCondition: insertVertexCondition.value,
                pixelTolerance: pixelTolerance.value,
                wrapX: wrapX.value,
                hitDetection: hitDetection.value
              });
              modify2.on("modifystart", function(event) {
                emit("modifystart", event);
              });
              modify2.on("modifyend", function(event) {
                emit("modifyend", event);
              });
              return modify2;
            };
            var modify = createModify();
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])([condition, deleteCondition, insertVertexCondition, pixelTolerance, wrapX, hitDetection], function() {
              map.removeInteraction(modify);
              modify = createModify();
              map.addInteraction(modify);
              modify.changed();
              map.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addInteraction(modify);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeInteraction(modify);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", modify);
          },
          props: {
            condition: {
              type: Function
            },
            deleteCondition: {
              type: Function
            },
            insertVertexCondition: {
              type: Function
            },
            pixelTolerance: {
              type: Number,
              default: 10
            },
            wrapX: {
              type: Boolean,
              default: false
            },
            hitDetection: {
              type: Boolean
            },
            features: {
              type: [ol_Collection, Object]
            }
          }
        };
        const ModifyInteraction_exports_ = exportHelper_default()(ModifyInteractionvue_type_script_lang_js, [["render", ModifyInteractionvue_type_template_id_13ac86b6_lang_true_render]]);
        var ModifyInteraction = ModifyInteraction_exports_;
        function TransformInteractionvue_type_template_id_044a350b_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var ol_interaction_Transform = function(options) {
          if (!options)
            options = {};
          var self2 = this;
          this.selection_ = new ol_Collection();
          this.handles_ = new ol_Collection();
          this.overlayLayer_ = new Vector({
            source: new source_Vector({
              features: this.handles_,
              useSpatialIndex: false,
              wrapX: false
            }),
            name: "Transform overlay",
            displayInLayerSwitcher: false,
            style: function(feature) {
              return self2.style[(feature.get("handle") || "default") + (feature.get("constraint") || "") + (feature.get("option") || "")];
            }
          });
          Pointer.call(this, {
            handleDownEvent: this.handleDownEvent_,
            handleDragEvent: this.handleDragEvent_,
            handleMoveEvent: this.handleMoveEvent_,
            handleUpEvent: this.handleUpEvent_
          });
          this.features_ = options.features;
          if (typeof options.filter === "function")
            this._filter = options.filter;
          this.layers_ = options.layers ? options.layers instanceof Array ? options.layers : [options.layers] : null;
          this._handleEvent = options.condition || function() {
            return true;
          };
          this.addFn_ = options.addCondition || function() {
            return false;
          };
          this.set("translateFeature", options.translateFeature !== false);
          this.set("translate", options.translate !== false);
          this.set("translateBBox", options.translateBBox === true);
          this.set("stretch", options.stretch !== false);
          this.set("scale", options.scale !== false);
          this.set("rotate", options.rotate !== false);
          this.set("keepAspectRatio", options.keepAspectRatio || function(e) {
            return e.originalEvent.shiftKey;
          });
          this.set("modifyCenter", options.modifyCenter || function(e) {
            return e.originalEvent.metaKey || e.originalEvent.ctrlKey;
          });
          this.set("noFlip", options.noFlip || false);
          this.set("selection", options.selection !== false);
          this.set("hitTolerance", options.hitTolerance || 0);
          this.set("enableRotatedTransform", options.enableRotatedTransform || false);
          this.set("keepRectangle", options.keepRectangle || false);
          this.on("propertychange", function() {
            this.drawSketch_();
          });
          this.setDefaultStyle();
        };
        util_ext(ol_interaction_Transform, Pointer);
        ol_interaction_Transform.prototype.Cursors = {
          "default": "auto",
          "select": "pointer",
          "translate": "move",
          "rotate": "move",
          "rotate0": "move",
          "scale": "nesw-resize",
          "scale1": "nwse-resize",
          "scale2": "nesw-resize",
          "scale3": "nwse-resize",
          "scalev": "ew-resize",
          "scaleh1": "ns-resize",
          "scalev2": "ew-resize",
          "scaleh3": "ns-resize"
        };
        ol_interaction_Transform.prototype.setMap = function(map) {
          var oldMap = this.getMap();
          if (oldMap) {
            var targetElement = oldMap.getTargetElement();
            oldMap.removeLayer(this.overlayLayer_);
            if (this.previousCursor_ && targetElement) {
              targetElement.style.cursor = this.previousCursor_;
            }
            this.previousCursor_ = void 0;
          }
          Pointer.prototype.setMap.call(this, map);
          this.overlayLayer_.setMap(map);
          if (map === null) {
            this.select(null);
          }
          if (map !== null) {
            this.isTouch = /touch/.test(map.getViewport().className);
            this.setDefaultStyle();
          }
        };
        ol_interaction_Transform.prototype.setActive = function(b) {
          this.select(null);
          this.overlayLayer_.setVisible(b);
          Pointer.prototype.setActive.call(this, b);
        };
        ol_interaction_Transform.prototype.setDefaultStyle = function(options) {
          options = options || {};
          var stroke = options.pointStroke || new style_Stroke({ color: [255, 0, 0, 1], width: 1 });
          var strokedash = options.stroke || new style_Stroke({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] });
          var fill0 = options.fill || new style_Fill({ color: [255, 0, 0, 0.01] });
          var fill = options.pointFill || new style_Fill({ color: [255, 255, 255, 0.8] });
          var circle = new style_RegularShape({
            fill,
            stroke,
            radius: this.isTouch ? 12 : 6,
            points: 15
          });
          circle.getAnchor()[0] = this.isTouch ? -10 : -5;
          var bigpt = new style_RegularShape({
            fill,
            stroke,
            radius: this.isTouch ? 16 : 8,
            points: 4,
            angle: Math.PI / 4
          });
          var smallpt = new style_RegularShape({
            fill,
            stroke,
            radius: this.isTouch ? 12 : 6,
            points: 4,
            angle: Math.PI / 4
          });
          function createStyle(img, stroke2, fill2) {
            return [new style_Style({ image: img, stroke: stroke2, fill: fill2 })];
          }
          this.style = {
            "default": createStyle(bigpt, strokedash, fill0),
            "translate": createStyle(bigpt, stroke, fill),
            "rotate": createStyle(circle, stroke, fill),
            "rotate0": createStyle(bigpt, stroke, fill),
            "scale": createStyle(bigpt, stroke, fill),
            "scale1": createStyle(bigpt, stroke, fill),
            "scale2": createStyle(bigpt, stroke, fill),
            "scale3": createStyle(bigpt, stroke, fill),
            "scalev": createStyle(smallpt, stroke, fill),
            "scaleh1": createStyle(smallpt, stroke, fill),
            "scalev2": createStyle(smallpt, stroke, fill),
            "scaleh3": createStyle(smallpt, stroke, fill)
          };
          this.drawSketch_();
        };
        ol_interaction_Transform.prototype.setStyle = function(style, olstyle) {
          if (!olstyle)
            return;
          if (olstyle instanceof Array)
            this.style[style] = olstyle;
          else
            this.style[style] = [olstyle];
          for (var i = 0; i < this.style[style].length; i++) {
            var im = this.style[style][i].getImage();
            if (im) {
              if (style == "rotate")
                im.getAnchor()[0] = -5;
              if (this.isTouch)
                im.setScale(1.8);
            }
            var tx = this.style[style][i].getText();
            if (tx) {
              if (style == "rotate")
                tx.setOffsetX(this.isTouch ? 14 : 7);
              if (this.isTouch)
                tx.setScale(1.8);
            }
          }
          this.drawSketch_();
        };
        ol_interaction_Transform.prototype.getFeatureAtPixel_ = function(pixel) {
          var self2 = this;
          return this.getMap().forEachFeatureAtPixel(pixel, function(feature, layer) {
            var found = false;
            if (!layer) {
              if (feature === self2.bbox_) {
                if (self2.get("translateBBox")) {
                  return { feature, handle: "translate", constraint: "", option: "" };
                } else {
                  return false;
                }
              }
              self2.handles_.forEach(function(f) {
                if (f === feature)
                  found = true;
              });
              if (found)
                return { feature, handle: feature.get("handle"), constraint: feature.get("constraint"), option: feature.get("option") };
            }
            if (!self2.get("selection")) {
              if (self2.selection_.getArray().some(function(f) {
                return feature === f;
              })) {
                return { feature };
              }
              return null;
            }
            if (self2._filter) {
              if (self2._filter(feature, layer))
                return { feature };
              else
                return null;
            } else if (self2.layers_) {
              for (var i = 0; i < self2.layers_.length; i++) {
                if (self2.layers_[i] === layer)
                  return { feature };
              }
              return null;
            } else if (self2.features_) {
              self2.features_.forEach(function(f) {
                if (f === feature)
                  found = true;
              });
              if (found)
                return { feature };
              else
                return null;
            } else
              return { feature };
          }, { hitTolerance: this.get("hitTolerance") }) || {};
        };
        ol_interaction_Transform.prototype.getGeometryRotateToZero_ = function(f, clone2) {
          var origGeom = f.getGeometry();
          var viewRotation = this.getMap().getView().getRotation();
          if (viewRotation === 0 || !this.get("enableRotatedTransform")) {
            return clone2 ? origGeom.clone() : origGeom;
          }
          var rotGeom = origGeom.clone();
          rotGeom.rotate(viewRotation * -1, this.getMap().getView().getCenter());
          return rotGeom;
        };
        ol_interaction_Transform.prototype._isRectangle = function(geom) {
          if (this.get("keepRectangle") && geom.getType() === "Polygon") {
            var coords = geom.getCoordinates()[0];
            return coords.length === 5;
          }
          return false;
        };
        ol_interaction_Transform.prototype.drawSketch_ = function(center) {
          var i, f, geom;
          var keepRectangle = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry());
          this.overlayLayer_.getSource().clear();
          if (!this.selection_.getLength())
            return;
          var viewRotation = this.getMap().getView().getRotation();
          var ext = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent();
          var coords;
          if (keepRectangle) {
            coords = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4);
            coords.unshift(coords[3]);
          }
          ext = extent_buffer(ext, 0);
          this.selection_.forEach(function(f2) {
            var extendExt = this.getGeometryRotateToZero_(f2).getExtent();
            extend2(ext, extendExt);
          }.bind(this));
          if (center === true) {
            if (!this.ispt_) {
              this.overlayLayer_.getSource().addFeature(new ol_Feature({ geometry: new geom_Point(this.center_), handle: "rotate0" }));
              geom = fromExtent(ext);
              if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                geom.rotate(viewRotation, this.getMap().getView().getCenter());
              }
              f = this.bbox_ = new ol_Feature(geom);
              this.overlayLayer_.getSource().addFeature(f);
            }
          } else {
            if (this.ispt_) {
              var p = this.getMap().getPixelFromCoordinate([ext[0], ext[1]]);
              if (p) {
                ext = boundingExtent([
                  this.getMap().getCoordinateFromPixel([p[0] - 10, p[1] - 10]),
                  this.getMap().getCoordinateFromPixel([p[0] + 10, p[1] + 10])
                ]);
              }
            }
            geom = keepRectangle ? new geom_Polygon([coords]) : fromExtent(ext);
            if (this.get("enableRotatedTransform") && viewRotation !== 0) {
              geom.rotate(viewRotation, this.getMap().getView().getCenter());
            }
            f = this.bbox_ = new ol_Feature(geom);
            var features = [];
            var g = geom.getCoordinates()[0];
            if (!this.ispt_) {
              features.push(f);
              if (!this.iscircle_ && this.get("stretch") && this.get("scale"))
                for (i = 0; i < g.length - 1; i++) {
                  f = new ol_Feature({ geometry: new geom_Point([(g[i][0] + g[i + 1][0]) / 2, (g[i][1] + g[i + 1][1]) / 2]), handle: "scale", constraint: i % 2 ? "h" : "v", option: i });
                  features.push(f);
                }
              if (this.get("scale"))
                for (i = 0; i < g.length - 1; i++) {
                  f = new ol_Feature({ geometry: new geom_Point(g[i]), handle: "scale", option: i });
                  features.push(f);
                }
              if (this.get("translate") && !this.get("translateFeature")) {
                f = new ol_Feature({ geometry: new geom_Point([(g[0][0] + g[2][0]) / 2, (g[0][1] + g[2][1]) / 2]), handle: "translate" });
                features.push(f);
              }
            }
            if (!this.iscircle_ && this.get("rotate")) {
              f = new ol_Feature({ geometry: new geom_Point(g[3]), handle: "rotate" });
              features.push(f);
            }
            this.overlayLayer_.getSource().addFeatures(features);
          }
        };
        ol_interaction_Transform.prototype.select = function(feature, add) {
          if (!feature) {
            this.selection_.clear();
            this.drawSketch_();
            return;
          }
          if (!feature.getGeometry || !feature.getGeometry())
            return;
          if (add) {
            this.selection_.push(feature);
          } else {
            var index = this.selection_.getArray().indexOf(feature);
            this.selection_.removeAt(index);
          }
          this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
          this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
          this.drawSketch_();
          this.watchFeatures_();
          this.dispatchEvent({ type: "select", feature, features: this.selection_ });
        };
        ol_interaction_Transform.prototype.setSelection = function(features) {
          this.selection_.clear();
          features.forEach(function(feature) {
            this.selection_.push(feature);
          }.bind(this));
          this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
          this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
          this.drawSketch_();
          this.watchFeatures_();
          this.dispatchEvent({ type: "select", features: this.selection_ });
        };
        ol_interaction_Transform.prototype.watchFeatures_ = function() {
          if (this._featureListeners) {
            this._featureListeners.forEach(function(l) {
              Object(Observable["b"])(l);
            });
          }
          this._featureListeners = [];
          this.selection_.forEach(function(f) {
            this._featureListeners.push(f.on("change", function() {
              if (!this.isUpdating_) {
                this.drawSketch_();
              }
            }.bind(this)));
          }.bind(this));
        };
        ol_interaction_Transform.prototype.handleDownEvent_ = function(evt) {
          if (!this._handleEvent(evt, this.selection_))
            return;
          var sel = this.getFeatureAtPixel_(evt.pixel);
          var feature = sel.feature;
          if (this.selection_.getLength() && this.selection_.getArray().indexOf(feature) >= 0 && (this.ispt_ && this.get("translate") || this.get("translateFeature"))) {
            sel.handle = "translate";
          }
          if (sel.handle) {
            this.mode_ = sel.handle;
            this.opt_ = sel.option;
            this.constraint_ = sel.constraint;
            var viewRotation = this.getMap().getView().getRotation();
            this.coordinate_ = evt.coordinate;
            this.pixel_ = evt.pixel;
            this.geoms_ = [];
            this.rotatedGeoms_ = [];
            var extent = createEmpty();
            var rotExtent = createEmpty();
            for (var i = 0, f; f = this.selection_.item(i); i++) {
              this.geoms_.push(f.getGeometry().clone());
              extent = extend2(extent, f.getGeometry().getExtent());
              if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                var rotGeom = this.getGeometryRotateToZero_(f, true);
                this.rotatedGeoms_.push(rotGeom);
                rotExtent = extend2(rotExtent, rotGeom.getExtent());
              }
            }
            this.extent_ = fromExtent(extent).getCoordinates()[0];
            if (this.get("enableRotatedTransform") && viewRotation !== 0) {
              this.rotatedExtent_ = fromExtent(rotExtent).getCoordinates()[0];
            }
            if (this.mode_ === "rotate") {
              this.center_ = this.getCenter() || extent_getCenter(extent);
              var element = evt.map.getTargetElement();
              element.style.cursor = this.Cursors.rotate0;
              this.previousCursor_ = element.style.cursor;
            } else {
              this.center_ = extent_getCenter(extent);
            }
            this.angle_ = Math.atan2(this.center_[1] - evt.coordinate[1], this.center_[0] - evt.coordinate[0]);
            this.dispatchEvent({
              type: this.mode_ + "start",
              feature: this.selection_.item(0),
              features: this.selection_,
              pixel: evt.pixel,
              coordinate: evt.coordinate
            });
            return true;
          } else if (this.get("selection")) {
            if (feature) {
              if (!this.addFn_(evt))
                this.selection_.clear();
              var index = this.selection_.getArray().indexOf(feature);
              if (index < 0)
                this.selection_.push(feature);
              else
                this.selection_.removeAt(index);
            } else {
              this.selection_.clear();
            }
            this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : false;
            this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : false;
            this.drawSketch_();
            this.watchFeatures_();
            this.dispatchEvent({ type: "select", feature, features: this.selection_, pixel: evt.pixel, coordinate: evt.coordinate });
            return false;
          }
        };
        ol_interaction_Transform.prototype.getFeatures = function() {
          return this.selection_;
        };
        ol_interaction_Transform.prototype.getCenter = function() {
          return this.get("center");
        };
        ol_interaction_Transform.prototype.setCenter = function(c) {
          return this.set("center", c);
        };
        function projectVectorOnVector(displacement_vector, base) {
          var k = (displacement_vector[0] * base[0] + displacement_vector[1] * base[1]) / (base[0] * base[0] + base[1] * base[1]);
          return [base[0] * k, base[1] * k];
        }
        function countVector(start, end) {
          return [end[0] - start[0], end[1] - start[1]];
        }
        function movePoint(point, displacementVector) {
          return [point[0] + displacementVector[0], point[1] + displacementVector[1]];
        }
        ol_interaction_Transform.prototype.handleDragEvent_ = function(evt) {
          if (!this._handleEvent(evt, this.features_))
            return;
          var viewRotation = this.getMap().getView().getRotation();
          var i, j, f, geometry;
          var pt0 = [this.coordinate_[0], this.coordinate_[1]];
          var pt = [evt.coordinate[0], evt.coordinate[1]];
          this.isUpdating_ = true;
          switch (this.mode_) {
            case "rotate": {
              var a = Math.atan2(this.center_[1] - pt[1], this.center_[0] - pt[0]);
              if (!this.ispt) {
                for (i = 0, f; f = this.selection_.item(i); i++) {
                  geometry = this.geoms_[i].clone();
                  geometry.rotate(a - this.angle_, this.center_);
                  if (geometry.getType() == "Circle")
                    geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius());
                  f.setGeometry(geometry);
                }
              }
              this.drawSketch_(true);
              this.dispatchEvent({
                type: "rotating",
                feature: this.selection_.item(0),
                features: this.selection_,
                angle: a - this.angle_,
                pixel: evt.pixel,
                coordinate: evt.coordinate
              });
              break;
            }
            case "translate": {
              var deltaX = pt[0] - pt0[0];
              var deltaY = pt[1] - pt0[1];
              for (i = 0, f; f = this.selection_.item(i); i++) {
                f.getGeometry().translate(deltaX, deltaY);
              }
              this.handles_.forEach(function(f2) {
                f2.getGeometry().translate(deltaX, deltaY);
              });
              this.coordinate_ = evt.coordinate;
              this.dispatchEvent({
                type: "translating",
                feature: this.selection_.item(0),
                features: this.selection_,
                delta: [deltaX, deltaY],
                pixel: evt.pixel,
                coordinate: evt.coordinate
              });
              break;
            }
            case "scale": {
              var center = this.center_;
              if (this.get("modifyCenter")(evt)) {
                var extentCoordinates = this.extent_;
                if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                  extentCoordinates = this.rotatedExtent_;
                }
                center = extentCoordinates[(Number(this.opt_) + 2) % 4];
              }
              var keepRectangle = this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]);
              var stretch = this.constraint_;
              var opt = this.opt_;
              var downCoordinate = this.coordinate_;
              var dragCoordinate = evt.coordinate;
              if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                var downPoint = new geom_Point(this.coordinate_);
                downPoint.rotate(viewRotation * -1, center);
                downCoordinate = downPoint.getCoordinates();
                var dragPoint = new geom_Point(evt.coordinate);
                dragPoint.rotate(viewRotation * -1, center);
                dragCoordinate = dragPoint.getCoordinates();
              }
              var scx = (dragCoordinate[0] - center[0]) / (downCoordinate[0] - center[0]);
              var scy = (dragCoordinate[1] - center[1]) / (downCoordinate[1] - center[1]);
              var displacementVector = [dragCoordinate[0] - downCoordinate[0], dragCoordinate[1] - downCoordinate[1]];
              if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                var centerPoint = new geom_Point(center);
                centerPoint.rotate(viewRotation * -1, this.getMap().getView().getCenter());
                center = centerPoint.getCoordinates();
              }
              if (this.get("noFlip")) {
                if (scx < 0)
                  scx = -scx;
                if (scy < 0)
                  scy = -scy;
              }
              if (this.constraint_) {
                if (this.constraint_ == "h")
                  scx = 1;
                else
                  scy = 1;
              } else {
                if (this.get("keepAspectRatio")(evt)) {
                  scx = scy = Math.min(scx, scy);
                }
              }
              for (i = 0, f; f = this.selection_.item(i); i++) {
                geometry = viewRotation === 0 || !this.get("enableRotatedTransform") ? this.geoms_[i].clone() : this.rotatedGeoms_[i].clone();
                geometry.applyTransform(function(g1, g2, dim) {
                  if (dim < 2)
                    return g2;
                  if (!keepRectangle) {
                    for (j = 0; j < g1.length; j += dim) {
                      if (scx != 1)
                        g2[j] = center[0] + (g1[j] - center[0]) * scx;
                      if (scy != 1)
                        g2[j + 1] = center[1] + (g1[j + 1] - center[1]) * scy;
                    }
                  } else {
                    var pointArray = [[6], [0, 8], [2], [4]];
                    var pointA = [g1[0], g1[1]];
                    var pointB = [g1[2], g1[3]];
                    var pointC = [g1[4], g1[5]];
                    var pointD = [g1[6], g1[7]];
                    var pointA1 = [g1[8], g1[9]];
                    if (stretch) {
                      var base = opt % 2 === 0 ? countVector(pointA, pointB) : countVector(pointD, pointA);
                      var projectedVector = projectVectorOnVector(displacementVector, base);
                      var nextIndex = opt + 1 < pointArray.length ? opt + 1 : 0;
                      var coordsToChange = [...pointArray[opt], ...pointArray[nextIndex]];
                      for (j = 0; j < g1.length; j += dim) {
                        g2[j] = coordsToChange.includes(j) ? g1[j] + projectedVector[0] : g1[j];
                        g2[j + 1] = coordsToChange.includes(j) ? g1[j + 1] + projectedVector[1] : g1[j + 1];
                      }
                    } else {
                      var projectedLeft, projectedRight;
                      switch (opt) {
                        case 0:
                          displacementVector = countVector(pointD, dragCoordinate);
                          projectedLeft = projectVectorOnVector(displacementVector, countVector(pointC, pointD));
                          projectedRight = projectVectorOnVector(displacementVector, countVector(pointA, pointD));
                          [g2[0], g2[1]] = movePoint(pointA, projectedLeft);
                          [g2[4], g2[5]] = movePoint(pointC, projectedRight);
                          [g2[6], g2[7]] = movePoint(pointD, displacementVector);
                          [g2[8], g2[9]] = movePoint(pointA1, projectedLeft);
                          break;
                        case 1:
                          displacementVector = countVector(pointA, dragCoordinate);
                          projectedLeft = projectVectorOnVector(displacementVector, countVector(pointD, pointA));
                          projectedRight = projectVectorOnVector(displacementVector, countVector(pointB, pointA));
                          [g2[0], g2[1]] = movePoint(pointA, displacementVector);
                          [g2[2], g2[3]] = movePoint(pointB, projectedLeft);
                          [g2[6], g2[7]] = movePoint(pointD, projectedRight);
                          [g2[8], g2[9]] = movePoint(pointA1, displacementVector);
                          break;
                        case 2:
                          displacementVector = countVector(pointB, dragCoordinate);
                          projectedLeft = projectVectorOnVector(displacementVector, countVector(pointA, pointB));
                          projectedRight = projectVectorOnVector(displacementVector, countVector(pointC, pointB));
                          [g2[0], g2[1]] = movePoint(pointA, projectedRight);
                          [g2[2], g2[3]] = movePoint(pointB, displacementVector);
                          [g2[4], g2[5]] = movePoint(pointC, projectedLeft);
                          [g2[8], g2[9]] = movePoint(pointA1, projectedRight);
                          break;
                        case 3:
                          displacementVector = countVector(pointC, dragCoordinate);
                          projectedLeft = projectVectorOnVector(displacementVector, countVector(pointB, pointC));
                          projectedRight = projectVectorOnVector(displacementVector, countVector(pointD, pointC));
                          [g2[2], g2[3]] = movePoint(pointB, projectedRight);
                          [g2[4], g2[5]] = movePoint(pointC, displacementVector);
                          [g2[6], g2[7]] = movePoint(pointD, projectedLeft);
                          break;
                      }
                    }
                  }
                  if (geometry.getType() == "Circle")
                    geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius());
                  return g2;
                });
                if (this.get("enableRotatedTransform") && viewRotation !== 0) {
                  geometry.rotate(viewRotation, this.getMap().getView().getCenter());
                }
                f.setGeometry(geometry);
              }
              this.drawSketch_();
              this.dispatchEvent({
                type: "scaling",
                feature: this.selection_.item(0),
                features: this.selection_,
                scale: [scx, scy],
                pixel: evt.pixel,
                coordinate: evt.coordinate
              });
              break;
            }
            default:
              break;
          }
          this.isUpdating_ = false;
        };
        ol_interaction_Transform.prototype.handleMoveEvent_ = function(evt) {
          if (!this._handleEvent(evt, this.features_))
            return;
          if (!this.mode_) {
            var sel = this.getFeatureAtPixel_(evt.pixel);
            var element = evt.map.getTargetElement();
            if (sel.feature) {
              var c = sel.handle ? this.Cursors[(sel.handle || "default") + (sel.constraint || "") + (sel.option || "")] : this.Cursors.select;
              if (this.previousCursor_ === void 0) {
                this.previousCursor_ = element.style.cursor;
              }
              element.style.cursor = c;
            } else {
              if (this.previousCursor_ !== void 0)
                element.style.cursor = this.previousCursor_;
              this.previousCursor_ = void 0;
            }
          }
        };
        ol_interaction_Transform.prototype.handleUpEvent_ = function(evt) {
          if (this.mode_ === "rotate") {
            var element = evt.map.getTargetElement();
            element.style.cursor = this.Cursors.default;
            this.previousCursor_ = void 0;
          }
          this.dispatchEvent({
            type: this.mode_ + "end",
            feature: this.selection_.item(0),
            features: this.selection_,
            oldgeom: this.geoms_[0],
            oldgeoms: this.geoms_
          });
          this.drawSketch_();
          this.mode_ = null;
          return false;
        };
        ol_interaction_Transform.prototype.getFeatures = function() {
          return this.selection_;
        };
        var Transform = ol_interaction_Transform;
        var TransformInteractionvue_type_script_lang_js = {
          name: "ol-interaction-transform",
          setup: function setup(props) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var transform2 = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var interaction = new Transform(_objectSpread2({}, properties));
              return interaction;
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(transform2, function(newVal, oldVal) {
              map.removeInteraction(oldVal);
              map.addInteraction(newVal);
              map.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addInteraction(transform2.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeInteraction(transform2.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("stylable", transform2);
          },
          props: {
            enableRotatedTransform: {
              type: Boolean,
              default: false
            },
            condition: {
              type: Function
            },
            addCondition: {
              type: Function
            },
            filter: {
              type: Function
            },
            layers: {
              type: Array
            },
            hitTolerance: {
              type: Number,
              default: 2
            },
            translateFeature: {
              type: Boolean,
              default: true
            },
            scale: {
              type: Boolean,
              default: true
            },
            rotate: {
              type: Boolean,
              default: true
            },
            keepAspectRatio: {
              type: Boolean,
              default: false
            },
            translate: {
              type: Boolean,
              default: true
            },
            stretch: {
              type: Boolean,
              default: true
            }
          }
        };
        const TransformInteraction_exports_ = exportHelper_default()(TransformInteractionvue_type_script_lang_js, [["render", TransformInteractionvue_type_template_id_044a350b_lang_true_render]]);
        var TransformInteraction = TransformInteraction_exports_;
        function DragRotateAndZoomInteractionvue_type_template_id_5cb90c30_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var DragRotateAndZoom_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var DragRotateAndZoom_DragRotateAndZoom = function(_super) {
          DragRotateAndZoom_extends(DragRotateAndZoom, _super);
          function DragRotateAndZoom(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, options) || this;
            _this.condition_ = options.condition ? options.condition : shiftKeyOnly;
            _this.lastAngle_ = void 0;
            _this.lastMagnitude_ = void 0;
            _this.lastScaleDelta_ = 0;
            _this.duration_ = options.duration !== void 0 ? options.duration : 400;
            return _this;
          }
          DragRotateAndZoom.prototype.handleDragEvent = function(mapBrowserEvent) {
            if (!mouseOnly(mapBrowserEvent)) {
              return;
            }
            var map = mapBrowserEvent.map;
            var size = map.getSize();
            var offset = mapBrowserEvent.pixel;
            var deltaX = offset[0] - size[0] / 2;
            var deltaY = size[1] / 2 - offset[1];
            var theta = Math.atan2(deltaY, deltaX);
            var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            var view = map.getView();
            if (this.lastAngle_ !== void 0) {
              var angleDelta = this.lastAngle_ - theta;
              view.adjustRotationInternal(angleDelta);
            }
            this.lastAngle_ = theta;
            if (this.lastMagnitude_ !== void 0) {
              view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);
            }
            if (this.lastMagnitude_ !== void 0) {
              this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
            }
            this.lastMagnitude_ = magnitude;
          };
          DragRotateAndZoom.prototype.handleUpEvent = function(mapBrowserEvent) {
            if (!mouseOnly(mapBrowserEvent)) {
              return true;
            }
            var map = mapBrowserEvent.map;
            var view = map.getView();
            var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
            view.endInteraction(this.duration_, direction);
            this.lastScaleDelta_ = 0;
            return false;
          };
          DragRotateAndZoom.prototype.handleDownEvent = function(mapBrowserEvent) {
            if (!mouseOnly(mapBrowserEvent)) {
              return false;
            }
            if (this.condition_(mapBrowserEvent)) {
              mapBrowserEvent.map.getView().beginInteraction();
              this.lastAngle_ = void 0;
              this.lastMagnitude_ = void 0;
              return true;
            } else {
              return false;
            }
          };
          return DragRotateAndZoom;
        }(Pointer);
        var interaction_DragRotateAndZoom = DragRotateAndZoom_DragRotateAndZoom;
        var DragRotateAndZoomInteractionvue_type_script_lang_js = {
          name: "ol-interaction-dragrotatezoom",
          setup: function setup(props) {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
            var dragrotatezoom = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
              var s = new interaction_DragRotateAndZoom(_objectSpread2({}, properties));
              return s;
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(dragrotatezoom, function(newVal, oldVal) {
              map.removeInteraction(oldVal);
              map.addInteraction(newVal);
              map.changed();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function() {
              map.addInteraction(dragrotatezoom.value);
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function() {
              map.removeInteraction(dragrotatezoom.value);
            });
          },
          props: {
            condition: {
              type: Function
            },
            duration: {
              type: Number,
              default: 400
            }
          }
        };
        const DragRotateAndZoomInteraction_exports_ = exportHelper_default()(DragRotateAndZoomInteractionvue_type_script_lang_js, [["render", DragRotateAndZoomInteractionvue_type_template_id_5cb90c30_lang_true_render]]);
        var DragRotateAndZoomInteraction = DragRotateAndZoomInteraction_exports_;
        function interaction_install(app) {
          if (interaction_install.installed) {
            return;
          }
          interaction_install.installed = true;
          app.component(SelectInteraction.name, SelectInteraction);
          app.component(ClusterSelectInteraction.name, ClusterSelectInteraction);
          app.component(DrawInteraction.name, DrawInteraction);
          app.component(SnapInteraction.name, SnapInteraction);
          app.component(ModifyInteraction.name, ModifyInteraction);
          app.component(TransformInteraction.name, TransformInteraction);
          app.component(DragRotateAndZoomInteraction.name, DragRotateAndZoomInteraction);
        }
        var components_interaction = interaction_install;
        function FeatureAnimationvue_type_template_id_733c99d6_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var FeatureAnimationvue_type_script_lang_js = {
          setup: function setup() {
            var map = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("map");
            var vectorLayer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])("vectorLayer");
            return {
              map,
              vectorLayer
            };
          },
          props: {
            duration: {
              type: Number,
              default: 1e3
            },
            revers: {
              type: Boolean,
              default: false
            },
            repeat: {
              type: Number,
              default: 0
            },
            fade: {
              type: Function
            },
            easing: {
              type: Function,
              default: easeOut
            }
          }
        };
        const FeatureAnimation_exports_ = exportHelper_default()(FeatureAnimationvue_type_script_lang_js, [["render", FeatureAnimationvue_type_template_id_733c99d6_lang_true_render]]);
        var FeatureAnimation = FeatureAnimation_exports_;
        function DropAnimationvue_type_template_id_75951dd8_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var es_array_map = __webpack_require__("d81d");
        var ol_featureAnimation = function(options) {
          options = options || {};
          this.duration_ = typeof options.duration == "number" ? options.duration >= 0 ? options.duration : 0 : 1e3;
          this.fade_ = typeof options.fade == "function" ? options.fade : null;
          this.repeat_ = Number(options.repeat);
          var easing = typeof options.easing == "function" ? options.easing : linear;
          if (options.revers)
            this.easing_ = function(t) {
              return 1 - easing(t);
            };
          else
            this.easing_ = easing;
          this.hiddenStyle = options.hiddenStyle;
          ol_Object["a"].call(this);
        };
        util_ext(ol_featureAnimation, ol_Object["a"]);
        ol_featureAnimation.hiddenStyle = new style_Style({
          image: new style_Circle({}),
          stroke: new style_Stroke({
            color: "transparent"
          })
        });
        ol_featureAnimation.prototype.drawGeom_ = function(e, geom, shadow) {
          if (this.fade_) {
            e.context.globalAlpha = this.fade_(1 - e.elapsed);
          }
          var style = e.style;
          for (var i = 0; i < style.length; i++) {
            try {
              var vectorContext = e.vectorContext || util_getVectorContext(e);
              vectorContext.setStyle(style[i]);
              if (style[i].getZIndex() < 0)
                vectorContext.drawGeometry(shadow || geom);
              else
                vectorContext.drawGeometry(geom);
            } catch (e2) {
            }
          }
        };
        ol_featureAnimation.prototype.animate = function() {
          return false;
        };
        ol_Map.prototype.animateFeature = function(feature, fanim) {
          var layer = this._featureAnimationLayer;
          if (!layer) {
            layer = this._featureAnimationLayer = new Vector({ source: new source_Vector() });
            layer.setMap(this);
          }
          layer.getSource().addFeature(feature);
          var listener = fanim.on("animationend", function(e) {
            if (e.feature === feature) {
              layer.getSource().removeFeature(feature);
              Object(Observable["b"])(listener);
            }
          });
          layer.animateFeature(feature, fanim);
        };
        Base.prototype.animateFeature = function(feature, fanim, useFilter) {
          var self2 = this;
          var listenerKey;
          var style = feature.getStyle();
          var flashStyle = style || (this.getStyleFunction ? this.getStyleFunction()(feature) : null);
          if (!flashStyle)
            flashStyle = [];
          if (!(flashStyle instanceof Array))
            flashStyle = [flashStyle];
          var event = {
            vectorContext: null,
            frameState: null,
            start: 0,
            time: 0,
            elapsed: 0,
            extent: false,
            feature,
            geom: feature.getGeometry(),
            typeGeom: feature.getGeometry().getType(),
            bbox: feature.getGeometry().getExtent(),
            coord: extent_getCenter(feature.getGeometry().getExtent()),
            style: flashStyle
          };
          if (!(fanim instanceof Array))
            fanim = [fanim];
          for (var i = fanim.length - 1; i >= 0; i--) {
            if (fanim[i].duration_ === 0)
              fanim.splice(i, 1);
          }
          var nb = 0, step = 0;
          var filters = useFilter && this.getFilters ? this.getFilters() : [];
          function animate(e) {
            event.type = e.type;
            try {
              event.vectorContext = e.vectorContext || util_getVectorContext(e);
            } catch (e2) {
            }
            event.frameState = e.frameState;
            event.inversePixelTransform = e.inversePixelTransform;
            if (!event.extent) {
              event.extent = e.frameState.extent;
              event.start = e.frameState.time;
              event.context = e.context;
            }
            event.time = e.frameState.time - event.start;
            event.elapsed = event.time / fanim[step].duration_;
            if (event.elapsed > 1)
              event.elapsed = 1;
            e.context.save();
            filters.forEach(function(f) {
              if (f.get("active"))
                f.precompose(e);
            });
            if (this.getOpacity) {
              e.context.globalAlpha = this.getOpacity();
            }
            if (!fanim[step].animate(event)) {
              nb++;
              if (nb < fanim[step].repeat_) {
                event.extent = false;
              } else if (step < fanim.length - 1) {
                fanim[step].dispatchEvent({ type: "animationend", feature });
                step++;
                nb = 0;
                event.extent = false;
              } else {
                stop();
              }
            } else {
              var animEvent = {
                type: "animating",
                step,
                start: event.start,
                time: event.time,
                elapsed: event.elapsed,
                rotation: event.rotation || 0,
                geom: event.geom,
                coordinate: event.coord,
                feature
              };
              fanim[step].dispatchEvent(animEvent);
              self2.dispatchEvent(animEvent);
            }
            filters.forEach(function(f) {
              if (f.get("active"))
                f.postcompose(e);
            });
            e.context.restore();
            e.frameState.animate = true;
          }
          function stop(options) {
            Object(Observable["b"])(listenerKey);
            listenerKey = null;
            feature.setStyle(style);
            var event2 = { type: "animationend", feature };
            if (options) {
              for (var i2 in options)
                if (options.hasOwnProperty(i2)) {
                  event2[i2] = options[i2];
                }
            }
            fanim[step].dispatchEvent(event2);
            self2.dispatchEvent(event2);
          }
          function start(options) {
            if (fanim.length && !listenerKey) {
              listenerKey = self2.on(["postcompose", "postrender"], animate.bind(self2));
              if (self2.renderSync) {
                try {
                  self2.renderSync();
                } catch (e) {
                }
              } else {
                self2.changed();
              }
              feature.setStyle(fanim[step].hiddenStyle || ol_featureAnimation.hiddenStyle);
              var event2 = { type: "animationstart", feature };
              if (options) {
                for (var i2 in options)
                  if (options.hasOwnProperty(i2)) {
                    event2[i2] = options[i2];
                  }
              }
              fanim[step].dispatchEvent(event2);
              self2.dispatchEvent(event2);
            }
          }
          start();
          return {
            start,
            stop,
            isPlaying: function() {
              return !!listenerKey;
            }
          };
        };
        var featureanimation_FeatureAnimation = ol_featureAnimation;
        var ol_featureAnimation_Drop = function(options) {
          options = options || {};
          this.speed_ = options.speed || 0;
          featureanimation_FeatureAnimation.call(this, options);
          this.side_ = options.side || "top";
        };
        util_ext(ol_featureAnimation_Drop, featureanimation_FeatureAnimation);
        ol_featureAnimation_Drop.prototype.animate = function(e) {
          if (!e.time) {
            var angle = e.frameState.viewState.rotation;
            var s = e.frameState.size[1] * e.frameState.viewState.resolution;
            if (this.side_ != "top")
              s *= -1;
            this.dx = -Math.sin(angle) * s;
            this.dy = Math.cos(angle) * s;
            if (this.speed_) {
              this.duration_ = s / this.speed_ / e.frameState.viewState.resolution;
            }
          }
          var flashGeom = e.geom.clone();
          flashGeom.translate(this.dx * (1 - this.easing_(e.elapsed)), this.dy * (1 - this.easing_(e.elapsed)));
          this.drawGeom_(e, flashGeom, e.geom);
          return e.time <= this.duration_;
        };
        var Drop = ol_featureAnimation_Drop;
        function useAnimation(AnimationType, props) {
          var _Animation$setup = FeatureAnimation.setup(), map = _Animation$setup.map, vectorLayer = _Animation$setup.vectorLayer;
          var _usePropsAsObjectProp = usePropsAsObjectProperties(props), properties = _usePropsAsObjectProp.properties;
          var animation = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function() {
            var anim = new AnimationType(_objectSpread2({}, properties));
            return anim;
          });
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])("animation", animation);
          return {
            map,
            vectorLayer,
            animation,
            properties
          };
        }
        var DropAnimationvue_type_script_lang_js = {
          name: "ol-animation-drop",
          extends: FeatureAnimation,
          setup: function setup(props) {
            var _useAnimation = useAnimation(Drop, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
            return {
              map,
              vectorLayer,
              properties
            };
          },
          props: {
            side: {
              type: Number,
              default: 0
            },
            speed: {
              type: Number,
              default: 0
            }
          }
        };
        const DropAnimation_exports_ = exportHelper_default()(DropAnimationvue_type_script_lang_js, [["render", DropAnimationvue_type_template_id_75951dd8_lang_true_render]]);
        var DropAnimation = DropAnimation_exports_;
        function ShakeAnimationvue_type_template_id_1703e1b0_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var ol_featureAnimation_Shake = function(options) {
          options = options || {};
          featureanimation_FeatureAnimation.call(this, options);
          this.amplitude_ = options.amplitude || 40;
          this.bounce_ = -Math.PI * (options.bounce || 6);
          this.horizontal_ = options.horizontal;
        };
        util_ext(ol_featureAnimation_Shake, featureanimation_FeatureAnimation);
        ol_featureAnimation_Shake.prototype.animate = function(e) {
          var flashGeom = e.geom.clone();
          var shadow = e.geom.clone();
          var t = this.easing_(e.elapsed);
          t = Math.sin(this.bounce_ * t) * this.amplitude_ * (1 - t) * e.frameState.viewState.resolution;
          if (this.horizontal_) {
            flashGeom.translate(t, 0);
            shadow.translate(t, 0);
          } else
            flashGeom.translate(0, t);
          this.drawGeom_(e, flashGeom, shadow);
          return e.time <= this.duration_;
        };
        var Shake = ol_featureAnimation_Shake;
        var ShakeAnimationvue_type_script_lang_js = {
          name: "ol-animation-shake",
          extends: FeatureAnimation,
          setup: function setup(props) {
            var _useAnimation = useAnimation(Shake, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties, animation = _useAnimation.animation;
            return {
              map,
              vectorLayer,
              properties,
              animation
            };
          },
          props: {
            bounce: {
              type: Number,
              default: 6
            },
            amplitude: {
              type: Number,
              default: 40
            },
            horizontal: {
              type: Boolean,
              default: false
            }
          }
        };
        const ShakeAnimation_exports_ = exportHelper_default()(ShakeAnimationvue_type_script_lang_js, [["render", ShakeAnimationvue_type_template_id_1703e1b0_lang_true_render]]);
        var ShakeAnimation = ShakeAnimation_exports_;
        function ZoomAnimationvue_type_template_id_06ca7ff1_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var ol_featureAnimation_Zoom = function(options) {
          options = options || {};
          featureanimation_FeatureAnimation.call(this, options);
          this.set("zoomout", options.zoomOut);
        };
        util_ext(ol_featureAnimation_Zoom, featureanimation_FeatureAnimation);
        var ol_featureAnimation_ZoomOut = function(options) {
          options = options || {};
          options.zoomOut = true;
          ol_featureAnimation_Zoom.call(this, options);
        };
        util_ext(ol_featureAnimation_ZoomOut, ol_featureAnimation_Zoom);
        ol_featureAnimation_Zoom.prototype.animate = function(e) {
          var fac = this.easing_(e.elapsed);
          if (fac) {
            if (this.get("zoomout"))
              fac = 1 / fac;
            var style = e.style;
            var i, imgs, sc = [];
            for (i = 0; i < style.length; i++) {
              imgs = style[i].getImage();
              if (imgs) {
                sc[i] = imgs.getScale();
                if (e.type === "postrender")
                  imgs.setScale(sc[i] * fac / e.frameState.pixelRatio);
                else
                  imgs.setScale(sc[i] * fac);
              }
            }
            this.drawGeom_(e, e.geom);
            for (i = 0; i < style.length; i++) {
              imgs = style[i].getImage();
              if (imgs)
                imgs.setScale(sc[i]);
            }
          }
          return e.time <= this.duration_;
        };
        var featureanimation_Zoom = ol_featureAnimation_Zoom;
        var ZoomAnimationvue_type_script_lang_js = {
          name: "ol-animation-zoom",
          extends: FeatureAnimation,
          setup: function setup(props) {
            var _useAnimation = useAnimation(featureanimation_Zoom, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
            return {
              map,
              vectorLayer,
              properties
            };
          },
          props: {
            zoomOut: {
              type: Boolean,
              default: false
            }
          }
        };
        const ZoomAnimation_exports_ = exportHelper_default()(ZoomAnimationvue_type_script_lang_js, [["render", ZoomAnimationvue_type_template_id_06ca7ff1_lang_true_render]]);
        var ZoomAnimation = ZoomAnimation_exports_;
        function TeleportAnimationvue_type_template_id_1d6d3df8_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var ol_featureAnimation_Teleport = function(options) {
          featureanimation_FeatureAnimation.call(this, options);
        };
        util_ext(ol_featureAnimation_Teleport, featureanimation_FeatureAnimation);
        ol_featureAnimation_Teleport.prototype.animate = function(e) {
          var sc = this.easing_(e.elapsed);
          if (sc) {
            e.context.save();
            var ratio = e.frameState.pixelRatio;
            e.context.globalAlpha = sc;
            e.context.scale(sc, 1 / sc);
            var m = e.frameState.coordinateToPixelTransform;
            var dx = (1 / sc - 1) * ratio * (m[0] * e.coord[0] + m[1] * e.coord[1] + m[4]);
            var dy = (sc - 1) * ratio * (m[2] * e.coord[0] + m[3] * e.coord[1] + m[5]);
            e.context.translate(dx, dy);
            this.drawGeom_(e, e.geom);
            e.context.restore();
          }
          return e.time <= this.duration_;
        };
        var Teleport = ol_featureAnimation_Teleport;
        var TeleportAnimationvue_type_script_lang_js = {
          name: "ol-animation-teleport",
          extends: FeatureAnimation,
          setup: function setup(props) {
            var _useAnimation = useAnimation(Teleport, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
            return {
              map,
              vectorLayer,
              properties
            };
          },
          props: {}
        };
        const TeleportAnimation_exports_ = exportHelper_default()(TeleportAnimationvue_type_script_lang_js, [["render", TeleportAnimationvue_type_template_id_1d6d3df8_lang_true_render]]);
        var TeleportAnimation = TeleportAnimation_exports_;
        function FadeAnimationvue_type_template_id_cb41c1b2_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var ol_featureAnimation_Fade = function(options) {
          options = options || {};
          this.speed_ = options.speed || 0;
          featureanimation_FeatureAnimation.call(this, options);
        };
        util_ext(ol_featureAnimation_Fade, featureanimation_FeatureAnimation);
        ol_featureAnimation_Fade.prototype.animate = function(e) {
          e.context.globalAlpha = this.easing_(e.elapsed);
          this.drawGeom_(e, e.geom);
          return e.time <= this.duration_;
        };
        var Fade = ol_featureAnimation_Fade;
        var FadeAnimationvue_type_script_lang_js = {
          name: "ol-animation-fade",
          extends: FeatureAnimation,
          setup: function setup(props) {
            var _useAnimation = useAnimation(Fade, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
            return {
              map,
              vectorLayer,
              properties
            };
          }
        };
        const FadeAnimation_exports_ = exportHelper_default()(FadeAnimationvue_type_script_lang_js, [["render", FadeAnimationvue_type_template_id_cb41c1b2_lang_true_render]]);
        var FadeAnimation = FadeAnimation_exports_;
        function SlideAnimationvue_type_template_id_11eaec2d_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var ol_featureAnimation_Slide = function(options) {
          options = options || {};
          this.speed_ = options.speed || 0;
          featureanimation_FeatureAnimation.call(this, options);
          this.side_ = options.side || "left";
        };
        util_ext(ol_featureAnimation_Slide, featureanimation_FeatureAnimation);
        ol_featureAnimation_Slide.prototype.animate = function(e) {
          if (!e.time) {
            if (this.side_ == "left")
              this.dx = e.extent[0] - e.bbox[2];
            else
              this.dx = e.extent[2] - e.bbox[0];
            if (this.speed_)
              this.duration_ = Math.abs(this.dx) / this.speed_ / e.frameState.viewState.resolution;
          }
          var flashGeom = e.geom.clone();
          flashGeom.translate(this.dx * (1 - this.easing_(e.elapsed)), 0);
          this.drawGeom_(e, flashGeom);
          return e.time <= this.duration_;
        };
        var Slide = ol_featureAnimation_Slide;
        var SlideAnimationvue_type_script_lang_js = {
          name: "ol-animation-slide",
          extends: FeatureAnimation,
          setup: function setup(props) {
            var _useAnimation = useAnimation(Slide, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
            return {
              map,
              vectorLayer,
              properties
            };
          },
          props: {
            speed: {
              type: Number,
              default: 0
            }
          }
        };
        const SlideAnimation_exports_ = exportHelper_default()(SlideAnimationvue_type_script_lang_js, [["render", SlideAnimationvue_type_template_id_11eaec2d_lang_true_render]]);
        var SlideAnimation = SlideAnimation_exports_;
        function PathAnimationvue_type_template_id_5e9800a8_lang_true_render(_ctx, _cache, $props, $setup, $data, $options) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["renderSlot"])(_ctx.$slots, "default");
        }
        var ol_featureAnimation_Path = function(options) {
          options = options || {};
          featureanimation_FeatureAnimation.call(this, options);
          this.speed_ = options.speed || 0;
          this.path_ = options.path;
          switch (options.rotate) {
            case true:
            case 0:
              this.rotate_ = 0;
              break;
            default:
              this.rotate_ = options.rotate || false;
              break;
          }
          if (this.path_ && this.path_.getGeometry)
            this.path_ = this.path_.getGeometry();
          if (this.path_ && this.path_.getLineString)
            this.path_ = this.path_.getLineString();
          if (this.path_.getLength) {
            this.dist_ = this.path_.getLength();
            if (this.path_ && this.path_.getCoordinates)
              this.path_ = this.path_.getCoordinates();
          } else {
            this.dist_ = 0;
          }
          if (this.speed_ > 0)
            this.duration_ = this.dist_ / this.speed_;
        };
        util_ext(ol_featureAnimation_Path, featureanimation_FeatureAnimation);
        ol_featureAnimation_Path.prototype.animate = function(e) {
          if (!e.time) {
            if (!this.dist_)
              return false;
          }
          var dmax = this.dist_ * this.easing_(e.elapsed);
          var p0, p, s, dx, dy, dl, d = 0;
          p = this.path_[0];
          for (var i = 1; i < this.path_.length; i++) {
            p0 = p;
            p = this.path_[i];
            dx = p[0] - p0[0];
            dy = p[1] - p0[1];
            dl = Math.sqrt(dx * dx + dy * dy);
            if (dl && d + dl >= dmax) {
              s = (dmax - d) / dl;
              p = [p0[0] + (p[0] - p0[0]) * s, p0[1] + (p[1] - p0[1]) * s];
              break;
            }
            d += dl;
          }
          var style = e.style;
          e.rotation = Math.PI / 2 + Math.atan2(p0[1] - p[1], p0[0] - p[0]);
          if (this.rotate_ !== false) {
            var st = [];
            var angle = this.rotate_ - e.rotation + e.frameState.viewState.rotation;
            e.rotation = Math.PI / 2 + Math.atan2(p0[1] - p[1], p0[0] - p[0]);
            for (var k = 0; s = e.style[k]; k++) {
              if (s.getImage()) {
                s.getImage().setRotation(angle);
              }
              st.push(s);
            }
            e.style = st;
          }
          e.geom.setCoordinates(p);
          this.drawGeom_(e, e.geom);
          e.style = style;
          return e.time <= this.duration_;
        };
        var Path = ol_featureAnimation_Path;
        var PathAnimationvue_type_script_lang_js = {
          name: "ol-animation-path",
          extends: FeatureAnimation,
          setup: function setup(props) {
            var _useAnimation = useAnimation(Path, props), map = _useAnimation.map, vectorLayer = _useAnimation.vectorLayer, properties = _useAnimation.properties;
            return {
              map,
              vectorLayer,
              properties
            };
          },
          props: {
            rotate: {
              type: Boolean,
              default: false
            },
            speed: {
              type: Number,
              default: 0
            },
            path: {
              type: Object
            }
          }
        };
        const PathAnimation_exports_ = exportHelper_default()(PathAnimationvue_type_script_lang_js, [["render", PathAnimationvue_type_template_id_5e9800a8_lang_true_render]]);
        var PathAnimation = PathAnimation_exports_;
        function animations_install(app) {
          if (animations_install.installed) {
            return;
          }
          animations_install.installed = true;
          app.component(FeatureAnimation.name, FeatureAnimation);
          app.component(DropAnimation.name, DropAnimation);
          app.component(ShakeAnimation.name, ShakeAnimation);
          app.component(ZoomAnimation.name, ZoomAnimation);
          app.component(TeleportAnimation.name, TeleportAnimation);
          app.component(FadeAnimation.name, FadeAnimation);
          app.component(SlideAnimation.name, SlideAnimation);
          app.component(PathAnimation.name, PathAnimation);
        }
        var animations = animations_install;
        var ol_ol = __webpack_require__("5bc0");
        var ol_ext = __webpack_require__("dbd0");
        var dist_ol_contextmenu = __webpack_require__("872d");
        var assets_style = __webpack_require__("7d05");
        var GeometryCollection_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GeometryCollection_GeometryCollection = function(_super) {
          GeometryCollection_extends(GeometryCollection, _super);
          function GeometryCollection(opt_geometries) {
            var _this = _super.call(this) || this;
            _this.geometries_ = opt_geometries ? opt_geometries : null;
            _this.changeEventsKeys_ = [];
            _this.listenGeometriesChange_();
            return _this;
          }
          GeometryCollection.prototype.unlistenGeometriesChange_ = function() {
            this.changeEventsKeys_.forEach(events["c"]);
            this.changeEventsKeys_.length = 0;
          };
          GeometryCollection.prototype.listenGeometriesChange_ = function() {
            if (!this.geometries_) {
              return;
            }
            for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
              this.changeEventsKeys_.push(Object(events["a"])(this.geometries_[i], EventType["a"].CHANGE, this.changed, this));
            }
          };
          GeometryCollection.prototype.clone = function() {
            var geometryCollection = new GeometryCollection(null);
            geometryCollection.setGeometries(this.geometries_);
            geometryCollection.applyProperties(this);
            return geometryCollection;
          };
          GeometryCollection.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
            }
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
            }
            return minSquaredDistance;
          };
          GeometryCollection.prototype.containsXY = function(x, y) {
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              if (geometries[i].containsXY(x, y)) {
                return true;
              }
            }
            return false;
          };
          GeometryCollection.prototype.computeExtent = function(extent) {
            createOrUpdateEmpty(extent);
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              extend2(extent, geometries[i].getExtent());
            }
            return extent;
          };
          GeometryCollection.prototype.getGeometries = function() {
            return cloneGeometries(this.geometries_);
          };
          GeometryCollection.prototype.getGeometriesArray = function() {
            return this.geometries_;
          };
          GeometryCollection.prototype.getGeometriesArrayRecursive = function() {
            var geometriesArray = [];
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              if (geometries[i].getType() === this.getType()) {
                geometriesArray = geometriesArray.concat(geometries[i].getGeometriesArrayRecursive());
              } else {
                geometriesArray.push(geometries[i]);
              }
            }
            return geometriesArray;
          };
          GeometryCollection.prototype.getSimplifiedGeometry = function(squaredTolerance) {
            if (this.simplifiedGeometryRevision !== this.getRevision()) {
              this.simplifiedGeometryMaxMinSquaredTolerance = 0;
              this.simplifiedGeometryRevision = this.getRevision();
            }
            if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
              return this;
            }
            var simplifiedGeometries = [];
            var geometries = this.geometries_;
            var simplified = false;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              var geometry = geometries[i];
              var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
              simplifiedGeometries.push(simplifiedGeometry);
              if (simplifiedGeometry !== geometry) {
                simplified = true;
              }
            }
            if (simplified) {
              var simplifiedGeometryCollection = new GeometryCollection(null);
              simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
              return simplifiedGeometryCollection;
            } else {
              this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
              return this;
            }
          };
          GeometryCollection.prototype.getType = function() {
            return geom_GeometryType.GEOMETRY_COLLECTION;
          };
          GeometryCollection.prototype.intersectsExtent = function(extent) {
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              if (geometries[i].intersectsExtent(extent)) {
                return true;
              }
            }
            return false;
          };
          GeometryCollection.prototype.isEmpty = function() {
            return this.geometries_.length === 0;
          };
          GeometryCollection.prototype.rotate = function(angle, anchor) {
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              geometries[i].rotate(angle, anchor);
            }
            this.changed();
          };
          GeometryCollection.prototype.scale = function(sx, opt_sy, opt_anchor) {
            var anchor = opt_anchor;
            if (!anchor) {
              anchor = extent_getCenter(this.getExtent());
            }
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              geometries[i].scale(sx, opt_sy, anchor);
            }
            this.changed();
          };
          GeometryCollection.prototype.setGeometries = function(geometries) {
            this.setGeometriesArray(cloneGeometries(geometries));
          };
          GeometryCollection.prototype.setGeometriesArray = function(geometries) {
            this.unlistenGeometriesChange_();
            this.geometries_ = geometries;
            this.listenGeometriesChange_();
            this.changed();
          };
          GeometryCollection.prototype.applyTransform = function(transformFn) {
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              geometries[i].applyTransform(transformFn);
            }
            this.changed();
          };
          GeometryCollection.prototype.translate = function(deltaX, deltaY) {
            var geometries = this.geometries_;
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              geometries[i].translate(deltaX, deltaY);
            }
            this.changed();
          };
          GeometryCollection.prototype.disposeInternal = function() {
            this.unlistenGeometriesChange_();
            _super.prototype.disposeInternal.call(this);
          };
          return GeometryCollection;
        }(geom_Geometry);
        function cloneGeometries(geometries) {
          var clonedGeometries = [];
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
            clonedGeometries.push(geometries[i].clone());
          }
          return clonedGeometries;
        }
        var geom_GeometryCollection = GeometryCollection_GeometryCollection;
        var Feature_FeatureFormat = function() {
          function FeatureFormat() {
            this.dataProjection = void 0;
            this.defaultFeatureProjection = void 0;
            this.supportedMediaTypes = null;
          }
          FeatureFormat.prototype.getReadOptions = function(source, opt_options) {
            var options;
            if (opt_options) {
              var dataProjection = opt_options.dataProjection ? proj_get(opt_options.dataProjection) : this.readProjection(source);
              if (opt_options.extent && dataProjection && dataProjection.getUnits() === proj_Units.TILE_PIXELS) {
                dataProjection = proj_get(dataProjection);
                dataProjection.setWorldExtent(opt_options.extent);
              }
              options = {
                dataProjection,
                featureProjection: opt_options.featureProjection
              };
            }
            return this.adaptOptions(options);
          };
          FeatureFormat.prototype.adaptOptions = function(options) {
            return Object(ol_obj["a"])({
              dataProjection: this.dataProjection,
              featureProjection: this.defaultFeatureProjection
            }, options);
          };
          FeatureFormat.prototype.getType = function() {
            return Object(util["b"])();
          };
          FeatureFormat.prototype.readFeature = function(source, opt_options) {
            return Object(util["b"])();
          };
          FeatureFormat.prototype.readFeatures = function(source, opt_options) {
            return Object(util["b"])();
          };
          FeatureFormat.prototype.readGeometry = function(source, opt_options) {
            return Object(util["b"])();
          };
          FeatureFormat.prototype.readProjection = function(source) {
            return Object(util["b"])();
          };
          FeatureFormat.prototype.writeFeature = function(feature, opt_options) {
            return Object(util["b"])();
          };
          FeatureFormat.prototype.writeFeatures = function(features, opt_options) {
            return Object(util["b"])();
          };
          FeatureFormat.prototype.writeGeometry = function(geometry, opt_options) {
            return Object(util["b"])();
          };
          return FeatureFormat;
        }();
        var format_Feature = Feature_FeatureFormat;
        function transformGeometryWithOptions(geometry, write, opt_options) {
          var featureProjection = opt_options ? proj_get(opt_options.featureProjection) : null;
          var dataProjection = opt_options ? proj_get(opt_options.dataProjection) : null;
          var transformed;
          if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
            transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
          } else {
            transformed = geometry;
          }
          if (write && opt_options && opt_options.decimals !== void 0) {
            var power_1 = Math.pow(10, opt_options.decimals);
            var transform2 = function(coordinates) {
              for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;
              }
              return coordinates;
            };
            if (transformed === geometry) {
              transformed = geometry.clone();
            }
            transformed.applyTransform(transform2);
          }
          return transformed;
        }
        function transformExtentWithOptions(extent, opt_options) {
          var featureProjection = opt_options ? proj_get(opt_options.featureProjection) : null;
          var dataProjection = opt_options ? proj_get(opt_options.dataProjection) : null;
          if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
            return transformExtent(extent, dataProjection, featureProjection);
          } else {
            return extent;
          }
        }
        var JSONFeature_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var JSONFeature_JSONFeature = function(_super) {
          JSONFeature_extends(JSONFeature, _super);
          function JSONFeature() {
            return _super.call(this) || this;
          }
          JSONFeature.prototype.getType = function() {
            return FormatType.JSON;
          };
          JSONFeature.prototype.readFeature = function(source, opt_options) {
            return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
          };
          JSONFeature.prototype.readFeatures = function(source, opt_options) {
            return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
          };
          JSONFeature.prototype.readFeatureFromObject = function(object, opt_options) {
            return Object(util["b"])();
          };
          JSONFeature.prototype.readFeaturesFromObject = function(object, opt_options) {
            return Object(util["b"])();
          };
          JSONFeature.prototype.readGeometry = function(source, opt_options) {
            return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
          };
          JSONFeature.prototype.readGeometryFromObject = function(object, opt_options) {
            return Object(util["b"])();
          };
          JSONFeature.prototype.readProjection = function(source) {
            return this.readProjectionFromObject(getObject(source));
          };
          JSONFeature.prototype.readProjectionFromObject = function(object) {
            return Object(util["b"])();
          };
          JSONFeature.prototype.writeFeature = function(feature, opt_options) {
            return JSON.stringify(this.writeFeatureObject(feature, opt_options));
          };
          JSONFeature.prototype.writeFeatureObject = function(feature, opt_options) {
            return Object(util["b"])();
          };
          JSONFeature.prototype.writeFeatures = function(features, opt_options) {
            return JSON.stringify(this.writeFeaturesObject(features, opt_options));
          };
          JSONFeature.prototype.writeFeaturesObject = function(features, opt_options) {
            return Object(util["b"])();
          };
          JSONFeature.prototype.writeGeometry = function(geometry, opt_options) {
            return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
          };
          JSONFeature.prototype.writeGeometryObject = function(geometry, opt_options) {
            return Object(util["b"])();
          };
          return JSONFeature;
        }(format_Feature);
        function getObject(source) {
          if (typeof source === "string") {
            var object = JSON.parse(source);
            return object ? object : null;
          } else if (source !== null) {
            return source;
          } else {
            return null;
          }
        }
        var format_JSONFeature = JSONFeature_JSONFeature;
        var EsriJSON_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GEOMETRY_READERS = {};
        GEOMETRY_READERS[geom_GeometryType.POINT] = readPointGeometry;
        GEOMETRY_READERS[geom_GeometryType.LINE_STRING] = readLineStringGeometry;
        GEOMETRY_READERS[geom_GeometryType.POLYGON] = readPolygonGeometry;
        GEOMETRY_READERS[geom_GeometryType.MULTI_POINT] = readMultiPointGeometry;
        GEOMETRY_READERS[geom_GeometryType.MULTI_LINE_STRING] = readMultiLineStringGeometry;
        GEOMETRY_READERS[geom_GeometryType.MULTI_POLYGON] = readMultiPolygonGeometry;
        var GEOMETRY_WRITERS = {};
        GEOMETRY_WRITERS[geom_GeometryType.POINT] = writePointGeometry;
        GEOMETRY_WRITERS[geom_GeometryType.LINE_STRING] = writeLineStringGeometry;
        GEOMETRY_WRITERS[geom_GeometryType.POLYGON] = writePolygonGeometry;
        GEOMETRY_WRITERS[geom_GeometryType.MULTI_POINT] = writeMultiPointGeometry;
        GEOMETRY_WRITERS[geom_GeometryType.MULTI_LINE_STRING] = writeMultiLineStringGeometry;
        GEOMETRY_WRITERS[geom_GeometryType.MULTI_POLYGON] = writeMultiPolygonGeometry;
        var EsriJSON_EsriJSON = function(_super) {
          EsriJSON_extends(EsriJSON, _super);
          function EsriJSON(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this) || this;
            _this.geometryName_ = options.geometryName;
            return _this;
          }
          EsriJSON.prototype.readFeatureFromObject = function(object, opt_options, opt_idField) {
            var esriJSONFeature = object;
            var geometry = readGeometry(esriJSONFeature.geometry, opt_options);
            var feature = new ol_Feature();
            if (this.geometryName_) {
              feature.setGeometryName(this.geometryName_);
            }
            feature.setGeometry(geometry);
            if (esriJSONFeature.attributes) {
              feature.setProperties(esriJSONFeature.attributes, true);
              var id = esriJSONFeature.attributes[opt_idField];
              if (id !== void 0) {
                feature.setId(id);
              }
            }
            return feature;
          };
          EsriJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
            var options = opt_options ? opt_options : {};
            if (object["features"]) {
              var esriJSONFeatureSet = object;
              var features = [];
              var esriJSONFeatures = esriJSONFeatureSet.features;
              for (var i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {
                features.push(this.readFeatureFromObject(esriJSONFeatures[i], options, object.objectIdFieldName));
              }
              return features;
            } else {
              return [this.readFeatureFromObject(object, options)];
            }
          };
          EsriJSON.prototype.readGeometryFromObject = function(object, opt_options) {
            return readGeometry(object, opt_options);
          };
          EsriJSON.prototype.readProjectionFromObject = function(object) {
            if (object["spatialReference"] && object["spatialReference"]["wkid"] !== void 0) {
              var spatialReference = object["spatialReference"];
              var crs = spatialReference.wkid;
              return proj_get("EPSG:" + crs);
            } else {
              return null;
            }
          };
          EsriJSON.prototype.writeGeometryObject = function(geometry, opt_options) {
            return writeGeometry(geometry, this.adaptOptions(opt_options));
          };
          EsriJSON.prototype.writeFeatureObject = function(feature, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            var object = {};
            if (!feature.hasProperties()) {
              object["attributes"] = {};
              return object;
            }
            var properties = feature.getProperties();
            var geometry = feature.getGeometry();
            if (geometry) {
              object["geometry"] = writeGeometry(geometry, opt_options);
              var projection = opt_options && (opt_options.dataProjection || opt_options.featureProjection);
              if (projection) {
                object["geometry"]["spatialReference"] = {
                  wkid: Number(proj_get(projection).getCode().split(":").pop())
                };
              }
              delete properties[feature.getGeometryName()];
            }
            if (!Object(ol_obj["d"])(properties)) {
              object["attributes"] = properties;
            } else {
              object["attributes"] = {};
            }
            return object;
          };
          EsriJSON.prototype.writeFeaturesObject = function(features, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            var objects = [];
            for (var i = 0, ii = features.length; i < ii; ++i) {
              objects.push(this.writeFeatureObject(features[i], opt_options));
            }
            return {
              "features": objects
            };
          };
          return EsriJSON;
        }(format_JSONFeature);
        function readGeometry(object, opt_options) {
          var _a, _b;
          if (!object) {
            return null;
          }
          var type;
          if (typeof object["x"] === "number" && typeof object["y"] === "number") {
            type = geom_GeometryType.POINT;
          } else if (object["points"]) {
            type = geom_GeometryType.MULTI_POINT;
          } else if (object["paths"]) {
            var esriJSONPolyline = object;
            if (esriJSONPolyline.paths.length === 1) {
              type = geom_GeometryType.LINE_STRING;
            } else {
              type = geom_GeometryType.MULTI_LINE_STRING;
            }
          } else if (object["rings"]) {
            var esriJSONPolygon = object;
            var layout = getGeometryLayout(esriJSONPolygon);
            var rings = convertRings(esriJSONPolygon.rings, layout);
            if (rings.length === 1) {
              type = geom_GeometryType.POLYGON;
              object = Object(ol_obj["a"])({}, object, (_a = {}, _a["rings"] = rings[0], _a));
            } else {
              type = geom_GeometryType.MULTI_POLYGON;
              object = Object(ol_obj["a"])({}, object, (_b = {}, _b["rings"] = rings, _b));
            }
          }
          var geometryReader = GEOMETRY_READERS[type];
          return transformGeometryWithOptions(geometryReader(object), false, opt_options);
        }
        function convertRings(rings, layout) {
          var flatRing = [];
          var outerRings = [];
          var holes = [];
          var i, ii;
          for (i = 0, ii = rings.length; i < ii; ++i) {
            flatRing.length = 0;
            deflateCoordinates(flatRing, 0, rings[i], layout.length);
            var clockwise = linearRingIsClockwise(flatRing, 0, flatRing.length, layout.length);
            if (clockwise) {
              outerRings.push([rings[i]]);
            } else {
              holes.push(rings[i]);
            }
          }
          while (holes.length) {
            var hole = holes.shift();
            var matched = false;
            for (i = outerRings.length - 1; i >= 0; i--) {
              var outerRing = outerRings[i][0];
              var containsHole = containsExtent(new geom_LinearRing(outerRing).getExtent(), new geom_LinearRing(hole).getExtent());
              if (containsHole) {
                outerRings[i].push(hole);
                matched = true;
                break;
              }
            }
            if (!matched) {
              outerRings.push([hole.reverse()]);
            }
          }
          return outerRings;
        }
        function readPointGeometry(object) {
          var point;
          if (object.m !== void 0 && object.z !== void 0) {
            point = new geom_Point([object.x, object.y, object.z, object.m], GeometryLayout.XYZM);
          } else if (object.z !== void 0) {
            point = new geom_Point([object.x, object.y, object.z], GeometryLayout.XYZ);
          } else if (object.m !== void 0) {
            point = new geom_Point([object.x, object.y, object.m], GeometryLayout.XYM);
          } else {
            point = new geom_Point([object.x, object.y]);
          }
          return point;
        }
        function readLineStringGeometry(object) {
          var layout = getGeometryLayout(object);
          return new geom_LineString(object.paths[0], layout);
        }
        function readMultiLineStringGeometry(object) {
          var layout = getGeometryLayout(object);
          return new geom_MultiLineString(object.paths, layout);
        }
        function getGeometryLayout(object) {
          var layout = GeometryLayout.XY;
          if (object.hasZ === true && object.hasM === true) {
            layout = GeometryLayout.XYZM;
          } else if (object.hasZ === true) {
            layout = GeometryLayout.XYZ;
          } else if (object.hasM === true) {
            layout = GeometryLayout.XYM;
          }
          return layout;
        }
        function readMultiPointGeometry(object) {
          var layout = getGeometryLayout(object);
          return new geom_MultiPoint(object.points, layout);
        }
        function readMultiPolygonGeometry(object) {
          var layout = getGeometryLayout(object);
          return new geom_MultiPolygon(object.rings, layout);
        }
        function readPolygonGeometry(object) {
          var layout = getGeometryLayout(object);
          return new geom_Polygon(object.rings, layout);
        }
        function writePointGeometry(geometry, opt_options) {
          var coordinates = geometry.getCoordinates();
          var esriJSON;
          var layout = geometry.getLayout();
          if (layout === GeometryLayout.XYZ) {
            esriJSON = {
              x: coordinates[0],
              y: coordinates[1],
              z: coordinates[2]
            };
          } else if (layout === GeometryLayout.XYM) {
            esriJSON = {
              x: coordinates[0],
              y: coordinates[1],
              m: coordinates[2]
            };
          } else if (layout === GeometryLayout.XYZM) {
            esriJSON = {
              x: coordinates[0],
              y: coordinates[1],
              z: coordinates[2],
              m: coordinates[3]
            };
          } else if (layout === GeometryLayout.XY) {
            esriJSON = {
              x: coordinates[0],
              y: coordinates[1]
            };
          } else {
            assert2(false, 34);
          }
          return esriJSON;
        }
        function getHasZM(geometry) {
          var layout = geometry.getLayout();
          return {
            hasZ: layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM,
            hasM: layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM
          };
        }
        function writeLineStringGeometry(lineString, opt_options) {
          var hasZM = getHasZM(lineString);
          return {
            hasZ: hasZM.hasZ,
            hasM: hasZM.hasM,
            paths: [
              lineString.getCoordinates()
            ]
          };
        }
        function writePolygonGeometry(polygon, opt_options) {
          var hasZM = getHasZM(polygon);
          return {
            hasZ: hasZM.hasZ,
            hasM: hasZM.hasM,
            rings: polygon.getCoordinates(false)
          };
        }
        function writeMultiLineStringGeometry(multiLineString, opt_options) {
          var hasZM = getHasZM(multiLineString);
          return {
            hasZ: hasZM.hasZ,
            hasM: hasZM.hasM,
            paths: multiLineString.getCoordinates()
          };
        }
        function writeMultiPointGeometry(multiPoint, opt_options) {
          var hasZM = getHasZM(multiPoint);
          return {
            hasZ: hasZM.hasZ,
            hasM: hasZM.hasM,
            points: multiPoint.getCoordinates()
          };
        }
        function writeMultiPolygonGeometry(geometry, opt_options) {
          var hasZM = getHasZM(geometry);
          var coordinates = geometry.getCoordinates(false);
          var output = [];
          for (var i = 0; i < coordinates.length; i++) {
            for (var x = coordinates[i].length - 1; x >= 0; x--) {
              output.push(coordinates[i][x]);
            }
          }
          return {
            hasZ: hasZM.hasZ,
            hasM: hasZM.hasM,
            rings: output
          };
        }
        function writeGeometry(geometry, opt_options) {
          var geometryWriter = GEOMETRY_WRITERS[geometry.getType()];
          return geometryWriter(transformGeometryWithOptions(geometry, true, opt_options), opt_options);
        }
        var format_EsriJSON = EsriJSON_EsriJSON;
        var GeoJSON_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GeoJSON_GeoJSON = function(_super) {
          GeoJSON_extends(GeoJSON, _super);
          function GeoJSON(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this) || this;
            _this.dataProjection = proj_get(options.dataProjection ? options.dataProjection : "EPSG:4326");
            if (options.featureProjection) {
              _this.defaultFeatureProjection = proj_get(options.featureProjection);
            }
            _this.geometryName_ = options.geometryName;
            _this.extractGeometryName_ = options.extractGeometryName;
            _this.supportedMediaTypes = [
              "application/geo+json",
              "application/vnd.geo+json"
            ];
            return _this;
          }
          GeoJSON.prototype.readFeatureFromObject = function(object, opt_options) {
            var geoJSONFeature = null;
            if (object["type"] === "Feature") {
              geoJSONFeature = object;
            } else {
              geoJSONFeature = {
                "type": "Feature",
                "geometry": object,
                "properties": null
              };
            }
            var geometry = GeoJSON_readGeometry(geoJSONFeature["geometry"], opt_options);
            var feature = new ol_Feature();
            if (this.geometryName_) {
              feature.setGeometryName(this.geometryName_);
            } else if (this.extractGeometryName_ && "geometry_name" in geoJSONFeature !== void 0) {
              feature.setGeometryName(geoJSONFeature["geometry_name"]);
            }
            feature.setGeometry(geometry);
            if ("id" in geoJSONFeature) {
              feature.setId(geoJSONFeature["id"]);
            }
            if (geoJSONFeature["properties"]) {
              feature.setProperties(geoJSONFeature["properties"], true);
            }
            return feature;
          };
          GeoJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
            var geoJSONObject = object;
            var features = null;
            if (geoJSONObject["type"] === "FeatureCollection") {
              var geoJSONFeatureCollection = object;
              features = [];
              var geoJSONFeatures = geoJSONFeatureCollection["features"];
              for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
                features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
              }
            } else {
              features = [this.readFeatureFromObject(object, opt_options)];
            }
            return features;
          };
          GeoJSON.prototype.readGeometryFromObject = function(object, opt_options) {
            return GeoJSON_readGeometry(object, opt_options);
          };
          GeoJSON.prototype.readProjectionFromObject = function(object) {
            var crs = object["crs"];
            var projection;
            if (crs) {
              if (crs["type"] == "name") {
                projection = proj_get(crs["properties"]["name"]);
              } else if (crs["type"] === "EPSG") {
                projection = proj_get("EPSG:" + crs["properties"]["code"]);
              } else {
                assert2(false, 36);
              }
            } else {
              projection = this.dataProjection;
            }
            return projection;
          };
          GeoJSON.prototype.writeFeatureObject = function(feature, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            var object = {
              "type": "Feature",
              geometry: null,
              properties: null
            };
            var id = feature.getId();
            if (id !== void 0) {
              object.id = id;
            }
            if (!feature.hasProperties()) {
              return object;
            }
            var properties = feature.getProperties();
            var geometry = feature.getGeometry();
            if (geometry) {
              object.geometry = GeoJSON_writeGeometry(geometry, opt_options);
              delete properties[feature.getGeometryName()];
            }
            if (!Object(ol_obj["d"])(properties)) {
              object.properties = properties;
            }
            return object;
          };
          GeoJSON.prototype.writeFeaturesObject = function(features, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            var objects = [];
            for (var i = 0, ii = features.length; i < ii; ++i) {
              objects.push(this.writeFeatureObject(features[i], opt_options));
            }
            return {
              type: "FeatureCollection",
              features: objects
            };
          };
          GeoJSON.prototype.writeGeometryObject = function(geometry, opt_options) {
            return GeoJSON_writeGeometry(geometry, this.adaptOptions(opt_options));
          };
          return GeoJSON;
        }(format_JSONFeature);
        function GeoJSON_readGeometry(object, opt_options) {
          if (!object) {
            return null;
          }
          var geometry;
          switch (object["type"]) {
            case geom_GeometryType.POINT: {
              geometry = GeoJSON_readPointGeometry(object);
              break;
            }
            case geom_GeometryType.LINE_STRING: {
              geometry = GeoJSON_readLineStringGeometry(object);
              break;
            }
            case geom_GeometryType.POLYGON: {
              geometry = GeoJSON_readPolygonGeometry(object);
              break;
            }
            case geom_GeometryType.MULTI_POINT: {
              geometry = GeoJSON_readMultiPointGeometry(object);
              break;
            }
            case geom_GeometryType.MULTI_LINE_STRING: {
              geometry = GeoJSON_readMultiLineStringGeometry(object);
              break;
            }
            case geom_GeometryType.MULTI_POLYGON: {
              geometry = GeoJSON_readMultiPolygonGeometry(object);
              break;
            }
            case geom_GeometryType.GEOMETRY_COLLECTION: {
              geometry = readGeometryCollectionGeometry(object);
              break;
            }
            default: {
              throw new Error("Unsupported GeoJSON type: " + object.type);
            }
          }
          return transformGeometryWithOptions(geometry, false, opt_options);
        }
        function readGeometryCollectionGeometry(object, opt_options) {
          var geometries = object["geometries"].map(function(geometry) {
            return GeoJSON_readGeometry(geometry, opt_options);
          });
          return new geom_GeometryCollection(geometries);
        }
        function GeoJSON_readPointGeometry(object) {
          return new geom_Point(object["coordinates"]);
        }
        function GeoJSON_readLineStringGeometry(object) {
          return new geom_LineString(object["coordinates"]);
        }
        function GeoJSON_readMultiLineStringGeometry(object) {
          return new geom_MultiLineString(object["coordinates"]);
        }
        function GeoJSON_readMultiPointGeometry(object) {
          return new geom_MultiPoint(object["coordinates"]);
        }
        function GeoJSON_readMultiPolygonGeometry(object) {
          return new geom_MultiPolygon(object["coordinates"]);
        }
        function GeoJSON_readPolygonGeometry(object) {
          return new geom_Polygon(object["coordinates"]);
        }
        function GeoJSON_writeGeometry(geometry, opt_options) {
          geometry = transformGeometryWithOptions(geometry, true, opt_options);
          var type = geometry.getType();
          var geoJSON;
          switch (type) {
            case geom_GeometryType.POINT: {
              geoJSON = GeoJSON_writePointGeometry(geometry, opt_options);
              break;
            }
            case geom_GeometryType.LINE_STRING: {
              geoJSON = GeoJSON_writeLineStringGeometry(geometry, opt_options);
              break;
            }
            case geom_GeometryType.POLYGON: {
              geoJSON = GeoJSON_writePolygonGeometry(geometry, opt_options);
              break;
            }
            case geom_GeometryType.MULTI_POINT: {
              geoJSON = GeoJSON_writeMultiPointGeometry(geometry, opt_options);
              break;
            }
            case geom_GeometryType.MULTI_LINE_STRING: {
              geoJSON = GeoJSON_writeMultiLineStringGeometry(geometry, opt_options);
              break;
            }
            case geom_GeometryType.MULTI_POLYGON: {
              geoJSON = GeoJSON_writeMultiPolygonGeometry(geometry, opt_options);
              break;
            }
            case geom_GeometryType.GEOMETRY_COLLECTION: {
              geoJSON = writeGeometryCollectionGeometry(geometry, opt_options);
              break;
            }
            case geom_GeometryType.CIRCLE: {
              geoJSON = {
                type: "GeometryCollection",
                geometries: []
              };
              break;
            }
            default: {
              throw new Error("Unsupported geometry type: " + type);
            }
          }
          return geoJSON;
        }
        function writeGeometryCollectionGeometry(geometry, opt_options) {
          var geometries = geometry.getGeometriesArray().map(function(geometry2) {
            var options = Object(ol_obj["a"])({}, opt_options);
            delete options.featureProjection;
            return GeoJSON_writeGeometry(geometry2, options);
          });
          return {
            type: "GeometryCollection",
            geometries
          };
        }
        function GeoJSON_writeLineStringGeometry(geometry, opt_options) {
          return {
            type: "LineString",
            coordinates: geometry.getCoordinates()
          };
        }
        function GeoJSON_writeMultiLineStringGeometry(geometry, opt_options) {
          return {
            type: "MultiLineString",
            coordinates: geometry.getCoordinates()
          };
        }
        function GeoJSON_writeMultiPointGeometry(geometry, opt_options) {
          return {
            type: "MultiPoint",
            coordinates: geometry.getCoordinates()
          };
        }
        function GeoJSON_writeMultiPolygonGeometry(geometry, opt_options) {
          var right;
          if (opt_options) {
            right = opt_options.rightHanded;
          }
          return {
            type: "MultiPolygon",
            coordinates: geometry.getCoordinates(right)
          };
        }
        function GeoJSON_writePointGeometry(geometry, opt_options) {
          return {
            type: "Point",
            coordinates: geometry.getCoordinates()
          };
        }
        function GeoJSON_writePolygonGeometry(geometry, opt_options) {
          var right;
          if (opt_options) {
            right = opt_options.rightHanded;
          }
          return {
            type: "Polygon",
            coordinates: geometry.getCoordinates(right)
          };
        }
        var format_GeoJSON = GeoJSON_GeoJSON;
        var XML_SCHEMA_INSTANCE_URI = "http://www.w3.org/2001/XMLSchema-instance";
        function createElementNS(namespaceURI, qualifiedName) {
          return getDocument().createElementNS(namespaceURI, qualifiedName);
        }
        function getAllTextContent(node, normalizeWhitespace) {
          return getAllTextContent_(node, normalizeWhitespace, []).join("");
        }
        function getAllTextContent_(node, normalizeWhitespace, accumulator) {
          if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
            if (normalizeWhitespace) {
              accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ""));
            } else {
              accumulator.push(node.nodeValue);
            }
          } else {
            var n = void 0;
            for (n = node.firstChild; n; n = n.nextSibling) {
              getAllTextContent_(n, normalizeWhitespace, accumulator);
            }
          }
          return accumulator;
        }
        function isDocument(object) {
          return "documentElement" in object;
        }
        function getAttributeNS(node, namespaceURI, name) {
          return node.getAttributeNS(namespaceURI, name) || "";
        }
        function xml_parse(xml) {
          return new DOMParser().parseFromString(xml, "application/xml");
        }
        function makeArrayExtender(valueReader, opt_this) {
          return function(node, objectStack) {
            var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
            if (value !== void 0) {
              var array = objectStack[objectStack.length - 1];
              Object(ol_array["c"])(array, value);
            }
          };
        }
        function makeArrayPusher(valueReader, opt_this) {
          return function(node, objectStack) {
            var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
            if (value !== void 0) {
              var array = objectStack[objectStack.length - 1];
              array.push(value);
            }
          };
        }
        function makeReplacer(valueReader, opt_this) {
          return function(node, objectStack) {
            var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
            if (value !== void 0) {
              objectStack[objectStack.length - 1] = value;
            }
          };
        }
        function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {
          return function(node, objectStack) {
            var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
            if (value !== void 0) {
              var object = objectStack[objectStack.length - 1];
              var property = opt_property !== void 0 ? opt_property : node.localName;
              var array = void 0;
              if (property in object) {
                array = object[property];
              } else {
                array = [];
                object[property] = array;
              }
              array.push(value);
            }
          };
        }
        function makeObjectPropertySetter(valueReader, opt_property, opt_this) {
          return function(node, objectStack) {
            var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
            if (value !== void 0) {
              var object = objectStack[objectStack.length - 1];
              var property = opt_property !== void 0 ? opt_property : node.localName;
              object[property] = value;
            }
          };
        }
        function makeChildAppender(nodeWriter, opt_this) {
          return function(node, value, objectStack) {
            nodeWriter.call(opt_this !== void 0 ? opt_this : this, node, value, objectStack);
            var parent = objectStack[objectStack.length - 1];
            var parentNode = parent.node;
            parentNode.appendChild(node);
          };
        }
        function makeArraySerializer(nodeWriter, opt_this) {
          var serializersNS, nodeFactory;
          return function(node, value, objectStack) {
            if (serializersNS === void 0) {
              serializersNS = {};
              var serializers = {};
              serializers[node.localName] = nodeWriter;
              serializersNS[node.namespaceURI] = serializers;
              nodeFactory = makeSimpleNodeFactory(node.localName);
            }
            serialize(serializersNS, nodeFactory, value, objectStack);
          };
        }
        function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {
          var fixedNodeName = opt_nodeName;
          return function(value, objectStack, opt_nodeName2) {
            var context = objectStack[objectStack.length - 1];
            var node = context.node;
            var nodeName = fixedNodeName;
            if (nodeName === void 0) {
              nodeName = opt_nodeName2;
            }
            var namespaceURI = opt_namespaceURI !== void 0 ? opt_namespaceURI : node.namespaceURI;
            return createElementNS(namespaceURI, nodeName);
          };
        }
        var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();
        function makeSequence(object, orderedKeys) {
          var length = orderedKeys.length;
          var sequence = new Array(length);
          for (var i = 0; i < length; ++i) {
            sequence[i] = object[orderedKeys[i]];
          }
          return sequence;
        }
        function makeStructureNS(namespaceURIs, structure, opt_structureNS) {
          var structureNS = opt_structureNS !== void 0 ? opt_structureNS : {};
          var i, ii;
          for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
            structureNS[namespaceURIs[i]] = structure;
          }
          return structureNS;
        }
        function parseNode(parsersNS, node, objectStack, opt_this) {
          var n;
          for (n = node.firstElementChild; n; n = n.nextElementSibling) {
            var parsers = parsersNS[n.namespaceURI];
            if (parsers !== void 0) {
              var parser2 = parsers[n.localName];
              if (parser2 !== void 0) {
                parser2.call(opt_this, n, objectStack);
              }
            }
          }
        }
        function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {
          objectStack.push(object);
          parseNode(parsersNS, node, objectStack, opt_this);
          return objectStack.pop();
        }
        function serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
          var length = (opt_keys !== void 0 ? opt_keys : values).length;
          var value, node;
          for (var i = 0; i < length; ++i) {
            value = values[i];
            if (value !== void 0) {
              node = nodeFactory.call(opt_this !== void 0 ? opt_this : this, value, objectStack, opt_keys !== void 0 ? opt_keys[i] : void 0);
              if (node !== void 0) {
                serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);
              }
            }
          }
        }
        function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
          objectStack.push(object);
          serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);
          return objectStack.pop();
        }
        var xmlSerializer_ = void 0;
        function registerXMLSerializer(xmlSerializer) {
          xmlSerializer_ = xmlSerializer;
        }
        function getXMLSerializer() {
          if (xmlSerializer_ === void 0 && typeof XMLSerializer !== "undefined") {
            xmlSerializer_ = new XMLSerializer();
          }
          return xmlSerializer_;
        }
        var document_ = void 0;
        function registerDocument(document2) {
          document_ = document2;
        }
        function getDocument() {
          if (document_ === void 0 && typeof document !== "undefined") {
            document_ = document.implementation.createDocument("", "", null);
          }
          return document_;
        }
        var XMLFeature_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var XMLFeature_XMLFeature = function(_super) {
          XMLFeature_extends(XMLFeature, _super);
          function XMLFeature() {
            var _this = _super.call(this) || this;
            _this.xmlSerializer_ = getXMLSerializer();
            return _this;
          }
          XMLFeature.prototype.getType = function() {
            return FormatType.XML;
          };
          XMLFeature.prototype.readFeature = function(source, opt_options) {
            if (!source) {
              return null;
            } else if (typeof source === "string") {
              var doc = xml_parse(source);
              return this.readFeatureFromDocument(doc, opt_options);
            } else if (isDocument(source)) {
              return this.readFeatureFromDocument(source, opt_options);
            } else {
              return this.readFeatureFromNode(source, opt_options);
            }
          };
          XMLFeature.prototype.readFeatureFromDocument = function(doc, opt_options) {
            var features = this.readFeaturesFromDocument(doc, opt_options);
            if (features.length > 0) {
              return features[0];
            } else {
              return null;
            }
          };
          XMLFeature.prototype.readFeatureFromNode = function(node, opt_options) {
            return null;
          };
          XMLFeature.prototype.readFeatures = function(source, opt_options) {
            if (!source) {
              return [];
            } else if (typeof source === "string") {
              var doc = xml_parse(source);
              return this.readFeaturesFromDocument(doc, opt_options);
            } else if (isDocument(source)) {
              return this.readFeaturesFromDocument(source, opt_options);
            } else {
              return this.readFeaturesFromNode(source, opt_options);
            }
          };
          XMLFeature.prototype.readFeaturesFromDocument = function(doc, opt_options) {
            var features = [];
            for (var n = doc.firstChild; n; n = n.nextSibling) {
              if (n.nodeType == Node.ELEMENT_NODE) {
                Object(ol_array["c"])(features, this.readFeaturesFromNode(n, opt_options));
              }
            }
            return features;
          };
          XMLFeature.prototype.readFeaturesFromNode = function(node, opt_options) {
            return Object(util["b"])();
          };
          XMLFeature.prototype.readGeometry = function(source, opt_options) {
            if (!source) {
              return null;
            } else if (typeof source === "string") {
              var doc = xml_parse(source);
              return this.readGeometryFromDocument(doc, opt_options);
            } else if (isDocument(source)) {
              return this.readGeometryFromDocument(source, opt_options);
            } else {
              return this.readGeometryFromNode(source, opt_options);
            }
          };
          XMLFeature.prototype.readGeometryFromDocument = function(doc, opt_options) {
            return null;
          };
          XMLFeature.prototype.readGeometryFromNode = function(node, opt_options) {
            return null;
          };
          XMLFeature.prototype.readProjection = function(source) {
            if (!source) {
              return null;
            } else if (typeof source === "string") {
              var doc = xml_parse(source);
              return this.readProjectionFromDocument(doc);
            } else if (isDocument(source)) {
              return this.readProjectionFromDocument(source);
            } else {
              return this.readProjectionFromNode(source);
            }
          };
          XMLFeature.prototype.readProjectionFromDocument = function(doc) {
            return this.dataProjection;
          };
          XMLFeature.prototype.readProjectionFromNode = function(node) {
            return this.dataProjection;
          };
          XMLFeature.prototype.writeFeature = function(feature, opt_options) {
            var node = this.writeFeatureNode(feature, opt_options);
            return this.xmlSerializer_.serializeToString(node);
          };
          XMLFeature.prototype.writeFeatureNode = function(feature, opt_options) {
            return null;
          };
          XMLFeature.prototype.writeFeatures = function(features, opt_options) {
            var node = this.writeFeaturesNode(features, opt_options);
            return this.xmlSerializer_.serializeToString(node);
          };
          XMLFeature.prototype.writeFeaturesNode = function(features, opt_options) {
            return null;
          };
          XMLFeature.prototype.writeGeometry = function(geometry, opt_options) {
            var node = this.writeGeometryNode(geometry, opt_options);
            return this.xmlSerializer_.serializeToString(node);
          };
          XMLFeature.prototype.writeGeometryNode = function(geometry, opt_options) {
            return null;
          };
          return XMLFeature;
        }(format_Feature);
        var format_XMLFeature = XMLFeature_XMLFeature;
        var GMLBase_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GMLNS = "http://www.opengis.net/gml";
        var ONLY_WHITESPACE_RE = /^[\s\xa0]*$/;
        var GMLBase_GMLBase = function(_super) {
          GMLBase_extends(GMLBase, _super);
          function GMLBase(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.featureType = options.featureType;
            _this.featureNS = options.featureNS;
            _this.srsName = options.srsName;
            _this.schemaLocation = "";
            _this.FEATURE_COLLECTION_PARSERS = {};
            _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {
              "featureMember": makeArrayPusher(_this.readFeaturesInternal),
              "featureMembers": makeReplacer(_this.readFeaturesInternal)
            };
            _this.supportedMediaTypes = ["application/gml+xml"];
            return _this;
          }
          GMLBase.prototype.readFeaturesInternal = function(node, objectStack) {
            var localName = node.localName;
            var features = null;
            if (localName == "FeatureCollection") {
              features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);
            } else if (localName == "featureMembers" || localName == "featureMember" || localName == "member") {
              var context = objectStack[0];
              var featureType = context["featureType"];
              var featureNS = context["featureNS"];
              var prefix = "p";
              var defaultPrefix = "p0";
              if (!featureType && node.childNodes) {
                featureType = [], featureNS = {};
                for (var i = 0, ii = node.childNodes.length; i < ii; ++i) {
                  var child = node.childNodes[i];
                  if (child.nodeType === 1) {
                    var ft = child.nodeName.split(":").pop();
                    if (featureType.indexOf(ft) === -1) {
                      var key = "";
                      var count = 0;
                      var uri = child.namespaceURI;
                      for (var candidate in featureNS) {
                        if (featureNS[candidate] === uri) {
                          key = candidate;
                          break;
                        }
                        ++count;
                      }
                      if (!key) {
                        key = prefix + count;
                        featureNS[key] = uri;
                      }
                      featureType.push(key + ":" + ft);
                    }
                  }
                }
                if (localName != "featureMember") {
                  context["featureType"] = featureType;
                  context["featureNS"] = featureNS;
                }
              }
              if (typeof featureNS === "string") {
                var ns = featureNS;
                featureNS = {};
                featureNS[defaultPrefix] = ns;
              }
              var parsersNS = {};
              var featureTypes = Array.isArray(featureType) ? featureType : [featureType];
              for (var p in featureNS) {
                var parsers = {};
                for (var i = 0, ii = featureTypes.length; i < ii; ++i) {
                  var featurePrefix = featureTypes[i].indexOf(":") === -1 ? defaultPrefix : featureTypes[i].split(":")[0];
                  if (featurePrefix === p) {
                    parsers[featureTypes[i].split(":").pop()] = localName == "featureMembers" ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);
                  }
                }
                parsersNS[featureNS[p]] = parsers;
              }
              if (localName == "featureMember" || localName == "member") {
                features = pushParseAndPop(void 0, parsersNS, node, objectStack);
              } else {
                features = pushParseAndPop([], parsersNS, node, objectStack);
              }
            }
            if (features === null) {
              features = [];
            }
            return features;
          };
          GMLBase.prototype.readGeometryElement = function(node, objectStack) {
            var context = objectStack[0];
            context["srsName"] = node.firstElementChild.getAttribute("srsName");
            context["srsDimension"] = node.firstElementChild.getAttribute("srsDimension");
            var geometry = pushParseAndPop(null, this.GEOMETRY_PARSERS, node, objectStack, this);
            if (geometry) {
              if (Array.isArray(geometry)) {
                return transformExtentWithOptions(geometry, context);
              } else {
                return transformGeometryWithOptions(geometry, false, context);
              }
            } else {
              return void 0;
            }
          };
          GMLBase.prototype.readFeatureElementInternal = function(node, objectStack, asFeature) {
            var geometryName;
            var values = {};
            for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
              var value = void 0;
              var localName = n.localName;
              if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {
                value = getAllTextContent(n, false);
                if (ONLY_WHITESPACE_RE.test(value)) {
                  value = void 0;
                }
              } else {
                if (asFeature) {
                  value = this.readGeometryElement(n, objectStack);
                }
                if (!value) {
                  value = this.readFeatureElementInternal(n, objectStack, false);
                } else if (localName !== "boundedBy") {
                  geometryName = localName;
                }
              }
              if (values[localName]) {
                if (!(values[localName] instanceof Array)) {
                  values[localName] = [values[localName]];
                }
                values[localName].push(value);
              } else {
                values[localName] = value;
              }
              var len = n.attributes.length;
              if (len > 0) {
                values[localName] = { _content_: values[localName] };
                for (var i = 0; i < len; i++) {
                  var attName = n.attributes[i].name;
                  values[localName][attName] = n.attributes[i].value;
                }
              }
            }
            if (!asFeature) {
              return values;
            } else {
              var feature = new ol_Feature(values);
              if (geometryName) {
                feature.setGeometryName(geometryName);
              }
              var fid = node.getAttribute("fid") || getAttributeNS(node, this.namespace, "id");
              if (fid) {
                feature.setId(fid);
              }
              return feature;
            }
          };
          GMLBase.prototype.readFeatureElement = function(node, objectStack) {
            return this.readFeatureElementInternal(node, objectStack, true);
          };
          GMLBase.prototype.readPoint = function(node, objectStack) {
            var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
            if (flatCoordinates) {
              return new geom_Point(flatCoordinates, GeometryLayout.XYZ);
            }
          };
          GMLBase.prototype.readMultiPoint = function(node, objectStack) {
            var coordinates = pushParseAndPop([], this.MULTIPOINT_PARSERS, node, objectStack, this);
            if (coordinates) {
              return new geom_MultiPoint(coordinates);
            } else {
              return void 0;
            }
          };
          GMLBase.prototype.readMultiLineString = function(node, objectStack) {
            var lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS, node, objectStack, this);
            if (lineStrings) {
              return new geom_MultiLineString(lineStrings);
            }
          };
          GMLBase.prototype.readMultiPolygon = function(node, objectStack) {
            var polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS, node, objectStack, this);
            if (polygons) {
              return new geom_MultiPolygon(polygons);
            }
          };
          GMLBase.prototype.pointMemberParser = function(node, objectStack) {
            parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);
          };
          GMLBase.prototype.lineStringMemberParser = function(node, objectStack) {
            parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);
          };
          GMLBase.prototype.polygonMemberParser = function(node, objectStack) {
            parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);
          };
          GMLBase.prototype.readLineString = function(node, objectStack) {
            var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
            if (flatCoordinates) {
              var lineString = new geom_LineString(flatCoordinates, GeometryLayout.XYZ);
              return lineString;
            } else {
              return void 0;
            }
          };
          GMLBase.prototype.readFlatLinearRing = function(node, objectStack) {
            var ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
            if (ring) {
              return ring;
            } else {
              return void 0;
            }
          };
          GMLBase.prototype.readLinearRing = function(node, objectStack) {
            var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
            if (flatCoordinates) {
              return new geom_LinearRing(flatCoordinates, GeometryLayout.XYZ);
            }
          };
          GMLBase.prototype.readPolygon = function(node, objectStack) {
            var flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
            if (flatLinearRings && flatLinearRings[0]) {
              var flatCoordinates = flatLinearRings[0];
              var ends = [flatCoordinates.length];
              var i = void 0, ii = void 0;
              for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
                Object(ol_array["c"])(flatCoordinates, flatLinearRings[i]);
                ends.push(flatCoordinates.length);
              }
              return new geom_Polygon(flatCoordinates, GeometryLayout.XYZ, ends);
            } else {
              return void 0;
            }
          };
          GMLBase.prototype.readFlatCoordinatesFromNode = function(node, objectStack) {
            return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
          };
          GMLBase.prototype.readGeometryFromNode = function(node, opt_options) {
            var geometry = this.readGeometryElement(node, [
              this.getReadOptions(node, opt_options ? opt_options : {})
            ]);
            return geometry ? geometry : null;
          };
          GMLBase.prototype.readFeaturesFromNode = function(node, opt_options) {
            var options = {
              featureType: this.featureType,
              featureNS: this.featureNS
            };
            if (opt_options) {
              Object(ol_obj["a"])(options, this.getReadOptions(node, opt_options));
            }
            var features = this.readFeaturesInternal(node, [options]);
            return features || [];
          };
          GMLBase.prototype.readProjectionFromNode = function(node) {
            return proj_get(this.srsName ? this.srsName : node.firstElementChild.getAttribute("srsName"));
          };
          return GMLBase;
        }(format_XMLFeature);
        GMLBase_GMLBase.prototype.namespace = GMLNS;
        GMLBase_GMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {
          "http://www.opengis.net/gml": {}
        };
        GMLBase_GMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
          "http://www.opengis.net/gml": {}
        };
        GMLBase_GMLBase.prototype.GEOMETRY_PARSERS = {
          "http://www.opengis.net/gml": {}
        };
        GMLBase_GMLBase.prototype.MULTIPOINT_PARSERS = {
          "http://www.opengis.net/gml": {
            "pointMember": makeArrayPusher(GMLBase_GMLBase.prototype.pointMemberParser),
            "pointMembers": makeArrayPusher(GMLBase_GMLBase.prototype.pointMemberParser)
          }
        };
        GMLBase_GMLBase.prototype.MULTILINESTRING_PARSERS = {
          "http://www.opengis.net/gml": {
            "lineStringMember": makeArrayPusher(GMLBase_GMLBase.prototype.lineStringMemberParser),
            "lineStringMembers": makeArrayPusher(GMLBase_GMLBase.prototype.lineStringMemberParser)
          }
        };
        GMLBase_GMLBase.prototype.MULTIPOLYGON_PARSERS = {
          "http://www.opengis.net/gml": {
            "polygonMember": makeArrayPusher(GMLBase_GMLBase.prototype.polygonMemberParser),
            "polygonMembers": makeArrayPusher(GMLBase_GMLBase.prototype.polygonMemberParser)
          }
        };
        GMLBase_GMLBase.prototype.POINTMEMBER_PARSERS = {
          "http://www.opengis.net/gml": {
            "Point": makeArrayPusher(GMLBase_GMLBase.prototype.readFlatCoordinatesFromNode)
          }
        };
        GMLBase_GMLBase.prototype.LINESTRINGMEMBER_PARSERS = {
          "http://www.opengis.net/gml": {
            "LineString": makeArrayPusher(GMLBase_GMLBase.prototype.readLineString)
          }
        };
        GMLBase_GMLBase.prototype.POLYGONMEMBER_PARSERS = {
          "http://www.opengis.net/gml": {
            "Polygon": makeArrayPusher(GMLBase_GMLBase.prototype.readPolygon)
          }
        };
        GMLBase_GMLBase.prototype.RING_PARSERS = {
          "http://www.opengis.net/gml": {
            "LinearRing": makeReplacer(GMLBase_GMLBase.prototype.readFlatLinearRing)
          }
        };
        var format_GMLBase = GMLBase_GMLBase;
        function readBoolean(node) {
          var s = getAllTextContent(node, false);
          return readBooleanString(s);
        }
        function readBooleanString(string) {
          var m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
          if (m) {
            return m[1] !== void 0 || false;
          } else {
            return void 0;
          }
        }
        function readDateTime(node) {
          var s = getAllTextContent(node, false);
          var dateTime = Date.parse(s);
          return isNaN(dateTime) ? void 0 : dateTime / 1e3;
        }
        function readDecimal(node) {
          var s = getAllTextContent(node, false);
          return readDecimalString(s);
        }
        function readDecimalString(string) {
          var m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
          if (m) {
            return parseFloat(m[1]);
          } else {
            return void 0;
          }
        }
        function readPositiveInteger(node) {
          var s = getAllTextContent(node, false);
          return readNonNegativeIntegerString(s);
        }
        function readNonNegativeIntegerString(string) {
          var m = /^\s*(\d+)\s*$/.exec(string);
          if (m) {
            return parseInt(m[1], 10);
          } else {
            return void 0;
          }
        }
        function readString(node) {
          return getAllTextContent(node, false).trim();
        }
        function writeBooleanTextNode(node, bool) {
          writeStringTextNode(node, bool ? "1" : "0");
        }
        function writeCDATASection(node, string) {
          node.appendChild(getDocument().createCDATASection(string));
        }
        function writeDateTimeTextNode(node, dateTime) {
          var date = new Date(dateTime * 1e3);
          var string = date.getUTCFullYear() + "-" + padNumber(date.getUTCMonth() + 1, 2) + "-" + padNumber(date.getUTCDate(), 2) + "T" + padNumber(date.getUTCHours(), 2) + ":" + padNumber(date.getUTCMinutes(), 2) + ":" + padNumber(date.getUTCSeconds(), 2) + "Z";
          node.appendChild(getDocument().createTextNode(string));
        }
        function writeDecimalTextNode(node, decimal) {
          var string = decimal.toPrecision();
          node.appendChild(getDocument().createTextNode(string));
        }
        function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {
          var string = nonNegativeInteger.toString();
          node.appendChild(getDocument().createTextNode(string));
        }
        function writeStringTextNode(node, string) {
          node.appendChild(getDocument().createTextNode(string));
        }
        var GML2_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var schemaLocation = GMLNS + " http://schemas.opengis.net/gml/2.1.2/feature.xsd";
        var MULTIGEOMETRY_TO_MEMBER_NODENAME = {
          "MultiLineString": "lineStringMember",
          "MultiCurve": "curveMember",
          "MultiPolygon": "polygonMember",
          "MultiSurface": "surfaceMember"
        };
        var GML2_GML2 = function(_super) {
          GML2_extends(GML2, _super);
          function GML2(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, options) || this;
            _this.FEATURE_COLLECTION_PARSERS[GMLNS]["featureMember"] = makeArrayPusher(_this.readFeaturesInternal);
            _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
            return _this;
          }
          GML2.prototype.readFlatCoordinates = function(node, objectStack) {
            var s = getAllTextContent(node, false).replace(/^\s*|\s*$/g, "");
            var context = objectStack[0];
            var containerSrs = context["srsName"];
            var axisOrientation = "enu";
            if (containerSrs) {
              var proj = proj_get(containerSrs);
              if (proj) {
                axisOrientation = proj.getAxisOrientation();
              }
            }
            var coordsGroups = s.trim().split(/\s+/);
            var flatCoordinates = [];
            for (var i = 0, ii = coordsGroups.length; i < ii; i++) {
              var coords = coordsGroups[i].split(/,+/);
              var x = parseFloat(coords[0]);
              var y = parseFloat(coords[1]);
              var z = coords.length === 3 ? parseFloat(coords[2]) : 0;
              if (axisOrientation.substr(0, 2) === "en") {
                flatCoordinates.push(x, y, z);
              } else {
                flatCoordinates.push(y, x, z);
              }
            }
            return flatCoordinates;
          };
          GML2.prototype.readBox = function(node, objectStack) {
            var flatCoordinates = pushParseAndPop([null], this.BOX_PARSERS_, node, objectStack, this);
            return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);
          };
          GML2.prototype.innerBoundaryIsParser = function(node, objectStack) {
            var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
            if (flatLinearRing) {
              var flatLinearRings = objectStack[objectStack.length - 1];
              flatLinearRings.push(flatLinearRing);
            }
          };
          GML2.prototype.outerBoundaryIsParser = function(node, objectStack) {
            var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
            if (flatLinearRing) {
              var flatLinearRings = objectStack[objectStack.length - 1];
              flatLinearRings[0] = flatLinearRing;
            }
          };
          GML2.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
            var context = objectStack[objectStack.length - 1];
            var multiSurface = context["multiSurface"];
            var surface = context["surface"];
            var multiCurve = context["multiCurve"];
            var nodeName;
            if (!Array.isArray(value)) {
              nodeName = value.getType();
              if (nodeName === "MultiPolygon" && multiSurface === true) {
                nodeName = "MultiSurface";
              } else if (nodeName === "Polygon" && surface === true) {
                nodeName = "Surface";
              } else if (nodeName === "MultiLineString" && multiCurve === true) {
                nodeName = "MultiCurve";
              }
            } else {
              nodeName = "Envelope";
            }
            return createElementNS("http://www.opengis.net/gml", nodeName);
          };
          GML2.prototype.writeFeatureElement = function(node, feature, objectStack) {
            var fid = feature.getId();
            if (fid) {
              node.setAttribute("fid", fid);
            }
            var context = objectStack[objectStack.length - 1];
            var featureNS = context["featureNS"];
            var geometryName = feature.getGeometryName();
            if (!context.serializers) {
              context.serializers = {};
              context.serializers[featureNS] = {};
            }
            var keys = [];
            var values = [];
            if (feature.hasProperties()) {
              var properties = feature.getProperties();
              for (var key in properties) {
                var value = properties[key];
                if (value !== null) {
                  keys.push(key);
                  values.push(value);
                  if (key == geometryName || typeof value.getSimplifiedGeometry === "function") {
                    if (!(key in context.serializers[featureNS])) {
                      context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);
                    }
                  } else {
                    if (!(key in context.serializers[featureNS])) {
                      context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
                    }
                  }
                }
              }
            }
            var item = Object(ol_obj["a"])({}, context);
            item.node = node;
            pushSerializeAndPop(item, context.serializers, makeSimpleNodeFactory(void 0, featureNS), values, objectStack, keys);
          };
          GML2.prototype.writeCurveOrLineString = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var srsName = context["srsName"];
            if (node.nodeName !== "LineStringSegment" && srsName) {
              node.setAttribute("srsName", srsName);
            }
            if (node.nodeName === "LineString" || node.nodeName === "LineStringSegment") {
              var coordinates = this.createCoordinatesNode_(node.namespaceURI);
              node.appendChild(coordinates);
              this.writeCoordinates_(coordinates, geometry, objectStack);
            } else if (node.nodeName === "Curve") {
              var segments = createElementNS(node.namespaceURI, "segments");
              node.appendChild(segments);
              this.writeCurveSegments_(segments, geometry, objectStack);
            }
          };
          GML2.prototype.writeLineStringOrCurveMember = function(node, line, objectStack) {
            var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
            if (child) {
              node.appendChild(child);
              this.writeCurveOrLineString(child, line, objectStack);
            }
          };
          GML2.prototype.writeMultiCurveOrLineString = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsName = context["srsName"];
            var curve = context["curve"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var lines = geometry.getLineStrings();
            pushSerializeAndPop({ node, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);
          };
          GML2.prototype.writeGeometryElement = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var item = Object(ol_obj["a"])({}, context);
            item["node"] = node;
            var value;
            if (Array.isArray(geometry)) {
              value = transformExtentWithOptions(geometry, context);
            } else {
              value = transformGeometryWithOptions(geometry, true, context);
            }
            pushSerializeAndPop(item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, void 0, this);
          };
          GML2.prototype.createCoordinatesNode_ = function(namespaceURI) {
            var coordinates = createElementNS(namespaceURI, "coordinates");
            coordinates.setAttribute("decimal", ".");
            coordinates.setAttribute("cs", ",");
            coordinates.setAttribute("ts", " ");
            return coordinates;
          };
          GML2.prototype.writeCoordinates_ = function(node, value, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsName = context["srsName"];
            var points = value.getCoordinates();
            var len = points.length;
            var parts = new Array(len);
            for (var i = 0; i < len; ++i) {
              var point = points[i];
              parts[i] = this.getCoords_(point, srsName, hasZ);
            }
            writeStringTextNode(node, parts.join(" "));
          };
          GML2.prototype.writeCurveSegments_ = function(node, line, objectStack) {
            var child = createElementNS(node.namespaceURI, "LineStringSegment");
            node.appendChild(child);
            this.writeCurveOrLineString(child, line, objectStack);
          };
          GML2.prototype.writeSurfaceOrPolygon = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsName = context["srsName"];
            if (node.nodeName !== "PolygonPatch" && srsName) {
              node.setAttribute("srsName", srsName);
            }
            if (node.nodeName === "Polygon" || node.nodeName === "PolygonPatch") {
              var rings = geometry.getLinearRings();
              pushSerializeAndPop({ node, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);
            } else if (node.nodeName === "Surface") {
              var patches = createElementNS(node.namespaceURI, "patches");
              node.appendChild(patches);
              this.writeSurfacePatches_(patches, geometry, objectStack);
            }
          };
          GML2.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
            var context = objectStack[objectStack.length - 1];
            var parentNode = context.node;
            var exteriorWritten = context["exteriorWritten"];
            if (exteriorWritten === void 0) {
              context["exteriorWritten"] = true;
            }
            return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs");
          };
          GML2.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {
            var child = createElementNS(node.namespaceURI, "PolygonPatch");
            node.appendChild(child);
            this.writeSurfaceOrPolygon(child, polygon, objectStack);
          };
          GML2.prototype.writeRing = function(node, ring, objectStack) {
            var linearRing = createElementNS(node.namespaceURI, "LinearRing");
            node.appendChild(linearRing);
            this.writeLinearRing(linearRing, ring, objectStack);
          };
          GML2.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {
            var axisOrientation = "enu";
            if (opt_srsName) {
              axisOrientation = proj_get(opt_srsName).getAxisOrientation();
            }
            var coords = axisOrientation.substr(0, 2) === "en" ? point[0] + "," + point[1] : point[1] + "," + point[0];
            if (opt_hasZ) {
              var z = point[2] || 0;
              coords += "," + z;
            }
            return coords;
          };
          GML2.prototype.writePoint = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsName = context["srsName"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var coordinates = this.createCoordinatesNode_(node.namespaceURI);
            node.appendChild(coordinates);
            var point = geometry.getCoordinates();
            var coord = this.getCoords_(point, srsName, hasZ);
            writeStringTextNode(coordinates, coord);
          };
          GML2.prototype.writeMultiPoint = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsName = context["srsName"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var points = geometry.getPoints();
            pushSerializeAndPop({ node, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory("pointMember"), points, objectStack, void 0, this);
          };
          GML2.prototype.writePointMember = function(node, point, objectStack) {
            var child = createElementNS(node.namespaceURI, "Point");
            node.appendChild(child);
            this.writePoint(child, point, objectStack);
          };
          GML2.prototype.writeLinearRing = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var srsName = context["srsName"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var coordinates = this.createCoordinatesNode_(node.namespaceURI);
            node.appendChild(coordinates);
            this.writeCoordinates_(coordinates, geometry, objectStack);
          };
          GML2.prototype.writeMultiSurfaceOrPolygon = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsName = context["srsName"];
            var surface = context["surface"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var polygons = geometry.getPolygons();
            pushSerializeAndPop({ node, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);
          };
          GML2.prototype.writeSurfaceOrPolygonMember = function(node, polygon, objectStack) {
            var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
            if (child) {
              node.appendChild(child);
              this.writeSurfaceOrPolygon(child, polygon, objectStack);
            }
          };
          GML2.prototype.writeEnvelope = function(node, extent, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var srsName = context["srsName"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var keys = ["lowerCorner", "upperCorner"];
            var values = [extent[0] + " " + extent[1], extent[2] + " " + extent[3]];
            pushSerializeAndPop({ node }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);
          };
          GML2.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
            var parentNode = objectStack[objectStack.length - 1].node;
            return createElementNS("http://www.opengis.net/gml", MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
          };
          return GML2;
        }(format_GMLBase);
        GML2_GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
          "http://www.opengis.net/gml": {
            "coordinates": makeReplacer(GML2_GML2.prototype.readFlatCoordinates)
          }
        };
        GML2_GML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {
          "http://www.opengis.net/gml": {
            "innerBoundaryIs": GML2_GML2.prototype.innerBoundaryIsParser,
            "outerBoundaryIs": GML2_GML2.prototype.outerBoundaryIsParser
          }
        };
        GML2_GML2.prototype.BOX_PARSERS_ = {
          "http://www.opengis.net/gml": {
            "coordinates": makeArrayPusher(GML2_GML2.prototype.readFlatCoordinates)
          }
        };
        GML2_GML2.prototype.GEOMETRY_PARSERS = {
          "http://www.opengis.net/gml": {
            "Point": makeReplacer(format_GMLBase.prototype.readPoint),
            "MultiPoint": makeReplacer(format_GMLBase.prototype.readMultiPoint),
            "LineString": makeReplacer(format_GMLBase.prototype.readLineString),
            "MultiLineString": makeReplacer(format_GMLBase.prototype.readMultiLineString),
            "LinearRing": makeReplacer(format_GMLBase.prototype.readLinearRing),
            "Polygon": makeReplacer(format_GMLBase.prototype.readPolygon),
            "MultiPolygon": makeReplacer(format_GMLBase.prototype.readMultiPolygon),
            "Box": makeReplacer(GML2_GML2.prototype.readBox)
          }
        };
        GML2_GML2.prototype.GEOMETRY_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "Curve": makeChildAppender(GML2_GML2.prototype.writeCurveOrLineString),
            "MultiCurve": makeChildAppender(GML2_GML2.prototype.writeMultiCurveOrLineString),
            "Point": makeChildAppender(GML2_GML2.prototype.writePoint),
            "MultiPoint": makeChildAppender(GML2_GML2.prototype.writeMultiPoint),
            "LineString": makeChildAppender(GML2_GML2.prototype.writeCurveOrLineString),
            "MultiLineString": makeChildAppender(GML2_GML2.prototype.writeMultiCurveOrLineString),
            "LinearRing": makeChildAppender(GML2_GML2.prototype.writeLinearRing),
            "Polygon": makeChildAppender(GML2_GML2.prototype.writeSurfaceOrPolygon),
            "MultiPolygon": makeChildAppender(GML2_GML2.prototype.writeMultiSurfaceOrPolygon),
            "Surface": makeChildAppender(GML2_GML2.prototype.writeSurfaceOrPolygon),
            "MultiSurface": makeChildAppender(GML2_GML2.prototype.writeMultiSurfaceOrPolygon),
            "Envelope": makeChildAppender(GML2_GML2.prototype.writeEnvelope)
          }
        };
        GML2_GML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "lineStringMember": makeChildAppender(GML2_GML2.prototype.writeLineStringOrCurveMember),
            "curveMember": makeChildAppender(GML2_GML2.prototype.writeLineStringOrCurveMember)
          }
        };
        GML2_GML2.prototype.RING_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "outerBoundaryIs": makeChildAppender(GML2_GML2.prototype.writeRing),
            "innerBoundaryIs": makeChildAppender(GML2_GML2.prototype.writeRing)
          }
        };
        GML2_GML2.prototype.POINTMEMBER_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "pointMember": makeChildAppender(GML2_GML2.prototype.writePointMember)
          }
        };
        GML2_GML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "surfaceMember": makeChildAppender(GML2_GML2.prototype.writeSurfaceOrPolygonMember),
            "polygonMember": makeChildAppender(GML2_GML2.prototype.writeSurfaceOrPolygonMember)
          }
        };
        GML2_GML2.prototype.ENVELOPE_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "lowerCorner": makeChildAppender(writeStringTextNode),
            "upperCorner": makeChildAppender(writeStringTextNode)
          }
        };
        var format_GML2 = GML2_GML2;
        var GML3_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GML3_schemaLocation = GMLNS + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd";
        var GML3_MULTIGEOMETRY_TO_MEMBER_NODENAME = {
          "MultiLineString": "lineStringMember",
          "MultiCurve": "curveMember",
          "MultiPolygon": "polygonMember",
          "MultiSurface": "surfaceMember"
        };
        var GML3_GML3 = function(_super) {
          GML3_extends(GML3, _super);
          function GML3(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, options) || this;
            _this.surface_ = options.surface !== void 0 ? options.surface : false;
            _this.curve_ = options.curve !== void 0 ? options.curve : false;
            _this.multiCurve_ = options.multiCurve !== void 0 ? options.multiCurve : true;
            _this.multiSurface_ = options.multiSurface !== void 0 ? options.multiSurface : true;
            _this.schemaLocation = options.schemaLocation ? options.schemaLocation : GML3_schemaLocation;
            _this.hasZ = options.hasZ !== void 0 ? options.hasZ : false;
            return _this;
          }
          GML3.prototype.readMultiCurve = function(node, objectStack) {
            var lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node, objectStack, this);
            if (lineStrings) {
              var multiLineString = new geom_MultiLineString(lineStrings);
              return multiLineString;
            } else {
              return void 0;
            }
          };
          GML3.prototype.readMultiSurface = function(node, objectStack) {
            var polygons = pushParseAndPop([], this.MULTISURFACE_PARSERS, node, objectStack, this);
            if (polygons) {
              return new geom_MultiPolygon(polygons);
            }
          };
          GML3.prototype.curveMemberParser = function(node, objectStack) {
            parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);
          };
          GML3.prototype.surfaceMemberParser = function(node, objectStack) {
            parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);
          };
          GML3.prototype.readPatch = function(node, objectStack) {
            return pushParseAndPop([null], this.PATCHES_PARSERS, node, objectStack, this);
          };
          GML3.prototype.readSegment = function(node, objectStack) {
            return pushParseAndPop([null], this.SEGMENTS_PARSERS, node, objectStack, this);
          };
          GML3.prototype.readPolygonPatch = function(node, objectStack) {
            return pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
          };
          GML3.prototype.readLineStringSegment = function(node, objectStack) {
            return pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
          };
          GML3.prototype.interiorParser = function(node, objectStack) {
            var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
            if (flatLinearRing) {
              var flatLinearRings = objectStack[objectStack.length - 1];
              flatLinearRings.push(flatLinearRing);
            }
          };
          GML3.prototype.exteriorParser = function(node, objectStack) {
            var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
            if (flatLinearRing) {
              var flatLinearRings = objectStack[objectStack.length - 1];
              flatLinearRings[0] = flatLinearRing;
            }
          };
          GML3.prototype.readSurface = function(node, objectStack) {
            var flatLinearRings = pushParseAndPop([null], this.SURFACE_PARSERS, node, objectStack, this);
            if (flatLinearRings && flatLinearRings[0]) {
              var flatCoordinates = flatLinearRings[0];
              var ends = [flatCoordinates.length];
              var i = void 0, ii = void 0;
              for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
                Object(ol_array["c"])(flatCoordinates, flatLinearRings[i]);
                ends.push(flatCoordinates.length);
              }
              return new geom_Polygon(flatCoordinates, GeometryLayout.XYZ, ends);
            } else {
              return void 0;
            }
          };
          GML3.prototype.readCurve = function(node, objectStack) {
            var flatCoordinates = pushParseAndPop([null], this.CURVE_PARSERS, node, objectStack, this);
            if (flatCoordinates) {
              var lineString = new geom_LineString(flatCoordinates, GeometryLayout.XYZ);
              return lineString;
            } else {
              return void 0;
            }
          };
          GML3.prototype.readEnvelope = function(node, objectStack) {
            var flatCoordinates = pushParseAndPop([null], this.ENVELOPE_PARSERS, node, objectStack, this);
            return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);
          };
          GML3.prototype.readFlatPos = function(node, objectStack) {
            var s = getAllTextContent(node, false);
            var re = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
            var flatCoordinates = [];
            var m;
            while (m = re.exec(s)) {
              flatCoordinates.push(parseFloat(m[1]));
              s = s.substr(m[0].length);
            }
            if (s !== "") {
              return void 0;
            }
            var context = objectStack[0];
            var containerSrs = context["srsName"];
            var axisOrientation = "enu";
            if (containerSrs) {
              var proj = proj_get(containerSrs);
              axisOrientation = proj.getAxisOrientation();
            }
            if (axisOrientation === "neu") {
              var i = void 0, ii = void 0;
              for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {
                var y = flatCoordinates[i];
                var x = flatCoordinates[i + 1];
                flatCoordinates[i] = x;
                flatCoordinates[i + 1] = y;
              }
            }
            var len = flatCoordinates.length;
            if (len == 2) {
              flatCoordinates.push(0);
            }
            if (len === 0) {
              return void 0;
            }
            return flatCoordinates;
          };
          GML3.prototype.readFlatPosList = function(node, objectStack) {
            var s = getAllTextContent(node, false).replace(/^\s*|\s*$/g, "");
            var context = objectStack[0];
            var containerSrs = context["srsName"];
            var contextDimension = context["srsDimension"];
            var axisOrientation = "enu";
            if (containerSrs) {
              var proj = proj_get(containerSrs);
              axisOrientation = proj.getAxisOrientation();
            }
            var coords = s.split(/\s+/);
            var dim = 2;
            if (node.getAttribute("srsDimension")) {
              dim = readNonNegativeIntegerString(node.getAttribute("srsDimension"));
            } else if (node.getAttribute("dimension")) {
              dim = readNonNegativeIntegerString(node.getAttribute("dimension"));
            } else if (node.parentNode.getAttribute("srsDimension")) {
              dim = readNonNegativeIntegerString(node.parentNode.getAttribute("srsDimension"));
            } else if (contextDimension) {
              dim = readNonNegativeIntegerString(contextDimension);
            }
            var x, y, z;
            var flatCoordinates = [];
            for (var i = 0, ii = coords.length; i < ii; i += dim) {
              x = parseFloat(coords[i]);
              y = parseFloat(coords[i + 1]);
              z = dim === 3 ? parseFloat(coords[i + 2]) : 0;
              if (axisOrientation.substr(0, 2) === "en") {
                flatCoordinates.push(x, y, z);
              } else {
                flatCoordinates.push(y, x, z);
              }
            }
            return flatCoordinates;
          };
          GML3.prototype.writePos_ = function(node, value, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsDimension = hasZ ? "3" : "2";
            node.setAttribute("srsDimension", srsDimension);
            var srsName = context["srsName"];
            var axisOrientation = "enu";
            if (srsName) {
              axisOrientation = proj_get(srsName).getAxisOrientation();
            }
            var point = value.getCoordinates();
            var coords;
            if (axisOrientation.substr(0, 2) === "en") {
              coords = point[0] + " " + point[1];
            } else {
              coords = point[1] + " " + point[0];
            }
            if (hasZ) {
              var z = point[2] || 0;
              coords += " " + z;
            }
            writeStringTextNode(node, coords);
          };
          GML3.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {
            var axisOrientation = "enu";
            if (opt_srsName) {
              axisOrientation = proj_get(opt_srsName).getAxisOrientation();
            }
            var coords = axisOrientation.substr(0, 2) === "en" ? point[0] + " " + point[1] : point[1] + " " + point[0];
            if (opt_hasZ) {
              var z = point[2] || 0;
              coords += " " + z;
            }
            return coords;
          };
          GML3.prototype.writePosList_ = function(node, value, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsDimension = hasZ ? "3" : "2";
            node.setAttribute("srsDimension", srsDimension);
            var srsName = context["srsName"];
            var points = value.getCoordinates();
            var len = points.length;
            var parts = new Array(len);
            var point;
            for (var i = 0; i < len; ++i) {
              point = points[i];
              parts[i] = this.getCoords_(point, srsName, hasZ);
            }
            writeStringTextNode(node, parts.join(" "));
          };
          GML3.prototype.writePoint = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var srsName = context["srsName"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var pos = createElementNS(node.namespaceURI, "pos");
            node.appendChild(pos);
            this.writePos_(pos, geometry, objectStack);
          };
          GML3.prototype.writeEnvelope = function(node, extent, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var srsName = context["srsName"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var keys = ["lowerCorner", "upperCorner"];
            var values = [extent[0] + " " + extent[1], extent[2] + " " + extent[3]];
            pushSerializeAndPop({ node }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);
          };
          GML3.prototype.writeLinearRing = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var srsName = context["srsName"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var posList = createElementNS(node.namespaceURI, "posList");
            node.appendChild(posList);
            this.writePosList_(posList, geometry, objectStack);
          };
          GML3.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
            var context = objectStack[objectStack.length - 1];
            var parentNode = context.node;
            var exteriorWritten = context["exteriorWritten"];
            if (exteriorWritten === void 0) {
              context["exteriorWritten"] = true;
            }
            return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? "interior" : "exterior");
          };
          GML3.prototype.writeSurfaceOrPolygon = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsName = context["srsName"];
            if (node.nodeName !== "PolygonPatch" && srsName) {
              node.setAttribute("srsName", srsName);
            }
            if (node.nodeName === "Polygon" || node.nodeName === "PolygonPatch") {
              var rings = geometry.getLinearRings();
              pushSerializeAndPop({ node, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);
            } else if (node.nodeName === "Surface") {
              var patches = createElementNS(node.namespaceURI, "patches");
              node.appendChild(patches);
              this.writeSurfacePatches_(patches, geometry, objectStack);
            }
          };
          GML3.prototype.writeCurveOrLineString = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var srsName = context["srsName"];
            if (node.nodeName !== "LineStringSegment" && srsName) {
              node.setAttribute("srsName", srsName);
            }
            if (node.nodeName === "LineString" || node.nodeName === "LineStringSegment") {
              var posList = createElementNS(node.namespaceURI, "posList");
              node.appendChild(posList);
              this.writePosList_(posList, geometry, objectStack);
            } else if (node.nodeName === "Curve") {
              var segments = createElementNS(node.namespaceURI, "segments");
              node.appendChild(segments);
              this.writeCurveSegments_(segments, geometry, objectStack);
            }
          };
          GML3.prototype.writeMultiSurfaceOrPolygon = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsName = context["srsName"];
            var surface = context["surface"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var polygons = geometry.getPolygons();
            pushSerializeAndPop({ node, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);
          };
          GML3.prototype.writeMultiPoint = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var srsName = context["srsName"];
            var hasZ = context["hasZ"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var points = geometry.getPoints();
            pushSerializeAndPop({ node, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory("pointMember"), points, objectStack, void 0, this);
          };
          GML3.prototype.writeMultiCurveOrLineString = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var hasZ = context["hasZ"];
            var srsName = context["srsName"];
            var curve = context["curve"];
            if (srsName) {
              node.setAttribute("srsName", srsName);
            }
            var lines = geometry.getLineStrings();
            pushSerializeAndPop({ node, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);
          };
          GML3.prototype.writeRing = function(node, ring, objectStack) {
            var linearRing = createElementNS(node.namespaceURI, "LinearRing");
            node.appendChild(linearRing);
            this.writeLinearRing(linearRing, ring, objectStack);
          };
          GML3.prototype.writeSurfaceOrPolygonMember = function(node, polygon, objectStack) {
            var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
            if (child) {
              node.appendChild(child);
              this.writeSurfaceOrPolygon(child, polygon, objectStack);
            }
          };
          GML3.prototype.writePointMember = function(node, point, objectStack) {
            var child = createElementNS(node.namespaceURI, "Point");
            node.appendChild(child);
            this.writePoint(child, point, objectStack);
          };
          GML3.prototype.writeLineStringOrCurveMember = function(node, line, objectStack) {
            var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
            if (child) {
              node.appendChild(child);
              this.writeCurveOrLineString(child, line, objectStack);
            }
          };
          GML3.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {
            var child = createElementNS(node.namespaceURI, "PolygonPatch");
            node.appendChild(child);
            this.writeSurfaceOrPolygon(child, polygon, objectStack);
          };
          GML3.prototype.writeCurveSegments_ = function(node, line, objectStack) {
            var child = createElementNS(node.namespaceURI, "LineStringSegment");
            node.appendChild(child);
            this.writeCurveOrLineString(child, line, objectStack);
          };
          GML3.prototype.writeGeometryElement = function(node, geometry, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var item = Object(ol_obj["a"])({}, context);
            item["node"] = node;
            var value;
            if (Array.isArray(geometry)) {
              value = transformExtentWithOptions(geometry, context);
            } else {
              value = transformGeometryWithOptions(geometry, true, context);
            }
            pushSerializeAndPop(item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, void 0, this);
          };
          GML3.prototype.writeFeatureElement = function(node, feature, objectStack) {
            var fid = feature.getId();
            if (fid) {
              node.setAttribute("fid", fid);
            }
            var context = objectStack[objectStack.length - 1];
            var featureNS = context["featureNS"];
            var geometryName = feature.getGeometryName();
            if (!context.serializers) {
              context.serializers = {};
              context.serializers[featureNS] = {};
            }
            var keys = [];
            var values = [];
            if (feature.hasProperties()) {
              var properties = feature.getProperties();
              for (var key in properties) {
                var value = properties[key];
                if (value !== null) {
                  keys.push(key);
                  values.push(value);
                  if (key == geometryName || typeof value.getSimplifiedGeometry === "function") {
                    if (!(key in context.serializers[featureNS])) {
                      context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);
                    }
                  } else {
                    if (!(key in context.serializers[featureNS])) {
                      context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
                    }
                  }
                }
              }
            }
            var item = Object(ol_obj["a"])({}, context);
            item.node = node;
            pushSerializeAndPop(item, context.serializers, makeSimpleNodeFactory(void 0, featureNS), values, objectStack, keys);
          };
          GML3.prototype.writeFeatureMembers_ = function(node, features, objectStack) {
            var context = objectStack[objectStack.length - 1];
            var featureType = context["featureType"];
            var featureNS = context["featureNS"];
            var serializers = {};
            serializers[featureNS] = {};
            serializers[featureNS][featureType] = makeChildAppender(this.writeFeatureElement, this);
            var item = Object(ol_obj["a"])({}, context);
            item.node = node;
            pushSerializeAndPop(item, serializers, makeSimpleNodeFactory(featureType, featureNS), features, objectStack);
          };
          GML3.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
            var parentNode = objectStack[objectStack.length - 1].node;
            return createElementNS(this.namespace, GML3_MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
          };
          GML3.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
            var context = objectStack[objectStack.length - 1];
            var multiSurface = context["multiSurface"];
            var surface = context["surface"];
            var curve = context["curve"];
            var multiCurve = context["multiCurve"];
            var nodeName;
            if (!Array.isArray(value)) {
              nodeName = value.getType();
              if (nodeName === "MultiPolygon" && multiSurface === true) {
                nodeName = "MultiSurface";
              } else if (nodeName === "Polygon" && surface === true) {
                nodeName = "Surface";
              } else if (nodeName === "LineString" && curve === true) {
                nodeName = "Curve";
              } else if (nodeName === "MultiLineString" && multiCurve === true) {
                nodeName = "MultiCurve";
              }
            } else {
              nodeName = "Envelope";
            }
            return createElementNS(this.namespace, nodeName);
          };
          GML3.prototype.writeGeometryNode = function(geometry, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            var geom = createElementNS(this.namespace, "geom");
            var context = {
              node: geom,
              hasZ: this.hasZ,
              srsName: this.srsName,
              curve: this.curve_,
              surface: this.surface_,
              multiSurface: this.multiSurface_,
              multiCurve: this.multiCurve_
            };
            if (opt_options) {
              Object(ol_obj["a"])(context, opt_options);
            }
            this.writeGeometryElement(geom, geometry, [context]);
            return geom;
          };
          GML3.prototype.writeFeaturesNode = function(features, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            var node = createElementNS(this.namespace, "featureMembers");
            node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", this.schemaLocation);
            var context = {
              srsName: this.srsName,
              hasZ: this.hasZ,
              curve: this.curve_,
              surface: this.surface_,
              multiSurface: this.multiSurface_,
              multiCurve: this.multiCurve_,
              featureNS: this.featureNS,
              featureType: this.featureType
            };
            if (opt_options) {
              Object(ol_obj["a"])(context, opt_options);
            }
            this.writeFeatureMembers_(node, features, [context]);
            return node;
          };
          return GML3;
        }(format_GMLBase);
        GML3_GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
          "http://www.opengis.net/gml": {
            "pos": makeReplacer(GML3_GML3.prototype.readFlatPos),
            "posList": makeReplacer(GML3_GML3.prototype.readFlatPosList),
            "coordinates": makeReplacer(format_GML2.prototype.readFlatCoordinates)
          }
        };
        GML3_GML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {
          "http://www.opengis.net/gml": {
            "interior": GML3_GML3.prototype.interiorParser,
            "exterior": GML3_GML3.prototype.exteriorParser
          }
        };
        GML3_GML3.prototype.GEOMETRY_PARSERS = {
          "http://www.opengis.net/gml": {
            "Point": makeReplacer(format_GMLBase.prototype.readPoint),
            "MultiPoint": makeReplacer(format_GMLBase.prototype.readMultiPoint),
            "LineString": makeReplacer(format_GMLBase.prototype.readLineString),
            "MultiLineString": makeReplacer(format_GMLBase.prototype.readMultiLineString),
            "LinearRing": makeReplacer(format_GMLBase.prototype.readLinearRing),
            "Polygon": makeReplacer(format_GMLBase.prototype.readPolygon),
            "MultiPolygon": makeReplacer(format_GMLBase.prototype.readMultiPolygon),
            "Surface": makeReplacer(GML3_GML3.prototype.readSurface),
            "MultiSurface": makeReplacer(GML3_GML3.prototype.readMultiSurface),
            "Curve": makeReplacer(GML3_GML3.prototype.readCurve),
            "MultiCurve": makeReplacer(GML3_GML3.prototype.readMultiCurve),
            "Envelope": makeReplacer(GML3_GML3.prototype.readEnvelope)
          }
        };
        GML3_GML3.prototype.MULTICURVE_PARSERS = {
          "http://www.opengis.net/gml": {
            "curveMember": makeArrayPusher(GML3_GML3.prototype.curveMemberParser),
            "curveMembers": makeArrayPusher(GML3_GML3.prototype.curveMemberParser)
          }
        };
        GML3_GML3.prototype.MULTISURFACE_PARSERS = {
          "http://www.opengis.net/gml": {
            "surfaceMember": makeArrayPusher(GML3_GML3.prototype.surfaceMemberParser),
            "surfaceMembers": makeArrayPusher(GML3_GML3.prototype.surfaceMemberParser)
          }
        };
        GML3_GML3.prototype.CURVEMEMBER_PARSERS = {
          "http://www.opengis.net/gml": {
            "LineString": makeArrayPusher(format_GMLBase.prototype.readLineString),
            "Curve": makeArrayPusher(GML3_GML3.prototype.readCurve)
          }
        };
        GML3_GML3.prototype.SURFACEMEMBER_PARSERS = {
          "http://www.opengis.net/gml": {
            "Polygon": makeArrayPusher(format_GMLBase.prototype.readPolygon),
            "Surface": makeArrayPusher(GML3_GML3.prototype.readSurface)
          }
        };
        GML3_GML3.prototype.SURFACE_PARSERS = {
          "http://www.opengis.net/gml": {
            "patches": makeReplacer(GML3_GML3.prototype.readPatch)
          }
        };
        GML3_GML3.prototype.CURVE_PARSERS = {
          "http://www.opengis.net/gml": {
            "segments": makeReplacer(GML3_GML3.prototype.readSegment)
          }
        };
        GML3_GML3.prototype.ENVELOPE_PARSERS = {
          "http://www.opengis.net/gml": {
            "lowerCorner": makeArrayPusher(GML3_GML3.prototype.readFlatPosList),
            "upperCorner": makeArrayPusher(GML3_GML3.prototype.readFlatPosList)
          }
        };
        GML3_GML3.prototype.PATCHES_PARSERS = {
          "http://www.opengis.net/gml": {
            "PolygonPatch": makeReplacer(GML3_GML3.prototype.readPolygonPatch)
          }
        };
        GML3_GML3.prototype.SEGMENTS_PARSERS = {
          "http://www.opengis.net/gml": {
            "LineStringSegment": makeReplacer(GML3_GML3.prototype.readLineStringSegment)
          }
        };
        GML3_GML3.prototype.writeFeatures;
        GML3_GML3.prototype.RING_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "exterior": makeChildAppender(GML3_GML3.prototype.writeRing),
            "interior": makeChildAppender(GML3_GML3.prototype.writeRing)
          }
        };
        GML3_GML3.prototype.ENVELOPE_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "lowerCorner": makeChildAppender(writeStringTextNode),
            "upperCorner": makeChildAppender(writeStringTextNode)
          }
        };
        GML3_GML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "surfaceMember": makeChildAppender(GML3_GML3.prototype.writeSurfaceOrPolygonMember),
            "polygonMember": makeChildAppender(GML3_GML3.prototype.writeSurfaceOrPolygonMember)
          }
        };
        GML3_GML3.prototype.POINTMEMBER_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "pointMember": makeChildAppender(GML3_GML3.prototype.writePointMember)
          }
        };
        GML3_GML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "lineStringMember": makeChildAppender(GML3_GML3.prototype.writeLineStringOrCurveMember),
            "curveMember": makeChildAppender(GML3_GML3.prototype.writeLineStringOrCurveMember)
          }
        };
        GML3_GML3.prototype.GEOMETRY_SERIALIZERS = {
          "http://www.opengis.net/gml": {
            "Curve": makeChildAppender(GML3_GML3.prototype.writeCurveOrLineString),
            "MultiCurve": makeChildAppender(GML3_GML3.prototype.writeMultiCurveOrLineString),
            "Point": makeChildAppender(GML3_GML3.prototype.writePoint),
            "MultiPoint": makeChildAppender(GML3_GML3.prototype.writeMultiPoint),
            "LineString": makeChildAppender(GML3_GML3.prototype.writeCurveOrLineString),
            "MultiLineString": makeChildAppender(GML3_GML3.prototype.writeMultiCurveOrLineString),
            "LinearRing": makeChildAppender(GML3_GML3.prototype.writeLinearRing),
            "Polygon": makeChildAppender(GML3_GML3.prototype.writeSurfaceOrPolygon),
            "MultiPolygon": makeChildAppender(GML3_GML3.prototype.writeMultiSurfaceOrPolygon),
            "Surface": makeChildAppender(GML3_GML3.prototype.writeSurfaceOrPolygon),
            "MultiSurface": makeChildAppender(GML3_GML3.prototype.writeMultiSurfaceOrPolygon),
            "Envelope": makeChildAppender(GML3_GML3.prototype.writeEnvelope)
          }
        };
        var format_GML3 = GML3_GML3;
        var GML = format_GML3;
        GML.prototype.writeFeatures;
        GML.prototype.writeFeaturesNode;
        var format_GML = GML;
        var GPX_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var NAMESPACE_URIS = [
          null,
          "http://www.topografix.com/GPX/1/0",
          "http://www.topografix.com/GPX/1/1"
        ];
        var SCHEMA_LOCATION = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd";
        var FEATURE_READER = {
          "rte": readRte,
          "trk": readTrk,
          "wpt": readWpt
        };
        var GPX_PARSERS = makeStructureNS(NAMESPACE_URIS, {
          "rte": makeArrayPusher(readRte),
          "trk": makeArrayPusher(readTrk),
          "wpt": makeArrayPusher(readWpt)
        });
        var LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
          "text": makeObjectPropertySetter(readString, "linkText"),
          "type": makeObjectPropertySetter(readString, "linkType")
        });
        var GPX_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
          "rte": makeChildAppender(writeRte),
          "trk": makeChildAppender(writeTrk),
          "wpt": makeChildAppender(writeWpt)
        });
        var GPX_GPX = function(_super) {
          GPX_extends(GPX, _super);
          function GPX(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.dataProjection = proj_get("EPSG:4326");
            _this.readExtensions_ = options.readExtensions;
            return _this;
          }
          GPX.prototype.handleReadExtensions_ = function(features) {
            if (!features) {
              features = [];
            }
            for (var i = 0, ii = features.length; i < ii; ++i) {
              var feature = features[i];
              if (this.readExtensions_) {
                var extensionsNode = feature.get("extensionsNode_") || null;
                this.readExtensions_(feature, extensionsNode);
              }
              feature.set("extensionsNode_", void 0);
            }
          };
          GPX.prototype.readFeatureFromNode = function(node, opt_options) {
            if (!Object(ol_array["f"])(NAMESPACE_URIS, node.namespaceURI)) {
              return null;
            }
            var featureReader = FEATURE_READER[node.localName];
            if (!featureReader) {
              return null;
            }
            var feature = featureReader(node, [
              this.getReadOptions(node, opt_options)
            ]);
            if (!feature) {
              return null;
            }
            this.handleReadExtensions_([feature]);
            return feature;
          };
          GPX.prototype.readFeaturesFromNode = function(node, opt_options) {
            if (!Object(ol_array["f"])(NAMESPACE_URIS, node.namespaceURI)) {
              return [];
            }
            if (node.localName == "gpx") {
              var features = pushParseAndPop([], GPX_PARSERS, node, [
                this.getReadOptions(node, opt_options)
              ]);
              if (features) {
                this.handleReadExtensions_(features);
                return features;
              } else {
                return [];
              }
            }
            return [];
          };
          GPX.prototype.writeFeaturesNode = function(features, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            var gpx = createElementNS("http://www.topografix.com/GPX/1/1", "gpx");
            var xmlnsUri = "http://www.w3.org/2000/xmlns/";
            gpx.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
            gpx.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATION);
            gpx.setAttribute("version", "1.1");
            gpx.setAttribute("creator", "OpenLayers");
            pushSerializeAndPop({ node: gpx }, GPX_SERIALIZERS, GPX_NODE_FACTORY, features, [opt_options]);
            return gpx;
          };
          return GPX;
        }(format_XMLFeature);
        var RTE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
          "name": makeObjectPropertySetter(readString),
          "cmt": makeObjectPropertySetter(readString),
          "desc": makeObjectPropertySetter(readString),
          "src": makeObjectPropertySetter(readString),
          "link": parseLink,
          "number": makeObjectPropertySetter(readPositiveInteger),
          "extensions": parseExtensions,
          "type": makeObjectPropertySetter(readString),
          "rtept": parseRtePt
        });
        var RTEPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
          "ele": makeObjectPropertySetter(readDecimal),
          "time": makeObjectPropertySetter(readDateTime)
        });
        var TRK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
          "name": makeObjectPropertySetter(readString),
          "cmt": makeObjectPropertySetter(readString),
          "desc": makeObjectPropertySetter(readString),
          "src": makeObjectPropertySetter(readString),
          "link": parseLink,
          "number": makeObjectPropertySetter(readPositiveInteger),
          "type": makeObjectPropertySetter(readString),
          "extensions": parseExtensions,
          "trkseg": parseTrkSeg
        });
        var TRKSEG_PARSERS = makeStructureNS(NAMESPACE_URIS, {
          "trkpt": parseTrkPt
        });
        var TRKPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
          "ele": makeObjectPropertySetter(readDecimal),
          "time": makeObjectPropertySetter(readDateTime)
        });
        var WPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
          "ele": makeObjectPropertySetter(readDecimal),
          "time": makeObjectPropertySetter(readDateTime),
          "magvar": makeObjectPropertySetter(readDecimal),
          "geoidheight": makeObjectPropertySetter(readDecimal),
          "name": makeObjectPropertySetter(readString),
          "cmt": makeObjectPropertySetter(readString),
          "desc": makeObjectPropertySetter(readString),
          "src": makeObjectPropertySetter(readString),
          "link": parseLink,
          "sym": makeObjectPropertySetter(readString),
          "type": makeObjectPropertySetter(readString),
          "fix": makeObjectPropertySetter(readString),
          "sat": makeObjectPropertySetter(readPositiveInteger),
          "hdop": makeObjectPropertySetter(readDecimal),
          "vdop": makeObjectPropertySetter(readDecimal),
          "pdop": makeObjectPropertySetter(readDecimal),
          "ageofdgpsdata": makeObjectPropertySetter(readDecimal),
          "dgpsid": makeObjectPropertySetter(readPositiveInteger),
          "extensions": parseExtensions
        });
        var LINK_SEQUENCE = ["text", "type"];
        var LINK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
          "text": makeChildAppender(writeStringTextNode),
          "type": makeChildAppender(writeStringTextNode)
        });
        var RTE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
          "name",
          "cmt",
          "desc",
          "src",
          "link",
          "number",
          "type",
          "rtept"
        ]);
        var RTE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
          "name": makeChildAppender(writeStringTextNode),
          "cmt": makeChildAppender(writeStringTextNode),
          "desc": makeChildAppender(writeStringTextNode),
          "src": makeChildAppender(writeStringTextNode),
          "link": makeChildAppender(writeLink),
          "number": makeChildAppender(writeNonNegativeIntegerTextNode),
          "type": makeChildAppender(writeStringTextNode),
          "rtept": makeArraySerializer(makeChildAppender(writeWptType))
        });
        var RTEPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ["ele", "time"]);
        var TRK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
          "name",
          "cmt",
          "desc",
          "src",
          "link",
          "number",
          "type",
          "trkseg"
        ]);
        var TRK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
          "name": makeChildAppender(writeStringTextNode),
          "cmt": makeChildAppender(writeStringTextNode),
          "desc": makeChildAppender(writeStringTextNode),
          "src": makeChildAppender(writeStringTextNode),
          "link": makeChildAppender(writeLink),
          "number": makeChildAppender(writeNonNegativeIntegerTextNode),
          "type": makeChildAppender(writeStringTextNode),
          "trkseg": makeArraySerializer(makeChildAppender(writeTrkSeg))
        });
        var TRKSEG_NODE_FACTORY = makeSimpleNodeFactory("trkpt");
        var TRKSEG_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
          "trkpt": makeChildAppender(writeWptType)
        });
        var WPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
          "ele",
          "time",
          "magvar",
          "geoidheight",
          "name",
          "cmt",
          "desc",
          "src",
          "link",
          "sym",
          "type",
          "fix",
          "sat",
          "hdop",
          "vdop",
          "pdop",
          "ageofdgpsdata",
          "dgpsid"
        ]);
        var WPT_TYPE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
          "ele": makeChildAppender(writeDecimalTextNode),
          "time": makeChildAppender(writeDateTimeTextNode),
          "magvar": makeChildAppender(writeDecimalTextNode),
          "geoidheight": makeChildAppender(writeDecimalTextNode),
          "name": makeChildAppender(writeStringTextNode),
          "cmt": makeChildAppender(writeStringTextNode),
          "desc": makeChildAppender(writeStringTextNode),
          "src": makeChildAppender(writeStringTextNode),
          "link": makeChildAppender(writeLink),
          "sym": makeChildAppender(writeStringTextNode),
          "type": makeChildAppender(writeStringTextNode),
          "fix": makeChildAppender(writeStringTextNode),
          "sat": makeChildAppender(writeNonNegativeIntegerTextNode),
          "hdop": makeChildAppender(writeDecimalTextNode),
          "vdop": makeChildAppender(writeDecimalTextNode),
          "pdop": makeChildAppender(writeDecimalTextNode),
          "ageofdgpsdata": makeChildAppender(writeDecimalTextNode),
          "dgpsid": makeChildAppender(writeNonNegativeIntegerTextNode)
        });
        var GEOMETRY_TYPE_TO_NODENAME = {
          "Point": "wpt",
          "LineString": "rte",
          "MultiLineString": "trk"
        };
        function GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {
          var geometry = value.getGeometry();
          if (geometry) {
            var nodeName = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];
            if (nodeName) {
              var parentNode = objectStack[objectStack.length - 1].node;
              return createElementNS(parentNode.namespaceURI, nodeName);
            }
          }
        }
        function appendCoordinate(flatCoordinates, layoutOptions, node, values) {
          flatCoordinates.push(parseFloat(node.getAttribute("lon")), parseFloat(node.getAttribute("lat")));
          if ("ele" in values) {
            flatCoordinates.push(values["ele"]);
            delete values["ele"];
            layoutOptions.hasZ = true;
          } else {
            flatCoordinates.push(0);
          }
          if ("time" in values) {
            flatCoordinates.push(values["time"]);
            delete values["time"];
            layoutOptions.hasM = true;
          } else {
            flatCoordinates.push(0);
          }
          return flatCoordinates;
        }
        function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
          var layout = GeometryLayout.XY;
          var stride = 2;
          if (layoutOptions.hasZ && layoutOptions.hasM) {
            layout = GeometryLayout.XYZM;
            stride = 4;
          } else if (layoutOptions.hasZ) {
            layout = GeometryLayout.XYZ;
            stride = 3;
          } else if (layoutOptions.hasM) {
            layout = GeometryLayout.XYM;
            stride = 3;
          }
          if (stride !== 4) {
            for (var i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {
              flatCoordinates[i * stride] = flatCoordinates[i * 4];
              flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];
              if (layoutOptions.hasZ) {
                flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];
              }
              if (layoutOptions.hasM) {
                flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];
              }
            }
            flatCoordinates.length = flatCoordinates.length / 4 * stride;
            if (ends) {
              for (var i = 0, ii = ends.length; i < ii; i++) {
                ends[i] = ends[i] / 4 * stride;
              }
            }
          }
          return layout;
        }
        function parseLink(node, objectStack) {
          var values = objectStack[objectStack.length - 1];
          var href = node.getAttribute("href");
          if (href !== null) {
            values["link"] = href;
          }
          parseNode(LINK_PARSERS, node, objectStack);
        }
        function parseExtensions(node, objectStack) {
          var values = objectStack[objectStack.length - 1];
          values["extensionsNode_"] = node;
        }
        function parseRtePt(node, objectStack) {
          var values = pushParseAndPop({}, RTEPT_PARSERS, node, objectStack);
          if (values) {
            var rteValues = objectStack[objectStack.length - 1];
            var flatCoordinates = rteValues["flatCoordinates"];
            var layoutOptions = rteValues["layoutOptions"];
            appendCoordinate(flatCoordinates, layoutOptions, node, values);
          }
        }
        function parseTrkPt(node, objectStack) {
          var values = pushParseAndPop({}, TRKPT_PARSERS, node, objectStack);
          if (values) {
            var trkValues = objectStack[objectStack.length - 1];
            var flatCoordinates = trkValues["flatCoordinates"];
            var layoutOptions = trkValues["layoutOptions"];
            appendCoordinate(flatCoordinates, layoutOptions, node, values);
          }
        }
        function parseTrkSeg(node, objectStack) {
          var values = objectStack[objectStack.length - 1];
          parseNode(TRKSEG_PARSERS, node, objectStack);
          var flatCoordinates = values["flatCoordinates"];
          var ends = values["ends"];
          ends.push(flatCoordinates.length);
        }
        function readRte(node, objectStack) {
          var options = objectStack[0];
          var values = pushParseAndPop({
            "flatCoordinates": [],
            "layoutOptions": {}
          }, RTE_PARSERS, node, objectStack);
          if (!values) {
            return void 0;
          }
          var flatCoordinates = values["flatCoordinates"];
          delete values["flatCoordinates"];
          var layoutOptions = values["layoutOptions"];
          delete values["layoutOptions"];
          var layout = applyLayoutOptions(layoutOptions, flatCoordinates);
          var geometry = new geom_LineString(flatCoordinates, layout);
          transformGeometryWithOptions(geometry, false, options);
          var feature = new ol_Feature(geometry);
          feature.setProperties(values, true);
          return feature;
        }
        function readTrk(node, objectStack) {
          var options = objectStack[0];
          var values = pushParseAndPop({
            "flatCoordinates": [],
            "ends": [],
            "layoutOptions": {}
          }, TRK_PARSERS, node, objectStack);
          if (!values) {
            return void 0;
          }
          var flatCoordinates = values["flatCoordinates"];
          delete values["flatCoordinates"];
          var ends = values["ends"];
          delete values["ends"];
          var layoutOptions = values["layoutOptions"];
          delete values["layoutOptions"];
          var layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
          var geometry = new geom_MultiLineString(flatCoordinates, layout, ends);
          transformGeometryWithOptions(geometry, false, options);
          var feature = new ol_Feature(geometry);
          feature.setProperties(values, true);
          return feature;
        }
        function readWpt(node, objectStack) {
          var options = objectStack[0];
          var values = pushParseAndPop({}, WPT_PARSERS, node, objectStack);
          if (!values) {
            return void 0;
          }
          var layoutOptions = {};
          var coordinates = appendCoordinate([], layoutOptions, node, values);
          var layout = applyLayoutOptions(layoutOptions, coordinates);
          var geometry = new geom_Point(coordinates, layout);
          transformGeometryWithOptions(geometry, false, options);
          var feature = new ol_Feature(geometry);
          feature.setProperties(values, true);
          return feature;
        }
        function writeLink(node, value, objectStack) {
          node.setAttribute("href", value);
          var context = objectStack[objectStack.length - 1];
          var properties = context["properties"];
          var link = [properties["linkText"], properties["linkType"]];
          pushSerializeAndPop({ node }, LINK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, link, objectStack, LINK_SEQUENCE);
        }
        function writeWptType(node, coordinate, objectStack) {
          var context = objectStack[objectStack.length - 1];
          var parentNode = context.node;
          var namespaceURI = parentNode.namespaceURI;
          var properties = context["properties"];
          node.setAttributeNS(null, "lat", String(coordinate[1]));
          node.setAttributeNS(null, "lon", String(coordinate[0]));
          var geometryLayout = context["geometryLayout"];
          switch (geometryLayout) {
            case GeometryLayout.XYZM:
              if (coordinate[3] !== 0) {
                properties["time"] = coordinate[3];
              }
            case GeometryLayout.XYZ:
              if (coordinate[2] !== 0) {
                properties["ele"] = coordinate[2];
              }
              break;
            case GeometryLayout.XYM:
              if (coordinate[2] !== 0) {
                properties["time"] = coordinate[2];
              }
              break;
            default:
          }
          var orderedKeys = node.nodeName == "rtept" ? RTEPT_TYPE_SEQUENCE[namespaceURI] : WPT_TYPE_SEQUENCE[namespaceURI];
          var values = makeSequence(properties, orderedKeys);
          pushSerializeAndPop({ node, "properties": properties }, WPT_TYPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
        }
        function writeRte(node, feature, objectStack) {
          var options = objectStack[0];
          var properties = feature.getProperties();
          var context = { node };
          context["properties"] = properties;
          var geometry = feature.getGeometry();
          if (geometry.getType() == geom_GeometryType.LINE_STRING) {
            var lineString = transformGeometryWithOptions(geometry, true, options);
            context["geometryLayout"] = lineString.getLayout();
            properties["rtept"] = lineString.getCoordinates();
          }
          var parentNode = objectStack[objectStack.length - 1].node;
          var orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
          var values = makeSequence(properties, orderedKeys);
          pushSerializeAndPop(context, RTE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
        }
        function writeTrk(node, feature, objectStack) {
          var options = objectStack[0];
          var properties = feature.getProperties();
          var context = { node };
          context["properties"] = properties;
          var geometry = feature.getGeometry();
          if (geometry.getType() == geom_GeometryType.MULTI_LINE_STRING) {
            var multiLineString = transformGeometryWithOptions(geometry, true, options);
            properties["trkseg"] = multiLineString.getLineStrings();
          }
          var parentNode = objectStack[objectStack.length - 1].node;
          var orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
          var values = makeSequence(properties, orderedKeys);
          pushSerializeAndPop(context, TRK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
        }
        function writeTrkSeg(node, lineString, objectStack) {
          var context = { node };
          context["geometryLayout"] = lineString.getLayout();
          context["properties"] = {};
          pushSerializeAndPop(context, TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY, lineString.getCoordinates(), objectStack);
        }
        function writeWpt(node, feature, objectStack) {
          var options = objectStack[0];
          var context = objectStack[objectStack.length - 1];
          context["properties"] = feature.getProperties();
          var geometry = feature.getGeometry();
          if (geometry.getType() == geom_GeometryType.POINT) {
            var point = transformGeometryWithOptions(geometry, true, options);
            context["geometryLayout"] = point.getLayout();
            writeWptType(node, point.getCoordinates(), objectStack);
          }
        }
        var format_GPX = GPX_GPX;
        var TextFeature_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var TextFeature_TextFeature = function(_super) {
          TextFeature_extends(TextFeature, _super);
          function TextFeature() {
            return _super.call(this) || this;
          }
          TextFeature.prototype.getType = function() {
            return FormatType.TEXT;
          };
          TextFeature.prototype.readFeature = function(source, opt_options) {
            return this.readFeatureFromText(getText(source), this.adaptOptions(opt_options));
          };
          TextFeature.prototype.readFeatureFromText = function(text, opt_options) {
            return Object(util["b"])();
          };
          TextFeature.prototype.readFeatures = function(source, opt_options) {
            return this.readFeaturesFromText(getText(source), this.adaptOptions(opt_options));
          };
          TextFeature.prototype.readFeaturesFromText = function(text, opt_options) {
            return Object(util["b"])();
          };
          TextFeature.prototype.readGeometry = function(source, opt_options) {
            return this.readGeometryFromText(getText(source), this.adaptOptions(opt_options));
          };
          TextFeature.prototype.readGeometryFromText = function(text, opt_options) {
            return Object(util["b"])();
          };
          TextFeature.prototype.readProjection = function(source) {
            return this.readProjectionFromText(getText(source));
          };
          TextFeature.prototype.readProjectionFromText = function(text) {
            return this.dataProjection;
          };
          TextFeature.prototype.writeFeature = function(feature, opt_options) {
            return this.writeFeatureText(feature, this.adaptOptions(opt_options));
          };
          TextFeature.prototype.writeFeatureText = function(feature, opt_options) {
            return Object(util["b"])();
          };
          TextFeature.prototype.writeFeatures = function(features, opt_options) {
            return this.writeFeaturesText(features, this.adaptOptions(opt_options));
          };
          TextFeature.prototype.writeFeaturesText = function(features, opt_options) {
            return Object(util["b"])();
          };
          TextFeature.prototype.writeGeometry = function(geometry, opt_options) {
            return this.writeGeometryText(geometry, this.adaptOptions(opt_options));
          };
          TextFeature.prototype.writeGeometryText = function(geometry, opt_options) {
            return Object(util["b"])();
          };
          return TextFeature;
        }(format_Feature);
        function getText(source) {
          if (typeof source === "string") {
            return source;
          } else {
            return "";
          }
        }
        var format_TextFeature = TextFeature_TextFeature;
        var IGC_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var IGCZ = {
          BAROMETRIC: "barometric",
          GPS: "gps",
          NONE: "none"
        };
        var B_RECORD_RE = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/;
        var H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;
        var HFDTE_RECORD_RE = /^HFDTE(\d{2})(\d{2})(\d{2})/;
        var NEWLINE_RE = /\r\n|\r|\n/;
        var IGC_IGC = function(_super) {
          IGC_extends(IGC, _super);
          function IGC(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.dataProjection = proj_get("EPSG:4326");
            _this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : IGCZ.NONE;
            return _this;
          }
          IGC.prototype.readFeatureFromText = function(text, opt_options) {
            var altitudeMode = this.altitudeMode_;
            var lines = text.split(NEWLINE_RE);
            var properties = {};
            var flatCoordinates = [];
            var year = 2e3;
            var month = 0;
            var day = 1;
            var lastDateTime = -1;
            var i, ii;
            for (i = 0, ii = lines.length; i < ii; ++i) {
              var line = lines[i];
              var m = void 0;
              if (line.charAt(0) == "B") {
                m = B_RECORD_RE.exec(line);
                if (m) {
                  var hour = parseInt(m[1], 10);
                  var minute = parseInt(m[2], 10);
                  var second = parseInt(m[3], 10);
                  var y = parseInt(m[4], 10) + parseInt(m[5], 10) / 6e4;
                  if (m[6] == "S") {
                    y = -y;
                  }
                  var x = parseInt(m[7], 10) + parseInt(m[8], 10) / 6e4;
                  if (m[9] == "W") {
                    x = -x;
                  }
                  flatCoordinates.push(x, y);
                  if (altitudeMode != IGCZ.NONE) {
                    var z = void 0;
                    if (altitudeMode == IGCZ.GPS) {
                      z = parseInt(m[11], 10);
                    } else if (altitudeMode == IGCZ.BAROMETRIC) {
                      z = parseInt(m[12], 10);
                    } else {
                      z = 0;
                    }
                    flatCoordinates.push(z);
                  }
                  var dateTime = Date.UTC(year, month, day, hour, minute, second);
                  if (dateTime < lastDateTime) {
                    dateTime = Date.UTC(year, month, day + 1, hour, minute, second);
                  }
                  flatCoordinates.push(dateTime / 1e3);
                  lastDateTime = dateTime;
                }
              } else if (line.charAt(0) == "H") {
                m = HFDTE_RECORD_RE.exec(line);
                if (m) {
                  day = parseInt(m[1], 10);
                  month = parseInt(m[2], 10) - 1;
                  year = 2e3 + parseInt(m[3], 10);
                } else {
                  m = H_RECORD_RE.exec(line);
                  if (m) {
                    properties[m[1]] = m[2].trim();
                  }
                }
              }
            }
            if (flatCoordinates.length === 0) {
              return null;
            }
            var layout = altitudeMode == IGCZ.NONE ? GeometryLayout.XYM : GeometryLayout.XYZM;
            var lineString = new geom_LineString(flatCoordinates, layout);
            var feature = new ol_Feature(transformGeometryWithOptions(lineString, false, opt_options));
            feature.setProperties(properties, true);
            return feature;
          };
          IGC.prototype.readFeaturesFromText = function(text, opt_options) {
            var feature = this.readFeatureFromText(text, opt_options);
            if (feature) {
              return [feature];
            } else {
              return [];
            }
          };
          return IGC;
        }(format_TextFeature);
        var format_IGC = IGC_IGC;
        var __spreadArray = function(to, from) {
          for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
          return to;
        };
        var Versions = {
          VERSION1: "version1",
          VERSION2: "version2",
          VERSION3: "version3"
        };
        var IIIF_PROFILE_VALUES = {};
        IIIF_PROFILE_VALUES[Versions.VERSION1] = {
          "level0": {
            supports: [],
            formats: [],
            qualities: ["native"]
          },
          "level1": {
            supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
            formats: ["jpg"],
            qualities: ["native"]
          },
          "level2": {
            supports: [
              "regionByPx",
              "regionByPct",
              "sizeByW",
              "sizeByH",
              "sizeByPct",
              "sizeByConfinedWh",
              "sizeByWh"
            ],
            formats: ["jpg", "png"],
            qualities: ["native", "color", "grey", "bitonal"]
          }
        };
        IIIF_PROFILE_VALUES[Versions.VERSION2] = {
          "level0": {
            supports: [],
            formats: ["jpg"],
            qualities: ["default"]
          },
          "level1": {
            supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
            formats: ["jpg"],
            qualities: ["default"]
          },
          "level2": {
            supports: [
              "regionByPx",
              "regionByPct",
              "sizeByW",
              "sizeByH",
              "sizeByPct",
              "sizeByConfinedWh",
              "sizeByDistortedWh",
              "sizeByWh"
            ],
            formats: ["jpg", "png"],
            qualities: ["default", "bitonal"]
          }
        };
        IIIF_PROFILE_VALUES[Versions.VERSION3] = {
          "level0": {
            supports: [],
            formats: ["jpg"],
            qualities: ["default"]
          },
          "level1": {
            supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"],
            formats: ["jpg"],
            qualities: ["default"]
          },
          "level2": {
            supports: [
              "regionByPx",
              "regionSquare",
              "regionByPct",
              "sizeByW",
              "sizeByH",
              "sizeByPct",
              "sizeByConfinedWh",
              "sizeByWh"
            ],
            formats: ["jpg", "png"],
            qualities: ["default"]
          }
        };
        IIIF_PROFILE_VALUES["none"] = {
          "none": {
            supports: [],
            formats: [],
            qualities: []
          }
        };
        var COMPLIANCE_VERSION1 = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/;
        var COMPLIANCE_VERSION2 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/;
        var COMPLIANCE_VERSION3 = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
        function generateVersion1Options(iiifInfo) {
          var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();
          if (levelProfile === void 0) {
            levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]["level0"];
          }
          return {
            url: iiifInfo.imageInfo["@id"] === void 0 ? void 0 : iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
            supports: levelProfile.supports,
            formats: __spreadArray(__spreadArray([], levelProfile.formats), [
              iiifInfo.imageInfo.formats === void 0 ? [] : iiifInfo.imageInfo.formats
            ]),
            qualities: __spreadArray(__spreadArray([], levelProfile.qualities), [
              iiifInfo.imageInfo.qualities === void 0 ? [] : iiifInfo.imageInfo.qualities
            ]),
            resolutions: iiifInfo.imageInfo.scale_factors,
            tileSize: iiifInfo.imageInfo.tile_width !== void 0 ? iiifInfo.imageInfo.tile_height !== void 0 ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != void 0 ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : void 0
          };
        }
        function generateVersion2Options(iiifInfo) {
          var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1, profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [], profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [], profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];
          return {
            url: iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
            sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
              return [size.width, size.height];
            }),
            tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
              iiifInfo.imageInfo.tiles.map(function(tile) {
                return tile.width;
              })[0],
              iiifInfo.imageInfo.tiles.map(function(tile) {
                return tile.height === void 0 ? tile.width : tile.height;
              })[0]
            ],
            resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile) {
              return tile.scaleFactors;
            })[0],
            supports: __spreadArray(__spreadArray([], levelProfile.supports), profileSupports),
            formats: __spreadArray(__spreadArray([], levelProfile.formats), profileFormats),
            qualities: __spreadArray(__spreadArray([], levelProfile.qualities), profileQualities)
          };
        }
        function generateVersion3Options(iiifInfo) {
          var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), formats = iiifInfo.imageInfo.extraFormats === void 0 ? levelProfile.formats : __spreadArray(__spreadArray([], levelProfile.formats), iiifInfo.imageInfo.extraFormats), preferredFormat = iiifInfo.imageInfo.preferredFormats !== void 0 && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function(format) {
            return Object(ol_array["f"])(["jpg", "png", "gif"], format);
          }).reduce(function(acc, format) {
            return acc === void 0 && Object(ol_array["f"])(formats, format) ? format : acc;
          }, void 0) : void 0;
          return {
            url: iiifInfo.imageInfo["id"],
            sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
              return [size.width, size.height];
            }),
            tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
              iiifInfo.imageInfo.tiles.map(function(tile) {
                return tile.width;
              })[0],
              iiifInfo.imageInfo.tiles.map(function(tile) {
                return tile.height;
              })[0]
            ],
            resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile) {
              return tile.scaleFactors;
            })[0],
            supports: iiifInfo.imageInfo.extraFeatures === void 0 ? levelProfile.supports : __spreadArray(__spreadArray([], levelProfile.supports), iiifInfo.imageInfo.extraFeatures),
            formats,
            qualities: iiifInfo.imageInfo.extraQualities === void 0 ? levelProfile.qualities : __spreadArray(__spreadArray([], levelProfile.qualities), iiifInfo.imageInfo.extraQualities),
            preferredFormat
          };
        }
        var versionFunctions = {};
        versionFunctions[Versions.VERSION1] = generateVersion1Options;
        versionFunctions[Versions.VERSION2] = generateVersion2Options;
        versionFunctions[Versions.VERSION3] = generateVersion3Options;
        var IIIFInfo_IIIFInfo = function() {
          function IIIFInfo(imageInfo) {
            this.setImageInfo(imageInfo);
          }
          IIIFInfo.prototype.setImageInfo = function(imageInfo) {
            if (typeof imageInfo == "string") {
              this.imageInfo = JSON.parse(imageInfo);
            } else {
              this.imageInfo = imageInfo;
            }
          };
          IIIFInfo.prototype.getImageApiVersion = function() {
            if (this.imageInfo === void 0) {
              return;
            }
            var context = this.imageInfo["@context"] || "ol-no-context";
            if (typeof context == "string") {
              context = [context];
            }
            for (var i = 0; i < context.length; i++) {
              switch (context[i]) {
                case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
                case "http://iiif.io/api/image/1/context.json":
                  return Versions.VERSION1;
                case "http://iiif.io/api/image/2/context.json":
                  return Versions.VERSION2;
                case "http://iiif.io/api/image/3/context.json":
                  return Versions.VERSION3;
                case "ol-no-context":
                  if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {
                    return Versions.VERSION1;
                  }
                  break;
                default:
              }
            }
            assert2(false, 61);
          };
          IIIFInfo.prototype.getComplianceLevelEntryFromProfile = function(version) {
            if (this.imageInfo === void 0 || this.imageInfo.profile === void 0) {
              return;
            }
            if (version === void 0) {
              version = this.getImageApiVersion();
            }
            switch (version) {
              case Versions.VERSION1:
                if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {
                  return this.imageInfo.profile;
                }
                break;
              case Versions.VERSION3:
                if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {
                  return this.imageInfo.profile;
                }
                break;
              case Versions.VERSION2:
                if (typeof this.imageInfo.profile === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {
                  return this.imageInfo.profile;
                }
                if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {
                  return this.imageInfo.profile[0];
                }
                break;
              default:
            }
          };
          IIIFInfo.prototype.getComplianceLevelFromProfile = function(version) {
            var complianceLevel = this.getComplianceLevelEntryFromProfile(version);
            if (complianceLevel === void 0) {
              return void 0;
            }
            var level = complianceLevel.match(/level[0-2](?:\.json)?$/g);
            return Array.isArray(level) ? level[0].replace(".json", "") : void 0;
          };
          IIIFInfo.prototype.getComplianceLevelSupportedFeatures = function() {
            if (this.imageInfo === void 0) {
              return;
            }
            var version = this.getImageApiVersion();
            var level = this.getComplianceLevelFromProfile(version);
            if (level === void 0) {
              return IIIF_PROFILE_VALUES["none"]["none"];
            }
            return IIIF_PROFILE_VALUES[version][level];
          };
          IIIFInfo.prototype.getTileSourceOptions = function(opt_preferredOptions) {
            var options = opt_preferredOptions || {}, version = this.getImageApiVersion();
            if (version === void 0) {
              return;
            }
            var imageOptions = version === void 0 ? void 0 : versionFunctions[version](this);
            if (imageOptions === void 0) {
              return;
            }
            return {
              url: imageOptions.url,
              version,
              size: [this.imageInfo.width, this.imageInfo.height],
              sizes: imageOptions.sizes,
              format: options.format !== void 0 && Object(ol_array["f"])(imageOptions.formats, options.format) ? options.format : imageOptions.preferredFormat !== void 0 ? imageOptions.preferredFormat : "jpg",
              supports: imageOptions.supports,
              quality: options.quality && Object(ol_array["f"])(imageOptions.qualities, options.quality) ? options.quality : Object(ol_array["f"])(imageOptions.qualities, "native") ? "native" : "default",
              resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function(a, b) {
                return b - a;
              }) : void 0,
              tileSize: imageOptions.tileSize
            };
          };
          return IIIFInfo;
        }();
        var format_IIIFInfo = IIIFInfo_IIIFInfo;
        var KML_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GX_NAMESPACE_URIS = ["http://www.google.com/kml/ext/2.2"];
        var KML_NAMESPACE_URIS = [
          null,
          "http://earth.google.com/kml/2.0",
          "http://earth.google.com/kml/2.1",
          "http://earth.google.com/kml/2.2",
          "http://www.opengis.net/kml/2.2"
        ];
        var KML_SCHEMA_LOCATION = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd";
        var ICON_ANCHOR_UNITS_MAP = {
          "fraction": IconAnchorUnits.FRACTION,
          "pixels": IconAnchorUnits.PIXELS,
          "insetPixels": IconAnchorUnits.PIXELS
        };
        var PLACEMARK_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "ExtendedData": extendedDataParser,
          "Region": regionParser,
          "MultiGeometry": makeObjectPropertySetter(readMultiGeometry, "geometry"),
          "LineString": makeObjectPropertySetter(readLineString, "geometry"),
          "LinearRing": makeObjectPropertySetter(readLinearRing, "geometry"),
          "Point": makeObjectPropertySetter(readPoint, "geometry"),
          "Polygon": makeObjectPropertySetter(readPolygon, "geometry"),
          "Style": makeObjectPropertySetter(readStyle),
          "StyleMap": placemarkStyleMapParser,
          "address": makeObjectPropertySetter(readString),
          "description": makeObjectPropertySetter(readString),
          "name": makeObjectPropertySetter(readString),
          "open": makeObjectPropertySetter(readBoolean),
          "phoneNumber": makeObjectPropertySetter(readString),
          "styleUrl": makeObjectPropertySetter(readStyleURL),
          "visibility": makeObjectPropertySetter(readBoolean)
        }, makeStructureNS(GX_NAMESPACE_URIS, {
          "MultiTrack": makeObjectPropertySetter(readGxMultiTrack, "geometry"),
          "Track": makeObjectPropertySetter(readGxTrack, "geometry")
        }));
        var NETWORK_LINK_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "ExtendedData": extendedDataParser,
          "Region": regionParser,
          "Link": linkParser,
          "address": makeObjectPropertySetter(readString),
          "description": makeObjectPropertySetter(readString),
          "name": makeObjectPropertySetter(readString),
          "open": makeObjectPropertySetter(readBoolean),
          "phoneNumber": makeObjectPropertySetter(readString),
          "visibility": makeObjectPropertySetter(readBoolean)
        });
        var KML_LINK_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "href": makeObjectPropertySetter(readURI)
        });
        var REGION_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "LatLonAltBox": latLonAltBoxParser,
          "Lod": lodParser
        });
        var KML_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, ["Document", "Placemark"]);
        var KML_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "Document": makeChildAppender(writeDocument),
          "Placemark": makeChildAppender(writePlacemark)
        });
        var DEFAULT_COLOR;
        var DEFAULT_FILL_STYLE = null;
        function getDefaultFillStyle() {
          return DEFAULT_FILL_STYLE;
        }
        var DEFAULT_IMAGE_STYLE_ANCHOR;
        var DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
        var DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
        var DEFAULT_IMAGE_STYLE_SIZE;
        var DEFAULT_IMAGE_STYLE_SRC;
        var DEFAULT_IMAGE_STYLE = null;
        function getDefaultImageStyle() {
          return DEFAULT_IMAGE_STYLE;
        }
        var DEFAULT_NO_IMAGE_STYLE;
        var DEFAULT_STROKE_STYLE = null;
        function getDefaultStrokeStyle() {
          return DEFAULT_STROKE_STYLE;
        }
        var DEFAULT_TEXT_STROKE_STYLE;
        var DEFAULT_TEXT_STYLE = null;
        function getDefaultTextStyle() {
          return DEFAULT_TEXT_STYLE;
        }
        var DEFAULT_STYLE = null;
        function getDefaultStyle() {
          return DEFAULT_STYLE;
        }
        var DEFAULT_STYLE_ARRAY = null;
        function getDefaultStyleArray() {
          return DEFAULT_STYLE_ARRAY;
        }
        function scaleForSize(size) {
          return 32 / Math.min(size[0], size[1]);
        }
        function createStyleDefaults() {
          DEFAULT_COLOR = [255, 255, 255, 1];
          DEFAULT_FILL_STYLE = new style_Fill({
            color: DEFAULT_COLOR
          });
          DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];
          DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = IconAnchorUnits.PIXELS;
          DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = IconAnchorUnits.PIXELS;
          DEFAULT_IMAGE_STYLE_SIZE = [64, 64];
          DEFAULT_IMAGE_STYLE_SRC = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png";
          DEFAULT_IMAGE_STYLE = new style_Icon({
            anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
            anchorOrigin: IconOrigin.BOTTOM_LEFT,
            anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
            anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
            crossOrigin: "anonymous",
            rotation: 0,
            scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),
            size: DEFAULT_IMAGE_STYLE_SIZE,
            src: DEFAULT_IMAGE_STYLE_SRC
          });
          DEFAULT_NO_IMAGE_STYLE = "NO_IMAGE";
          DEFAULT_STROKE_STYLE = new style_Stroke({
            color: DEFAULT_COLOR,
            width: 1
          });
          DEFAULT_TEXT_STROKE_STYLE = new style_Stroke({
            color: [51, 51, 51, 1],
            width: 2
          });
          DEFAULT_TEXT_STYLE = new style_Text({
            font: "bold 16px Helvetica",
            fill: DEFAULT_FILL_STYLE,
            stroke: DEFAULT_TEXT_STROKE_STYLE,
            scale: 0.8
          });
          DEFAULT_STYLE = new style_Style({
            fill: DEFAULT_FILL_STYLE,
            image: DEFAULT_IMAGE_STYLE,
            text: DEFAULT_TEXT_STYLE,
            stroke: DEFAULT_STROKE_STYLE,
            zIndex: 0
          });
          DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];
        }
        var TEXTAREA;
        function defaultIconUrlFunction(href) {
          return href;
        }
        var KML_KML = function(_super) {
          KML_extends(KML, _super);
          function KML(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            if (!DEFAULT_STYLE_ARRAY) {
              createStyleDefaults();
            }
            _this.dataProjection = proj_get("EPSG:4326");
            _this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : DEFAULT_STYLE_ARRAY;
            _this.extractStyles_ = options.extractStyles !== void 0 ? options.extractStyles : true;
            _this.writeStyles_ = options.writeStyles !== void 0 ? options.writeStyles : true;
            _this.sharedStyles_ = {};
            _this.showPointNames_ = options.showPointNames !== void 0 ? options.showPointNames : true;
            _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
            _this.iconUrlFunction_ = options.iconUrlFunction ? options.iconUrlFunction : defaultIconUrlFunction;
            _this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
            return _this;
          }
          KML.prototype.readDocumentOrFolder_ = function(node, objectStack) {
            var parsersNS = makeStructureNS(KML_NAMESPACE_URIS, {
              "Document": makeArrayExtender(this.readDocumentOrFolder_, this),
              "Folder": makeArrayExtender(this.readDocumentOrFolder_, this),
              "Placemark": makeArrayPusher(this.readPlacemark_, this),
              "Style": this.readSharedStyle_.bind(this),
              "StyleMap": this.readSharedStyleMap_.bind(this)
            });
            var features = pushParseAndPop([], parsersNS, node, objectStack, this);
            if (features) {
              return features;
            } else {
              return void 0;
            }
          };
          KML.prototype.readPlacemark_ = function(node, objectStack) {
            var object = pushParseAndPop({ "geometry": null }, PLACEMARK_PARSERS, node, objectStack, this);
            if (!object) {
              return void 0;
            }
            var feature = new ol_Feature();
            var id = node.getAttribute("id");
            if (id !== null) {
              feature.setId(id);
            }
            var options = objectStack[0];
            var geometry = object["geometry"];
            if (geometry) {
              transformGeometryWithOptions(geometry, false, options);
            }
            feature.setGeometry(geometry);
            delete object["geometry"];
            if (this.extractStyles_) {
              var style = object["Style"];
              var styleUrl = object["styleUrl"];
              var styleFunction = createFeatureStyleFunction(style, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
              feature.setStyle(styleFunction);
            }
            delete object["Style"];
            feature.setProperties(object, true);
            return feature;
          };
          KML.prototype.readSharedStyle_ = function(node, objectStack) {
            var id = node.getAttribute("id");
            if (id !== null) {
              var style = readStyle.call(this, node, objectStack);
              if (style) {
                var styleUri = void 0;
                var baseURI = node.baseURI;
                if (!baseURI || baseURI == "about:blank") {
                  baseURI = window.location.href;
                }
                if (baseURI) {
                  var url = new URL("#" + id, baseURI);
                  styleUri = url.href;
                } else {
                  styleUri = "#" + id;
                }
                this.sharedStyles_[styleUri] = style;
              }
            }
          };
          KML.prototype.readSharedStyleMap_ = function(node, objectStack) {
            var id = node.getAttribute("id");
            if (id === null) {
              return;
            }
            var styleMapValue = readStyleMapValue.call(this, node, objectStack);
            if (!styleMapValue) {
              return;
            }
            var styleUri;
            var baseURI = node.baseURI;
            if (!baseURI || baseURI == "about:blank") {
              baseURI = window.location.href;
            }
            if (baseURI) {
              var url = new URL("#" + id, baseURI);
              styleUri = url.href;
            } else {
              styleUri = "#" + id;
            }
            this.sharedStyles_[styleUri] = styleMapValue;
          };
          KML.prototype.readFeatureFromNode = function(node, opt_options) {
            if (!Object(ol_array["f"])(KML_NAMESPACE_URIS, node.namespaceURI)) {
              return null;
            }
            var feature = this.readPlacemark_(node, [
              this.getReadOptions(node, opt_options)
            ]);
            if (feature) {
              return feature;
            } else {
              return null;
            }
          };
          KML.prototype.readFeaturesFromNode = function(node, opt_options) {
            if (!Object(ol_array["f"])(KML_NAMESPACE_URIS, node.namespaceURI)) {
              return [];
            }
            var features;
            var localName = node.localName;
            if (localName == "Document" || localName == "Folder") {
              features = this.readDocumentOrFolder_(node, [
                this.getReadOptions(node, opt_options)
              ]);
              if (features) {
                return features;
              } else {
                return [];
              }
            } else if (localName == "Placemark") {
              var feature = this.readPlacemark_(node, [
                this.getReadOptions(node, opt_options)
              ]);
              if (feature) {
                return [feature];
              } else {
                return [];
              }
            } else if (localName == "kml") {
              features = [];
              for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                var fs = this.readFeaturesFromNode(n, opt_options);
                if (fs) {
                  Object(ol_array["c"])(features, fs);
                }
              }
              return features;
            } else {
              return [];
            }
          };
          KML.prototype.readName = function(source) {
            if (!source) {
              return void 0;
            } else if (typeof source === "string") {
              var doc = xml_parse(source);
              return this.readNameFromDocument(doc);
            } else if (isDocument(source)) {
              return this.readNameFromDocument(source);
            } else {
              return this.readNameFromNode(source);
            }
          };
          KML.prototype.readNameFromDocument = function(doc) {
            for (var n = doc.firstChild; n; n = n.nextSibling) {
              if (n.nodeType == Node.ELEMENT_NODE) {
                var name_1 = this.readNameFromNode(n);
                if (name_1) {
                  return name_1;
                }
              }
            }
            return void 0;
          };
          KML.prototype.readNameFromNode = function(node) {
            for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
              if (Object(ol_array["f"])(KML_NAMESPACE_URIS, n.namespaceURI) && n.localName == "name") {
                return readString(n);
              }
            }
            for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
              var localName = n.localName;
              if (Object(ol_array["f"])(KML_NAMESPACE_URIS, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "Placemark" || localName == "kml")) {
                var name_2 = this.readNameFromNode(n);
                if (name_2) {
                  return name_2;
                }
              }
            }
            return void 0;
          };
          KML.prototype.readNetworkLinks = function(source) {
            var networkLinks = [];
            if (typeof source === "string") {
              var doc = xml_parse(source);
              Object(ol_array["c"])(networkLinks, this.readNetworkLinksFromDocument(doc));
            } else if (isDocument(source)) {
              Object(ol_array["c"])(networkLinks, this.readNetworkLinksFromDocument(source));
            } else {
              Object(ol_array["c"])(networkLinks, this.readNetworkLinksFromNode(source));
            }
            return networkLinks;
          };
          KML.prototype.readNetworkLinksFromDocument = function(doc) {
            var networkLinks = [];
            for (var n = doc.firstChild; n; n = n.nextSibling) {
              if (n.nodeType == Node.ELEMENT_NODE) {
                Object(ol_array["c"])(networkLinks, this.readNetworkLinksFromNode(n));
              }
            }
            return networkLinks;
          };
          KML.prototype.readNetworkLinksFromNode = function(node) {
            var networkLinks = [];
            for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
              if (Object(ol_array["f"])(KML_NAMESPACE_URIS, n.namespaceURI) && n.localName == "NetworkLink") {
                var obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);
                networkLinks.push(obj);
              }
            }
            for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
              var localName = n.localName;
              if (Object(ol_array["f"])(KML_NAMESPACE_URIS, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
                Object(ol_array["c"])(networkLinks, this.readNetworkLinksFromNode(n));
              }
            }
            return networkLinks;
          };
          KML.prototype.readRegion = function(source) {
            var regions = [];
            if (typeof source === "string") {
              var doc = xml_parse(source);
              Object(ol_array["c"])(regions, this.readRegionFromDocument(doc));
            } else if (isDocument(source)) {
              Object(ol_array["c"])(regions, this.readRegionFromDocument(source));
            } else {
              Object(ol_array["c"])(regions, this.readRegionFromNode(source));
            }
            return regions;
          };
          KML.prototype.readRegionFromDocument = function(doc) {
            var regions = [];
            for (var n = doc.firstChild; n; n = n.nextSibling) {
              if (n.nodeType == Node.ELEMENT_NODE) {
                Object(ol_array["c"])(regions, this.readRegionFromNode(n));
              }
            }
            return regions;
          };
          KML.prototype.readRegionFromNode = function(node) {
            var regions = [];
            for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
              if (Object(ol_array["f"])(KML_NAMESPACE_URIS, n.namespaceURI) && n.localName == "Region") {
                var obj = pushParseAndPop({}, REGION_PARSERS, n, []);
                regions.push(obj);
              }
            }
            for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
              var localName = n.localName;
              if (Object(ol_array["f"])(KML_NAMESPACE_URIS, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
                Object(ol_array["c"])(regions, this.readRegionFromNode(n));
              }
            }
            return regions;
          };
          KML.prototype.writeFeaturesNode = function(features, opt_options) {
            opt_options = this.adaptOptions(opt_options);
            var kml = createElementNS(KML_NAMESPACE_URIS[4], "kml");
            var xmlnsUri = "http://www.w3.org/2000/xmlns/";
            kml.setAttributeNS(xmlnsUri, "xmlns:gx", GX_NAMESPACE_URIS[0]);
            kml.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
            kml.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", KML_SCHEMA_LOCATION);
            var context = {
              node: kml
            };
            var properties = {};
            if (features.length > 1) {
              properties["Document"] = features;
            } else if (features.length == 1) {
              properties["Placemark"] = features[0];
            }
            var orderedKeys = KML_SEQUENCE[kml.namespaceURI];
            var values = makeSequence(properties, orderedKeys);
            pushSerializeAndPop(context, KML_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, [opt_options], orderedKeys, this);
            return kml;
          };
          return KML;
        }(format_XMLFeature);
        function createNameStyleFunction(foundStyle, name) {
          var textOffset = [0, 0];
          var textAlign = "start";
          var imageStyle = foundStyle.getImage();
          if (imageStyle) {
            var imageSize = imageStyle.getSize();
            if (imageSize && imageSize.length == 2) {
              var imageScale = imageStyle.getScaleArray();
              var anchor = imageStyle.getAnchor();
              textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);
              textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);
              textAlign = "left";
            }
          }
          var textStyle = foundStyle.getText();
          if (textStyle) {
            textStyle = textStyle.clone();
            textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());
            textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());
            textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());
            textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
          } else {
            textStyle = DEFAULT_TEXT_STYLE.clone();
          }
          textStyle.setText(name);
          textStyle.setOffsetX(textOffset[0]);
          textStyle.setOffsetY(textOffset[1]);
          textStyle.setTextAlign(textAlign);
          var nameStyle = new style_Style({
            image: imageStyle,
            text: textStyle
          });
          return nameStyle;
        }
        function createFeatureStyleFunction(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {
          return function(feature, resolution) {
            var drawName = showPointNames;
            var name = "";
            var multiGeometryPoints = [];
            if (drawName) {
              var geometry = feature.getGeometry();
              if (geometry) {
                var type = geometry.getType();
                if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                  multiGeometryPoints = geometry.getGeometriesArrayRecursive().filter(function(geometry2) {
                    var type2 = geometry2.getType();
                    return type2 === geom_GeometryType.POINT || type2 === geom_GeometryType.MULTI_POINT;
                  });
                  drawName = multiGeometryPoints.length > 0;
                } else {
                  drawName = type === geom_GeometryType.POINT || type === geom_GeometryType.MULTI_POINT;
                }
              }
            }
            if (drawName) {
              name = feature.get("name");
              drawName = drawName && !!name;
              if (drawName && name.search(/&[^&]+;/) > -1) {
                if (!TEXTAREA) {
                  TEXTAREA = document.createElement("textarea");
                }
                TEXTAREA.innerHTML = name;
                name = TEXTAREA.value;
              }
            }
            var featureStyle = defaultStyle;
            if (style) {
              featureStyle = style;
            } else if (styleUrl) {
              featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
            }
            if (drawName) {
              var nameStyle = createNameStyleFunction(featureStyle[0], name);
              if (multiGeometryPoints.length > 0) {
                nameStyle.setGeometry(new geom_GeometryCollection(multiGeometryPoints));
                var baseStyle = new style_Style({
                  geometry: featureStyle[0].getGeometry(),
                  image: null,
                  fill: featureStyle[0].getFill(),
                  stroke: featureStyle[0].getStroke(),
                  text: null
                });
                return [nameStyle, baseStyle].concat(featureStyle.slice(1));
              }
              return nameStyle;
            }
            return featureStyle;
          };
        }
        function findStyle(styleValue, defaultStyle, sharedStyles) {
          if (Array.isArray(styleValue)) {
            return styleValue;
          } else if (typeof styleValue === "string") {
            return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
          } else {
            return defaultStyle;
          }
        }
        function readColor(node) {
          var s = getAllTextContent(node, false);
          var m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);
          if (m) {
            var hexColor = m[1];
            return [
              parseInt(hexColor.substr(6, 2), 16),
              parseInt(hexColor.substr(4, 2), 16),
              parseInt(hexColor.substr(2, 2), 16),
              parseInt(hexColor.substr(0, 2), 16) / 255
            ];
          } else {
            return void 0;
          }
        }
        function readFlatCoordinates(node) {
          var s = getAllTextContent(node, false);
          var flatCoordinates = [];
          s = s.replace(/\s*,\s*/g, ",");
          var re = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
          var m;
          while (m = re.exec(s)) {
            var x = parseFloat(m[1]);
            var y = parseFloat(m[2]);
            var z = m[3] ? parseFloat(m[3]) : 0;
            flatCoordinates.push(x, y, z);
            s = s.substr(m[0].length);
          }
          if (s !== "") {
            return void 0;
          }
          return flatCoordinates;
        }
        function readURI(node) {
          var s = getAllTextContent(node, false).trim();
          var baseURI = node.baseURI;
          if (!baseURI || baseURI == "about:blank") {
            baseURI = window.location.href;
          }
          if (baseURI) {
            var url = new URL(s, baseURI);
            return url.href;
          } else {
            return s;
          }
        }
        function readStyleURL(node) {
          var s = getAllTextContent(node, false).trim().replace(/^(?!.*#)/, "#");
          var baseURI = node.baseURI;
          if (!baseURI || baseURI == "about:blank") {
            baseURI = window.location.href;
          }
          if (baseURI) {
            var url = new URL(s, baseURI);
            return url.href;
          } else {
            return s;
          }
        }
        function readVec2(node) {
          var xunits = node.getAttribute("xunits");
          var yunits = node.getAttribute("yunits");
          var origin;
          if (xunits !== "insetPixels") {
            if (yunits !== "insetPixels") {
              origin = IconOrigin.BOTTOM_LEFT;
            } else {
              origin = IconOrigin.TOP_LEFT;
            }
          } else {
            if (yunits !== "insetPixels") {
              origin = IconOrigin.BOTTOM_RIGHT;
            } else {
              origin = IconOrigin.TOP_RIGHT;
            }
          }
          return {
            x: parseFloat(node.getAttribute("x")),
            xunits: ICON_ANCHOR_UNITS_MAP[xunits],
            y: parseFloat(node.getAttribute("y")),
            yunits: ICON_ANCHOR_UNITS_MAP[yunits],
            origin
          };
        }
        function readScale(node) {
          return readDecimal(node);
        }
        var STYLE_MAP_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "Pair": pairDataParser
        });
        function readStyleMapValue(node, objectStack) {
          return pushParseAndPop(void 0, STYLE_MAP_PARSERS, node, objectStack, this);
        }
        var ICON_STYLE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "Icon": makeObjectPropertySetter(readIcon),
          "color": makeObjectPropertySetter(readColor),
          "heading": makeObjectPropertySetter(readDecimal),
          "hotSpot": makeObjectPropertySetter(readVec2),
          "scale": makeObjectPropertySetter(readScale)
        });
        function iconStyleParser(node, objectStack) {
          var object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);
          if (!object) {
            return;
          }
          var styleObject = objectStack[objectStack.length - 1];
          var IconObject = "Icon" in object ? object["Icon"] : {};
          var drawIcon = !("Icon" in object) || Object.keys(IconObject).length > 0;
          var src;
          var href = IconObject["href"];
          if (href) {
            src = href;
          } else if (drawIcon) {
            src = DEFAULT_IMAGE_STYLE_SRC;
          }
          var anchor, anchorXUnits, anchorYUnits;
          var anchorOrigin = IconOrigin.BOTTOM_LEFT;
          var hotSpot = object["hotSpot"];
          if (hotSpot) {
            anchor = [hotSpot.x, hotSpot.y];
            anchorXUnits = hotSpot.xunits;
            anchorYUnits = hotSpot.yunits;
            anchorOrigin = hotSpot.origin;
          } else if (/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
            if (/pushpin/.test(src)) {
              anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
              anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
              anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
            } else if (/arrow-reverse/.test(src)) {
              anchor = [54, 42];
              anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
              anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
            } else if (/paddle/.test(src)) {
              anchor = [32, 1];
              anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
              anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
            }
          }
          var offset;
          var x = IconObject["x"];
          var y = IconObject["y"];
          if (x !== void 0 && y !== void 0) {
            offset = [x, y];
          }
          var size;
          var w = IconObject["w"];
          var h = IconObject["h"];
          if (w !== void 0 && h !== void 0) {
            size = [w, h];
          }
          var rotation;
          var heading = object["heading"];
          if (heading !== void 0) {
            rotation = toRadians(heading);
          }
          var scale = object["scale"];
          var color = object["color"];
          if (drawIcon) {
            if (src == DEFAULT_IMAGE_STYLE_SRC) {
              size = DEFAULT_IMAGE_STYLE_SIZE;
            }
            var imageStyle_1 = new style_Icon({
              anchor,
              anchorOrigin,
              anchorXUnits,
              anchorYUnits,
              crossOrigin: this.crossOrigin_,
              offset,
              offsetOrigin: IconOrigin.BOTTOM_LEFT,
              rotation,
              scale,
              size,
              src: this.iconUrlFunction_(src),
              color
            });
            var imageScale_1 = imageStyle_1.getScaleArray()[0];
            var imageSize = imageStyle_1.getSize();
            if (imageSize === null) {
              var imageState = imageStyle_1.getImageState();
              if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {
                var listener_1 = function() {
                  var imageState2 = imageStyle_1.getImageState();
                  if (!(imageState2 === ImageState.IDLE || imageState2 === ImageState.LOADING)) {
                    var imageSize_1 = imageStyle_1.getSize();
                    if (imageSize_1 && imageSize_1.length == 2) {
                      var resizeScale2 = scaleForSize(imageSize_1);
                      imageStyle_1.setScale(imageScale_1 * resizeScale2);
                    }
                    imageStyle_1.unlistenImageChange(listener_1);
                  }
                };
                imageStyle_1.listenImageChange(listener_1);
                if (imageState === ImageState.IDLE) {
                  imageStyle_1.load();
                }
              }
            } else if (imageSize.length == 2) {
              var resizeScale = scaleForSize(imageSize);
              imageStyle_1.setScale(imageScale_1 * resizeScale);
            }
            styleObject["imageStyle"] = imageStyle_1;
          } else {
            styleObject["imageStyle"] = DEFAULT_NO_IMAGE_STYLE;
          }
        }
        var LABEL_STYLE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "color": makeObjectPropertySetter(readColor),
          "scale": makeObjectPropertySetter(readScale)
        });
        function labelStyleParser(node, objectStack) {
          var object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);
          if (!object) {
            return;
          }
          var styleObject = objectStack[objectStack.length - 1];
          var textStyle = new style_Text({
            fill: new style_Fill({
              color: "color" in object ? object["color"] : DEFAULT_COLOR
            }),
            scale: object["scale"]
          });
          styleObject["textStyle"] = textStyle;
        }
        var LINE_STYLE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "color": makeObjectPropertySetter(readColor),
          "width": makeObjectPropertySetter(readDecimal)
        });
        function lineStyleParser(node, objectStack) {
          var object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);
          if (!object) {
            return;
          }
          var styleObject = objectStack[objectStack.length - 1];
          var strokeStyle = new style_Stroke({
            color: "color" in object ? object["color"] : DEFAULT_COLOR,
            width: "width" in object ? object["width"] : 1
          });
          styleObject["strokeStyle"] = strokeStyle;
        }
        var POLY_STYLE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "color": makeObjectPropertySetter(readColor),
          "fill": makeObjectPropertySetter(readBoolean),
          "outline": makeObjectPropertySetter(readBoolean)
        });
        function polyStyleParser(node, objectStack) {
          var object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);
          if (!object) {
            return;
          }
          var styleObject = objectStack[objectStack.length - 1];
          var fillStyle = new style_Fill({
            color: "color" in object ? object["color"] : DEFAULT_COLOR
          });
          styleObject["fillStyle"] = fillStyle;
          var fill = object["fill"];
          if (fill !== void 0) {
            styleObject["fill"] = fill;
          }
          var outline = object["outline"];
          if (outline !== void 0) {
            styleObject["outline"] = outline;
          }
        }
        var FLAT_LINEAR_RING_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "coordinates": makeReplacer(readFlatCoordinates)
        });
        function readFlatLinearRing(node, objectStack) {
          return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);
        }
        function gxCoordParser(node, objectStack) {
          var gxTrackObject = objectStack[objectStack.length - 1];
          var coordinates = gxTrackObject.coordinates;
          var s = getAllTextContent(node, false);
          var re = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
          var m = re.exec(s);
          if (m) {
            var x = parseFloat(m[1]);
            var y = parseFloat(m[2]);
            var z = parseFloat(m[3]);
            coordinates.push([x, y, z]);
          } else {
            coordinates.push([]);
          }
        }
        var GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {
          "Track": makeArrayPusher(readGxTrack)
        });
        function readGxMultiTrack(node, objectStack) {
          var lineStrings = pushParseAndPop([], GX_MULTITRACK_GEOMETRY_PARSERS, node, objectStack);
          if (!lineStrings) {
            return void 0;
          }
          return new geom_MultiLineString(lineStrings);
        }
        var GX_TRACK_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "when": whenParser
        }, makeStructureNS(GX_NAMESPACE_URIS, {
          "coord": gxCoordParser
        }));
        function readGxTrack(node, objectStack) {
          var gxTrackObject = pushParseAndPop({
            coordinates: [],
            whens: []
          }, GX_TRACK_PARSERS, node, objectStack);
          if (!gxTrackObject) {
            return void 0;
          }
          var flatCoordinates = [];
          var coordinates = gxTrackObject.coordinates;
          var whens = gxTrackObject.whens;
          for (var i = 0, ii = Math.min(coordinates.length, whens.length); i < ii; ++i) {
            if (coordinates[i].length == 3) {
              flatCoordinates.push(coordinates[i][0], coordinates[i][1], coordinates[i][2], whens[i]);
            }
          }
          return new geom_LineString(flatCoordinates, GeometryLayout.XYZM);
        }
        var ICON_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "href": makeObjectPropertySetter(readURI)
        }, makeStructureNS(GX_NAMESPACE_URIS, {
          "x": makeObjectPropertySetter(readDecimal),
          "y": makeObjectPropertySetter(readDecimal),
          "w": makeObjectPropertySetter(readDecimal),
          "h": makeObjectPropertySetter(readDecimal)
        }));
        function readIcon(node, objectStack) {
          var iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);
          if (iconObject) {
            return iconObject;
          } else {
            return null;
          }
        }
        var GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "coordinates": makeReplacer(readFlatCoordinates)
        });
        function readFlatCoordinatesFromNode(node, objectStack) {
          return pushParseAndPop(null, GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack);
        }
        var EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "extrude": makeObjectPropertySetter(readBoolean),
          "tessellate": makeObjectPropertySetter(readBoolean),
          "altitudeMode": makeObjectPropertySetter(readString)
        });
        function readLineString(node, objectStack) {
          var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
          var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
          if (flatCoordinates) {
            var lineString = new geom_LineString(flatCoordinates, GeometryLayout.XYZ);
            lineString.setProperties(properties, true);
            return lineString;
          } else {
            return void 0;
          }
        }
        function readLinearRing(node, objectStack) {
          var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
          var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
          if (flatCoordinates) {
            var polygon = new geom_Polygon(flatCoordinates, GeometryLayout.XYZ, [
              flatCoordinates.length
            ]);
            polygon.setProperties(properties, true);
            return polygon;
          } else {
            return void 0;
          }
        }
        var MULTI_GEOMETRY_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "LineString": makeArrayPusher(readLineString),
          "LinearRing": makeArrayPusher(readLinearRing),
          "MultiGeometry": makeArrayPusher(readMultiGeometry),
          "Point": makeArrayPusher(readPoint),
          "Polygon": makeArrayPusher(readPolygon)
        });
        function readMultiGeometry(node, objectStack) {
          var geometries = pushParseAndPop([], MULTI_GEOMETRY_PARSERS, node, objectStack);
          if (!geometries) {
            return null;
          }
          if (geometries.length === 0) {
            return new geom_GeometryCollection(geometries);
          }
          var multiGeometry;
          var homogeneous = true;
          var type = geometries[0].getType();
          var geometry;
          for (var i = 1, ii = geometries.length; i < ii; ++i) {
            geometry = geometries[i];
            if (geometry.getType() != type) {
              homogeneous = false;
              break;
            }
          }
          if (homogeneous) {
            var layout = void 0;
            var flatCoordinates = void 0;
            if (type == geom_GeometryType.POINT) {
              var point = geometries[0];
              layout = point.getLayout();
              flatCoordinates = point.getFlatCoordinates();
              for (var i = 1, ii = geometries.length; i < ii; ++i) {
                geometry = geometries[i];
                Object(ol_array["c"])(flatCoordinates, geometry.getFlatCoordinates());
              }
              multiGeometry = new geom_MultiPoint(flatCoordinates, layout);
              setCommonGeometryProperties(multiGeometry, geometries);
            } else if (type == geom_GeometryType.LINE_STRING) {
              multiGeometry = new geom_MultiLineString(geometries);
              setCommonGeometryProperties(multiGeometry, geometries);
            } else if (type == geom_GeometryType.POLYGON) {
              multiGeometry = new geom_MultiPolygon(geometries);
              setCommonGeometryProperties(multiGeometry, geometries);
            } else if (type == geom_GeometryType.GEOMETRY_COLLECTION) {
              multiGeometry = new geom_GeometryCollection(geometries);
            } else {
              assert2(false, 37);
            }
          } else {
            multiGeometry = new geom_GeometryCollection(geometries);
          }
          return multiGeometry;
        }
        function readPoint(node, objectStack) {
          var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
          var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
          if (flatCoordinates) {
            var point = new geom_Point(flatCoordinates, GeometryLayout.XYZ);
            point.setProperties(properties, true);
            return point;
          } else {
            return void 0;
          }
        }
        var FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "innerBoundaryIs": innerBoundaryIsParser,
          "outerBoundaryIs": outerBoundaryIsParser
        });
        function readPolygon(node, objectStack) {
          var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
          var flatLinearRings = pushParseAndPop([null], FLAT_LINEAR_RINGS_PARSERS, node, objectStack);
          if (flatLinearRings && flatLinearRings[0]) {
            var flatCoordinates = flatLinearRings[0];
            var ends = [flatCoordinates.length];
            for (var i = 1, ii = flatLinearRings.length; i < ii; ++i) {
              Object(ol_array["c"])(flatCoordinates, flatLinearRings[i]);
              ends.push(flatCoordinates.length);
            }
            var polygon = new geom_Polygon(flatCoordinates, GeometryLayout.XYZ, ends);
            polygon.setProperties(properties, true);
            return polygon;
          } else {
            return void 0;
          }
        }
        var STYLE_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "IconStyle": iconStyleParser,
          "LabelStyle": labelStyleParser,
          "LineStyle": lineStyleParser,
          "PolyStyle": polyStyleParser
        });
        function readStyle(node, objectStack) {
          var styleObject = pushParseAndPop({}, STYLE_PARSERS, node, objectStack, this);
          if (!styleObject) {
            return null;
          }
          var fillStyle = "fillStyle" in styleObject ? styleObject["fillStyle"] : DEFAULT_FILL_STYLE;
          var fill = styleObject["fill"];
          if (fill !== void 0 && !fill) {
            fillStyle = null;
          }
          var imageStyle;
          if ("imageStyle" in styleObject) {
            if (styleObject["imageStyle"] != DEFAULT_NO_IMAGE_STYLE) {
              imageStyle = styleObject["imageStyle"];
            }
          } else {
            imageStyle = DEFAULT_IMAGE_STYLE;
          }
          var textStyle = "textStyle" in styleObject ? styleObject["textStyle"] : DEFAULT_TEXT_STYLE;
          var strokeStyle = "strokeStyle" in styleObject ? styleObject["strokeStyle"] : DEFAULT_STROKE_STYLE;
          var outline = styleObject["outline"];
          if (outline !== void 0 && !outline) {
            return [
              new style_Style({
                geometry: function(feature) {
                  var geometry = feature.getGeometry();
                  var type = geometry.getType();
                  if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                    var collection = geometry;
                    return new geom_GeometryCollection(collection.getGeometriesArrayRecursive().filter(function(geometry2) {
                      var type2 = geometry2.getType();
                      return type2 !== geom_GeometryType.POLYGON && type2 !== geom_GeometryType.MULTI_POLYGON;
                    }));
                  } else if (type !== geom_GeometryType.POLYGON && type !== geom_GeometryType.MULTI_POLYGON) {
                    return geometry;
                  }
                },
                fill: fillStyle,
                image: imageStyle,
                stroke: strokeStyle,
                text: textStyle,
                zIndex: void 0
              }),
              new style_Style({
                geometry: function(feature) {
                  var geometry = feature.getGeometry();
                  var type = geometry.getType();
                  if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                    var collection = geometry;
                    return new geom_GeometryCollection(collection.getGeometriesArrayRecursive().filter(function(geometry2) {
                      var type2 = geometry2.getType();
                      return type2 === geom_GeometryType.POLYGON || type2 === geom_GeometryType.MULTI_POLYGON;
                    }));
                  } else if (type === geom_GeometryType.POLYGON || type === geom_GeometryType.MULTI_POLYGON) {
                    return geometry;
                  }
                },
                fill: fillStyle,
                stroke: null,
                zIndex: void 0
              })
            ];
          }
          return [
            new style_Style({
              fill: fillStyle,
              image: imageStyle,
              stroke: strokeStyle,
              text: textStyle,
              zIndex: void 0
            })
          ];
        }
        function setCommonGeometryProperties(multiGeometry, geometries) {
          var ii = geometries.length;
          var extrudes = new Array(geometries.length);
          var tessellates = new Array(geometries.length);
          var altitudeModes = new Array(geometries.length);
          var hasExtrude, hasTessellate, hasAltitudeMode;
          hasExtrude = false;
          hasTessellate = false;
          hasAltitudeMode = false;
          for (var i = 0; i < ii; ++i) {
            var geometry = geometries[i];
            extrudes[i] = geometry.get("extrude");
            tessellates[i] = geometry.get("tessellate");
            altitudeModes[i] = geometry.get("altitudeMode");
            hasExtrude = hasExtrude || extrudes[i] !== void 0;
            hasTessellate = hasTessellate || tessellates[i] !== void 0;
            hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
          }
          if (hasExtrude) {
            multiGeometry.set("extrude", extrudes);
          }
          if (hasTessellate) {
            multiGeometry.set("tessellate", tessellates);
          }
          if (hasAltitudeMode) {
            multiGeometry.set("altitudeMode", altitudeModes);
          }
        }
        var DATA_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "displayName": makeObjectPropertySetter(readString),
          "value": makeObjectPropertySetter(readString)
        });
        function dataParser(node, objectStack) {
          var name = node.getAttribute("name");
          parseNode(DATA_PARSERS, node, objectStack);
          var featureObject = objectStack[objectStack.length - 1];
          if (name && featureObject.displayName) {
            featureObject[name] = {
              value: featureObject.value,
              displayName: featureObject.displayName,
              toString: function() {
                return featureObject.value;
              }
            };
          } else if (name !== null) {
            featureObject[name] = featureObject.value;
          } else if (featureObject.displayName !== null) {
            featureObject[featureObject.displayName] = featureObject.value;
          }
          delete featureObject["value"];
        }
        var EXTENDED_DATA_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "Data": dataParser,
          "SchemaData": schemaDataParser
        });
        function extendedDataParser(node, objectStack) {
          parseNode(EXTENDED_DATA_PARSERS, node, objectStack);
        }
        function regionParser(node, objectStack) {
          parseNode(REGION_PARSERS, node, objectStack);
        }
        var PAIR_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "Style": makeObjectPropertySetter(readStyle),
          "key": makeObjectPropertySetter(readString),
          "styleUrl": makeObjectPropertySetter(readStyleURL)
        });
        function pairDataParser(node, objectStack) {
          var pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);
          if (!pairObject) {
            return;
          }
          var key = pairObject["key"];
          if (key && key == "normal") {
            var styleUrl = pairObject["styleUrl"];
            if (styleUrl) {
              objectStack[objectStack.length - 1] = styleUrl;
            }
            var style = pairObject["Style"];
            if (style) {
              objectStack[objectStack.length - 1] = style;
            }
          }
        }
        function placemarkStyleMapParser(node, objectStack) {
          var styleMapValue = readStyleMapValue.call(this, node, objectStack);
          if (!styleMapValue) {
            return;
          }
          var placemarkObject = objectStack[objectStack.length - 1];
          if (Array.isArray(styleMapValue)) {
            placemarkObject["Style"] = styleMapValue;
          } else if (typeof styleMapValue === "string") {
            placemarkObject["styleUrl"] = styleMapValue;
          } else {
            assert2(false, 38);
          }
        }
        var SCHEMA_DATA_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "SimpleData": simpleDataParser
        });
        function schemaDataParser(node, objectStack) {
          parseNode(SCHEMA_DATA_PARSERS, node, objectStack);
        }
        function simpleDataParser(node, objectStack) {
          var name = node.getAttribute("name");
          if (name !== null) {
            var data = readString(node);
            var featureObject = objectStack[objectStack.length - 1];
            featureObject[name] = data;
          }
        }
        var LAT_LON_ALT_BOX_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "altitudeMode": makeObjectPropertySetter(readString),
          "minAltitude": makeObjectPropertySetter(readDecimal),
          "maxAltitude": makeObjectPropertySetter(readDecimal),
          "north": makeObjectPropertySetter(readDecimal),
          "south": makeObjectPropertySetter(readDecimal),
          "east": makeObjectPropertySetter(readDecimal),
          "west": makeObjectPropertySetter(readDecimal)
        });
        function latLonAltBoxParser(node, objectStack) {
          var object = pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node, objectStack);
          if (!object) {
            return;
          }
          var regionObject = objectStack[objectStack.length - 1];
          var extent = [
            parseFloat(object["west"]),
            parseFloat(object["south"]),
            parseFloat(object["east"]),
            parseFloat(object["north"])
          ];
          regionObject["extent"] = extent;
          regionObject["altitudeMode"] = object["altitudeMode"];
          regionObject["minAltitude"] = parseFloat(object["minAltitude"]);
          regionObject["maxAltitude"] = parseFloat(object["maxAltitude"]);
        }
        var LOD_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "minLodPixels": makeObjectPropertySetter(readDecimal),
          "maxLodPixels": makeObjectPropertySetter(readDecimal),
          "minFadeExtent": makeObjectPropertySetter(readDecimal),
          "maxFadeExtent": makeObjectPropertySetter(readDecimal)
        });
        function lodParser(node, objectStack) {
          var object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);
          if (!object) {
            return;
          }
          var lodObject = objectStack[objectStack.length - 1];
          lodObject["minLodPixels"] = parseFloat(object["minLodPixels"]);
          lodObject["maxLodPixels"] = parseFloat(object["maxLodPixels"]);
          lodObject["minFadeExtent"] = parseFloat(object["minFadeExtent"]);
          lodObject["maxFadeExtent"] = parseFloat(object["maxFadeExtent"]);
        }
        var INNER_BOUNDARY_IS_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "LinearRing": makeArrayPusher(readFlatLinearRing)
        });
        function innerBoundaryIsParser(node, objectStack) {
          var innerBoundaryFlatLinearRings = pushParseAndPop([], INNER_BOUNDARY_IS_PARSERS, node, objectStack);
          if (innerBoundaryFlatLinearRings.length > 0) {
            var flatLinearRings = objectStack[objectStack.length - 1];
            flatLinearRings.push.apply(flatLinearRings, innerBoundaryFlatLinearRings);
          }
        }
        var OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "LinearRing": makeReplacer(readFlatLinearRing)
        });
        function outerBoundaryIsParser(node, objectStack) {
          var flatLinearRing = pushParseAndPop(void 0, OUTER_BOUNDARY_IS_PARSERS, node, objectStack);
          if (flatLinearRing) {
            var flatLinearRings = objectStack[objectStack.length - 1];
            flatLinearRings[0] = flatLinearRing;
          }
        }
        function linkParser(node, objectStack) {
          parseNode(KML_LINK_PARSERS, node, objectStack);
        }
        function whenParser(node, objectStack) {
          var gxTrackObject = objectStack[objectStack.length - 1];
          var whens = gxTrackObject.whens;
          var s = getAllTextContent(node, false);
          var when = Date.parse(s);
          whens.push(isNaN(when) ? 0 : when);
        }
        function writeColorTextNode(node, color) {
          var rgba = asArray(color);
          var opacity = rgba.length == 4 ? rgba[3] : 1;
          var abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];
          for (var i = 0; i < 4; ++i) {
            var hex = Math.floor(abgr[i]).toString(16);
            abgr[i] = hex.length == 1 ? "0" + hex : hex;
          }
          writeStringTextNode(node, abgr.join(""));
        }
        function writeCoordinatesTextNode(node, coordinates, objectStack) {
          var context = objectStack[objectStack.length - 1];
          var layout = context["layout"];
          var stride = context["stride"];
          var dimension;
          if (layout == GeometryLayout.XY || layout == GeometryLayout.XYM) {
            dimension = 2;
          } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYZM) {
            dimension = 3;
          } else {
            assert2(false, 34);
          }
          var ii = coordinates.length;
          var text = "";
          if (ii > 0) {
            text += coordinates[0];
            for (var d = 1; d < dimension; ++d) {
              text += "," + coordinates[d];
            }
            for (var i = stride; i < ii; i += stride) {
              text += " " + coordinates[i];
              for (var d = 1; d < dimension; ++d) {
                text += "," + coordinates[i + d];
              }
            }
          }
          writeStringTextNode(node, text);
        }
        var EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "Data": makeChildAppender(writeDataNode),
          "value": makeChildAppender(writeDataNodeValue),
          "displayName": makeChildAppender(writeDataNodeName)
        });
        function writeDataNode(node, pair, objectStack) {
          node.setAttribute("name", pair.name);
          var context = { node };
          var value = pair.value;
          if (typeof value == "object") {
            if (value !== null && value.displayName) {
              pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ["displayName"]);
            }
            if (value !== null && value.value) {
              pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ["value"]);
            }
          } else {
            pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ["value"]);
          }
        }
        function writeDataNodeName(node, name) {
          writeCDATASection(node, name);
        }
        function writeDataNodeValue(node, value) {
          writeStringTextNode(node, value);
        }
        var DOCUMENT_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "Placemark": makeChildAppender(writePlacemark)
        });
        var DOCUMENT_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
          var parentNode = objectStack[objectStack.length - 1].node;
          return createElementNS(parentNode.namespaceURI, "Placemark");
        };
        function writeDocument(node, features, objectStack) {
          var context = { node };
          pushSerializeAndPop(context, DOCUMENT_SERIALIZERS, DOCUMENT_NODE_FACTORY, features, objectStack, void 0, this);
        }
        var DATA_NODE_FACTORY = makeSimpleNodeFactory("Data");
        function writeExtendedData(node, namesAndValues, objectStack) {
          var context = { node };
          var names = namesAndValues.names;
          var values = namesAndValues.values;
          var length = names.length;
          for (var i = 0; i < length; i++) {
            pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, DATA_NODE_FACTORY, [{ name: names[i], value: values[i] }], objectStack);
          }
        }
        var ICON_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, ["href"], makeStructureNS(GX_NAMESPACE_URIS, ["x", "y", "w", "h"]));
        var ICON_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "href": makeChildAppender(writeStringTextNode)
        }, makeStructureNS(GX_NAMESPACE_URIS, {
          "x": makeChildAppender(writeDecimalTextNode),
          "y": makeChildAppender(writeDecimalTextNode),
          "w": makeChildAppender(writeDecimalTextNode),
          "h": makeChildAppender(writeDecimalTextNode)
        }));
        var GX_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
          return createElementNS(GX_NAMESPACE_URIS[0], "gx:" + opt_nodeName);
        };
        function writeIcon(node, icon, objectStack) {
          var context = { node };
          var parentNode = objectStack[objectStack.length - 1].node;
          var orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
          var values = makeSequence(icon, orderedKeys);
          pushSerializeAndPop(context, ICON_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
          orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
          values = makeSequence(icon, orderedKeys);
          pushSerializeAndPop(context, ICON_SERIALIZERS, GX_NODE_FACTORY, values, objectStack, orderedKeys);
        }
        var ICON_STYLE_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
          "scale",
          "heading",
          "Icon",
          "color",
          "hotSpot"
        ]);
        var ICON_STYLE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "Icon": makeChildAppender(writeIcon),
          "color": makeChildAppender(writeColorTextNode),
          "heading": makeChildAppender(writeDecimalTextNode),
          "hotSpot": makeChildAppender(writeVec2),
          "scale": makeChildAppender(writeScaleTextNode)
        });
        function writeIconStyle(node, style, objectStack) {
          var context = { node };
          var properties = {};
          var src = style.getSrc();
          var size = style.getSize();
          var iconImageSize = style.getImageSize();
          var iconProperties = {
            "href": src
          };
          if (size) {
            iconProperties["w"] = size[0];
            iconProperties["h"] = size[1];
            var anchor = style.getAnchor();
            var origin_1 = style.getOrigin();
            if (origin_1 && iconImageSize && origin_1[0] !== 0 && origin_1[1] !== size[1]) {
              iconProperties["x"] = origin_1[0];
              iconProperties["y"] = iconImageSize[1] - (origin_1[1] + size[1]);
            }
            if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
              var hotSpot = {
                x: anchor[0],
                xunits: IconAnchorUnits.PIXELS,
                y: size[1] - anchor[1],
                yunits: IconAnchorUnits.PIXELS
              };
              properties["hotSpot"] = hotSpot;
            }
          }
          properties["Icon"] = iconProperties;
          var scale = style.getScaleArray()[0];
          var imageSize = size;
          if (imageSize === null) {
            imageSize = DEFAULT_IMAGE_STYLE_SIZE;
          }
          if (imageSize.length == 2) {
            var resizeScale = scaleForSize(imageSize);
            scale = scale / resizeScale;
          }
          if (scale !== 1) {
            properties["scale"] = scale;
          }
          var rotation = style.getRotation();
          if (rotation !== 0) {
            properties["heading"] = rotation;
          }
          var color = style.getColor();
          if (color) {
            properties["color"] = color;
          }
          var parentNode = objectStack[objectStack.length - 1].node;
          var orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
          var values = makeSequence(properties, orderedKeys);
          pushSerializeAndPop(context, ICON_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
        }
        var LABEL_STYLE_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
          "color",
          "scale"
        ]);
        var LABEL_STYLE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "color": makeChildAppender(writeColorTextNode),
          "scale": makeChildAppender(writeScaleTextNode)
        });
        function writeLabelStyle(node, style, objectStack) {
          var context = { node };
          var properties = {};
          var fill = style.getFill();
          if (fill) {
            properties["color"] = fill.getColor();
          }
          var scale = style.getScale();
          if (scale && scale !== 1) {
            properties["scale"] = scale;
          }
          var parentNode = objectStack[objectStack.length - 1].node;
          var orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
          var values = makeSequence(properties, orderedKeys);
          pushSerializeAndPop(context, LABEL_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
        }
        var LINE_STYLE_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, ["color", "width"]);
        var LINE_STYLE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "color": makeChildAppender(writeColorTextNode),
          "width": makeChildAppender(writeDecimalTextNode)
        });
        function writeLineStyle(node, style, objectStack) {
          var context = { node };
          var properties = {
            "color": style.getColor(),
            "width": Number(style.getWidth()) || 1
          };
          var parentNode = objectStack[objectStack.length - 1].node;
          var orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
          var values = makeSequence(properties, orderedKeys);
          pushSerializeAndPop(context, LINE_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
        }
        var KML_GEOMETRY_TYPE_TO_NODENAME = {
          "Point": "Point",
          "LineString": "LineString",
          "LinearRing": "LinearRing",
          "Polygon": "Polygon",
          "MultiPoint": "MultiGeometry",
          "MultiLineString": "MultiGeometry",
          "MultiPolygon": "MultiGeometry",
          "GeometryCollection": "MultiGeometry"
        };
        var GEOMETRY_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
          if (value) {
            var parentNode = objectStack[objectStack.length - 1].node;
            return createElementNS(parentNode.namespaceURI, KML_GEOMETRY_TYPE_TO_NODENAME[value.getType()]);
          }
        };
        var POINT_NODE_FACTORY = makeSimpleNodeFactory("Point");
        var LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory("LineString");
        var LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory("LinearRing");
        var POLYGON_NODE_FACTORY = makeSimpleNodeFactory("Polygon");
        var MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "LineString": makeChildAppender(writePrimitiveGeometry),
          "Point": makeChildAppender(writePrimitiveGeometry),
          "Polygon": makeChildAppender(writePolygon),
          "GeometryCollection": makeChildAppender(writeMultiGeometry)
        });
        function writeMultiGeometry(node, geometry, objectStack) {
          var context = { node };
          var type = geometry.getType();
          var geometries = [];
          var factory;
          if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
            geometry.getGeometriesArrayRecursive().forEach(function(geometry2) {
              var type2 = geometry2.getType();
              if (type2 === geom_GeometryType.MULTI_POINT) {
                geometries = geometries.concat(geometry2.getPoints());
              } else if (type2 === geom_GeometryType.MULTI_LINE_STRING) {
                geometries = geometries.concat(geometry2.getLineStrings());
              } else if (type2 === geom_GeometryType.MULTI_POLYGON) {
                geometries = geometries.concat(geometry2.getPolygons());
              } else if (type2 === geom_GeometryType.POINT || type2 === geom_GeometryType.LINE_STRING || type2 === geom_GeometryType.POLYGON) {
                geometries.push(geometry2);
              } else {
                assert2(false, 39);
              }
            });
            factory = GEOMETRY_NODE_FACTORY;
          } else if (type === geom_GeometryType.MULTI_POINT) {
            geometries = geometry.getPoints();
            factory = POINT_NODE_FACTORY;
          } else if (type === geom_GeometryType.MULTI_LINE_STRING) {
            geometries = geometry.getLineStrings();
            factory = LINE_STRING_NODE_FACTORY;
          } else if (type === geom_GeometryType.MULTI_POLYGON) {
            geometries = geometry.getPolygons();
            factory = POLYGON_NODE_FACTORY;
          } else {
            assert2(false, 39);
          }
          pushSerializeAndPop(context, MULTI_GEOMETRY_SERIALIZERS, factory, geometries, objectStack);
        }
        var BOUNDARY_IS_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "LinearRing": makeChildAppender(writePrimitiveGeometry)
        });
        function writeBoundaryIs(node, linearRing, objectStack) {
          var context = { node };
          pushSerializeAndPop(context, BOUNDARY_IS_SERIALIZERS, LINEAR_RING_NODE_FACTORY, [linearRing], objectStack);
        }
        var PLACEMARK_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "ExtendedData": makeChildAppender(writeExtendedData),
          "MultiGeometry": makeChildAppender(writeMultiGeometry),
          "LineString": makeChildAppender(writePrimitiveGeometry),
          "LinearRing": makeChildAppender(writePrimitiveGeometry),
          "Point": makeChildAppender(writePrimitiveGeometry),
          "Polygon": makeChildAppender(writePolygon),
          "Style": makeChildAppender(writeStyle),
          "address": makeChildAppender(writeStringTextNode),
          "description": makeChildAppender(writeStringTextNode),
          "name": makeChildAppender(writeStringTextNode),
          "open": makeChildAppender(writeBooleanTextNode),
          "phoneNumber": makeChildAppender(writeStringTextNode),
          "styleUrl": makeChildAppender(writeStringTextNode),
          "visibility": makeChildAppender(writeBooleanTextNode)
        });
        var PLACEMARK_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
          "name",
          "open",
          "visibility",
          "address",
          "phoneNumber",
          "description",
          "styleUrl",
          "Style"
        ]);
        var EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory("ExtendedData");
        function writePlacemark(node, feature, objectStack) {
          var context = { node };
          if (feature.getId()) {
            node.setAttribute("id", feature.getId());
          }
          var properties = feature.getProperties();
          var filter = {
            "address": 1,
            "description": 1,
            "name": 1,
            "open": 1,
            "phoneNumber": 1,
            "styleUrl": 1,
            "visibility": 1
          };
          filter[feature.getGeometryName()] = 1;
          var keys = Object.keys(properties || {}).sort().filter(function(v) {
            return !filter[v];
          });
          var styleFunction = feature.getStyleFunction();
          if (styleFunction) {
            var styles = styleFunction(feature, 0);
            if (styles) {
              var styleArray = Array.isArray(styles) ? styles : [styles];
              var pointStyles = styleArray;
              if (feature.getGeometry()) {
                pointStyles = styleArray.filter(function(style) {
                  var geometry2 = style.getGeometryFunction()(feature);
                  if (geometry2) {
                    var type = geometry2.getType();
                    if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                      return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                        var type2 = geometry3.getType();
                        return type2 === geom_GeometryType.POINT || type2 === geom_GeometryType.MULTI_POINT;
                      }).length;
                    }
                    return type === geom_GeometryType.POINT || type === geom_GeometryType.MULTI_POINT;
                  }
                });
              }
              if (this.writeStyles_) {
                var lineStyles = styleArray;
                var polyStyles = styleArray;
                if (feature.getGeometry()) {
                  lineStyles = styleArray.filter(function(style) {
                    var geometry2 = style.getGeometryFunction()(feature);
                    if (geometry2) {
                      var type = geometry2.getType();
                      if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                        return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                          var type2 = geometry3.getType();
                          return type2 === geom_GeometryType.LINE_STRING || type2 === geom_GeometryType.MULTI_LINE_STRING;
                        }).length;
                      }
                      return type === geom_GeometryType.LINE_STRING || type === geom_GeometryType.MULTI_LINE_STRING;
                    }
                  });
                  polyStyles = styleArray.filter(function(style) {
                    var geometry2 = style.getGeometryFunction()(feature);
                    if (geometry2) {
                      var type = geometry2.getType();
                      if (type === geom_GeometryType.GEOMETRY_COLLECTION) {
                        return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                          var type2 = geometry3.getType();
                          return type2 === geom_GeometryType.POLYGON || type2 === geom_GeometryType.MULTI_POLYGON;
                        }).length;
                      }
                      return type === geom_GeometryType.POLYGON || type === geom_GeometryType.MULTI_POLYGON;
                    }
                  });
                }
                properties["Style"] = {
                  pointStyles,
                  lineStyles,
                  polyStyles
                };
              }
              if (pointStyles.length && properties["name"] === void 0) {
                var textStyle = pointStyles[0].getText();
                if (textStyle) {
                  properties["name"] = textStyle.getText();
                }
              }
            }
          }
          var parentNode = objectStack[objectStack.length - 1].node;
          var orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
          var values = makeSequence(properties, orderedKeys);
          pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
          if (keys.length > 0) {
            var sequence = makeSequence(properties, keys);
            var namesAndValues = { names: keys, values: sequence };
            pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);
          }
          var options = objectStack[0];
          var geometry = feature.getGeometry();
          if (geometry) {
            geometry = transformGeometryWithOptions(geometry, true, options);
          }
          pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, GEOMETRY_NODE_FACTORY, [geometry], objectStack);
        }
        var PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
          "extrude",
          "tessellate",
          "altitudeMode",
          "coordinates"
        ]);
        var PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "extrude": makeChildAppender(writeBooleanTextNode),
          "tessellate": makeChildAppender(writeBooleanTextNode),
          "altitudeMode": makeChildAppender(writeStringTextNode),
          "coordinates": makeChildAppender(writeCoordinatesTextNode)
        });
        function writePrimitiveGeometry(node, geometry, objectStack) {
          var flatCoordinates = geometry.getFlatCoordinates();
          var context = { node };
          context["layout"] = geometry.getLayout();
          context["stride"] = geometry.getStride();
          var properties = geometry.getProperties();
          properties.coordinates = flatCoordinates;
          var parentNode = objectStack[objectStack.length - 1].node;
          var orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
          var values = makeSequence(properties, orderedKeys);
          pushSerializeAndPop(context, PRIMITIVE_GEOMETRY_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
        }
        var POLY_STYLE_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
          "color",
          "fill",
          "outline"
        ]);
        var POLYGON_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "outerBoundaryIs": makeChildAppender(writeBoundaryIs),
          "innerBoundaryIs": makeChildAppender(writeBoundaryIs)
        });
        var INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("innerBoundaryIs");
        var OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("outerBoundaryIs");
        function writePolygon(node, polygon, objectStack) {
          var linearRings = polygon.getLinearRings();
          var outerRing = linearRings.shift();
          var context = { node };
          pushSerializeAndPop(context, POLYGON_SERIALIZERS, INNER_BOUNDARY_NODE_FACTORY, linearRings, objectStack);
          pushSerializeAndPop(context, POLYGON_SERIALIZERS, OUTER_BOUNDARY_NODE_FACTORY, [outerRing], objectStack);
        }
        var POLY_STYLE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "color": makeChildAppender(writeColorTextNode),
          "fill": makeChildAppender(writeBooleanTextNode),
          "outline": makeChildAppender(writeBooleanTextNode)
        });
        function writePolyStyle(node, style, objectStack) {
          var context = { node };
          var fill = style.getFill();
          var stroke = style.getStroke();
          var properties = {
            "color": fill ? fill.getColor() : void 0,
            "fill": fill ? void 0 : false,
            "outline": stroke ? void 0 : false
          };
          var parentNode = objectStack[objectStack.length - 1].node;
          var orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];
          var values = makeSequence(properties, orderedKeys);
          pushSerializeAndPop(context, POLY_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
        }
        function writeScaleTextNode(node, scale) {
          writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);
        }
        var STYLE_SEQUENCE = makeStructureNS(KML_NAMESPACE_URIS, [
          "IconStyle",
          "LabelStyle",
          "LineStyle",
          "PolyStyle"
        ]);
        var STYLE_SERIALIZERS = makeStructureNS(KML_NAMESPACE_URIS, {
          "IconStyle": makeChildAppender(writeIconStyle),
          "LabelStyle": makeChildAppender(writeLabelStyle),
          "LineStyle": makeChildAppender(writeLineStyle),
          "PolyStyle": makeChildAppender(writePolyStyle)
        });
        function writeStyle(node, styles, objectStack) {
          var context = { node };
          var properties = {};
          if (styles.pointStyles.length) {
            var textStyle = styles.pointStyles[0].getText();
            if (textStyle) {
              properties["LabelStyle"] = textStyle;
            }
            var imageStyle = styles.pointStyles[0].getImage();
            if (imageStyle && typeof imageStyle.getSrc === "function") {
              properties["IconStyle"] = imageStyle;
            }
          }
          if (styles.lineStyles.length) {
            var strokeStyle = styles.lineStyles[0].getStroke();
            if (strokeStyle) {
              properties["LineStyle"] = strokeStyle;
            }
          }
          if (styles.polyStyles.length) {
            var strokeStyle = styles.polyStyles[0].getStroke();
            if (strokeStyle && !properties["LineStyle"]) {
              properties["LineStyle"] = strokeStyle;
            }
            properties["PolyStyle"] = styles.polyStyles[0];
          }
          var parentNode = objectStack[objectStack.length - 1].node;
          var orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
          var values = makeSequence(properties, orderedKeys);
          pushSerializeAndPop(context, STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
        }
        function writeVec2(node, vec2) {
          node.setAttribute("x", String(vec2.x));
          node.setAttribute("y", String(vec2.y));
          node.setAttribute("xunits", vec2.xunits);
          node.setAttribute("yunits", vec2.yunits);
        }
        var format_KML = KML_KML;
        var node_modules_pbf = __webpack_require__("7915");
        var pbf_default = __webpack_require__.n(node_modules_pbf);
        var Feature_tmpTransform = create();
        var Feature_RenderFeature = function() {
          function RenderFeature(type, flatCoordinates, ends, properties, id) {
            this.styleFunction;
            this.extent_;
            this.id_ = id;
            this.type_ = type;
            this.flatCoordinates_ = flatCoordinates;
            this.flatInteriorPoints_ = null;
            this.flatMidpoints_ = null;
            this.ends_ = ends;
            this.properties_ = properties;
          }
          RenderFeature.prototype.get = function(key) {
            return this.properties_[key];
          };
          RenderFeature.prototype.getExtent = function() {
            if (!this.extent_) {
              this.extent_ = this.type_ === geom_GeometryType.POINT ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
            }
            return this.extent_;
          };
          RenderFeature.prototype.getFlatInteriorPoint = function() {
            if (!this.flatInteriorPoints_) {
              var flatCenter = extent_getCenter(this.getExtent());
              this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenter, 0);
            }
            return this.flatInteriorPoints_;
          };
          RenderFeature.prototype.getFlatInteriorPoints = function() {
            if (!this.flatInteriorPoints_) {
              var flatCenters = center_linearRingss(this.flatCoordinates_, 0, this.ends_, 2);
              this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenters);
            }
            return this.flatInteriorPoints_;
          };
          RenderFeature.prototype.getFlatMidpoint = function() {
            if (!this.flatMidpoints_) {
              this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
            }
            return this.flatMidpoints_;
          };
          RenderFeature.prototype.getFlatMidpoints = function() {
            if (!this.flatMidpoints_) {
              this.flatMidpoints_ = [];
              var flatCoordinates = this.flatCoordinates_;
              var offset = 0;
              var ends = this.ends_;
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                var end = ends[i];
                var midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);
                Object(ol_array["c"])(this.flatMidpoints_, midpoint);
                offset = end;
              }
            }
            return this.flatMidpoints_;
          };
          RenderFeature.prototype.getId = function() {
            return this.id_;
          };
          RenderFeature.prototype.getOrientedFlatCoordinates = function() {
            return this.flatCoordinates_;
          };
          RenderFeature.prototype.getGeometry = function() {
            return this;
          };
          RenderFeature.prototype.getSimplifiedGeometry = function(squaredTolerance) {
            return this;
          };
          RenderFeature.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {
            return this;
          };
          RenderFeature.prototype.getProperties = function() {
            return this.properties_;
          };
          RenderFeature.prototype.getStride = function() {
            return 2;
          };
          RenderFeature.prototype.getStyleFunction = function() {
            return this.styleFunction;
          };
          RenderFeature.prototype.getType = function() {
            return this.type_;
          };
          RenderFeature.prototype.transform = function(projection) {
            projection = proj_get(projection);
            var pixelExtent = projection.getExtent();
            var projectedExtent = projection.getWorldExtent();
            if (pixelExtent && projectedExtent) {
              var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
              compose(Feature_tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
              transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, Feature_tmpTransform, this.flatCoordinates_);
            }
          };
          RenderFeature.prototype.getEnds = function() {
            return this.ends_;
          };
          return RenderFeature;
        }();
        Feature_RenderFeature.prototype.getEndss = Feature_RenderFeature.prototype.getEnds;
        Feature_RenderFeature.prototype.getFlatCoordinates = Feature_RenderFeature.prototype.getOrientedFlatCoordinates;
        var render_Feature = Feature_RenderFeature;
        var MVT_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var MVT_MVT = function(_super) {
          MVT_extends(MVT, _super);
          function MVT(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.dataProjection = new proj_Projection({
              code: "",
              units: proj_Units.TILE_PIXELS
            });
            _this.featureClass_ = options.featureClass ? options.featureClass : render_Feature;
            _this.geometryName_ = options.geometryName;
            _this.layerName_ = options.layerName ? options.layerName : "layer";
            _this.layers_ = options.layers ? options.layers : null;
            _this.idProperty_ = options.idProperty;
            _this.supportedMediaTypes = [
              "application/vnd.mapbox-vector-tile",
              "application/x-protobuf"
            ];
            return _this;
          }
          MVT.prototype.readRawGeometry_ = function(pbf, feature, flatCoordinates, ends) {
            pbf.pos = feature.geometry;
            var end = pbf.readVarint() + pbf.pos;
            var cmd = 1;
            var length = 0;
            var x = 0;
            var y = 0;
            var coordsLen = 0;
            var currentEnd = 0;
            while (pbf.pos < end) {
              if (!length) {
                var cmdLen = pbf.readVarint();
                cmd = cmdLen & 7;
                length = cmdLen >> 3;
              }
              length--;
              if (cmd === 1 || cmd === 2) {
                x += pbf.readSVarint();
                y += pbf.readSVarint();
                if (cmd === 1) {
                  if (coordsLen > currentEnd) {
                    ends.push(coordsLen);
                    currentEnd = coordsLen;
                  }
                }
                flatCoordinates.push(x, y);
                coordsLen += 2;
              } else if (cmd === 7) {
                if (coordsLen > currentEnd) {
                  flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);
                  coordsLen += 2;
                }
              } else {
                assert2(false, 59);
              }
            }
            if (coordsLen > currentEnd) {
              ends.push(coordsLen);
              currentEnd = coordsLen;
            }
          };
          MVT.prototype.createFeature_ = function(pbf, rawFeature, options) {
            var type = rawFeature.type;
            if (type === 0) {
              return null;
            }
            var feature;
            var values = rawFeature.properties;
            var id;
            if (!this.idProperty_) {
              id = rawFeature.id;
            } else {
              id = values[this.idProperty_];
              delete values[this.idProperty_];
            }
            values[this.layerName_] = rawFeature.layer.name;
            var flatCoordinates = [];
            var ends = [];
            this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);
            var geometryType = getGeometryType(type, ends.length);
            if (this.featureClass_ === render_Feature) {
              feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);
              feature.transform(options.dataProjection);
            } else {
              var geom = void 0;
              if (geometryType == geom_GeometryType.POLYGON) {
                var endss = [];
                var offset = 0;
                var prevEndIndex = 0;
                for (var i = 0, ii = ends.length; i < ii; ++i) {
                  var end = ends[i];
                  if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {
                    endss.push(ends.slice(prevEndIndex, i + 1));
                  } else {
                    if (endss.length === 0) {
                      continue;
                    }
                    endss[endss.length - 1].push(ends[prevEndIndex]);
                  }
                  prevEndIndex = i + 1;
                  offset = end;
                }
                if (endss.length > 1) {
                  geom = new geom_MultiPolygon(flatCoordinates, GeometryLayout.XY, endss);
                } else {
                  geom = new geom_Polygon(flatCoordinates, GeometryLayout.XY, ends);
                }
              } else {
                geom = geometryType === geom_GeometryType.POINT ? new geom_Point(flatCoordinates, GeometryLayout.XY) : geometryType === geom_GeometryType.LINE_STRING ? new geom_LineString(flatCoordinates, GeometryLayout.XY) : geometryType === geom_GeometryType.POLYGON ? new geom_Polygon(flatCoordinates, GeometryLayout.XY, ends) : geometryType === geom_GeometryType.MULTI_POINT ? new geom_MultiPoint(flatCoordinates, GeometryLayout.XY) : geometryType === geom_GeometryType.MULTI_LINE_STRING ? new geom_MultiLineString(flatCoordinates, GeometryLayout.XY, ends) : null;
              }
              var ctor = this.featureClass_;
              feature = new ctor();
              if (this.geometryName_) {
                feature.setGeometryName(this.geometryName_);
              }
              var geometry = transformGeometryWithOptions(geom, false, options);
              feature.setGeometry(geometry);
              feature.setId(id);
              feature.setProperties(values, true);
            }
            return feature;
          };
          MVT.prototype.getType = function() {
            return FormatType.ARRAY_BUFFER;
          };
          MVT.prototype.readFeatures = function(source, opt_options) {
            var layers = this.layers_;
            var options = this.adaptOptions(opt_options);
            var dataProjection = proj_get(options.dataProjection);
            dataProjection.setWorldExtent(options.extent);
            options.dataProjection = dataProjection;
            var pbf = new pbf_default.a(source);
            var pbfLayers = pbf.readFields(layersPBFReader, {});
            var features = [];
            for (var name_1 in pbfLayers) {
              if (layers && layers.indexOf(name_1) == -1) {
                continue;
              }
              var pbfLayer = pbfLayers[name_1];
              var extent = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;
              dataProjection.setExtent(extent);
              for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {
                var rawFeature = readRawFeature(pbf, pbfLayer, i);
                var feature = this.createFeature_(pbf, rawFeature, options);
                if (feature !== null) {
                  features.push(feature);
                }
              }
            }
            return features;
          };
          MVT.prototype.readProjection = function(source) {
            return this.dataProjection;
          };
          MVT.prototype.setLayers = function(layers) {
            this.layers_ = layers;
          };
          return MVT;
        }(format_Feature);
        function layersPBFReader(tag, layers, pbf) {
          if (tag === 3) {
            var layer = {
              keys: [],
              values: [],
              features: []
            };
            var end = pbf.readVarint() + pbf.pos;
            pbf.readFields(layerPBFReader, layer, end);
            layer.length = layer.features.length;
            if (layer.length) {
              layers[layer.name] = layer;
            }
          }
        }
        function layerPBFReader(tag, layer, pbf) {
          if (tag === 15) {
            layer.version = pbf.readVarint();
          } else if (tag === 1) {
            layer.name = pbf.readString();
          } else if (tag === 5) {
            layer.extent = pbf.readVarint();
          } else if (tag === 2) {
            layer.features.push(pbf.pos);
          } else if (tag === 3) {
            layer.keys.push(pbf.readString());
          } else if (tag === 4) {
            var value = null;
            var end = pbf.readVarint() + pbf.pos;
            while (pbf.pos < end) {
              tag = pbf.readVarint() >> 3;
              value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
            }
            layer.values.push(value);
          }
        }
        function featurePBFReader(tag, feature, pbf) {
          if (tag == 1) {
            feature.id = pbf.readVarint();
          } else if (tag == 2) {
            var end = pbf.readVarint() + pbf.pos;
            while (pbf.pos < end) {
              var key = feature.layer.keys[pbf.readVarint()];
              var value = feature.layer.values[pbf.readVarint()];
              feature.properties[key] = value;
            }
          } else if (tag == 3) {
            feature.type = pbf.readVarint();
          } else if (tag == 4) {
            feature.geometry = pbf.pos;
          }
        }
        function readRawFeature(pbf, layer, i) {
          pbf.pos = layer.features[i];
          var end = pbf.readVarint() + pbf.pos;
          var feature = {
            layer,
            type: 0,
            properties: {}
          };
          pbf.readFields(featurePBFReader, feature, end);
          return feature;
        }
        function getGeometryType(type, numEnds) {
          var geometryType;
          if (type === 1) {
            geometryType = numEnds === 1 ? geom_GeometryType.POINT : geom_GeometryType.MULTI_POINT;
          } else if (type === 2) {
            geometryType = numEnds === 1 ? geom_GeometryType.LINE_STRING : geom_GeometryType.MULTI_LINE_STRING;
          } else if (type === 3) {
            geometryType = geom_GeometryType.POLYGON;
          }
          return geometryType;
        }
        var format_MVT = MVT_MVT;
        var XML_XML = function() {
          function XML() {
          }
          XML.prototype.read = function(source) {
            if (!source) {
              return null;
            } else if (typeof source === "string") {
              var doc = xml_parse(source);
              return this.readFromDocument(doc);
            } else if (isDocument(source)) {
              return this.readFromDocument(source);
            } else {
              return this.readFromNode(source);
            }
          };
          XML.prototype.readFromDocument = function(doc) {
            for (var n = doc.firstChild; n; n = n.nextSibling) {
              if (n.nodeType == Node.ELEMENT_NODE) {
                return this.readFromNode(n);
              }
            }
            return null;
          };
          XML.prototype.readFromNode = function(node) {
          };
          return XML;
        }();
        var format_XML = XML_XML;
        var NAMESPACE_URI = "http://www.w3.org/1999/xlink";
        function readHref(node) {
          return node.getAttributeNS(NAMESPACE_URI, "href");
        }
        var OWS_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var OWS_NAMESPACE_URIS = [null, "http://www.opengis.net/ows/1.1"];
        var PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "ServiceIdentification": makeObjectPropertySetter(readServiceIdentification),
          "ServiceProvider": makeObjectPropertySetter(readServiceProvider),
          "OperationsMetadata": makeObjectPropertySetter(readOperationsMetadata)
        });
        var OWS_OWS = function(_super) {
          OWS_extends(OWS, _super);
          function OWS() {
            return _super.call(this) || this;
          }
          OWS.prototype.readFromNode = function(node) {
            var owsObject = pushParseAndPop({}, PARSERS, node, []);
            return owsObject ? owsObject : null;
          };
          return OWS;
        }(format_XML);
        var ADDRESS_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "DeliveryPoint": makeObjectPropertySetter(readString),
          "City": makeObjectPropertySetter(readString),
          "AdministrativeArea": makeObjectPropertySetter(readString),
          "PostalCode": makeObjectPropertySetter(readString),
          "Country": makeObjectPropertySetter(readString),
          "ElectronicMailAddress": makeObjectPropertySetter(readString)
        });
        var ALLOWED_VALUES_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "Value": makeObjectPropertyPusher(readValue)
        });
        var CONSTRAINT_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "AllowedValues": makeObjectPropertySetter(readAllowedValues)
        });
        var CONTACT_INFO_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "Phone": makeObjectPropertySetter(readPhone),
          "Address": makeObjectPropertySetter(readAddress)
        });
        var DCP_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "HTTP": makeObjectPropertySetter(readHttp)
        });
        var HTTP_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "Get": makeObjectPropertyPusher(readGet),
          "Post": void 0
        });
        var OPERATION_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "DCP": makeObjectPropertySetter(readDcp)
        });
        var OPERATIONS_METADATA_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "Operation": readOperation
        });
        var PHONE_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "Voice": makeObjectPropertySetter(readString),
          "Facsimile": makeObjectPropertySetter(readString)
        });
        var REQUEST_METHOD_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "Constraint": makeObjectPropertyPusher(readConstraint)
        });
        var SERVICE_CONTACT_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "IndividualName": makeObjectPropertySetter(readString),
          "PositionName": makeObjectPropertySetter(readString),
          "ContactInfo": makeObjectPropertySetter(readContactInfo)
        });
        var SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "Abstract": makeObjectPropertySetter(readString),
          "AccessConstraints": makeObjectPropertySetter(readString),
          "Fees": makeObjectPropertySetter(readString),
          "Title": makeObjectPropertySetter(readString),
          "ServiceTypeVersion": makeObjectPropertySetter(readString),
          "ServiceType": makeObjectPropertySetter(readString)
        });
        var SERVICE_PROVIDER_PARSERS = makeStructureNS(OWS_NAMESPACE_URIS, {
          "ProviderName": makeObjectPropertySetter(readString),
          "ProviderSite": makeObjectPropertySetter(readHref),
          "ServiceContact": makeObjectPropertySetter(readServiceContact)
        });
        function readAddress(node, objectStack) {
          return pushParseAndPop({}, ADDRESS_PARSERS, node, objectStack);
        }
        function readAllowedValues(node, objectStack) {
          return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node, objectStack);
        }
        function readConstraint(node, objectStack) {
          var name = node.getAttribute("name");
          if (!name) {
            return void 0;
          }
          return pushParseAndPop({ "name": name }, CONSTRAINT_PARSERS, node, objectStack);
        }
        function readContactInfo(node, objectStack) {
          return pushParseAndPop({}, CONTACT_INFO_PARSERS, node, objectStack);
        }
        function readDcp(node, objectStack) {
          return pushParseAndPop({}, DCP_PARSERS, node, objectStack);
        }
        function readGet(node, objectStack) {
          var href = readHref(node);
          if (!href) {
            return void 0;
          }
          return pushParseAndPop({ "href": href }, REQUEST_METHOD_PARSERS, node, objectStack);
        }
        function readHttp(node, objectStack) {
          return pushParseAndPop({}, HTTP_PARSERS, node, objectStack);
        }
        function readOperation(node, objectStack) {
          var name = node.getAttribute("name");
          var value = pushParseAndPop({}, OPERATION_PARSERS, node, objectStack);
          if (!value) {
            return void 0;
          }
          var object = objectStack[objectStack.length - 1];
          object[name] = value;
        }
        function readOperationsMetadata(node, objectStack) {
          return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node, objectStack);
        }
        function readPhone(node, objectStack) {
          return pushParseAndPop({}, PHONE_PARSERS, node, objectStack);
        }
        function readServiceIdentification(node, objectStack) {
          return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);
        }
        function readServiceContact(node, objectStack) {
          return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node, objectStack);
        }
        function readServiceProvider(node, objectStack) {
          return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node, objectStack);
        }
        function readValue(node, objectStack) {
          return readString(node);
        }
        var format_OWS = OWS_OWS;
        function flipXY(flatCoordinates, offset, end, stride, opt_dest, opt_destOffset) {
          var dest, destOffset;
          if (opt_dest !== void 0) {
            dest = opt_dest;
            destOffset = opt_destOffset !== void 0 ? opt_destOffset : 0;
          } else {
            dest = [];
            destOffset = 0;
          }
          var j = offset;
          while (j < end) {
            var x = flatCoordinates[j++];
            dest[destOffset++] = flatCoordinates[j++];
            dest[destOffset++] = x;
            for (var k = 2; k < stride; ++k) {
              dest[destOffset++] = flatCoordinates[j++];
            }
          }
          dest.length = destOffset;
          return dest;
        }
        var Polyline_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Polyline_Polyline = function(_super) {
          Polyline_extends(Polyline, _super);
          function Polyline(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.dataProjection = proj_get("EPSG:4326");
            _this.factor_ = options.factor ? options.factor : 1e5;
            _this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : GeometryLayout.XY;
            return _this;
          }
          Polyline.prototype.readFeatureFromText = function(text, opt_options) {
            var geometry = this.readGeometryFromText(text, opt_options);
            return new ol_Feature(geometry);
          };
          Polyline.prototype.readFeaturesFromText = function(text, opt_options) {
            var feature = this.readFeatureFromText(text, opt_options);
            return [feature];
          };
          Polyline.prototype.readGeometryFromText = function(text, opt_options) {
            var stride = getStrideForLayout(this.geometryLayout_);
            var flatCoordinates = decodeDeltas(text, stride, this.factor_);
            flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
            var coordinates = inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
            var lineString = new geom_LineString(coordinates, this.geometryLayout_);
            return transformGeometryWithOptions(lineString, false, this.adaptOptions(opt_options));
          };
          Polyline.prototype.writeFeatureText = function(feature, opt_options) {
            var geometry = feature.getGeometry();
            if (geometry) {
              return this.writeGeometryText(geometry, opt_options);
            } else {
              assert2(false, 40);
              return "";
            }
          };
          Polyline.prototype.writeFeaturesText = function(features, opt_options) {
            return this.writeFeatureText(features[0], opt_options);
          };
          Polyline.prototype.writeGeometryText = function(geometry, opt_options) {
            geometry = transformGeometryWithOptions(geometry, true, this.adaptOptions(opt_options));
            var flatCoordinates = geometry.getFlatCoordinates();
            var stride = geometry.getStride();
            flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
            return encodeDeltas(flatCoordinates, stride, this.factor_);
          };
          return Polyline;
        }(format_TextFeature);
        function encodeDeltas(numbers, stride, opt_factor) {
          var factor = opt_factor ? opt_factor : 1e5;
          var d;
          var lastNumbers = new Array(stride);
          for (d = 0; d < stride; ++d) {
            lastNumbers[d] = 0;
          }
          for (var i = 0, ii = numbers.length; i < ii; ) {
            for (d = 0; d < stride; ++d, ++i) {
              var num = numbers[i];
              var delta = num - lastNumbers[d];
              lastNumbers[d] = num;
              numbers[i] = delta;
            }
          }
          return encodeFloats(numbers, factor);
        }
        function decodeDeltas(encoded, stride, opt_factor) {
          var factor = opt_factor ? opt_factor : 1e5;
          var d;
          var lastNumbers = new Array(stride);
          for (d = 0; d < stride; ++d) {
            lastNumbers[d] = 0;
          }
          var numbers = decodeFloats(encoded, factor);
          for (var i = 0, ii = numbers.length; i < ii; ) {
            for (d = 0; d < stride; ++d, ++i) {
              lastNumbers[d] += numbers[i];
              numbers[i] = lastNumbers[d];
            }
          }
          return numbers;
        }
        function encodeFloats(numbers, opt_factor) {
          var factor = opt_factor ? opt_factor : 1e5;
          for (var i = 0, ii = numbers.length; i < ii; ++i) {
            numbers[i] = Math.round(numbers[i] * factor);
          }
          return encodeSignedIntegers(numbers);
        }
        function decodeFloats(encoded, opt_factor) {
          var factor = opt_factor ? opt_factor : 1e5;
          var numbers = decodeSignedIntegers(encoded);
          for (var i = 0, ii = numbers.length; i < ii; ++i) {
            numbers[i] /= factor;
          }
          return numbers;
        }
        function encodeSignedIntegers(numbers) {
          for (var i = 0, ii = numbers.length; i < ii; ++i) {
            var num = numbers[i];
            numbers[i] = num < 0 ? ~(num << 1) : num << 1;
          }
          return encodeUnsignedIntegers(numbers);
        }
        function decodeSignedIntegers(encoded) {
          var numbers = decodeUnsignedIntegers(encoded);
          for (var i = 0, ii = numbers.length; i < ii; ++i) {
            var num = numbers[i];
            numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;
          }
          return numbers;
        }
        function encodeUnsignedIntegers(numbers) {
          var encoded = "";
          for (var i = 0, ii = numbers.length; i < ii; ++i) {
            encoded += encodeUnsignedInteger(numbers[i]);
          }
          return encoded;
        }
        function decodeUnsignedIntegers(encoded) {
          var numbers = [];
          var current = 0;
          var shift = 0;
          for (var i = 0, ii = encoded.length; i < ii; ++i) {
            var b = encoded.charCodeAt(i) - 63;
            current |= (b & 31) << shift;
            if (b < 32) {
              numbers.push(current);
              current = 0;
              shift = 0;
            } else {
              shift += 5;
            }
          }
          return numbers;
        }
        function encodeUnsignedInteger(num) {
          var value, encoded = "";
          while (num >= 32) {
            value = (32 | num & 31) + 63;
            encoded += String.fromCharCode(value);
            num >>= 5;
          }
          value = num + 63;
          encoded += String.fromCharCode(value);
          return encoded;
        }
        var format_Polyline = Polyline_Polyline;
        var TopoJSON_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var TopoJSON_TopoJSON = function(_super) {
          TopoJSON_extends(TopoJSON, _super);
          function TopoJSON(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.layerName_ = options.layerName;
            _this.layers_ = options.layers ? options.layers : null;
            _this.dataProjection = proj_get(options.dataProjection ? options.dataProjection : "EPSG:4326");
            return _this;
          }
          TopoJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
            if (object.type == "Topology") {
              var topoJSONTopology = object;
              var transform2 = void 0, scale = null, translate = null;
              if (topoJSONTopology["transform"]) {
                transform2 = topoJSONTopology["transform"];
                scale = transform2["scale"];
                translate = transform2["translate"];
              }
              var arcs = topoJSONTopology["arcs"];
              if (transform2) {
                transformArcs(arcs, scale, translate);
              }
              var features = [];
              var topoJSONFeatures = topoJSONTopology["objects"];
              var property = this.layerName_;
              var feature = void 0;
              for (var objectName in topoJSONFeatures) {
                if (this.layers_ && this.layers_.indexOf(objectName) == -1) {
                  continue;
                }
                if (topoJSONFeatures[objectName].type === "GeometryCollection") {
                  feature = topoJSONFeatures[objectName];
                  features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, opt_options));
                } else {
                  feature = topoJSONFeatures[objectName];
                  features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, opt_options));
                }
              }
              return features;
            } else {
              return [];
            }
          };
          TopoJSON.prototype.readProjectionFromObject = function(object) {
            return this.dataProjection;
          };
          return TopoJSON;
        }(format_JSONFeature);
        var TopoJSON_GEOMETRY_READERS = {
          "Point": TopoJSON_readPointGeometry,
          "LineString": TopoJSON_readLineStringGeometry,
          "Polygon": TopoJSON_readPolygonGeometry,
          "MultiPoint": TopoJSON_readMultiPointGeometry,
          "MultiLineString": TopoJSON_readMultiLineStringGeometry,
          "MultiPolygon": TopoJSON_readMultiPolygonGeometry
        };
        function concatenateArcs(indices, arcs) {
          var coordinates = [];
          var index;
          for (var i = 0, ii = indices.length; i < ii; ++i) {
            index = indices[i];
            if (i > 0) {
              coordinates.pop();
            }
            if (index >= 0) {
              var arc = arcs[index];
              for (var j = 0, jj = arc.length; j < jj; ++j) {
                coordinates.push(arc[j].slice(0));
              }
            } else {
              var arc = arcs[~index];
              for (var j = arc.length - 1; j >= 0; --j) {
                coordinates.push(arc[j].slice(0));
              }
            }
          }
          return coordinates;
        }
        function TopoJSON_readPointGeometry(object, scale, translate) {
          var coordinates = object["coordinates"];
          if (scale && translate) {
            transformVertex(coordinates, scale, translate);
          }
          return new geom_Point(coordinates);
        }
        function TopoJSON_readMultiPointGeometry(object, scale, translate) {
          var coordinates = object["coordinates"];
          if (scale && translate) {
            for (var i = 0, ii = coordinates.length; i < ii; ++i) {
              transformVertex(coordinates[i], scale, translate);
            }
          }
          return new geom_MultiPoint(coordinates);
        }
        function TopoJSON_readLineStringGeometry(object, arcs) {
          var coordinates = concatenateArcs(object["arcs"], arcs);
          return new geom_LineString(coordinates);
        }
        function TopoJSON_readMultiLineStringGeometry(object, arcs) {
          var coordinates = [];
          for (var i = 0, ii = object["arcs"].length; i < ii; ++i) {
            coordinates[i] = concatenateArcs(object["arcs"][i], arcs);
          }
          return new geom_MultiLineString(coordinates);
        }
        function TopoJSON_readPolygonGeometry(object, arcs) {
          var coordinates = [];
          for (var i = 0, ii = object["arcs"].length; i < ii; ++i) {
            coordinates[i] = concatenateArcs(object["arcs"][i], arcs);
          }
          return new geom_Polygon(coordinates);
        }
        function TopoJSON_readMultiPolygonGeometry(object, arcs) {
          var coordinates = [];
          for (var i = 0, ii = object["arcs"].length; i < ii; ++i) {
            var polyArray = object["arcs"][i];
            var ringCoords = [];
            for (var j = 0, jj = polyArray.length; j < jj; ++j) {
              ringCoords[j] = concatenateArcs(polyArray[j], arcs);
            }
            coordinates[i] = ringCoords;
          }
          return new geom_MultiPolygon(coordinates);
        }
        function readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, opt_options) {
          var geometries = collection["geometries"];
          var features = [];
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
            features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, opt_options);
          }
          return features;
        }
        function readFeatureFromGeometry(object, arcs, scale, translate, property, name, opt_options) {
          var geometry = null;
          var type = object.type;
          if (type) {
            var geometryReader = TopoJSON_GEOMETRY_READERS[type];
            if (type === "Point" || type === "MultiPoint") {
              geometry = geometryReader(object, scale, translate);
            } else {
              geometry = geometryReader(object, arcs);
            }
            geometry = transformGeometryWithOptions(geometry, false, opt_options);
          }
          var feature = new ol_Feature({ geometry });
          if (object.id !== void 0) {
            feature.setId(object.id);
          }
          var properties = object.properties;
          if (property) {
            if (!properties) {
              properties = {};
            }
            properties[property] = name;
          }
          if (properties) {
            feature.setProperties(properties, true);
          }
          return feature;
        }
        function transformArcs(arcs, scale, translate) {
          for (var i = 0, ii = arcs.length; i < ii; ++i) {
            transformArc(arcs[i], scale, translate);
          }
        }
        function transformArc(arc, scale, translate) {
          var x = 0;
          var y = 0;
          for (var i = 0, ii = arc.length; i < ii; ++i) {
            var vertex = arc[i];
            x += vertex[0];
            y += vertex[1];
            vertex[0] = x;
            vertex[1] = y;
            transformVertex(vertex, scale, translate);
          }
        }
        function transformVertex(vertex, scale, translate) {
          vertex[0] = vertex[0] * scale[0] + translate[0];
          vertex[1] = vertex[1] * scale[1] + translate[1];
        }
        var format_TopoJSON = TopoJSON_TopoJSON;
        var GML32_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GML32 = function(_super) {
          GML32_extends(GML322, _super);
          function GML322(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            _this = _super.call(this, options) || this;
            _this.schemaLocation = options.schemaLocation ? options.schemaLocation : _this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
            return _this;
          }
          return GML322;
        }(format_GML3);
        GML32.prototype.namespace = "http://www.opengis.net/gml/3.2";
        GML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "pos": makeReplacer(format_GML3.prototype.readFlatPos),
            "posList": makeReplacer(format_GML3.prototype.readFlatPosList),
            "coordinates": makeReplacer(format_GML2.prototype.readFlatCoordinates)
          }
        };
        GML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "interior": format_GML3.prototype.interiorParser,
            "exterior": format_GML3.prototype.exteriorParser
          }
        };
        GML32.prototype.GEOMETRY_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "Point": makeReplacer(format_GMLBase.prototype.readPoint),
            "MultiPoint": makeReplacer(format_GMLBase.prototype.readMultiPoint),
            "LineString": makeReplacer(format_GMLBase.prototype.readLineString),
            "MultiLineString": makeReplacer(format_GMLBase.prototype.readMultiLineString),
            "LinearRing": makeReplacer(format_GMLBase.prototype.readLinearRing),
            "Polygon": makeReplacer(format_GMLBase.prototype.readPolygon),
            "MultiPolygon": makeReplacer(format_GMLBase.prototype.readMultiPolygon),
            "Surface": makeReplacer(GML32.prototype.readSurface),
            "MultiSurface": makeReplacer(format_GML3.prototype.readMultiSurface),
            "Curve": makeReplacer(GML32.prototype.readCurve),
            "MultiCurve": makeReplacer(format_GML3.prototype.readMultiCurve),
            "Envelope": makeReplacer(GML32.prototype.readEnvelope)
          }
        };
        GML32.prototype.MULTICURVE_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "curveMember": makeArrayPusher(format_GML3.prototype.curveMemberParser),
            "curveMembers": makeArrayPusher(format_GML3.prototype.curveMemberParser)
          }
        };
        GML32.prototype.MULTISURFACE_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "surfaceMember": makeArrayPusher(format_GML3.prototype.surfaceMemberParser),
            "surfaceMembers": makeArrayPusher(format_GML3.prototype.surfaceMemberParser)
          }
        };
        GML32.prototype.CURVEMEMBER_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "LineString": makeArrayPusher(format_GMLBase.prototype.readLineString),
            "Curve": makeArrayPusher(format_GML3.prototype.readCurve)
          }
        };
        GML32.prototype.SURFACEMEMBER_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "Polygon": makeArrayPusher(format_GMLBase.prototype.readPolygon),
            "Surface": makeArrayPusher(format_GML3.prototype.readSurface)
          }
        };
        GML32.prototype.SURFACE_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "patches": makeReplacer(format_GML3.prototype.readPatch)
          }
        };
        GML32.prototype.CURVE_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "segments": makeReplacer(format_GML3.prototype.readSegment)
          }
        };
        GML32.prototype.ENVELOPE_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "lowerCorner": makeArrayPusher(format_GML3.prototype.readFlatPosList),
            "upperCorner": makeArrayPusher(format_GML3.prototype.readFlatPosList)
          }
        };
        GML32.prototype.PATCHES_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "PolygonPatch": makeReplacer(format_GML3.prototype.readPolygonPatch)
          }
        };
        GML32.prototype.SEGMENTS_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "LineStringSegment": makeReplacer(format_GML3.prototype.readLineStringSegment)
          }
        };
        GML32.prototype.MULTIPOINT_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "pointMember": makeArrayPusher(format_GMLBase.prototype.pointMemberParser),
            "pointMembers": makeArrayPusher(format_GMLBase.prototype.pointMemberParser)
          }
        };
        GML32.prototype.MULTILINESTRING_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "lineStringMember": makeArrayPusher(format_GMLBase.prototype.lineStringMemberParser),
            "lineStringMembers": makeArrayPusher(format_GMLBase.prototype.lineStringMemberParser)
          }
        };
        GML32.prototype.MULTIPOLYGON_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "polygonMember": makeArrayPusher(format_GMLBase.prototype.polygonMemberParser),
            "polygonMembers": makeArrayPusher(format_GMLBase.prototype.polygonMemberParser)
          }
        };
        GML32.prototype.POINTMEMBER_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "Point": makeArrayPusher(format_GMLBase.prototype.readFlatCoordinatesFromNode)
          }
        };
        GML32.prototype.LINESTRINGMEMBER_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "LineString": makeArrayPusher(format_GMLBase.prototype.readLineString)
          }
        };
        GML32.prototype.POLYGONMEMBER_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "Polygon": makeArrayPusher(format_GMLBase.prototype.readPolygon)
          }
        };
        GML32.prototype.RING_PARSERS = {
          "http://www.opengis.net/gml/3.2": {
            "LinearRing": makeReplacer(format_GMLBase.prototype.readFlatLinearRing)
          }
        };
        GML32.prototype.RING_SERIALIZERS = {
          "http://www.opengis.net/gml/3.2": {
            "exterior": makeChildAppender(format_GML3.prototype.writeRing),
            "interior": makeChildAppender(format_GML3.prototype.writeRing)
          }
        };
        GML32.prototype.ENVELOPE_SERIALIZERS = {
          "http://www.opengis.net/gml/3.2": {
            "lowerCorner": makeChildAppender(writeStringTextNode),
            "upperCorner": makeChildAppender(writeStringTextNode)
          }
        };
        GML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
          "http://www.opengis.net/gml/3.2": {
            "surfaceMember": makeChildAppender(format_GML3.prototype.writeSurfaceOrPolygonMember),
            "polygonMember": makeChildAppender(format_GML3.prototype.writeSurfaceOrPolygonMember)
          }
        };
        GML32.prototype.POINTMEMBER_SERIALIZERS = {
          "http://www.opengis.net/gml/3.2": {
            "pointMember": makeChildAppender(format_GML3.prototype.writePointMember)
          }
        };
        GML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
          "http://www.opengis.net/gml/3.2": {
            "lineStringMember": makeChildAppender(format_GML3.prototype.writeLineStringOrCurveMember),
            "curveMember": makeChildAppender(format_GML3.prototype.writeLineStringOrCurveMember)
          }
        };
        GML32.prototype.GEOMETRY_SERIALIZERS = {
          "http://www.opengis.net/gml/3.2": {
            "Curve": makeChildAppender(format_GML3.prototype.writeCurveOrLineString),
            "MultiCurve": makeChildAppender(format_GML3.prototype.writeMultiCurveOrLineString),
            "Point": makeChildAppender(GML32.prototype.writePoint),
            "MultiPoint": makeChildAppender(format_GML3.prototype.writeMultiPoint),
            "LineString": makeChildAppender(format_GML3.prototype.writeCurveOrLineString),
            "MultiLineString": makeChildAppender(format_GML3.prototype.writeMultiCurveOrLineString),
            "LinearRing": makeChildAppender(format_GML3.prototype.writeLinearRing),
            "Polygon": makeChildAppender(format_GML3.prototype.writeSurfaceOrPolygon),
            "MultiPolygon": makeChildAppender(format_GML3.prototype.writeMultiSurfaceOrPolygon),
            "Surface": makeChildAppender(format_GML3.prototype.writeSurfaceOrPolygon),
            "MultiSurface": makeChildAppender(format_GML3.prototype.writeMultiSurfaceOrPolygon),
            "Envelope": makeChildAppender(format_GML3.prototype.writeEnvelope)
          }
        };
        var format_GML32 = GML32;
        var Filter = function() {
          function Filter2(tagName) {
            this.tagName_ = tagName;
          }
          Filter2.prototype.getTagName = function() {
            return this.tagName_;
          };
          return Filter2;
        }();
        var filter_Filter = Filter;
        var LogicalNary_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var LogicalNary_LogicalNary = function(_super) {
          LogicalNary_extends(LogicalNary, _super);
          function LogicalNary(tagName, conditions) {
            var _this = _super.call(this, tagName) || this;
            _this.conditions = conditions;
            assert2(_this.conditions.length >= 2, 57);
            return _this;
          }
          return LogicalNary;
        }(filter_Filter);
        var filter_LogicalNary = LogicalNary_LogicalNary;
        var And_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var And = function(_super) {
          And_extends(And2, _super);
          function And2(conditions) {
            return _super.call(this, "And", Array.prototype.slice.call(arguments)) || this;
          }
          return And2;
        }(filter_LogicalNary);
        var filter_And = And;
        var Bbox_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Bbox = function(_super) {
          Bbox_extends(Bbox2, _super);
          function Bbox2(geometryName, extent, opt_srsName) {
            var _this = _super.call(this, "BBOX") || this;
            _this.geometryName = geometryName;
            _this.extent = extent;
            if (extent.length !== 4) {
              throw new Error("Expected an extent with four values ([minX, minY, maxX, maxY])");
            }
            _this.srsName = opt_srsName;
            return _this;
          }
          return Bbox2;
        }(filter_Filter);
        var filter_Bbox = Bbox;
        var Spatial_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Spatial = function(_super) {
          Spatial_extends(Spatial2, _super);
          function Spatial2(tagName, geometryName, geometry, opt_srsName) {
            var _this = _super.call(this, tagName) || this;
            _this.geometryName = geometryName || "the_geom";
            _this.geometry = geometry;
            _this.srsName = opt_srsName;
            return _this;
          }
          return Spatial2;
        }(filter_Filter);
        var filter_Spatial = Spatial;
        var Contains_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Contains = function(_super) {
          Contains_extends(Contains2, _super);
          function Contains2(geometryName, geometry, opt_srsName) {
            return _super.call(this, "Contains", geometryName, geometry, opt_srsName) || this;
          }
          return Contains2;
        }(filter_Spatial);
        var filter_Contains = Contains;
        var DWithin_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var DWithin = function(_super) {
          DWithin_extends(DWithin2, _super);
          function DWithin2(geometryName, geometry, distance, unit, opt_srsName) {
            var _this = _super.call(this, "DWithin", geometryName, geometry, opt_srsName) || this;
            _this.distance = distance;
            _this.unit = unit;
            return _this;
          }
          return DWithin2;
        }(filter_Spatial);
        var filter_DWithin = DWithin;
        var Disjoint_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Disjoint = function(_super) {
          Disjoint_extends(Disjoint2, _super);
          function Disjoint2(geometryName, geometry, opt_srsName) {
            return _super.call(this, "Disjoint", geometryName, geometry, opt_srsName) || this;
          }
          return Disjoint2;
        }(filter_Spatial);
        var filter_Disjoint = Disjoint;
        var Comparison_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Comparison = function(_super) {
          Comparison_extends(Comparison2, _super);
          function Comparison2(tagName, propertyName) {
            var _this = _super.call(this, tagName) || this;
            _this.propertyName = propertyName;
            return _this;
          }
          return Comparison2;
        }(filter_Filter);
        var filter_Comparison = Comparison;
        var During_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var During = function(_super) {
          During_extends(During2, _super);
          function During2(propertyName, begin, end) {
            var _this = _super.call(this, "During", propertyName) || this;
            _this.begin = begin;
            _this.end = end;
            return _this;
          }
          return During2;
        }(filter_Comparison);
        var filter_During = During;
        var ComparisonBinary_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ComparisonBinary = function(_super) {
          ComparisonBinary_extends(ComparisonBinary2, _super);
          function ComparisonBinary2(tagName, propertyName, expression, opt_matchCase) {
            var _this = _super.call(this, tagName, propertyName) || this;
            _this.expression = expression;
            _this.matchCase = opt_matchCase;
            return _this;
          }
          return ComparisonBinary2;
        }(filter_Comparison);
        var filter_ComparisonBinary = ComparisonBinary;
        var EqualTo_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var EqualTo = function(_super) {
          EqualTo_extends(EqualTo2, _super);
          function EqualTo2(propertyName, expression, opt_matchCase) {
            return _super.call(this, "PropertyIsEqualTo", propertyName, expression, opt_matchCase) || this;
          }
          return EqualTo2;
        }(filter_ComparisonBinary);
        var filter_EqualTo = EqualTo;
        var GreaterThan_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GreaterThan = function(_super) {
          GreaterThan_extends(GreaterThan2, _super);
          function GreaterThan2(propertyName, expression) {
            return _super.call(this, "PropertyIsGreaterThan", propertyName, expression) || this;
          }
          return GreaterThan2;
        }(filter_ComparisonBinary);
        var filter_GreaterThan = GreaterThan;
        var GreaterThanOrEqualTo_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GreaterThanOrEqualTo = function(_super) {
          GreaterThanOrEqualTo_extends(GreaterThanOrEqualTo2, _super);
          function GreaterThanOrEqualTo2(propertyName, expression) {
            return _super.call(this, "PropertyIsGreaterThanOrEqualTo", propertyName, expression) || this;
          }
          return GreaterThanOrEqualTo2;
        }(filter_ComparisonBinary);
        var filter_GreaterThanOrEqualTo = GreaterThanOrEqualTo;
        var Intersects_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Intersects = function(_super) {
          Intersects_extends(Intersects2, _super);
          function Intersects2(geometryName, geometry, opt_srsName) {
            return _super.call(this, "Intersects", geometryName, geometry, opt_srsName) || this;
          }
          return Intersects2;
        }(filter_Spatial);
        var filter_Intersects = Intersects;
        var IsBetween_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var IsBetween = function(_super) {
          IsBetween_extends(IsBetween2, _super);
          function IsBetween2(propertyName, lowerBoundary, upperBoundary) {
            var _this = _super.call(this, "PropertyIsBetween", propertyName) || this;
            _this.lowerBoundary = lowerBoundary;
            _this.upperBoundary = upperBoundary;
            return _this;
          }
          return IsBetween2;
        }(filter_Comparison);
        var filter_IsBetween = IsBetween;
        var IsLike_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var IsLike = function(_super) {
          IsLike_extends(IsLike2, _super);
          function IsLike2(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
            var _this = _super.call(this, "PropertyIsLike", propertyName) || this;
            _this.pattern = pattern;
            _this.wildCard = opt_wildCard !== void 0 ? opt_wildCard : "*";
            _this.singleChar = opt_singleChar !== void 0 ? opt_singleChar : ".";
            _this.escapeChar = opt_escapeChar !== void 0 ? opt_escapeChar : "!";
            _this.matchCase = opt_matchCase;
            return _this;
          }
          return IsLike2;
        }(filter_Comparison);
        var filter_IsLike = IsLike;
        var IsNull_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var IsNull = function(_super) {
          IsNull_extends(IsNull2, _super);
          function IsNull2(propertyName) {
            return _super.call(this, "PropertyIsNull", propertyName) || this;
          }
          return IsNull2;
        }(filter_Comparison);
        var filter_IsNull = IsNull;
        var LessThan_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var LessThan = function(_super) {
          LessThan_extends(LessThan2, _super);
          function LessThan2(propertyName, expression) {
            return _super.call(this, "PropertyIsLessThan", propertyName, expression) || this;
          }
          return LessThan2;
        }(filter_ComparisonBinary);
        var filter_LessThan = LessThan;
        var LessThanOrEqualTo_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var LessThanOrEqualTo = function(_super) {
          LessThanOrEqualTo_extends(LessThanOrEqualTo2, _super);
          function LessThanOrEqualTo2(propertyName, expression) {
            return _super.call(this, "PropertyIsLessThanOrEqualTo", propertyName, expression) || this;
          }
          return LessThanOrEqualTo2;
        }(filter_ComparisonBinary);
        var filter_LessThanOrEqualTo = LessThanOrEqualTo;
        var Not_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Not = function(_super) {
          Not_extends(Not2, _super);
          function Not2(condition) {
            var _this = _super.call(this, "Not") || this;
            _this.condition = condition;
            return _this;
          }
          return Not2;
        }(filter_Filter);
        var filter_Not = Not;
        var NotEqualTo_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var NotEqualTo = function(_super) {
          NotEqualTo_extends(NotEqualTo2, _super);
          function NotEqualTo2(propertyName, expression, opt_matchCase) {
            return _super.call(this, "PropertyIsNotEqualTo", propertyName, expression, opt_matchCase) || this;
          }
          return NotEqualTo2;
        }(filter_ComparisonBinary);
        var filter_NotEqualTo = NotEqualTo;
        var Or_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Or = function(_super) {
          Or_extends(Or2, _super);
          function Or2(conditions) {
            return _super.call(this, "Or", Array.prototype.slice.call(arguments)) || this;
          }
          return Or2;
        }(filter_LogicalNary);
        var filter_Or = Or;
        var ResourceId_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var ResourceId = function(_super) {
          ResourceId_extends(ResourceId2, _super);
          function ResourceId2(rid) {
            var _this = _super.call(this, "ResourceId") || this;
            _this.rid = rid;
            return _this;
          }
          return ResourceId2;
        }(filter_Filter);
        var filter_ResourceId = ResourceId;
        var Within_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var Within = function(_super) {
          Within_extends(Within2, _super);
          function Within2(geometryName, geometry, opt_srsName) {
            return _super.call(this, "Within", geometryName, geometry, opt_srsName) || this;
          }
          return Within2;
        }(filter_Spatial);
        var filter_Within = Within;
        function and(conditions) {
          var params = [null].concat(Array.prototype.slice.call(arguments));
          return new (Function.prototype.bind.apply(filter_And, params))();
        }
        function or(conditions) {
          var params = [null].concat(Array.prototype.slice.call(arguments));
          return new (Function.prototype.bind.apply(filter_Or, params))();
        }
        function not(condition) {
          return new filter_Not(condition);
        }
        function filter_bbox(geometryName, extent, opt_srsName) {
          return new filter_Bbox(geometryName, extent, opt_srsName);
        }
        function filter_contains(geometryName, geometry, opt_srsName) {
          return new filter_Contains(geometryName, geometry, opt_srsName);
        }
        function filter_intersects(geometryName, geometry, opt_srsName) {
          return new filter_Intersects(geometryName, geometry, opt_srsName);
        }
        function disjoint(geometryName, geometry, opt_srsName) {
          return new filter_Disjoint(geometryName, geometry, opt_srsName);
        }
        function within(geometryName, geometry, opt_srsName) {
          return new filter_Within(geometryName, geometry, opt_srsName);
        }
        function dwithin(geometryName, geometry, distance, unit, opt_srsName) {
          return new filter_DWithin(geometryName, geometry, distance, unit, opt_srsName);
        }
        function equalTo(propertyName, expression, opt_matchCase) {
          return new filter_EqualTo(propertyName, expression, opt_matchCase);
        }
        function notEqualTo(propertyName, expression, opt_matchCase) {
          return new filter_NotEqualTo(propertyName, expression, opt_matchCase);
        }
        function lessThan(propertyName, expression) {
          return new filter_LessThan(propertyName, expression);
        }
        function lessThanOrEqualTo(propertyName, expression) {
          return new filter_LessThanOrEqualTo(propertyName, expression);
        }
        function greaterThan(propertyName, expression) {
          return new filter_GreaterThan(propertyName, expression);
        }
        function greaterThanOrEqualTo(propertyName, expression) {
          return new filter_GreaterThanOrEqualTo(propertyName, expression);
        }
        function isNull(propertyName) {
          return new filter_IsNull(propertyName);
        }
        function between(propertyName, lowerBoundary, upperBoundary) {
          return new filter_IsBetween(propertyName, lowerBoundary, upperBoundary);
        }
        function like(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
          return new filter_IsLike(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);
        }
        function during(propertyName, begin, end) {
          return new filter_During(propertyName, begin, end);
        }
        function resourceId(rid) {
          return new filter_ResourceId(rid);
        }
        var WFS_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var FEATURE_COLLECTION_PARSERS = {
          "http://www.opengis.net/gml": {
            "boundedBy": makeObjectPropertySetter(format_GMLBase.prototype.readGeometryElement, "bounds")
          },
          "http://www.opengis.net/wfs/2.0": {
            "member": makeArrayPusher(format_GMLBase.prototype.readFeaturesInternal)
          }
        };
        var TRANSACTION_SUMMARY_PARSERS = {
          "http://www.opengis.net/wfs": {
            "totalInserted": makeObjectPropertySetter(readPositiveInteger),
            "totalUpdated": makeObjectPropertySetter(readPositiveInteger),
            "totalDeleted": makeObjectPropertySetter(readPositiveInteger)
          },
          "http://www.opengis.net/wfs/2.0": {
            "totalInserted": makeObjectPropertySetter(readPositiveInteger),
            "totalUpdated": makeObjectPropertySetter(readPositiveInteger),
            "totalDeleted": makeObjectPropertySetter(readPositiveInteger)
          }
        };
        var TRANSACTION_RESPONSE_PARSERS = {
          "http://www.opengis.net/wfs": {
            "TransactionSummary": makeObjectPropertySetter(readTransactionSummary, "transactionSummary"),
            "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
          },
          "http://www.opengis.net/wfs/2.0": {
            "TransactionSummary": makeObjectPropertySetter(readTransactionSummary, "transactionSummary"),
            "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
          }
        };
        var QUERY_SERIALIZERS = {
          "http://www.opengis.net/wfs": {
            "PropertyName": makeChildAppender(writeStringTextNode)
          },
          "http://www.opengis.net/wfs/2.0": {
            "PropertyName": makeChildAppender(writeStringTextNode)
          }
        };
        var TRANSACTION_SERIALIZERS = {
          "http://www.opengis.net/wfs": {
            "Insert": makeChildAppender(writeFeature),
            "Update": makeChildAppender(writeUpdate),
            "Delete": makeChildAppender(writeDelete),
            "Property": makeChildAppender(writeProperty),
            "Native": makeChildAppender(writeNative)
          },
          "http://www.opengis.net/wfs/2.0": {
            "Insert": makeChildAppender(writeFeature),
            "Update": makeChildAppender(writeUpdate),
            "Delete": makeChildAppender(writeDelete),
            "Property": makeChildAppender(writeProperty),
            "Native": makeChildAppender(writeNative)
          }
        };
        var FEATURE_PREFIX = "feature";
        var XMLNS = "http://www.w3.org/2000/xmlns/";
        var OGCNS = {
          "2.0.0": "http://www.opengis.net/ogc/1.1",
          "1.1.0": "http://www.opengis.net/ogc",
          "1.0.0": "http://www.opengis.net/ogc"
        };
        var WFSNS = {
          "2.0.0": "http://www.opengis.net/wfs/2.0",
          "1.1.0": "http://www.opengis.net/wfs",
          "1.0.0": "http://www.opengis.net/wfs"
        };
        var FESNS = {
          "2.0.0": "http://www.opengis.net/fes/2.0",
          "1.1.0": "http://www.opengis.net/fes",
          "1.0.0": "http://www.opengis.net/fes"
        };
        var SCHEMA_LOCATIONS = {
          "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
          "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
          "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
        };
        var GML_FORMATS = {
          "2.0.0": format_GML32,
          "1.1.0": format_GML3,
          "1.0.0": format_GML2
        };
        var DEFAULT_VERSION = "1.1.0";
        var WFS_WFS = function(_super) {
          WFS_extends(WFS, _super);
          function WFS(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.version_ = options.version ? options.version : DEFAULT_VERSION;
            _this.featureType_ = options.featureType;
            _this.featureNS_ = options.featureNS;
            _this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[_this.version_]();
            _this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[_this.version_];
            return _this;
          }
          WFS.prototype.getFeatureType = function() {
            return this.featureType_;
          };
          WFS.prototype.setFeatureType = function(featureType) {
            this.featureType_ = featureType;
          };
          WFS.prototype.readFeaturesFromNode = function(node, opt_options) {
            var context = {
              node
            };
            Object(ol_obj["a"])(context, {
              "featureType": this.featureType_,
              "featureNS": this.featureNS_
            });
            Object(ol_obj["a"])(context, this.getReadOptions(node, opt_options ? opt_options : {}));
            var objectStack = [context];
            var featuresNS;
            if (this.version_ === "2.0.0") {
              featuresNS = FEATURE_COLLECTION_PARSERS;
            } else {
              featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
            }
            var features = pushParseAndPop([], featuresNS, node, objectStack, this.gmlFormat_);
            if (!features) {
              features = [];
            }
            return features;
          };
          WFS.prototype.readTransactionResponse = function(source) {
            if (!source) {
              return void 0;
            } else if (typeof source === "string") {
              var doc = xml_parse(source);
              return this.readTransactionResponseFromDocument(doc);
            } else if (isDocument(source)) {
              return this.readTransactionResponseFromDocument(source);
            } else {
              return this.readTransactionResponseFromNode(source);
            }
          };
          WFS.prototype.readFeatureCollectionMetadata = function(source) {
            if (!source) {
              return void 0;
            } else if (typeof source === "string") {
              var doc = xml_parse(source);
              return this.readFeatureCollectionMetadataFromDocument(doc);
            } else if (isDocument(source)) {
              return this.readFeatureCollectionMetadataFromDocument(source);
            } else {
              return this.readFeatureCollectionMetadataFromNode(source);
            }
          };
          WFS.prototype.readFeatureCollectionMetadataFromDocument = function(doc) {
            for (var n = doc.firstChild; n; n = n.nextSibling) {
              if (n.nodeType == Node.ELEMENT_NODE) {
                return this.readFeatureCollectionMetadataFromNode(n);
              }
            }
            return void 0;
          };
          WFS.prototype.readFeatureCollectionMetadataFromNode = function(node) {
            var result = {};
            var value = readNonNegativeIntegerString(node.getAttribute("numberOfFeatures"));
            result["numberOfFeatures"] = value;
            return pushParseAndPop(result, FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);
          };
          WFS.prototype.readTransactionResponseFromDocument = function(doc) {
            for (var n = doc.firstChild; n; n = n.nextSibling) {
              if (n.nodeType == Node.ELEMENT_NODE) {
                return this.readTransactionResponseFromNode(n);
              }
            }
            return void 0;
          };
          WFS.prototype.readTransactionResponseFromNode = function(node) {
            return pushParseAndPop({}, TRANSACTION_RESPONSE_PARSERS, node, []);
          };
          WFS.prototype.writeGetFeature = function(options) {
            var _this = this;
            var node = createElementNS(WFSNS[this.version_], "GetFeature");
            node.setAttribute("service", "WFS");
            node.setAttribute("version", this.version_);
            if (options.handle) {
              node.setAttribute("handle", options.handle);
            }
            if (options.outputFormat) {
              node.setAttribute("outputFormat", options.outputFormat);
            }
            if (options.maxFeatures !== void 0) {
              node.setAttribute("maxFeatures", String(options.maxFeatures));
            }
            if (options.resultType) {
              node.setAttribute("resultType", options.resultType);
            }
            if (options.startIndex !== void 0) {
              node.setAttribute("startIndex", String(options.startIndex));
            }
            if (options.count !== void 0) {
              node.setAttribute("count", String(options.count));
            }
            if (options.viewParams !== void 0) {
              node.setAttribute("viewParams", options.viewParams);
            }
            node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", this.schemaLocation_);
            var context = {
              node
            };
            Object(ol_obj["a"])(context, {
              "version": this.version_,
              "srsName": options.srsName,
              "featureNS": options.featureNS ? options.featureNS : this.featureNS_,
              "featurePrefix": options.featurePrefix,
              "propertyNames": options.propertyNames ? options.propertyNames : []
            });
            assert2(Array.isArray(options.featureTypes), 11);
            if (typeof options.featureTypes[0] === "string") {
              var filter = options.filter;
              if (options.bbox) {
                assert2(options.geometryName, 12);
                filter = this.combineBboxAndFilter(options.geometryName, options.bbox, options.srsName, filter);
              }
              Object(ol_obj["a"])(context, {
                "geometryName": options.geometryName,
                "filter": filter
              });
              writeGetFeature(node, options.featureTypes, [context]);
            } else {
              options.featureTypes.forEach(function(featureType) {
                var completeFilter = _this.combineBboxAndFilter(featureType.geometryName, featureType.bbox, options.srsName, options.filter);
                Object(ol_obj["a"])(context, {
                  "geometryName": featureType.geometryName,
                  "filter": completeFilter
                });
                writeGetFeature(node, [featureType.name], [context]);
              });
            }
            return node;
          };
          WFS.prototype.combineBboxAndFilter = function(geometryName, extent, opt_srsName, opt_filter) {
            var bboxFilter = filter_bbox(geometryName, extent, opt_srsName);
            if (opt_filter) {
              return and(opt_filter, bboxFilter);
            }
            return bboxFilter;
          };
          WFS.prototype.writeTransaction = function(inserts, updates, deletes, options) {
            var objectStack = [];
            var version = options.version ? options.version : this.version_;
            var node = createElementNS(WFSNS[version], "Transaction");
            node.setAttribute("service", "WFS");
            node.setAttribute("version", version);
            var baseObj;
            if (options) {
              baseObj = options.gmlOptions ? options.gmlOptions : {};
              if (options.handle) {
                node.setAttribute("handle", options.handle);
              }
            }
            node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATIONS[version]);
            var request = createTransactionRequest(node, baseObj, version, options);
            if (inserts) {
              serializeTransactionRequest("Insert", inserts, objectStack, request);
            }
            if (updates) {
              serializeTransactionRequest("Update", updates, objectStack, request);
            }
            if (deletes) {
              serializeTransactionRequest("Delete", deletes, objectStack, request);
            }
            if (options.nativeElements) {
              serializeTransactionRequest("Native", options.nativeElements, objectStack, request);
            }
            return node;
          };
          WFS.prototype.readProjectionFromDocument = function(doc) {
            for (var n = doc.firstChild; n; n = n.nextSibling) {
              if (n.nodeType == Node.ELEMENT_NODE) {
                return this.readProjectionFromNode(n);
              }
            }
            return null;
          };
          WFS.prototype.readProjectionFromNode = function(node) {
            if (node.firstElementChild && node.firstElementChild.firstElementChild) {
              node = node.firstElementChild.firstElementChild;
              for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
                if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {
                  var objectStack = [{}];
                  this.gmlFormat_.readGeometryElement(n, objectStack);
                  return proj_get(objectStack.pop().srsName);
                }
              }
            }
            return null;
          };
          return WFS;
        }(format_XMLFeature);
        function createTransactionRequest(node, baseObj, version, options) {
          var featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;
          var gmlVersion;
          if (version === "1.0.0") {
            gmlVersion = 2;
          } else if (version === "1.1.0") {
            gmlVersion = 3;
          } else if (version === "2.0.0") {
            gmlVersion = 3.2;
          }
          var obj = Object(ol_obj["a"])({ node }, {
            version,
            "featureNS": options.featureNS,
            "featureType": options.featureType,
            "featurePrefix": featurePrefix,
            "gmlVersion": gmlVersion,
            "hasZ": options.hasZ,
            "srsName": options.srsName
          }, baseObj);
          return obj;
        }
        function serializeTransactionRequest(type, features, objectStack, request) {
          pushSerializeAndPop(request, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory(type), features, objectStack);
        }
        function readTransactionSummary(node, objectStack) {
          return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);
        }
        var OGC_FID_PARSERS = {
          "http://www.opengis.net/ogc": {
            "FeatureId": makeArrayPusher(function(node, objectStack) {
              return node.getAttribute("fid");
            })
          },
          "http://www.opengis.net/ogc/1.1": {
            "FeatureId": makeArrayPusher(function(node, objectStack) {
              return node.getAttribute("fid");
            })
          }
        };
        function fidParser(node, objectStack) {
          parseNode(OGC_FID_PARSERS, node, objectStack);
        }
        var INSERT_RESULTS_PARSERS = {
          "http://www.opengis.net/wfs": {
            "Feature": fidParser
          },
          "http://www.opengis.net/wfs/2.0": {
            "Feature": fidParser
          }
        };
        function readInsertResults(node, objectStack) {
          return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);
        }
        function writeFeature(node, feature, objectStack) {
          var context = objectStack[objectStack.length - 1];
          var featureType = context["featureType"];
          var featureNS = context["featureNS"];
          var gmlVersion = context["gmlVersion"];
          var child = createElementNS(featureNS, featureType);
          node.appendChild(child);
          if (gmlVersion === 2) {
            format_GML2.prototype.writeFeatureElement(child, feature, objectStack);
          } else if (gmlVersion === 3) {
            format_GML3.prototype.writeFeatureElement(child, feature, objectStack);
          } else {
            format_GML32.prototype.writeFeatureElement(child, feature, objectStack);
          }
        }
        function writeOgcFidFilter(node, fid, objectStack) {
          var context = objectStack[objectStack.length - 1];
          var version = context["version"];
          var ns = OGCNS[version];
          var filter = createElementNS(ns, "Filter");
          var child = createElementNS(ns, "FeatureId");
          filter.appendChild(child);
          child.setAttribute("fid", fid);
          node.appendChild(filter);
        }
        function getTypeName(featurePrefix, featureType) {
          featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;
          var prefix = featurePrefix + ":";
          if (featureType.indexOf(prefix) === 0) {
            return featureType;
          } else {
            return prefix + featureType;
          }
        }
        function writeDelete(node, feature, objectStack) {
          var context = objectStack[objectStack.length - 1];
          assert2(feature.getId() !== void 0, 26);
          var featureType = context["featureType"];
          var featurePrefix = context["featurePrefix"];
          var featureNS = context["featureNS"];
          var typeName = getTypeName(featurePrefix, featureType);
          node.setAttribute("typeName", typeName);
          node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
          var fid = feature.getId();
          if (fid !== void 0) {
            writeOgcFidFilter(node, fid, objectStack);
          }
        }
        function writeUpdate(node, feature, objectStack) {
          var context = objectStack[objectStack.length - 1];
          assert2(feature.getId() !== void 0, 27);
          var version = context["version"];
          var featureType = context["featureType"];
          var featurePrefix = context["featurePrefix"];
          var featureNS = context["featureNS"];
          var typeName = getTypeName(featurePrefix, featureType);
          var geometryName = feature.getGeometryName();
          node.setAttribute("typeName", typeName);
          node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
          var fid = feature.getId();
          if (fid !== void 0) {
            var keys = feature.getKeys();
            var values = [];
            for (var i = 0, ii = keys.length; i < ii; i++) {
              var value = feature.get(keys[i]);
              if (value !== void 0) {
                var name_1 = keys[i];
                if (value && typeof value.getSimplifiedGeometry === "function") {
                  name_1 = geometryName;
                }
                values.push({ name: name_1, value });
              }
            }
            pushSerializeAndPop({
              version,
              "gmlVersion": context["gmlVersion"],
              node,
              "hasZ": context["hasZ"],
              "srsName": context["srsName"]
            }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory("Property"), values, objectStack);
            writeOgcFidFilter(node, fid, objectStack);
          }
        }
        function writeProperty(node, pair, objectStack) {
          var context = objectStack[objectStack.length - 1];
          var version = context["version"];
          var ns = WFSNS[version];
          var name = createElementNS(ns, "Name");
          var gmlVersion = context["gmlVersion"];
          node.appendChild(name);
          writeStringTextNode(name, pair.name);
          if (pair.value !== void 0 && pair.value !== null) {
            var value = createElementNS(ns, "Value");
            node.appendChild(value);
            if (pair.value && typeof pair.value.getSimplifiedGeometry === "function") {
              if (gmlVersion === 2) {
                format_GML2.prototype.writeGeometryElement(value, pair.value, objectStack);
              } else if (gmlVersion === 3) {
                format_GML3.prototype.writeGeometryElement(value, pair.value, objectStack);
              } else {
                format_GML32.prototype.writeGeometryElement(value, pair.value, objectStack);
              }
            } else {
              writeStringTextNode(value, pair.value);
            }
          }
        }
        function writeNative(node, nativeElement, objectStack) {
          if (nativeElement.vendorId) {
            node.setAttribute("vendorId", nativeElement.vendorId);
          }
          if (nativeElement.safeToIgnore !== void 0) {
            node.setAttribute("safeToIgnore", String(nativeElement.safeToIgnore));
          }
          if (nativeElement.value !== void 0) {
            writeStringTextNode(node, nativeElement.value);
          }
        }
        var GETFEATURE_SERIALIZERS = {
          "http://www.opengis.net/wfs": {
            "Query": makeChildAppender(writeQuery)
          },
          "http://www.opengis.net/wfs/2.0": {
            "Query": makeChildAppender(writeQuery)
          },
          "http://www.opengis.net/ogc": {
            "During": makeChildAppender(writeDuringFilter),
            "And": makeChildAppender(writeLogicalFilter),
            "Or": makeChildAppender(writeLogicalFilter),
            "Not": makeChildAppender(writeNotFilter),
            "BBOX": makeChildAppender(writeBboxFilter),
            "Contains": makeChildAppender(writeSpatialFilter),
            "Intersects": makeChildAppender(writeSpatialFilter),
            "Within": makeChildAppender(writeSpatialFilter),
            "DWithin": makeChildAppender(writeDWithinFilter),
            "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
            "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
            "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
            "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
            "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
            "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
            "PropertyIsNull": makeChildAppender(writeIsNullFilter),
            "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
            "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
          },
          "http://www.opengis.net/fes/2.0": {
            "During": makeChildAppender(writeDuringFilter),
            "And": makeChildAppender(writeLogicalFilter),
            "Or": makeChildAppender(writeLogicalFilter),
            "Not": makeChildAppender(writeNotFilter),
            "BBOX": makeChildAppender(writeBboxFilter),
            "Contains": makeChildAppender(writeSpatialFilter),
            "Disjoint": makeChildAppender(writeSpatialFilter),
            "Intersects": makeChildAppender(writeSpatialFilter),
            "ResourceId": makeChildAppender(writeResourceIdFilter),
            "Within": makeChildAppender(writeSpatialFilter),
            "DWithin": makeChildAppender(writeDWithinFilter),
            "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
            "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
            "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
            "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
            "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
            "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
            "PropertyIsNull": makeChildAppender(writeIsNullFilter),
            "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
            "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
          }
        };
        function writeQuery(node, featureType, objectStack) {
          var context = objectStack[objectStack.length - 1];
          var version = context["version"];
          var featurePrefix = context["featurePrefix"];
          var featureNS = context["featureNS"];
          var propertyNames = context["propertyNames"];
          var srsName = context["srsName"];
          var typeName;
          if (featurePrefix) {
            typeName = getTypeName(featurePrefix, featureType);
          } else {
            typeName = featureType;
          }
          var typeNameAttr;
          if (version === "2.0.0") {
            typeNameAttr = "typeNames";
          } else {
            typeNameAttr = "typeName";
          }
          node.setAttribute(typeNameAttr, typeName);
          if (srsName) {
            node.setAttribute("srsName", srsName);
          }
          if (featureNS) {
            node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
          }
          var item = Object(ol_obj["a"])({}, context);
          item.node = node;
          pushSerializeAndPop(item, QUERY_SERIALIZERS, makeSimpleNodeFactory("PropertyName"), propertyNames, objectStack);
          var filter = context["filter"];
          if (filter) {
            var child = createElementNS(getFilterNS(version), "Filter");
            node.appendChild(child);
            writeFilterCondition(child, filter, objectStack);
          }
        }
        function writeFilterCondition(node, filter, objectStack) {
          var context = objectStack[objectStack.length - 1];
          var item = { node };
          Object(ol_obj["a"])(item, { context });
          pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);
        }
        function writeBboxFilter(node, filter, objectStack) {
          var parent = objectStack[objectStack.length - 1];
          var context = parent["context"];
          var version = context["version"];
          parent["srsName"] = filter.srsName;
          var format = GML_FORMATS[version];
          writePropertyName(version, node, filter.geometryName);
          format.prototype.writeGeometryElement(node, filter.extent, objectStack);
        }
        function writeResourceIdFilter(node, filter, objectStack) {
          node.setAttribute("rid", filter.rid);
        }
        function writeSpatialFilter(node, filter, objectStack) {
          var parent = objectStack[objectStack.length - 1];
          var context = parent["context"];
          var version = context["version"];
          parent["srsName"] = filter.srsName;
          var format = GML_FORMATS[version];
          writePropertyName(version, node, filter.geometryName);
          format.prototype.writeGeometryElement(node, filter.geometry, objectStack);
        }
        function writeDWithinFilter(node, filter, objectStack) {
          var parent = objectStack[objectStack.length - 1];
          var context = parent["context"];
          var version = context["version"];
          writeSpatialFilter(node, filter, objectStack);
          var distance = createElementNS(getFilterNS(version), "Distance");
          writeStringTextNode(distance, filter.distance.toString());
          if (version === "2.0.0") {
            distance.setAttribute("uom", filter.unit);
          } else {
            distance.setAttribute("units", filter.unit);
          }
          node.appendChild(distance);
        }
        function writeDuringFilter(node, filter, objectStack) {
          var parent = objectStack[objectStack.length - 1];
          var context = parent["context"];
          var version = context["version"];
          writeExpression(FESNS[version], "ValueReference", node, filter.propertyName);
          var timePeriod = createElementNS(GMLNS, "TimePeriod");
          node.appendChild(timePeriod);
          var begin = createElementNS(GMLNS, "begin");
          timePeriod.appendChild(begin);
          writeTimeInstant(begin, filter.begin);
          var end = createElementNS(GMLNS, "end");
          timePeriod.appendChild(end);
          writeTimeInstant(end, filter.end);
        }
        function writeLogicalFilter(node, filter, objectStack) {
          var parent = objectStack[objectStack.length - 1];
          var context = parent["context"];
          var item = { node };
          Object(ol_obj["a"])(item, { context });
          var conditions = filter.conditions;
          for (var i = 0, ii = conditions.length; i < ii; ++i) {
            var condition = conditions[i];
            pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
          }
        }
        function writeNotFilter(node, filter, objectStack) {
          var parent = objectStack[objectStack.length - 1];
          var context = parent["context"];
          var item = { node };
          Object(ol_obj["a"])(item, { context });
          var condition = filter.condition;
          pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
        }
        function writeComparisonFilter(node, filter, objectStack) {
          var parent = objectStack[objectStack.length - 1];
          var context = parent["context"];
          var version = context["version"];
          if (filter.matchCase !== void 0) {
            node.setAttribute("matchCase", filter.matchCase.toString());
          }
          writePropertyName(version, node, filter.propertyName);
          writeLiteral(version, node, "" + filter.expression);
        }
        function writeIsNullFilter(node, filter, objectStack) {
          var parent = objectStack[objectStack.length - 1];
          var context = parent["context"];
          var version = context["version"];
          writePropertyName(version, node, filter.propertyName);
        }
        function writeIsBetweenFilter(node, filter, objectStack) {
          var parent = objectStack[objectStack.length - 1];
          var context = parent["context"];
          var version = context["version"];
          var ns = getFilterNS(version);
          writePropertyName(version, node, filter.propertyName);
          var lowerBoundary = createElementNS(ns, "LowerBoundary");
          node.appendChild(lowerBoundary);
          writeLiteral(version, lowerBoundary, "" + filter.lowerBoundary);
          var upperBoundary = createElementNS(ns, "UpperBoundary");
          node.appendChild(upperBoundary);
          writeLiteral(version, upperBoundary, "" + filter.upperBoundary);
        }
        function writeIsLikeFilter(node, filter, objectStack) {
          var parent = objectStack[objectStack.length - 1];
          var context = parent["context"];
          var version = context["version"];
          node.setAttribute("wildCard", filter.wildCard);
          node.setAttribute("singleChar", filter.singleChar);
          node.setAttribute("escapeChar", filter.escapeChar);
          if (filter.matchCase !== void 0) {
            node.setAttribute("matchCase", filter.matchCase.toString());
          }
          writePropertyName(version, node, filter.propertyName);
          writeLiteral(version, node, "" + filter.pattern);
        }
        function writeExpression(ns, tagName, node, value) {
          var property = createElementNS(ns, tagName);
          writeStringTextNode(property, value);
          node.appendChild(property);
        }
        function writeLiteral(version, node, value) {
          writeExpression(getFilterNS(version), "Literal", node, value);
        }
        function writePropertyName(version, node, value) {
          if (version === "2.0.0") {
            writeExpression(FESNS[version], "ValueReference", node, value);
          } else {
            writeExpression(OGCNS[version], "PropertyName", node, value);
          }
        }
        function writeTimeInstant(node, time) {
          var timeInstant = createElementNS(GMLNS, "TimeInstant");
          node.appendChild(timeInstant);
          var timePosition = createElementNS(GMLNS, "timePosition");
          timeInstant.appendChild(timePosition);
          writeStringTextNode(timePosition, time);
        }
        function writeFilter(filter, opt_version) {
          var version = opt_version || "1.1.0";
          var child = createElementNS(getFilterNS(version), "Filter");
          var context = {
            node: child
          };
          Object(ol_obj["a"])(context, {
            "version": version,
            "filter": filter
          });
          writeFilterCondition(child, filter, [context]);
          return child;
        }
        function writeGetFeature(node, featureTypes, objectStack) {
          var context = objectStack[objectStack.length - 1];
          var item = Object(ol_obj["a"])({}, context);
          item.node = node;
          pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory("Query"), featureTypes, objectStack);
        }
        function getFilterNS(version) {
          var ns;
          if (version === "2.0.0") {
            ns = FESNS[version];
          } else {
            ns = OGCNS[version];
          }
          return ns;
        }
        var format_WFS = WFS_WFS;
        var WKB_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var WKBGeometryType = {
          POINT: 1,
          LINE_STRING: 2,
          POLYGON: 3,
          MULTI_POINT: 4,
          MULTI_LINE_STRING: 5,
          MULTI_POLYGON: 6,
          GEOMETRY_COLLECTION: 7,
          POLYHEDRAL_SURFACE: 15,
          TIN: 16,
          TRIANGLE: 17
        };
        var WKB_WkbReader = function() {
          function WkbReader(view) {
            this.view_ = view;
            this.pos_ = 0;
            this.initialized_ = false;
            this.isLittleEndian_ = false;
            this.hasZ_ = false;
            this.hasM_ = false;
            this.srid_ = null;
            this.layout_ = GeometryLayout.XY;
          }
          WkbReader.prototype.readUint8 = function() {
            return this.view_.getUint8(this.pos_++);
          };
          WkbReader.prototype.readUint32 = function(isLittleEndian) {
            return this.view_.getUint32((this.pos_ += 4) - 4, isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_);
          };
          WkbReader.prototype.readDouble = function(isLittleEndian) {
            return this.view_.getFloat64((this.pos_ += 8) - 8, isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_);
          };
          WkbReader.prototype.readPoint = function() {
            var coords = [];
            coords.push(this.readDouble());
            coords.push(this.readDouble());
            if (this.hasZ_) {
              coords.push(this.readDouble());
            }
            if (this.hasM_) {
              coords.push(this.readDouble());
            }
            return coords;
          };
          WkbReader.prototype.readLineString = function() {
            var numPoints = this.readUint32();
            var coords = [];
            for (var i = 0; i < numPoints; i++) {
              coords.push(this.readPoint());
            }
            return coords;
          };
          WkbReader.prototype.readPolygon = function() {
            var numRings = this.readUint32();
            var rings = [];
            for (var i = 0; i < numRings; i++) {
              rings.push(this.readLineString());
            }
            return rings;
          };
          WkbReader.prototype.readWkbHeader = function(expectedTypeId) {
            var byteOrder = this.readUint8();
            var isLittleEndian = byteOrder > 0;
            var wkbType = this.readUint32(isLittleEndian);
            var wkbTypeThousandth = Math.floor((wkbType & 268435455) / 1e3);
            var hasZ = Boolean(wkbType & 2147483648) || wkbTypeThousandth === 1 || wkbTypeThousandth === 3;
            var hasM = Boolean(wkbType & 1073741824) || wkbTypeThousandth === 2 || wkbTypeThousandth === 3;
            var hasSRID = Boolean(wkbType & 536870912);
            var typeId = (wkbType & 268435455) % 1e3;
            var layout = ["XY", hasZ ? "Z" : "", hasM ? "M" : ""].join("");
            var srid = hasSRID ? this.readUint32(isLittleEndian) : null;
            if (expectedTypeId !== void 0 && expectedTypeId !== typeId) {
              throw new Error("Unexpected WKB geometry type " + typeId);
            }
            if (this.initialized_) {
              if (this.isLittleEndian_ !== isLittleEndian) {
                throw new Error("Inconsistent endian");
              }
              if (this.layout_ !== layout) {
                throw new Error("Inconsistent geometry layout");
              }
              if (srid && this.srid_ !== srid) {
                throw new Error("Inconsistent coordinate system (SRID)");
              }
            } else {
              this.isLittleEndian_ = isLittleEndian;
              this.hasZ_ = hasZ;
              this.hasM_ = hasM;
              this.layout_ = layout;
              this.srid_ = srid;
              this.initialized_ = true;
            }
            return typeId;
          };
          WkbReader.prototype.readWkbPayload = function(typeId) {
            switch (typeId) {
              case WKBGeometryType.POINT:
                return this.readPoint();
              case WKBGeometryType.LINE_STRING:
                return this.readLineString();
              case WKBGeometryType.POLYGON:
              case WKBGeometryType.TRIANGLE:
                return this.readPolygon();
              case WKBGeometryType.MULTI_POINT:
                return this.readMultiPoint();
              case WKBGeometryType.MULTI_LINE_STRING:
                return this.readMultiLineString();
              case WKBGeometryType.MULTI_POLYGON:
              case WKBGeometryType.POLYHEDRAL_SURFACE:
              case WKBGeometryType.TIN:
                return this.readMultiPolygon();
              case WKBGeometryType.GEOMETRY_COLLECTION:
                return this.readGeometryCollection();
              default:
                throw new Error("Unsupported WKB geometry type " + typeId + " is found");
            }
          };
          WkbReader.prototype.readWkbBlock = function(expectedTypeId) {
            return this.readWkbPayload(this.readWkbHeader(expectedTypeId));
          };
          WkbReader.prototype.readWkbCollection = function(reader, expectedTypeId) {
            var num = this.readUint32();
            var items = [];
            for (var i = 0; i < num; i++) {
              var result = reader.call(this, expectedTypeId);
              if (result) {
                items.push(result);
              }
            }
            return items;
          };
          WkbReader.prototype.readMultiPoint = function() {
            return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);
          };
          WkbReader.prototype.readMultiLineString = function() {
            return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.LINE_STRING);
          };
          WkbReader.prototype.readMultiPolygon = function() {
            return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);
          };
          WkbReader.prototype.readGeometryCollection = function() {
            return this.readWkbCollection(this.readGeometry);
          };
          WkbReader.prototype.readGeometry = function() {
            var typeId = this.readWkbHeader();
            var result = this.readWkbPayload(typeId);
            switch (typeId) {
              case WKBGeometryType.POINT:
                return new geom_Point(result, this.layout_);
              case WKBGeometryType.LINE_STRING:
                return new geom_LineString(result, this.layout_);
              case WKBGeometryType.POLYGON:
              case WKBGeometryType.TRIANGLE:
                return new geom_Polygon(result, this.layout_);
              case WKBGeometryType.MULTI_POINT:
                return new geom_MultiPoint(result, this.layout_);
              case WKBGeometryType.MULTI_LINE_STRING:
                return new geom_MultiLineString(result, this.layout_);
              case WKBGeometryType.MULTI_POLYGON:
              case WKBGeometryType.POLYHEDRAL_SURFACE:
              case WKBGeometryType.TIN:
                return new geom_MultiPolygon(result, this.layout_);
              case WKBGeometryType.GEOMETRY_COLLECTION:
                return new geom_GeometryCollection(result);
              default:
                return null;
            }
          };
          WkbReader.prototype.getSrid = function() {
            return this.srid_;
          };
          return WkbReader;
        }();
        var WKB_WkbWriter = function() {
          function WkbWriter(opts) {
            opts = opts || {};
            this.layout_ = opts.layout;
            this.isLittleEndian_ = opts.littleEndian !== false;
            this.isEWKB_ = opts.ewkb !== false;
            this.writeQueue_ = [];
            this.nodata_ = Object(ol_obj["a"])({ X: 0, Y: 0, Z: 0, M: 0 }, opts.nodata);
          }
          WkbWriter.prototype.writeUint8 = function(value) {
            this.writeQueue_.push([1, value]);
          };
          WkbWriter.prototype.writeUint32 = function(value) {
            this.writeQueue_.push([4, value]);
          };
          WkbWriter.prototype.writeDouble = function(value) {
            this.writeQueue_.push([8, value]);
          };
          WkbWriter.prototype.writePoint = function(coords, layout) {
            var coordsObj = ol_obj["a"].apply(null, layout.split("").map(function(axis2, idx) {
              var _a2;
              return _a2 = {}, _a2[axis2] = coords[idx], _a2;
            }));
            for (var _i = 0, _a = this.layout_; _i < _a.length; _i++) {
              var axis = _a[_i];
              this.writeDouble(axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]);
            }
          };
          WkbWriter.prototype.writeLineString = function(coords, layout) {
            this.writeUint32(coords.length);
            for (var i = 0; i < coords.length; i++) {
              this.writePoint(coords[i], layout);
            }
          };
          WkbWriter.prototype.writePolygon = function(rings, layout) {
            this.writeUint32(rings.length);
            for (var i = 0; i < rings.length; i++) {
              this.writeLineString(rings[i], layout);
            }
          };
          WkbWriter.prototype.writeWkbHeader = function(wkbType, srid) {
            wkbType %= 1e3;
            if (this.layout_.indexOf("Z") >= 0) {
              wkbType += this.isEWKB_ ? 2147483648 : 1e3;
            }
            if (this.layout_.indexOf("M") >= 0) {
              wkbType += this.isEWKB_ ? 1073741824 : 2e3;
            }
            if (this.isEWKB_ && Number.isInteger(srid)) {
              wkbType |= 536870912;
            }
            this.writeUint8(this.isLittleEndian_ ? 1 : 0);
            this.writeUint32(wkbType);
            if (this.isEWKB_ && Number.isInteger(srid)) {
              this.writeUint32(srid);
            }
          };
          WkbWriter.prototype.writeMultiPoint = function(coords, layout) {
            this.writeUint32(coords.length);
            for (var i = 0; i < coords.length; i++) {
              this.writeWkbHeader(1);
              this.writePoint(coords[i], layout);
            }
          };
          WkbWriter.prototype.writeMultiLineString = function(coords, layout) {
            this.writeUint32(coords.length);
            for (var i = 0; i < coords.length; i++) {
              this.writeWkbHeader(2);
              this.writeLineString(coords[i], layout);
            }
          };
          WkbWriter.prototype.writeMultiPolygon = function(coords, layout) {
            this.writeUint32(coords.length);
            for (var i = 0; i < coords.length; i++) {
              this.writeWkbHeader(3);
              this.writePolygon(coords[i], layout);
            }
          };
          WkbWriter.prototype.writeGeometryCollection = function(geometries) {
            this.writeUint32(geometries.length);
            for (var i = 0; i < geometries.length; i++) {
              this.writeGeometry(geometries[i]);
            }
          };
          WkbWriter.prototype.findMinimumLayout = function(geom, layout) {
            if (layout === void 0) {
              layout = GeometryLayout.XYZM;
            }
            var GeometryLayout_min = function(a, b) {
              if (a === b) {
                return a;
              }
              if (a === GeometryLayout.XYZM) {
                return b;
              }
              if (b === GeometryLayout.XYZM) {
                return a;
              }
              return GeometryLayout.XY;
            };
            if (geom instanceof geom_SimpleGeometry) {
              return GeometryLayout_min(geom.getLayout(), layout);
            }
            if (geom instanceof geom_GeometryCollection) {
              var geoms = geom.getGeometriesArray();
              for (var i = 0; i < geoms.length && layout !== GeometryLayout.XY; i++) {
                layout = this.findMinimumLayout(geoms[i], layout);
              }
            }
            return layout;
          };
          WkbWriter.prototype.writeGeometry = function(geom, srid) {
            var _a, _b;
            var wkblut = (_a = {}, _a[geom_GeometryType.POINT] = WKBGeometryType.POINT, _a[geom_GeometryType.LINE_STRING] = WKBGeometryType.LINE_STRING, _a[geom_GeometryType.POLYGON] = WKBGeometryType.POLYGON, _a[geom_GeometryType.MULTI_POINT] = WKBGeometryType.MULTI_POINT, _a[geom_GeometryType.MULTI_LINE_STRING] = WKBGeometryType.MULTI_LINE_STRING, _a[geom_GeometryType.MULTI_POLYGON] = WKBGeometryType.MULTI_POLYGON, _a[geom_GeometryType.GEOMETRY_COLLECTION] = WKBGeometryType.GEOMETRY_COLLECTION, _a);
            var geomType = geom.getType();
            var typeId = wkblut[geomType];
            if (!typeId) {
              throw new Error("GeometryType " + geomType + " is not supported");
            }
            if (!this.layout_) {
              this.layout_ = this.findMinimumLayout(geom);
            }
            this.writeWkbHeader(typeId, srid);
            if (geom instanceof geom_SimpleGeometry) {
              var writerLUT = (_b = {}, _b[geom_GeometryType.POINT] = this.writePoint, _b[geom_GeometryType.LINE_STRING] = this.writeLineString, _b[geom_GeometryType.POLYGON] = this.writePolygon, _b[geom_GeometryType.MULTI_POINT] = this.writeMultiPoint, _b[geom_GeometryType.MULTI_LINE_STRING] = this.writeMultiLineString, _b[geom_GeometryType.MULTI_POLYGON] = this.writeMultiPolygon, _b);
              writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());
            } else if (geom instanceof geom_GeometryCollection) {
              this.writeGeometryCollection(geom.getGeometriesArray());
            }
          };
          WkbWriter.prototype.getBuffer = function() {
            var _this = this;
            var byteLength = this.writeQueue_.reduce(function(acc, item) {
              return acc + item[0];
            }, 0);
            var buffer = new ArrayBuffer(byteLength);
            var view = new DataView(buffer);
            var pos = 0;
            this.writeQueue_.forEach(function(item) {
              switch (item[0]) {
                case 1:
                  view.setUint8(pos, item[1]);
                  break;
                case 4:
                  view.setUint32(pos, item[1], _this.isLittleEndian_);
                  break;
                case 8:
                  view.setFloat64(pos, item[1], _this.isLittleEndian_);
                  break;
                default:
                  break;
              }
              pos += item[0];
            });
            return buffer;
          };
          return WkbWriter;
        }();
        var WKB_WKB = function(_super) {
          WKB_extends(WKB, _super);
          function WKB(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.splitCollection = Boolean(options.splitCollection);
            _this.viewCache_ = null;
            _this.hex_ = options.hex !== false;
            _this.littleEndian_ = options.littleEndian !== false;
            _this.ewkb_ = options.ewkb !== false;
            _this.layout_ = options.geometryLayout;
            _this.nodataZ_ = options.nodataZ || 0;
            _this.nodataM_ = options.nodataM || 0;
            _this.srid_ = options.srid;
            return _this;
          }
          WKB.prototype.getType = function() {
            return this.hex_ ? FormatType.TEXT : FormatType.ARRAY_BUFFER;
          };
          WKB.prototype.readFeature = function(source, opt_options) {
            return new ol_Feature({
              geometry: this.readGeometry(source, opt_options)
            });
          };
          WKB.prototype.readFeatures = function(source, opt_options) {
            var geometries = [];
            var geometry = this.readGeometry(source, opt_options);
            if (this.splitCollection && geometry instanceof geom_GeometryCollection) {
              geometries = geometry.getGeometriesArray();
            } else {
              geometries = [geometry];
            }
            return geometries.map(function(geometry2) {
              return new ol_Feature({ geometry: geometry2 });
            });
          };
          WKB.prototype.readGeometry = function(source, opt_options) {
            var view = getDataView(source);
            if (!view) {
              return null;
            }
            var reader = new WKB_WkbReader(view);
            var geometry = reader.readGeometry();
            this.viewCache_ = view;
            var options = this.getReadOptions(source, opt_options);
            this.viewCache_ = null;
            return transformGeometryWithOptions(geometry, false, options);
          };
          WKB.prototype.readProjection = function(source) {
            var view = this.viewCache_ || getDataView(source);
            if (!view) {
              return void 0;
            }
            var reader = new WKB_WkbReader(view);
            reader.readWkbHeader();
            return reader.getSrid() && proj_get("EPSG:" + reader.getSrid()) || void 0;
          };
          WKB.prototype.writeFeature = function(feature, opt_options) {
            return this.writeGeometry(feature.getGeometry(), opt_options);
          };
          WKB.prototype.writeFeatures = function(features, opt_options) {
            return this.writeGeometry(new geom_GeometryCollection(features.map(function(f) {
              return f.getGeometry();
            })), opt_options);
          };
          WKB.prototype.writeGeometry = function(geometry, opt_options) {
            var options = this.adaptOptions(opt_options);
            var writer = new WKB_WkbWriter({
              layout: this.layout_,
              littleEndian: this.littleEndian_,
              ewkb: this.ewkb_,
              nodata: {
                Z: this.nodataZ_,
                M: this.nodataM_
              }
            });
            var srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
            if (this.srid_ !== false && !Number.isInteger(this.srid_)) {
              var dataProjection = options.dataProjection && proj_get(options.dataProjection);
              if (dataProjection) {
                var code = dataProjection.getCode();
                if (code.indexOf("EPSG:") === 0) {
                  srid = Number(code.substring(5));
                }
              }
            }
            writer.writeGeometry(transformGeometryWithOptions(geometry, true, options), srid);
            var buffer = writer.getBuffer();
            return this.hex_ ? encodeHexString(buffer) : buffer;
          };
          return WKB;
        }(format_Feature);
        function encodeHexString(buffer) {
          var view = new Uint8Array(buffer);
          return Array.from(view.values()).map(function(x) {
            return (x < 16 ? "0" : "") + Number(x).toString(16).toUpperCase();
          }).join("");
        }
        function decodeHexString(text) {
          var buffer = new Uint8Array(text.length / 2);
          for (var i = 0; i < text.length / 2; i++) {
            buffer[i] = parseInt(text.substr(i * 2, 2), 16);
          }
          return new DataView(buffer.buffer);
        }
        function getDataView(source) {
          if (typeof source === "string") {
            return decodeHexString(source);
          } else if (ArrayBuffer.isView(source)) {
            if (source instanceof DataView) {
              return source;
            }
            return new DataView(source.buffer, source.byteOffset, source.byteLength);
          } else if (source instanceof ArrayBuffer) {
            return new DataView(source);
          } else {
            return null;
          }
        }
        var format_WKB = WKB_WKB;
        var WKT_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var GeometryConstructor = {
          "POINT": geom_Point,
          "LINESTRING": geom_LineString,
          "POLYGON": geom_Polygon,
          "MULTIPOINT": geom_MultiPoint,
          "MULTILINESTRING": geom_MultiLineString,
          "MULTIPOLYGON": geom_MultiPolygon
        };
        var EMPTY = "EMPTY";
        var WKT_Z = "Z";
        var WKT_M = "M";
        var ZM = "ZM";
        var TokenType = {
          START: 0,
          TEXT: 1,
          LEFT_PAREN: 2,
          RIGHT_PAREN: 3,
          NUMBER: 4,
          COMMA: 5,
          EOF: 6
        };
        var WKTGeometryType = {};
        for (var WKT_type in geom_GeometryType) {
          WKTGeometryType[WKT_type] = geom_GeometryType[WKT_type].toUpperCase();
        }
        var Lexer = function() {
          function Lexer2(wkt) {
            this.wkt = wkt;
            this.index_ = -1;
          }
          Lexer2.prototype.isAlpha_ = function(c) {
            return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
          };
          Lexer2.prototype.isNumeric_ = function(c, opt_decimal) {
            var decimal = opt_decimal !== void 0 ? opt_decimal : false;
            return c >= "0" && c <= "9" || c == "." && !decimal;
          };
          Lexer2.prototype.isWhiteSpace_ = function(c) {
            return c == " " || c == "	" || c == "\r" || c == "\n";
          };
          Lexer2.prototype.nextChar_ = function() {
            return this.wkt.charAt(++this.index_);
          };
          Lexer2.prototype.nextToken = function() {
            var c = this.nextChar_();
            var position = this.index_;
            var value = c;
            var type;
            if (c == "(") {
              type = TokenType.LEFT_PAREN;
            } else if (c == ",") {
              type = TokenType.COMMA;
            } else if (c == ")") {
              type = TokenType.RIGHT_PAREN;
            } else if (this.isNumeric_(c) || c == "-") {
              type = TokenType.NUMBER;
              value = this.readNumber_();
            } else if (this.isAlpha_(c)) {
              type = TokenType.TEXT;
              value = this.readText_();
            } else if (this.isWhiteSpace_(c)) {
              return this.nextToken();
            } else if (c === "") {
              type = TokenType.EOF;
            } else {
              throw new Error("Unexpected character: " + c);
            }
            return { position, value, type };
          };
          Lexer2.prototype.readNumber_ = function() {
            var c;
            var index = this.index_;
            var decimal = false;
            var scientificNotation = false;
            do {
              if (c == ".") {
                decimal = true;
              } else if (c == "e" || c == "E") {
                scientificNotation = true;
              }
              c = this.nextChar_();
            } while (this.isNumeric_(c, decimal) || !scientificNotation && (c == "e" || c == "E") || scientificNotation && (c == "-" || c == "+"));
            return parseFloat(this.wkt.substring(index, this.index_--));
          };
          Lexer2.prototype.readText_ = function() {
            var c;
            var index = this.index_;
            do {
              c = this.nextChar_();
            } while (this.isAlpha_(c));
            return this.wkt.substring(index, this.index_--).toUpperCase();
          };
          return Lexer2;
        }();
        var WKT_Parser = function() {
          function Parser(lexer) {
            this.lexer_ = lexer;
            this.token_ = {
              position: 0,
              type: TokenType.START
            };
            this.layout_ = GeometryLayout.XY;
          }
          Parser.prototype.consume_ = function() {
            this.token_ = this.lexer_.nextToken();
          };
          Parser.prototype.isTokenType = function(type) {
            return this.token_.type == type;
          };
          Parser.prototype.match = function(type) {
            var isMatch = this.isTokenType(type);
            if (isMatch) {
              this.consume_();
            }
            return isMatch;
          };
          Parser.prototype.parse = function() {
            this.consume_();
            return this.parseGeometry_();
          };
          Parser.prototype.parseGeometryLayout_ = function() {
            var layout = GeometryLayout.XY;
            var dimToken = this.token_;
            if (this.isTokenType(TokenType.TEXT)) {
              var dimInfo = dimToken.value;
              if (dimInfo === WKT_Z) {
                layout = GeometryLayout.XYZ;
              } else if (dimInfo === WKT_M) {
                layout = GeometryLayout.XYM;
              } else if (dimInfo === ZM) {
                layout = GeometryLayout.XYZM;
              }
              if (layout !== GeometryLayout.XY) {
                this.consume_();
              }
            }
            return layout;
          };
          Parser.prototype.parseGeometryCollectionText_ = function() {
            if (this.match(TokenType.LEFT_PAREN)) {
              var geometries = [];
              do {
                geometries.push(this.parseGeometry_());
              } while (this.match(TokenType.COMMA));
              if (this.match(TokenType.RIGHT_PAREN)) {
                return geometries;
              }
            }
            throw new Error(this.formatErrorMessage_());
          };
          Parser.prototype.parsePointText_ = function() {
            if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = this.parsePoint_();
              if (this.match(TokenType.RIGHT_PAREN)) {
                return coordinates;
              }
            }
            throw new Error(this.formatErrorMessage_());
          };
          Parser.prototype.parseLineStringText_ = function() {
            if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = this.parsePointList_();
              if (this.match(TokenType.RIGHT_PAREN)) {
                return coordinates;
              }
            }
            throw new Error(this.formatErrorMessage_());
          };
          Parser.prototype.parsePolygonText_ = function() {
            if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = this.parseLineStringTextList_();
              if (this.match(TokenType.RIGHT_PAREN)) {
                return coordinates;
              }
            }
            throw new Error(this.formatErrorMessage_());
          };
          Parser.prototype.parseMultiPointText_ = function() {
            if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = void 0;
              if (this.token_.type == TokenType.LEFT_PAREN) {
                coordinates = this.parsePointTextList_();
              } else {
                coordinates = this.parsePointList_();
              }
              if (this.match(TokenType.RIGHT_PAREN)) {
                return coordinates;
              }
            }
            throw new Error(this.formatErrorMessage_());
          };
          Parser.prototype.parseMultiLineStringText_ = function() {
            if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = this.parseLineStringTextList_();
              if (this.match(TokenType.RIGHT_PAREN)) {
                return coordinates;
              }
            }
            throw new Error(this.formatErrorMessage_());
          };
          Parser.prototype.parseMultiPolygonText_ = function() {
            if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = this.parsePolygonTextList_();
              if (this.match(TokenType.RIGHT_PAREN)) {
                return coordinates;
              }
            }
            throw new Error(this.formatErrorMessage_());
          };
          Parser.prototype.parsePoint_ = function() {
            var coordinates = [];
            var dimensions = this.layout_.length;
            for (var i = 0; i < dimensions; ++i) {
              var token = this.token_;
              if (this.match(TokenType.NUMBER)) {
                coordinates.push(token.value);
              } else {
                break;
              }
            }
            if (coordinates.length == dimensions) {
              return coordinates;
            }
            throw new Error(this.formatErrorMessage_());
          };
          Parser.prototype.parsePointList_ = function() {
            var coordinates = [this.parsePoint_()];
            while (this.match(TokenType.COMMA)) {
              coordinates.push(this.parsePoint_());
            }
            return coordinates;
          };
          Parser.prototype.parsePointTextList_ = function() {
            var coordinates = [this.parsePointText_()];
            while (this.match(TokenType.COMMA)) {
              coordinates.push(this.parsePointText_());
            }
            return coordinates;
          };
          Parser.prototype.parseLineStringTextList_ = function() {
            var coordinates = [this.parseLineStringText_()];
            while (this.match(TokenType.COMMA)) {
              coordinates.push(this.parseLineStringText_());
            }
            return coordinates;
          };
          Parser.prototype.parsePolygonTextList_ = function() {
            var coordinates = [this.parsePolygonText_()];
            while (this.match(TokenType.COMMA)) {
              coordinates.push(this.parsePolygonText_());
            }
            return coordinates;
          };
          Parser.prototype.isEmptyGeometry_ = function() {
            var isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;
            if (isEmpty) {
              this.consume_();
            }
            return isEmpty;
          };
          Parser.prototype.formatErrorMessage_ = function() {
            return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
          };
          Parser.prototype.parseGeometry_ = function() {
            var token = this.token_;
            if (this.match(TokenType.TEXT)) {
              var geomType = token.value;
              this.layout_ = this.parseGeometryLayout_();
              var isEmpty = this.isEmptyGeometry_();
              if (geomType == "GEOMETRYCOLLECTION") {
                if (isEmpty) {
                  return new geom_GeometryCollection([]);
                }
                var geometries = this.parseGeometryCollectionText_();
                return new geom_GeometryCollection(geometries);
              } else {
                var ctor = GeometryConstructor[geomType];
                if (!ctor) {
                  throw new Error("Invalid geometry type: " + geomType);
                }
                var coordinates = void 0;
                if (isEmpty) {
                  if (geomType == "POINT") {
                    coordinates = [NaN, NaN];
                  } else {
                    coordinates = [];
                  }
                } else {
                  switch (geomType) {
                    case "POINT": {
                      coordinates = this.parsePointText_();
                      break;
                    }
                    case "LINESTRING": {
                      coordinates = this.parseLineStringText_();
                      break;
                    }
                    case "POLYGON": {
                      coordinates = this.parsePolygonText_();
                      break;
                    }
                    case "MULTIPOINT": {
                      coordinates = this.parseMultiPointText_();
                      break;
                    }
                    case "MULTILINESTRING": {
                      coordinates = this.parseMultiLineStringText_();
                      break;
                    }
                    case "MULTIPOLYGON": {
                      coordinates = this.parseMultiPolygonText_();
                      break;
                    }
                    default:
                      break;
                  }
                }
                return new ctor(coordinates, this.layout_);
              }
            }
            throw new Error(this.formatErrorMessage_());
          };
          return Parser;
        }();
        var WKT_WKT = function(_super) {
          WKT_extends(WKT, _super);
          function WKT(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.splitCollection_ = options.splitCollection !== void 0 ? options.splitCollection : false;
            return _this;
          }
          WKT.prototype.parse_ = function(wkt) {
            var lexer = new Lexer(wkt);
            var parser2 = new WKT_Parser(lexer);
            return parser2.parse();
          };
          WKT.prototype.readFeatureFromText = function(text, opt_options) {
            var geom = this.readGeometryFromText(text, opt_options);
            var feature = new ol_Feature();
            feature.setGeometry(geom);
            return feature;
          };
          WKT.prototype.readFeaturesFromText = function(text, opt_options) {
            var geometries = [];
            var geometry = this.readGeometryFromText(text, opt_options);
            if (this.splitCollection_ && geometry.getType() == geom_GeometryType.GEOMETRY_COLLECTION) {
              geometries = geometry.getGeometriesArray();
            } else {
              geometries = [geometry];
            }
            var features = [];
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              var feature = new ol_Feature();
              feature.setGeometry(geometries[i]);
              features.push(feature);
            }
            return features;
          };
          WKT.prototype.readGeometryFromText = function(text, opt_options) {
            var geometry = this.parse_(text);
            return transformGeometryWithOptions(geometry, false, opt_options);
          };
          WKT.prototype.writeFeatureText = function(feature, opt_options) {
            var geometry = feature.getGeometry();
            if (geometry) {
              return this.writeGeometryText(geometry, opt_options);
            }
            return "";
          };
          WKT.prototype.writeFeaturesText = function(features, opt_options) {
            if (features.length == 1) {
              return this.writeFeatureText(features[0], opt_options);
            }
            var geometries = [];
            for (var i = 0, ii = features.length; i < ii; ++i) {
              geometries.push(features[i].getGeometry());
            }
            var collection = new geom_GeometryCollection(geometries);
            return this.writeGeometryText(collection, opt_options);
          };
          WKT.prototype.writeGeometryText = function(geometry, opt_options) {
            return WKT_encode(transformGeometryWithOptions(geometry, true, opt_options));
          };
          return WKT;
        }(format_TextFeature);
        function encodePointGeometry(geom) {
          var coordinates = geom.getCoordinates();
          if (coordinates.length === 0) {
            return "";
          }
          return coordinates.join(" ");
        }
        function encodeMultiPointGeometry(geom) {
          var array = [];
          var components = geom.getPoints();
          for (var i = 0, ii = components.length; i < ii; ++i) {
            array.push("(" + encodePointGeometry(components[i]) + ")");
          }
          return array.join(",");
        }
        function encodeGeometryCollectionGeometry(geom) {
          var array = [];
          var geoms = geom.getGeometries();
          for (var i = 0, ii = geoms.length; i < ii; ++i) {
            array.push(WKT_encode(geoms[i]));
          }
          return array.join(",");
        }
        function encodeLineStringGeometry(geom) {
          var coordinates = geom.getCoordinates();
          var array = [];
          for (var i = 0, ii = coordinates.length; i < ii; ++i) {
            array.push(coordinates[i].join(" "));
          }
          return array.join(",");
        }
        function encodeMultiLineStringGeometry(geom) {
          var array = [];
          var components = geom.getLineStrings();
          for (var i = 0, ii = components.length; i < ii; ++i) {
            array.push("(" + encodeLineStringGeometry(components[i]) + ")");
          }
          return array.join(",");
        }
        function encodePolygonGeometry(geom) {
          var array = [];
          var rings = geom.getLinearRings();
          for (var i = 0, ii = rings.length; i < ii; ++i) {
            array.push("(" + encodeLineStringGeometry(rings[i]) + ")");
          }
          return array.join(",");
        }
        function encodeMultiPolygonGeometry(geom) {
          var array = [];
          var components = geom.getPolygons();
          for (var i = 0, ii = components.length; i < ii; ++i) {
            array.push("(" + encodePolygonGeometry(components[i]) + ")");
          }
          return array.join(",");
        }
        function encodeGeometryLayout(geom) {
          var layout = geom.getLayout();
          var dimInfo = "";
          if (layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM) {
            dimInfo += WKT_Z;
          }
          if (layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM) {
            dimInfo += WKT_M;
          }
          return dimInfo;
        }
        var GeometryEncoder = {
          "Point": encodePointGeometry,
          "LineString": encodeLineStringGeometry,
          "Polygon": encodePolygonGeometry,
          "MultiPoint": encodeMultiPointGeometry,
          "MultiLineString": encodeMultiLineStringGeometry,
          "MultiPolygon": encodeMultiPolygonGeometry,
          "GeometryCollection": encodeGeometryCollectionGeometry
        };
        function WKT_encode(geom) {
          var type = geom.getType();
          var geometryEncoder = GeometryEncoder[type];
          var enc = geometryEncoder(geom);
          type = type.toUpperCase();
          if (typeof geom.getFlatCoordinates === "function") {
            var dimInfo = encodeGeometryLayout(geom);
            if (dimInfo.length > 0) {
              type += " " + dimInfo;
            }
          }
          if (enc.length === 0) {
            return type + " " + EMPTY;
          }
          return type + "(" + enc + ")";
        }
        var format_WKT = WKT_WKT;
        var WMSCapabilities_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var WMSCapabilities_NAMESPACE_URIS = [null, "http://www.opengis.net/wms"];
        var WMSCapabilities_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Service": makeObjectPropertySetter(readService),
          "Capability": makeObjectPropertySetter(readCapability)
        });
        var CAPABILITY_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Request": makeObjectPropertySetter(readRequest),
          "Exception": makeObjectPropertySetter(readException),
          "Layer": makeObjectPropertySetter(readCapabilityLayer)
        });
        var WMSCapabilities_WMSCapabilities = function(_super) {
          WMSCapabilities_extends(WMSCapabilities, _super);
          function WMSCapabilities() {
            var _this = _super.call(this) || this;
            _this.version = void 0;
            return _this;
          }
          WMSCapabilities.prototype.readFromNode = function(node) {
            this.version = node.getAttribute("version").trim();
            var wmsCapabilityObject = pushParseAndPop({
              "version": this.version
            }, WMSCapabilities_PARSERS, node, []);
            return wmsCapabilityObject ? wmsCapabilityObject : null;
          };
          return WMSCapabilities;
        }(format_XML);
        var SERVICE_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Name": makeObjectPropertySetter(readString),
          "Title": makeObjectPropertySetter(readString),
          "Abstract": makeObjectPropertySetter(readString),
          "KeywordList": makeObjectPropertySetter(readKeywordList),
          "OnlineResource": makeObjectPropertySetter(readHref),
          "ContactInformation": makeObjectPropertySetter(readContactInformation),
          "Fees": makeObjectPropertySetter(readString),
          "AccessConstraints": makeObjectPropertySetter(readString),
          "LayerLimit": makeObjectPropertySetter(readPositiveInteger),
          "MaxWidth": makeObjectPropertySetter(readPositiveInteger),
          "MaxHeight": makeObjectPropertySetter(readPositiveInteger)
        });
        var CONTACT_INFORMATION_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "ContactPersonPrimary": makeObjectPropertySetter(readContactPersonPrimary),
          "ContactPosition": makeObjectPropertySetter(readString),
          "ContactAddress": makeObjectPropertySetter(readContactAddress),
          "ContactVoiceTelephone": makeObjectPropertySetter(readString),
          "ContactFacsimileTelephone": makeObjectPropertySetter(readString),
          "ContactElectronicMailAddress": makeObjectPropertySetter(readString)
        });
        var CONTACT_PERSON_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "ContactPerson": makeObjectPropertySetter(readString),
          "ContactOrganization": makeObjectPropertySetter(readString)
        });
        var CONTACT_ADDRESS_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "AddressType": makeObjectPropertySetter(readString),
          "Address": makeObjectPropertySetter(readString),
          "City": makeObjectPropertySetter(readString),
          "StateOrProvince": makeObjectPropertySetter(readString),
          "PostCode": makeObjectPropertySetter(readString),
          "Country": makeObjectPropertySetter(readString)
        });
        var EXCEPTION_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Format": makeArrayPusher(readString)
        });
        var LAYER_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Name": makeObjectPropertySetter(readString),
          "Title": makeObjectPropertySetter(readString),
          "Abstract": makeObjectPropertySetter(readString),
          "KeywordList": makeObjectPropertySetter(readKeywordList),
          "CRS": makeObjectPropertyPusher(readString),
          "EX_GeographicBoundingBox": makeObjectPropertySetter(readEXGeographicBoundingBox),
          "BoundingBox": makeObjectPropertyPusher(readBoundingBox),
          "Dimension": makeObjectPropertyPusher(readDimension),
          "Attribution": makeObjectPropertySetter(readAttribution),
          "AuthorityURL": makeObjectPropertyPusher(readAuthorityURL),
          "Identifier": makeObjectPropertyPusher(readString),
          "MetadataURL": makeObjectPropertyPusher(readMetadataURL),
          "DataURL": makeObjectPropertyPusher(readFormatOnlineresource),
          "FeatureListURL": makeObjectPropertyPusher(readFormatOnlineresource),
          "Style": makeObjectPropertyPusher(WMSCapabilities_readStyle),
          "MinScaleDenominator": makeObjectPropertySetter(readDecimal),
          "MaxScaleDenominator": makeObjectPropertySetter(readDecimal),
          "Layer": makeObjectPropertyPusher(readLayer)
        });
        var ATTRIBUTION_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Title": makeObjectPropertySetter(readString),
          "OnlineResource": makeObjectPropertySetter(readHref),
          "LogoURL": makeObjectPropertySetter(readSizedFormatOnlineresource)
        });
        var EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "westBoundLongitude": makeObjectPropertySetter(readDecimal),
          "eastBoundLongitude": makeObjectPropertySetter(readDecimal),
          "southBoundLatitude": makeObjectPropertySetter(readDecimal),
          "northBoundLatitude": makeObjectPropertySetter(readDecimal)
        });
        var REQUEST_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "GetCapabilities": makeObjectPropertySetter(readOperationType),
          "GetMap": makeObjectPropertySetter(readOperationType),
          "GetFeatureInfo": makeObjectPropertySetter(readOperationType)
        });
        var OPERATIONTYPE_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Format": makeObjectPropertyPusher(readString),
          "DCPType": makeObjectPropertyPusher(readDCPType)
        });
        var DCPTYPE_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "HTTP": makeObjectPropertySetter(readHTTP)
        });
        var WMSCapabilities_HTTP_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Get": makeObjectPropertySetter(readFormatOnlineresource),
          "Post": makeObjectPropertySetter(readFormatOnlineresource)
        });
        var WMSCapabilities_STYLE_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Name": makeObjectPropertySetter(readString),
          "Title": makeObjectPropertySetter(readString),
          "Abstract": makeObjectPropertySetter(readString),
          "LegendURL": makeObjectPropertyPusher(readSizedFormatOnlineresource),
          "StyleSheetURL": makeObjectPropertySetter(readFormatOnlineresource),
          "StyleURL": makeObjectPropertySetter(readFormatOnlineresource)
        });
        var FORMAT_ONLINERESOURCE_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Format": makeObjectPropertySetter(readString),
          "OnlineResource": makeObjectPropertySetter(readHref)
        });
        var KEYWORDLIST_PARSERS = makeStructureNS(WMSCapabilities_NAMESPACE_URIS, {
          "Keyword": makeArrayPusher(readString)
        });
        function readAttribution(node, objectStack) {
          return pushParseAndPop({}, ATTRIBUTION_PARSERS, node, objectStack);
        }
        function readBoundingBox(node, objectStack) {
          var extent = [
            readDecimalString(node.getAttribute("minx")),
            readDecimalString(node.getAttribute("miny")),
            readDecimalString(node.getAttribute("maxx")),
            readDecimalString(node.getAttribute("maxy"))
          ];
          var resolutions = [
            readDecimalString(node.getAttribute("resx")),
            readDecimalString(node.getAttribute("resy"))
          ];
          return {
            "crs": node.getAttribute("CRS"),
            "extent": extent,
            "res": resolutions
          };
        }
        function readEXGeographicBoundingBox(node, objectStack) {
          var geographicBoundingBox = pushParseAndPop({}, EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS, node, objectStack);
          if (!geographicBoundingBox) {
            return void 0;
          }
          var westBoundLongitude = geographicBoundingBox["westBoundLongitude"];
          var southBoundLatitude = geographicBoundingBox["southBoundLatitude"];
          var eastBoundLongitude = geographicBoundingBox["eastBoundLongitude"];
          var northBoundLatitude = geographicBoundingBox["northBoundLatitude"];
          if (westBoundLongitude === void 0 || southBoundLatitude === void 0 || eastBoundLongitude === void 0 || northBoundLatitude === void 0) {
            return void 0;
          }
          return [
            westBoundLongitude,
            southBoundLatitude,
            eastBoundLongitude,
            northBoundLatitude
          ];
        }
        function readCapability(node, objectStack) {
          return pushParseAndPop({}, CAPABILITY_PARSERS, node, objectStack);
        }
        function readService(node, objectStack) {
          return pushParseAndPop({}, SERVICE_PARSERS, node, objectStack);
        }
        function readContactInformation(node, objectStack) {
          return pushParseAndPop({}, CONTACT_INFORMATION_PARSERS, node, objectStack);
        }
        function readContactPersonPrimary(node, objectStack) {
          return pushParseAndPop({}, CONTACT_PERSON_PARSERS, node, objectStack);
        }
        function readContactAddress(node, objectStack) {
          return pushParseAndPop({}, CONTACT_ADDRESS_PARSERS, node, objectStack);
        }
        function readException(node, objectStack) {
          return pushParseAndPop([], EXCEPTION_PARSERS, node, objectStack);
        }
        function readCapabilityLayer(node, objectStack) {
          var layerObject = pushParseAndPop({}, LAYER_PARSERS, node, objectStack);
          if (layerObject["Layer"] === void 0) {
            return Object.assign(layerObject, readLayer(node, objectStack));
          }
          return layerObject;
        }
        function readLayer(node, objectStack) {
          var parentLayerObject = objectStack[objectStack.length - 1];
          var layerObject = pushParseAndPop({}, LAYER_PARSERS, node, objectStack);
          if (!layerObject) {
            return void 0;
          }
          var queryable = readBooleanString(node.getAttribute("queryable"));
          if (queryable === void 0) {
            queryable = parentLayerObject["queryable"];
          }
          layerObject["queryable"] = queryable !== void 0 ? queryable : false;
          var cascaded = readNonNegativeIntegerString(node.getAttribute("cascaded"));
          if (cascaded === void 0) {
            cascaded = parentLayerObject["cascaded"];
          }
          layerObject["cascaded"] = cascaded;
          var opaque = readBooleanString(node.getAttribute("opaque"));
          if (opaque === void 0) {
            opaque = parentLayerObject["opaque"];
          }
          layerObject["opaque"] = opaque !== void 0 ? opaque : false;
          var noSubsets = readBooleanString(node.getAttribute("noSubsets"));
          if (noSubsets === void 0) {
            noSubsets = parentLayerObject["noSubsets"];
          }
          layerObject["noSubsets"] = noSubsets !== void 0 ? noSubsets : false;
          var fixedWidth = readDecimalString(node.getAttribute("fixedWidth"));
          if (!fixedWidth) {
            fixedWidth = parentLayerObject["fixedWidth"];
          }
          layerObject["fixedWidth"] = fixedWidth;
          var fixedHeight = readDecimalString(node.getAttribute("fixedHeight"));
          if (!fixedHeight) {
            fixedHeight = parentLayerObject["fixedHeight"];
          }
          layerObject["fixedHeight"] = fixedHeight;
          var addKeys = ["Style", "CRS", "AuthorityURL"];
          addKeys.forEach(function(key) {
            if (key in parentLayerObject) {
              var childValue = layerObject[key] || [];
              layerObject[key] = childValue.concat(parentLayerObject[key]);
            }
          });
          var replaceKeys = [
            "EX_GeographicBoundingBox",
            "BoundingBox",
            "Dimension",
            "Attribution",
            "MinScaleDenominator",
            "MaxScaleDenominator"
          ];
          replaceKeys.forEach(function(key) {
            if (!(key in layerObject)) {
              var parentValue = parentLayerObject[key];
              layerObject[key] = parentValue;
            }
          });
          return layerObject;
        }
        function readDimension(node, objectStack) {
          var dimensionObject = {
            "name": node.getAttribute("name"),
            "units": node.getAttribute("units"),
            "unitSymbol": node.getAttribute("unitSymbol"),
            "default": node.getAttribute("default"),
            "multipleValues": readBooleanString(node.getAttribute("multipleValues")),
            "nearestValue": readBooleanString(node.getAttribute("nearestValue")),
            "current": readBooleanString(node.getAttribute("current")),
            "values": readString(node)
          };
          return dimensionObject;
        }
        function readFormatOnlineresource(node, objectStack) {
          return pushParseAndPop({}, FORMAT_ONLINERESOURCE_PARSERS, node, objectStack);
        }
        function readRequest(node, objectStack) {
          return pushParseAndPop({}, REQUEST_PARSERS, node, objectStack);
        }
        function readDCPType(node, objectStack) {
          return pushParseAndPop({}, DCPTYPE_PARSERS, node, objectStack);
        }
        function readHTTP(node, objectStack) {
          return pushParseAndPop({}, WMSCapabilities_HTTP_PARSERS, node, objectStack);
        }
        function readOperationType(node, objectStack) {
          return pushParseAndPop({}, OPERATIONTYPE_PARSERS, node, objectStack);
        }
        function readSizedFormatOnlineresource(node, objectStack) {
          var formatOnlineresource = readFormatOnlineresource(node, objectStack);
          if (formatOnlineresource) {
            var size = [
              readNonNegativeIntegerString(node.getAttribute("width")),
              readNonNegativeIntegerString(node.getAttribute("height"))
            ];
            formatOnlineresource["size"] = size;
            return formatOnlineresource;
          }
          return void 0;
        }
        function readAuthorityURL(node, objectStack) {
          var authorityObject = readFormatOnlineresource(node, objectStack);
          if (authorityObject) {
            authorityObject["name"] = node.getAttribute("name");
            return authorityObject;
          }
          return void 0;
        }
        function readMetadataURL(node, objectStack) {
          var metadataObject = readFormatOnlineresource(node, objectStack);
          if (metadataObject) {
            metadataObject["type"] = node.getAttribute("type");
            return metadataObject;
          }
          return void 0;
        }
        function WMSCapabilities_readStyle(node, objectStack) {
          return pushParseAndPop({}, WMSCapabilities_STYLE_PARSERS, node, objectStack);
        }
        function readKeywordList(node, objectStack) {
          return pushParseAndPop([], KEYWORDLIST_PARSERS, node, objectStack);
        }
        var format_WMSCapabilities = WMSCapabilities_WMSCapabilities;
        var WMSGetFeatureInfo_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var featureIdentifier = "_feature";
        var layerIdentifier = "_layer";
        var WMSGetFeatureInfo_WMSGetFeatureInfo = function(_super) {
          WMSGetFeatureInfo_extends(WMSGetFeatureInfo, _super);
          function WMSGetFeatureInfo(opt_options) {
            var _this = _super.call(this) || this;
            var options = opt_options ? opt_options : {};
            _this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver";
            _this.gmlFormat_ = new format_GML2();
            _this.layers_ = options.layers ? options.layers : null;
            return _this;
          }
          WMSGetFeatureInfo.prototype.getLayers = function() {
            return this.layers_;
          };
          WMSGetFeatureInfo.prototype.setLayers = function(layers) {
            this.layers_ = layers;
          };
          WMSGetFeatureInfo.prototype.readFeatures_ = function(node, objectStack) {
            node.setAttribute("namespaceURI", this.featureNS_);
            var localName = node.localName;
            var features = [];
            if (node.childNodes.length === 0) {
              return features;
            }
            if (localName == "msGMLOutput") {
              for (var i = 0, ii = node.childNodes.length; i < ii; i++) {
                var layer = node.childNodes[i];
                if (layer.nodeType !== Node.ELEMENT_NODE) {
                  continue;
                }
                var layerElement = layer;
                var context = objectStack[0];
                var toRemove = layerIdentifier;
                var layerName = layerElement.localName.replace(toRemove, "");
                if (this.layers_ && !Object(ol_array["f"])(this.layers_, layerName)) {
                  continue;
                }
                var featureType = layerName + featureIdentifier;
                context["featureType"] = featureType;
                context["featureNS"] = this.featureNS_;
                var parsers = {};
                parsers[featureType] = makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
                var parsersNS = makeStructureNS([context["featureNS"], null], parsers);
                layerElement.setAttribute("namespaceURI", this.featureNS_);
                var layerFeatures = pushParseAndPop([], parsersNS, layerElement, objectStack, this.gmlFormat_);
                if (layerFeatures) {
                  Object(ol_array["c"])(features, layerFeatures);
                }
              }
            }
            if (localName == "FeatureCollection") {
              var gmlFeatures = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, [{}], this.gmlFormat_);
              if (gmlFeatures) {
                features = gmlFeatures;
              }
            }
            return features;
          };
          WMSGetFeatureInfo.prototype.readFeaturesFromNode = function(node, opt_options) {
            var options = {};
            if (opt_options) {
              Object(ol_obj["a"])(options, this.getReadOptions(node, opt_options));
            }
            return this.readFeatures_(node, [options]);
          };
          return WMSGetFeatureInfo;
        }(format_XMLFeature);
        var format_WMSGetFeatureInfo = WMSGetFeatureInfo_WMSGetFeatureInfo;
        var WMTSCapabilities_extends = function() {
          var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p in b2)
                if (Object.prototype.hasOwnProperty.call(b2, p))
                  d2[p] = b2[p];
            };
            return extendStatics(d, b);
          };
          return function(d, b) {
            if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
        }();
        var WMTSCapabilities_NAMESPACE_URIS = [null, "http://www.opengis.net/wmts/1.0"];
        var WMTSCapabilities_OWS_NAMESPACE_URIS = [null, "http://www.opengis.net/ows/1.1"];
        var WMTSCapabilities_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
          "Contents": makeObjectPropertySetter(readContents)
        });
        var WMTSCapabilities_WMTSCapabilities = function(_super) {
          WMTSCapabilities_extends(WMTSCapabilities, _super);
          function WMTSCapabilities() {
            var _this = _super.call(this) || this;
            _this.owsParser_ = new format_OWS();
            return _this;
          }
          WMTSCapabilities.prototype.readFromNode = function(node) {
            var version = node.getAttribute("version");
            if (version) {
              version = version.trim();
            }
            var WMTSCapabilityObject = this.owsParser_.readFromNode(node);
            if (!WMTSCapabilityObject) {
              return null;
            }
            WMTSCapabilityObject["version"] = version;
            WMTSCapabilityObject = pushParseAndPop(WMTSCapabilityObject, WMTSCapabilities_PARSERS, node, []);
            return WMTSCapabilityObject ? WMTSCapabilityObject : null;
          };
          return WMTSCapabilities;
        }(format_XML);
        var CONTENTS_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
          "Layer": makeObjectPropertyPusher(WMTSCapabilities_readLayer),
          "TileMatrixSet": makeObjectPropertyPusher(readTileMatrixSet)
        });
        var WMTSCapabilities_LAYER_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
          "Style": makeObjectPropertyPusher(WMTSCapabilities_readStyle),
          "Format": makeObjectPropertyPusher(readString),
          "TileMatrixSetLink": makeObjectPropertyPusher(readTileMatrixSetLink),
          "Dimension": makeObjectPropertyPusher(readDimensions),
          "ResourceURL": makeObjectPropertyPusher(readResourceUrl)
        }, makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
          "Title": makeObjectPropertySetter(readString),
          "Abstract": makeObjectPropertySetter(readString),
          "WGS84BoundingBox": makeObjectPropertySetter(WMTSCapabilities_readBoundingBox),
          "Identifier": makeObjectPropertySetter(readString)
        }));
        var WMTSCapabilities_STYLE_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
          "LegendURL": makeObjectPropertyPusher(readLegendUrl)
        }, makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
          "Title": makeObjectPropertySetter(readString),
          "Identifier": makeObjectPropertySetter(readString)
        }));
        var TMS_LINKS_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
          "TileMatrixSet": makeObjectPropertySetter(readString),
          "TileMatrixSetLimits": makeObjectPropertySetter(readTileMatrixLimitsList)
        });
        var TMS_LIMITS_LIST_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
          "TileMatrixLimits": makeArrayPusher(readTileMatrixLimits)
        });
        var TMS_LIMITS_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
          "TileMatrix": makeObjectPropertySetter(readString),
          "MinTileRow": makeObjectPropertySetter(readPositiveInteger),
          "MaxTileRow": makeObjectPropertySetter(readPositiveInteger),
          "MinTileCol": makeObjectPropertySetter(readPositiveInteger),
          "MaxTileCol": makeObjectPropertySetter(readPositiveInteger)
        });
        var DIMENSION_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
          "Default": makeObjectPropertySetter(readString),
          "Value": makeObjectPropertyPusher(readString)
        }, makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
          "Identifier": makeObjectPropertySetter(readString)
        }));
        var WGS84_BBOX_READERS = makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
          "LowerCorner": makeArrayPusher(readCoordinates),
          "UpperCorner": makeArrayPusher(readCoordinates)
        });
        var TMS_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
          "WellKnownScaleSet": makeObjectPropertySetter(readString),
          "TileMatrix": makeObjectPropertyPusher(readTileMatrix)
        }, makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
          "SupportedCRS": makeObjectPropertySetter(readString),
          "Identifier": makeObjectPropertySetter(readString),
          "BoundingBox": makeObjectPropertySetter(WMTSCapabilities_readBoundingBox)
        }));
        var TM_PARSERS = makeStructureNS(WMTSCapabilities_NAMESPACE_URIS, {
          "TopLeftCorner": makeObjectPropertySetter(readCoordinates),
          "ScaleDenominator": makeObjectPropertySetter(readDecimal),
          "TileWidth": makeObjectPropertySetter(readPositiveInteger),
          "TileHeight": makeObjectPropertySetter(readPositiveInteger),
          "MatrixWidth": makeObjectPropertySetter(readPositiveInteger),
          "MatrixHeight": makeObjectPropertySetter(readPositiveInteger)
        }, makeStructureNS(WMTSCapabilities_OWS_NAMESPACE_URIS, {
          "Identifier": makeObjectPropertySetter(readString)
        }));
        function readContents(node, objectStack) {
          return pushParseAndPop({}, CONTENTS_PARSERS, node, objectStack);
        }
        function WMTSCapabilities_readLayer(node, objectStack) {
          return pushParseAndPop({}, WMTSCapabilities_LAYER_PARSERS, node, objectStack);
        }
        function readTileMatrixSet(node, objectStack) {
          return pushParseAndPop({}, TMS_PARSERS, node, objectStack);
        }
        function WMTSCapabilities_readStyle(node, objectStack) {
          var style = pushParseAndPop({}, WMTSCapabilities_STYLE_PARSERS, node, objectStack);
          if (!style) {
            return void 0;
          }
          var isDefault = node.getAttribute("isDefault") === "true";
          style["isDefault"] = isDefault;
          return style;
        }
        function readTileMatrixSetLink(node, objectStack) {
          return pushParseAndPop({}, TMS_LINKS_PARSERS, node, objectStack);
        }
        function readDimensions(node, objectStack) {
          return pushParseAndPop({}, DIMENSION_PARSERS, node, objectStack);
        }
        function readResourceUrl(node, objectStack) {
          var format = node.getAttribute("format");
          var template = node.getAttribute("template");
          var resourceType = node.getAttribute("resourceType");
          var resource = {};
          if (format) {
            resource["format"] = format;
          }
          if (template) {
            resource["template"] = template;
          }
          if (resourceType) {
            resource["resourceType"] = resourceType;
          }
          return resource;
        }
        function WMTSCapabilities_readBoundingBox(node, objectStack) {
          var coordinates = pushParseAndPop([], WGS84_BBOX_READERS, node, objectStack);
          if (coordinates.length != 2) {
            return void 0;
          }
          return boundingExtent(coordinates);
        }
        function readLegendUrl(node, objectStack) {
          var legend = {};
          legend["format"] = node.getAttribute("format");
          legend["href"] = readHref(node);
          return legend;
        }
        function readCoordinates(node, objectStack) {
          var coordinates = readString(node).split(/\s+/);
          if (!coordinates || coordinates.length != 2) {
            return void 0;
          }
          var x = +coordinates[0];
          var y = +coordinates[1];
          if (isNaN(x) || isNaN(y)) {
            return void 0;
          }
          return [x, y];
        }
        function readTileMatrix(node, objectStack) {
          return pushParseAndPop({}, TM_PARSERS, node, objectStack);
        }
        function readTileMatrixLimitsList(node, objectStack) {
          return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node, objectStack);
        }
        function readTileMatrixLimits(node, objectStack) {
          return pushParseAndPop({}, TMS_LIMITS_PARSERS, node, objectStack);
        }
        var format_WMTSCapabilities = WMTSCapabilities_WMTSCapabilities;
        function src_install(app) {
          if (src_install.installed) {
            console.error("OPENLAYERS MAP ALREADY INSTALLED");
            return;
          }
          src_install.installed = true;
          app.use(map_namespaceObject);
          app.use(layers_namespaceObject);
          app.use(sources_namespaceObject);
          app.use(mapControls_namespaceObject);
          app.use(geometries_namespaceObject);
          app.use(styles_namespaceObject);
          app.use(components_interaction_namespaceObject);
          app.use(animations_namespaceObject);
          app.provide("ol-feature", ol_Feature);
          app.provide("ol-geom", geom_namespaceObject);
          app.provide("ol-animations", easing_namespaceObject);
          app.provide("ol-format", format_namespaceObject);
          app.provide("ol-loadingstrategy", loadingstrategy_namespaceObject);
          app.provide("ol-selectconditions", condition_namespaceObject);
          app.provide("ol-extent", extent_namespaceObject);
        }
        var entry_lib = __webpack_exports__["default"] = src_install;
      },
      "fb6a": function(module2, exports2, __webpack_require__) {
        "use strict";
        var $ = __webpack_require__("23e7");
        var global = __webpack_require__("da84");
        var isArray2 = __webpack_require__("e8b5");
        var isConstructor = __webpack_require__("68ee");
        var isObject2 = __webpack_require__("861d");
        var toAbsoluteIndex = __webpack_require__("23cb");
        var lengthOfArrayLike = __webpack_require__("07fa");
        var toIndexedObject = __webpack_require__("fc6a");
        var createProperty = __webpack_require__("8418");
        var wellKnownSymbol = __webpack_require__("b622");
        var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
        var un$Slice = __webpack_require__("f36a");
        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
        var SPECIES = wellKnownSymbol("species");
        var Array2 = global.Array;
        var max = Math.max;
        $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
          slice: function slice(start, end) {
            var O = toIndexedObject(this);
            var length = lengthOfArrayLike(O);
            var k = toAbsoluteIndex(start, length);
            var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
            var Constructor, result, n;
            if (isArray2(O)) {
              Constructor = O.constructor;
              if (isConstructor(Constructor) && (Constructor === Array2 || isArray2(Constructor.prototype))) {
                Constructor = void 0;
              } else if (isObject2(Constructor)) {
                Constructor = Constructor[SPECIES];
                if (Constructor === null)
                  Constructor = void 0;
              }
              if (Constructor === Array2 || Constructor === void 0) {
                return un$Slice(O, k, fin);
              }
            }
            result = new (Constructor === void 0 ? Array2 : Constructor)(max(fin - k, 0));
            for (n = 0; k < fin; k++, n++)
              if (k in O)
                createProperty(result, n, O[k]);
            result.length = n;
            return result;
          }
        });
      },
      "fc6a": function(module2, exports2, __webpack_require__) {
        var IndexedObject = __webpack_require__("44ad");
        var requireObjectCoercible = __webpack_require__("1d80");
        module2.exports = function(it) {
          return IndexedObject(requireObjectCoercible(it));
        };
      },
      "fce3": function(module2, exports2, __webpack_require__) {
        var fails = __webpack_require__("d039");
        var global = __webpack_require__("da84");
        var $RegExp = global.RegExp;
        module2.exports = fails(function() {
          var re = $RegExp(".", "s");
          return !(re.dotAll && re.exec("\n") && re.flags === "s");
        });
      },
      "fdbc": function(module2, exports2) {
        module2.exports = {
          CSSRuleList: 0,
          CSSStyleDeclaration: 0,
          CSSValueList: 0,
          ClientRectList: 0,
          DOMRectList: 0,
          DOMStringList: 0,
          DOMTokenList: 1,
          DataTransferItemList: 0,
          FileList: 0,
          HTMLAllCollection: 0,
          HTMLCollection: 0,
          HTMLFormElement: 0,
          HTMLSelectElement: 0,
          MediaList: 0,
          MimeTypeArray: 0,
          NamedNodeMap: 0,
          NodeList: 1,
          PaintRequestList: 0,
          Plugin: 0,
          PluginArray: 0,
          SVGLengthList: 0,
          SVGNumberList: 0,
          SVGPathSegList: 0,
          SVGPointList: 0,
          SVGStringList: 0,
          SVGTransformList: 0,
          SourceBufferList: 0,
          StyleSheetList: 0,
          TextTrackCueList: 0,
          TextTrackList: 0,
          TouchList: 0
        };
      },
      "fdbf": function(module2, exports2, __webpack_require__) {
        var NATIVE_SYMBOL = __webpack_require__("4930");
        module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
      }
    });
  }
});

// dep:vue3-openlayers
var vue3_openlayers_default = require_vue3_openlayers_common();
export {
  vue3_openlayers_default as default
};
/*!
  * ol-contextmenu - v4.1.0
  * https://github.com/jonataswalker/ol-contextmenu
  * Built: Sat Aug 15 2020 10:43:26 GMT-0300 (Brasilia Standard Time)
  */
/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <http://feross.org>
* @license  MIT
*/
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.0 Built on 2021-12-21T09:44:51.866Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
//# sourceMappingURL=vue3-openlayers.js.map
