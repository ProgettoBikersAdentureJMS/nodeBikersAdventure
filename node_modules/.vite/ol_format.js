import {
  Fill_default,
  FormatType_default,
  GeometryLayout_default,
  Geometry_default,
  IconAnchorUnits_default,
  IconOrigin_default,
  Icon_default,
  ImageState_default,
  LineString_default,
  LinearRing_default,
  MultiLineString_default,
  MultiPoint_default,
  MultiPolygon_default,
  Point_default,
  Polygon_default,
  SimpleGeometry_default,
  Stroke_default,
  Style_default,
  Text_default,
  asArray,
  compose,
  create,
  deflateCoordinates,
  getInteriorPointOfArray,
  getInteriorPointsOfMultiArray,
  getStrideForLayout,
  inflateCoordinates,
  interpolatePoint,
  linearRingIsClockwise,
  linearRingss,
  transform2D
} from "./chunk-226OU5IW.js";
import {
  GeometryType_default,
  Projection_default,
  Units_default,
  boundingExtent,
  closestSquaredDistanceXY,
  containsExtent,
  createOrUpdate,
  createOrUpdateEmpty,
  createOrUpdateFromCoordinate,
  createOrUpdateFromFlatCoordinates,
  equivalent,
  extend as extend2,
  get,
  getCenter,
  getHeight,
  padNumber,
  toRadians,
  transformExtent
} from "./chunk-JM4NXXBV.js";
import {
  EventType_default,
  Feature_default,
  extend,
  includes,
  listen,
  unlistenByKey
} from "./chunk-2LXOYDUW.js";
import {
  abstract,
  assert,
  assign,
  isEmpty
} from "./chunk-FHOVFLD4.js";
import {
  __commonJS,
  __toModule
} from "./chunk-ESTXZSVW.js";

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/pbf/index.js
var require_pbf = __commonJS({
  "node_modules/pbf/index.js"(exports, module) {
    "use strict";
    module.exports = Pbf;
    var ieee754 = require_ieee754();
    function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf.Varint = 0;
    Pbf.Fixed64 = 1;
    Pbf.Bytes = 2;
    Pbf.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var TEXT_DECODER_MIN_LENGTH = 12;
    var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
    Pbf.prototype = {
      destroy: function() {
        this.buf = null;
      },
      readFields: function(readField, result, end) {
        end = end || this.length;
        while (this.pos < end) {
          var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
          this.type = val & 7;
          readField(tag, result, this);
          if (this.pos === startPos)
            this.skip(val);
        }
        return result;
      },
      readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
      },
      readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
      },
      readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
      },
      readVarint: function(isSigned) {
        var buf = this.buf, val, b;
        b = buf[this.pos++];
        val = b & 127;
        if (b < 128)
          return val;
        b = buf[this.pos++];
        val |= (b & 127) << 7;
        if (b < 128)
          return val;
        b = buf[this.pos++];
        val |= (b & 127) << 14;
        if (b < 128)
          return val;
        b = buf[this.pos++];
        val |= (b & 127) << 21;
        if (b < 128)
          return val;
        b = buf[this.pos];
        val |= (b & 15) << 28;
        return readVarintRemainder(val, isSigned, this);
      },
      readVarint64: function() {
        return this.readVarint(true);
      },
      readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      },
      readBoolean: function() {
        return Boolean(this.readVarint());
      },
      readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
          return readUtf8TextDecoder(this.buf, pos, end);
        }
        return readUtf8(this.buf, pos, end);
      },
      readBytes: function() {
        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
      },
      readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readVarint(isSigned));
        return arr;
      },
      readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSVarint());
        return arr;
      },
      readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readBoolean());
        return arr;
      },
      readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFloat());
        return arr;
      },
      readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readDouble());
        return arr;
      },
      readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed32());
        return arr;
      },
      readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed32());
        return arr;
      },
      readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed64());
        return arr;
      },
      readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed64());
        return arr;
      },
      skip: function(val) {
        var type = val & 7;
        if (type === Pbf.Varint)
          while (this.buf[this.pos++] > 127) {
          }
        else if (type === Pbf.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32)
          this.pos += 4;
        else if (type === Pbf.Fixed64)
          this.pos += 8;
        else
          throw new Error("Unimplemented type: " + type);
      },
      writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
      },
      realloc: function(min) {
        var length = this.length || 16;
        while (length < this.pos + min)
          length *= 2;
        if (length !== this.length) {
          var buf = new Uint8Array(length);
          buf.set(this.buf);
          this.buf = buf;
          this.length = length;
        }
      },
      finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
      },
      writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeVarint: function(val) {
        val = +val || 0;
        if (val > 268435455 || val < 0) {
          writeBigVarint(val, this);
          return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
        if (val <= 127)
          return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127)
          return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127)
          return;
        this.buf[this.pos++] = val >>> 7 & 127;
      },
      writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
      },
      writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
      },
      writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);
        this.pos++;
        var startPos = this.pos;
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
      },
      writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
      },
      writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++)
          this.buf[this.pos++] = buffer[i];
      },
      writeRawMessage: function(fn, obj) {
        this.pos++;
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
      },
      writePackedVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedVarint, arr);
      },
      writePackedSVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSVarint, arr);
      },
      writePackedBoolean: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedBoolean, arr);
      },
      writePackedFloat: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFloat, arr);
      },
      writePackedDouble: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedDouble, arr);
      },
      writePackedFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed32, arr);
      },
      writePackedSFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed32, arr);
      },
      writePackedFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed64, arr);
      },
      writePackedSFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed64, arr);
      },
      writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
      },
      writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
      },
      writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
      },
      writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
      },
      writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
      },
      writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
      },
      writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
      },
      writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
      },
      writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
      },
      writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
      },
      writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
      }
    };
    function readVarintRemainder(l, s, p) {
      var buf = p.buf, h, b;
      b = buf[p.pos++];
      h = (b & 112) >> 4;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 3;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 10;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 17;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 24;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 1) << 31;
      if (b < 128)
        return toNum(l, h, s);
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val, pbf) {
      var low, high;
      if (val >= 0) {
        low = val % 4294967296 | 0;
        high = val / 4294967296 | 0;
      } else {
        low = ~(-val % 4294967296);
        high = ~(-val / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len, pbf) {
      var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i = pbf.pos - 1; i >= startPos; i--)
        pbf.buf[i + extraLen] = pbf.buf[i];
    }
    function writePackedVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeVarint(arr[i]);
    }
    function writePackedSVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeSVarint(arr[i]);
    }
    function writePackedFloat(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeFloat(arr[i]);
    }
    function writePackedDouble(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeDouble(arr[i]);
    }
    function writePackedBoolean(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeBoolean(arr[i]);
    }
    function writePackedFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeFixed32(arr[i]);
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeSFixed32(arr[i]);
    }
    function writePackedFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeFixed64(arr[i]);
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeSFixed64(arr[i]);
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val, pos) {
      buf[pos] = val;
      buf[pos + 1] = val >>> 8;
      buf[pos + 2] = val >>> 16;
      buf[pos + 3] = val >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str = "";
      var i = pos;
      while (i < end) {
        var b0 = buf[i];
        var c = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i + bytesPerSequence > end)
          break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c = b0;
          }
        } else if (bytesPerSequence === 2) {
          b1 = buf[i + 1];
          if ((b1 & 192) === 128) {
            c = (b0 & 31) << 6 | b1 & 63;
            if (c <= 127) {
              c = null;
            }
          }
        } else if (bytesPerSequence === 3) {
          b1 = buf[i + 1];
          b2 = buf[i + 2];
          if ((b1 & 192) === 128 && (b2 & 192) === 128) {
            c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
            if (c <= 2047 || c >= 55296 && c <= 57343) {
              c = null;
            }
          }
        } else if (bytesPerSequence === 4) {
          b1 = buf[i + 1];
          b2 = buf[i + 2];
          b3 = buf[i + 3];
          if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
            c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
            if (c <= 65535 || c >= 1114112) {
              c = null;
            }
          }
        }
        if (c === null) {
          c = 65533;
          bytesPerSequence = 1;
        } else if (c > 65535) {
          c -= 65536;
          str += String.fromCharCode(c >>> 10 & 1023 | 55296);
          c = 56320 | c & 1023;
        }
        str += String.fromCharCode(c);
        i += bytesPerSequence;
      }
      return str;
    }
    function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
    }
    function writeUtf8(buf, str, pos) {
      for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i);
        if (c > 55295 && c < 57344) {
          if (lead) {
            if (c < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c;
              continue;
            } else {
              c = lead - 55296 << 10 | c - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c > 56319 || i + 1 === str.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c;
            }
            continue;
          }
        } else if (lead) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = null;
        }
        if (c < 128) {
          buf[pos++] = c;
        } else {
          if (c < 2048) {
            buf[pos++] = c >> 6 | 192;
          } else {
            if (c < 65536) {
              buf[pos++] = c >> 12 | 224;
            } else {
              buf[pos++] = c >> 18 | 240;
              buf[pos++] = c >> 12 & 63 | 128;
            }
            buf[pos++] = c >> 6 & 63 | 128;
          }
          buf[pos++] = c & 63 | 128;
        }
      }
      return pos;
    }
  }
});

// node_modules/ol/format/Feature.js
var FeatureFormat = function() {
  function FeatureFormat2() {
    this.dataProjection = void 0;
    this.defaultFeatureProjection = void 0;
    this.supportedMediaTypes = null;
  }
  FeatureFormat2.prototype.getReadOptions = function(source, opt_options) {
    var options;
    if (opt_options) {
      var dataProjection = opt_options.dataProjection ? get(opt_options.dataProjection) : this.readProjection(source);
      if (opt_options.extent && dataProjection && dataProjection.getUnits() === Units_default.TILE_PIXELS) {
        dataProjection = get(dataProjection);
        dataProjection.setWorldExtent(opt_options.extent);
      }
      options = {
        dataProjection,
        featureProjection: opt_options.featureProjection
      };
    }
    return this.adaptOptions(options);
  };
  FeatureFormat2.prototype.adaptOptions = function(options) {
    return assign({
      dataProjection: this.dataProjection,
      featureProjection: this.defaultFeatureProjection
    }, options);
  };
  FeatureFormat2.prototype.getType = function() {
    return abstract();
  };
  FeatureFormat2.prototype.readFeature = function(source, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.readFeatures = function(source, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.readGeometry = function(source, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.readProjection = function(source) {
    return abstract();
  };
  FeatureFormat2.prototype.writeFeature = function(feature, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.writeFeatures = function(features, opt_options) {
    return abstract();
  };
  FeatureFormat2.prototype.writeGeometry = function(geometry, opt_options) {
    return abstract();
  };
  return FeatureFormat2;
}();
var Feature_default2 = FeatureFormat;
function transformGeometryWithOptions(geometry, write, opt_options) {
  var featureProjection = opt_options ? get(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? get(opt_options.dataProjection) : null;
  var transformed;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
  } else {
    transformed = geometry;
  }
  if (write && opt_options && opt_options.decimals !== void 0) {
    var power_1 = Math.pow(10, opt_options.decimals);
    var transform = function(coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;
      }
      return coordinates;
    };
    if (transformed === geometry) {
      transformed = geometry.clone();
    }
    transformed.applyTransform(transform);
  }
  return transformed;
}
function transformExtentWithOptions(extent, opt_options) {
  var featureProjection = opt_options ? get(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? get(opt_options.dataProjection) : null;
  if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
    return transformExtent(extent, dataProjection, featureProjection);
  } else {
    return extent;
  }
}

// node_modules/ol/format/JSONFeature.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var JSONFeature = function(_super) {
  __extends(JSONFeature2, _super);
  function JSONFeature2() {
    return _super.call(this) || this;
  }
  JSONFeature2.prototype.getType = function() {
    return FormatType_default.JSON;
  };
  JSONFeature2.prototype.readFeature = function(source, opt_options) {
    return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readFeatures = function(source, opt_options) {
    return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readFeatureFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readFeaturesFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readGeometry = function(source, opt_options) {
    return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
  };
  JSONFeature2.prototype.readGeometryFromObject = function(object, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.readProjection = function(source) {
    return this.readProjectionFromObject(getObject(source));
  };
  JSONFeature2.prototype.readProjectionFromObject = function(object) {
    return abstract();
  };
  JSONFeature2.prototype.writeFeature = function(feature, opt_options) {
    return JSON.stringify(this.writeFeatureObject(feature, opt_options));
  };
  JSONFeature2.prototype.writeFeatureObject = function(feature, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.writeFeatures = function(features, opt_options) {
    return JSON.stringify(this.writeFeaturesObject(features, opt_options));
  };
  JSONFeature2.prototype.writeFeaturesObject = function(features, opt_options) {
    return abstract();
  };
  JSONFeature2.prototype.writeGeometry = function(geometry, opt_options) {
    return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
  };
  JSONFeature2.prototype.writeGeometryObject = function(geometry, opt_options) {
    return abstract();
  };
  return JSONFeature2;
}(Feature_default2);
function getObject(source) {
  if (typeof source === "string") {
    var object = JSON.parse(source);
    return object ? object : null;
  } else if (source !== null) {
    return source;
  } else {
    return null;
  }
}
var JSONFeature_default = JSONFeature;

// node_modules/ol/format/EsriJSON.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GEOMETRY_READERS = {};
GEOMETRY_READERS[GeometryType_default.POINT] = readPointGeometry;
GEOMETRY_READERS[GeometryType_default.LINE_STRING] = readLineStringGeometry;
GEOMETRY_READERS[GeometryType_default.POLYGON] = readPolygonGeometry;
GEOMETRY_READERS[GeometryType_default.MULTI_POINT] = readMultiPointGeometry;
GEOMETRY_READERS[GeometryType_default.MULTI_LINE_STRING] = readMultiLineStringGeometry;
GEOMETRY_READERS[GeometryType_default.MULTI_POLYGON] = readMultiPolygonGeometry;
var GEOMETRY_WRITERS = {};
GEOMETRY_WRITERS[GeometryType_default.POINT] = writePointGeometry;
GEOMETRY_WRITERS[GeometryType_default.LINE_STRING] = writeLineStringGeometry;
GEOMETRY_WRITERS[GeometryType_default.POLYGON] = writePolygonGeometry;
GEOMETRY_WRITERS[GeometryType_default.MULTI_POINT] = writeMultiPointGeometry;
GEOMETRY_WRITERS[GeometryType_default.MULTI_LINE_STRING] = writeMultiLineStringGeometry;
GEOMETRY_WRITERS[GeometryType_default.MULTI_POLYGON] = writeMultiPolygonGeometry;
var EsriJSON = function(_super) {
  __extends2(EsriJSON2, _super);
  function EsriJSON2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this) || this;
    _this.geometryName_ = options.geometryName;
    return _this;
  }
  EsriJSON2.prototype.readFeatureFromObject = function(object, opt_options, opt_idField) {
    var esriJSONFeature = object;
    var geometry = readGeometry(esriJSONFeature.geometry, opt_options);
    var feature = new Feature_default();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    }
    feature.setGeometry(geometry);
    if (esriJSONFeature.attributes) {
      feature.setProperties(esriJSONFeature.attributes, true);
      var id = esriJSONFeature.attributes[opt_idField];
      if (id !== void 0) {
        feature.setId(id);
      }
    }
    return feature;
  };
  EsriJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {
    var options = opt_options ? opt_options : {};
    if (object["features"]) {
      var esriJSONFeatureSet = object;
      var features = [];
      var esriJSONFeatures = esriJSONFeatureSet.features;
      for (var i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(esriJSONFeatures[i], options, object.objectIdFieldName));
      }
      return features;
    } else {
      return [this.readFeatureFromObject(object, options)];
    }
  };
  EsriJSON2.prototype.readGeometryFromObject = function(object, opt_options) {
    return readGeometry(object, opt_options);
  };
  EsriJSON2.prototype.readProjectionFromObject = function(object) {
    if (object["spatialReference"] && object["spatialReference"]["wkid"] !== void 0) {
      var spatialReference = object["spatialReference"];
      var crs = spatialReference.wkid;
      return get("EPSG:" + crs);
    } else {
      return null;
    }
  };
  EsriJSON2.prototype.writeGeometryObject = function(geometry, opt_options) {
    return writeGeometry(geometry, this.adaptOptions(opt_options));
  };
  EsriJSON2.prototype.writeFeatureObject = function(feature, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var object = {};
    if (!feature.hasProperties()) {
      object["attributes"] = {};
      return object;
    }
    var properties = feature.getProperties();
    var geometry = feature.getGeometry();
    if (geometry) {
      object["geometry"] = writeGeometry(geometry, opt_options);
      var projection = opt_options && (opt_options.dataProjection || opt_options.featureProjection);
      if (projection) {
        object["geometry"]["spatialReference"] = {
          wkid: Number(get(projection).getCode().split(":").pop())
        };
      }
      delete properties[feature.getGeometryName()];
    }
    if (!isEmpty(properties)) {
      object["attributes"] = properties;
    } else {
      object["attributes"] = {};
    }
    return object;
  };
  EsriJSON2.prototype.writeFeaturesObject = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var objects = [];
    for (var i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], opt_options));
    }
    return {
      "features": objects
    };
  };
  return EsriJSON2;
}(JSONFeature_default);
function readGeometry(object, opt_options) {
  var _a, _b;
  if (!object) {
    return null;
  }
  var type;
  if (typeof object["x"] === "number" && typeof object["y"] === "number") {
    type = GeometryType_default.POINT;
  } else if (object["points"]) {
    type = GeometryType_default.MULTI_POINT;
  } else if (object["paths"]) {
    var esriJSONPolyline = object;
    if (esriJSONPolyline.paths.length === 1) {
      type = GeometryType_default.LINE_STRING;
    } else {
      type = GeometryType_default.MULTI_LINE_STRING;
    }
  } else if (object["rings"]) {
    var esriJSONPolygon = object;
    var layout = getGeometryLayout(esriJSONPolygon);
    var rings = convertRings(esriJSONPolygon.rings, layout);
    if (rings.length === 1) {
      type = GeometryType_default.POLYGON;
      object = assign({}, object, (_a = {}, _a["rings"] = rings[0], _a));
    } else {
      type = GeometryType_default.MULTI_POLYGON;
      object = assign({}, object, (_b = {}, _b["rings"] = rings, _b));
    }
  }
  var geometryReader = GEOMETRY_READERS[type];
  return transformGeometryWithOptions(geometryReader(object), false, opt_options);
}
function convertRings(rings, layout) {
  var flatRing = [];
  var outerRings = [];
  var holes = [];
  var i, ii;
  for (i = 0, ii = rings.length; i < ii; ++i) {
    flatRing.length = 0;
    deflateCoordinates(flatRing, 0, rings[i], layout.length);
    var clockwise = linearRingIsClockwise(flatRing, 0, flatRing.length, layout.length);
    if (clockwise) {
      outerRings.push([rings[i]]);
    } else {
      holes.push(rings[i]);
    }
  }
  while (holes.length) {
    var hole = holes.shift();
    var matched = false;
    for (i = outerRings.length - 1; i >= 0; i--) {
      var outerRing = outerRings[i][0];
      var containsHole = containsExtent(new LinearRing_default(outerRing).getExtent(), new LinearRing_default(hole).getExtent());
      if (containsHole) {
        outerRings[i].push(hole);
        matched = true;
        break;
      }
    }
    if (!matched) {
      outerRings.push([hole.reverse()]);
    }
  }
  return outerRings;
}
function readPointGeometry(object) {
  var point;
  if (object.m !== void 0 && object.z !== void 0) {
    point = new Point_default([object.x, object.y, object.z, object.m], GeometryLayout_default.XYZM);
  } else if (object.z !== void 0) {
    point = new Point_default([object.x, object.y, object.z], GeometryLayout_default.XYZ);
  } else if (object.m !== void 0) {
    point = new Point_default([object.x, object.y, object.m], GeometryLayout_default.XYM);
  } else {
    point = new Point_default([object.x, object.y]);
  }
  return point;
}
function readLineStringGeometry(object) {
  var layout = getGeometryLayout(object);
  return new LineString_default(object.paths[0], layout);
}
function readMultiLineStringGeometry(object) {
  var layout = getGeometryLayout(object);
  return new MultiLineString_default(object.paths, layout);
}
function getGeometryLayout(object) {
  var layout = GeometryLayout_default.XY;
  if (object.hasZ === true && object.hasM === true) {
    layout = GeometryLayout_default.XYZM;
  } else if (object.hasZ === true) {
    layout = GeometryLayout_default.XYZ;
  } else if (object.hasM === true) {
    layout = GeometryLayout_default.XYM;
  }
  return layout;
}
function readMultiPointGeometry(object) {
  var layout = getGeometryLayout(object);
  return new MultiPoint_default(object.points, layout);
}
function readMultiPolygonGeometry(object) {
  var layout = getGeometryLayout(object);
  return new MultiPolygon_default(object.rings, layout);
}
function readPolygonGeometry(object) {
  var layout = getGeometryLayout(object);
  return new Polygon_default(object.rings, layout);
}
function writePointGeometry(geometry, opt_options) {
  var coordinates = geometry.getCoordinates();
  var esriJSON;
  var layout = geometry.getLayout();
  if (layout === GeometryLayout_default.XYZ) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1],
      z: coordinates[2]
    };
  } else if (layout === GeometryLayout_default.XYM) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1],
      m: coordinates[2]
    };
  } else if (layout === GeometryLayout_default.XYZM) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1],
      z: coordinates[2],
      m: coordinates[3]
    };
  } else if (layout === GeometryLayout_default.XY) {
    esriJSON = {
      x: coordinates[0],
      y: coordinates[1]
    };
  } else {
    assert(false, 34);
  }
  return esriJSON;
}
function getHasZM(geometry) {
  var layout = geometry.getLayout();
  return {
    hasZ: layout === GeometryLayout_default.XYZ || layout === GeometryLayout_default.XYZM,
    hasM: layout === GeometryLayout_default.XYM || layout === GeometryLayout_default.XYZM
  };
}
function writeLineStringGeometry(lineString, opt_options) {
  var hasZM = getHasZM(lineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths: [
      lineString.getCoordinates()
    ]
  };
}
function writePolygonGeometry(polygon, opt_options) {
  var hasZM = getHasZM(polygon);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings: polygon.getCoordinates(false)
  };
}
function writeMultiLineStringGeometry(multiLineString, opt_options) {
  var hasZM = getHasZM(multiLineString);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    paths: multiLineString.getCoordinates()
  };
}
function writeMultiPointGeometry(multiPoint, opt_options) {
  var hasZM = getHasZM(multiPoint);
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    points: multiPoint.getCoordinates()
  };
}
function writeMultiPolygonGeometry(geometry, opt_options) {
  var hasZM = getHasZM(geometry);
  var coordinates = geometry.getCoordinates(false);
  var output = [];
  for (var i = 0; i < coordinates.length; i++) {
    for (var x = coordinates[i].length - 1; x >= 0; x--) {
      output.push(coordinates[i][x]);
    }
  }
  return {
    hasZ: hasZM.hasZ,
    hasM: hasZM.hasM,
    rings: output
  };
}
function writeGeometry(geometry, opt_options) {
  var geometryWriter = GEOMETRY_WRITERS[geometry.getType()];
  return geometryWriter(transformGeometryWithOptions(geometry, true, opt_options), opt_options);
}
var EsriJSON_default = EsriJSON;

// node_modules/ol/geom/GeometryCollection.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GeometryCollection = function(_super) {
  __extends3(GeometryCollection2, _super);
  function GeometryCollection2(opt_geometries) {
    var _this = _super.call(this) || this;
    _this.geometries_ = opt_geometries ? opt_geometries : null;
    _this.changeEventsKeys_ = [];
    _this.listenGeometriesChange_();
    return _this;
  }
  GeometryCollection2.prototype.unlistenGeometriesChange_ = function() {
    this.changeEventsKeys_.forEach(unlistenByKey);
    this.changeEventsKeys_.length = 0;
  };
  GeometryCollection2.prototype.listenGeometriesChange_ = function() {
    if (!this.geometries_) {
      return;
    }
    for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
      this.changeEventsKeys_.push(listen(this.geometries_[i], EventType_default.CHANGE, this.changed, this));
    }
  };
  GeometryCollection2.prototype.clone = function() {
    var geometryCollection = new GeometryCollection2(null);
    geometryCollection.setGeometries(this.geometries_);
    geometryCollection.applyProperties(this);
    return geometryCollection;
  };
  GeometryCollection2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
    }
    return minSquaredDistance;
  };
  GeometryCollection2.prototype.containsXY = function(x, y) {
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].containsXY(x, y)) {
        return true;
      }
    }
    return false;
  };
  GeometryCollection2.prototype.computeExtent = function(extent) {
    createOrUpdateEmpty(extent);
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      extend2(extent, geometries[i].getExtent());
    }
    return extent;
  };
  GeometryCollection2.prototype.getGeometries = function() {
    return cloneGeometries(this.geometries_);
  };
  GeometryCollection2.prototype.getGeometriesArray = function() {
    return this.geometries_;
  };
  GeometryCollection2.prototype.getGeometriesArrayRecursive = function() {
    var geometriesArray = [];
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].getType() === this.getType()) {
        geometriesArray = geometriesArray.concat(geometries[i].getGeometriesArrayRecursive());
      } else {
        geometriesArray.push(geometries[i]);
      }
    }
    return geometriesArray;
  };
  GeometryCollection2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    var simplifiedGeometries = [];
    var geometries = this.geometries_;
    var simplified = false;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      var geometry = geometries[i];
      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);
      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }
    if (simplified) {
      var simplifiedGeometryCollection = new GeometryCollection2(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      return simplifiedGeometryCollection;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  };
  GeometryCollection2.prototype.getType = function() {
    return GeometryType_default.GEOMETRY_COLLECTION;
  };
  GeometryCollection2.prototype.intersectsExtent = function(extent) {
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      if (geometries[i].intersectsExtent(extent)) {
        return true;
      }
    }
    return false;
  };
  GeometryCollection2.prototype.isEmpty = function() {
    return this.geometries_.length === 0;
  };
  GeometryCollection2.prototype.rotate = function(angle, anchor) {
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].rotate(angle, anchor);
    }
    this.changed();
  };
  GeometryCollection2.prototype.scale = function(sx, opt_sy, opt_anchor) {
    var anchor = opt_anchor;
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].scale(sx, opt_sy, anchor);
    }
    this.changed();
  };
  GeometryCollection2.prototype.setGeometries = function(geometries) {
    this.setGeometriesArray(cloneGeometries(geometries));
  };
  GeometryCollection2.prototype.setGeometriesArray = function(geometries) {
    this.unlistenGeometriesChange_();
    this.geometries_ = geometries;
    this.listenGeometriesChange_();
    this.changed();
  };
  GeometryCollection2.prototype.applyTransform = function(transformFn) {
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].applyTransform(transformFn);
    }
    this.changed();
  };
  GeometryCollection2.prototype.translate = function(deltaX, deltaY) {
    var geometries = this.geometries_;
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      geometries[i].translate(deltaX, deltaY);
    }
    this.changed();
  };
  GeometryCollection2.prototype.disposeInternal = function() {
    this.unlistenGeometriesChange_();
    _super.prototype.disposeInternal.call(this);
  };
  return GeometryCollection2;
}(Geometry_default);
function cloneGeometries(geometries) {
  var clonedGeometries = [];
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }
  return clonedGeometries;
}
var GeometryCollection_default = GeometryCollection;

// node_modules/ol/format/GeoJSON.js
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GeoJSON = function(_super) {
  __extends4(GeoJSON2, _super);
  function GeoJSON2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this) || this;
    _this.dataProjection = get(options.dataProjection ? options.dataProjection : "EPSG:4326");
    if (options.featureProjection) {
      _this.defaultFeatureProjection = get(options.featureProjection);
    }
    _this.geometryName_ = options.geometryName;
    _this.extractGeometryName_ = options.extractGeometryName;
    _this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
    return _this;
  }
  GeoJSON2.prototype.readFeatureFromObject = function(object, opt_options) {
    var geoJSONFeature = null;
    if (object["type"] === "Feature") {
      geoJSONFeature = object;
    } else {
      geoJSONFeature = {
        "type": "Feature",
        "geometry": object,
        "properties": null
      };
    }
    var geometry = readGeometry2(geoJSONFeature["geometry"], opt_options);
    var feature = new Feature_default();
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    } else if (this.extractGeometryName_ && "geometry_name" in geoJSONFeature !== void 0) {
      feature.setGeometryName(geoJSONFeature["geometry_name"]);
    }
    feature.setGeometry(geometry);
    if ("id" in geoJSONFeature) {
      feature.setId(geoJSONFeature["id"]);
    }
    if (geoJSONFeature["properties"]) {
      feature.setProperties(geoJSONFeature["properties"], true);
    }
    return feature;
  };
  GeoJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {
    var geoJSONObject = object;
    var features = null;
    if (geoJSONObject["type"] === "FeatureCollection") {
      var geoJSONFeatureCollection = object;
      features = [];
      var geoJSONFeatures = geoJSONFeatureCollection["features"];
      for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
        features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
      }
    } else {
      features = [this.readFeatureFromObject(object, opt_options)];
    }
    return features;
  };
  GeoJSON2.prototype.readGeometryFromObject = function(object, opt_options) {
    return readGeometry2(object, opt_options);
  };
  GeoJSON2.prototype.readProjectionFromObject = function(object) {
    var crs = object["crs"];
    var projection;
    if (crs) {
      if (crs["type"] == "name") {
        projection = get(crs["properties"]["name"]);
      } else if (crs["type"] === "EPSG") {
        projection = get("EPSG:" + crs["properties"]["code"]);
      } else {
        assert(false, 36);
      }
    } else {
      projection = this.dataProjection;
    }
    return projection;
  };
  GeoJSON2.prototype.writeFeatureObject = function(feature, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var object = {
      "type": "Feature",
      geometry: null,
      properties: null
    };
    var id = feature.getId();
    if (id !== void 0) {
      object.id = id;
    }
    if (!feature.hasProperties()) {
      return object;
    }
    var properties = feature.getProperties();
    var geometry = feature.getGeometry();
    if (geometry) {
      object.geometry = writeGeometry2(geometry, opt_options);
      delete properties[feature.getGeometryName()];
    }
    if (!isEmpty(properties)) {
      object.properties = properties;
    }
    return object;
  };
  GeoJSON2.prototype.writeFeaturesObject = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var objects = [];
    for (var i = 0, ii = features.length; i < ii; ++i) {
      objects.push(this.writeFeatureObject(features[i], opt_options));
    }
    return {
      type: "FeatureCollection",
      features: objects
    };
  };
  GeoJSON2.prototype.writeGeometryObject = function(geometry, opt_options) {
    return writeGeometry2(geometry, this.adaptOptions(opt_options));
  };
  return GeoJSON2;
}(JSONFeature_default);
function readGeometry2(object, opt_options) {
  if (!object) {
    return null;
  }
  var geometry;
  switch (object["type"]) {
    case GeometryType_default.POINT: {
      geometry = readPointGeometry2(object);
      break;
    }
    case GeometryType_default.LINE_STRING: {
      geometry = readLineStringGeometry2(object);
      break;
    }
    case GeometryType_default.POLYGON: {
      geometry = readPolygonGeometry2(object);
      break;
    }
    case GeometryType_default.MULTI_POINT: {
      geometry = readMultiPointGeometry2(object);
      break;
    }
    case GeometryType_default.MULTI_LINE_STRING: {
      geometry = readMultiLineStringGeometry2(object);
      break;
    }
    case GeometryType_default.MULTI_POLYGON: {
      geometry = readMultiPolygonGeometry2(object);
      break;
    }
    case GeometryType_default.GEOMETRY_COLLECTION: {
      geometry = readGeometryCollectionGeometry(object);
      break;
    }
    default: {
      throw new Error("Unsupported GeoJSON type: " + object.type);
    }
  }
  return transformGeometryWithOptions(geometry, false, opt_options);
}
function readGeometryCollectionGeometry(object, opt_options) {
  var geometries = object["geometries"].map(function(geometry) {
    return readGeometry2(geometry, opt_options);
  });
  return new GeometryCollection_default(geometries);
}
function readPointGeometry2(object) {
  return new Point_default(object["coordinates"]);
}
function readLineStringGeometry2(object) {
  return new LineString_default(object["coordinates"]);
}
function readMultiLineStringGeometry2(object) {
  return new MultiLineString_default(object["coordinates"]);
}
function readMultiPointGeometry2(object) {
  return new MultiPoint_default(object["coordinates"]);
}
function readMultiPolygonGeometry2(object) {
  return new MultiPolygon_default(object["coordinates"]);
}
function readPolygonGeometry2(object) {
  return new Polygon_default(object["coordinates"]);
}
function writeGeometry2(geometry, opt_options) {
  geometry = transformGeometryWithOptions(geometry, true, opt_options);
  var type = geometry.getType();
  var geoJSON;
  switch (type) {
    case GeometryType_default.POINT: {
      geoJSON = writePointGeometry2(geometry, opt_options);
      break;
    }
    case GeometryType_default.LINE_STRING: {
      geoJSON = writeLineStringGeometry2(geometry, opt_options);
      break;
    }
    case GeometryType_default.POLYGON: {
      geoJSON = writePolygonGeometry2(geometry, opt_options);
      break;
    }
    case GeometryType_default.MULTI_POINT: {
      geoJSON = writeMultiPointGeometry2(geometry, opt_options);
      break;
    }
    case GeometryType_default.MULTI_LINE_STRING: {
      geoJSON = writeMultiLineStringGeometry2(geometry, opt_options);
      break;
    }
    case GeometryType_default.MULTI_POLYGON: {
      geoJSON = writeMultiPolygonGeometry2(geometry, opt_options);
      break;
    }
    case GeometryType_default.GEOMETRY_COLLECTION: {
      geoJSON = writeGeometryCollectionGeometry(geometry, opt_options);
      break;
    }
    case GeometryType_default.CIRCLE: {
      geoJSON = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return geoJSON;
}
function writeGeometryCollectionGeometry(geometry, opt_options) {
  var geometries = geometry.getGeometriesArray().map(function(geometry2) {
    var options = assign({}, opt_options);
    delete options.featureProjection;
    return writeGeometry2(geometry2, options);
  });
  return {
    type: "GeometryCollection",
    geometries
  };
}
function writeLineStringGeometry2(geometry, opt_options) {
  return {
    type: "LineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiLineStringGeometry2(geometry, opt_options) {
  return {
    type: "MultiLineString",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPointGeometry2(geometry, opt_options) {
  return {
    type: "MultiPoint",
    coordinates: geometry.getCoordinates()
  };
}
function writeMultiPolygonGeometry2(geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return {
    type: "MultiPolygon",
    coordinates: geometry.getCoordinates(right)
  };
}
function writePointGeometry2(geometry, opt_options) {
  return {
    type: "Point",
    coordinates: geometry.getCoordinates()
  };
}
function writePolygonGeometry2(geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return {
    type: "Polygon",
    coordinates: geometry.getCoordinates(right)
  };
}
var GeoJSON_default = GeoJSON;

// node_modules/ol/xml.js
var XML_SCHEMA_INSTANCE_URI = "http://www.w3.org/2001/XMLSchema-instance";
function createElementNS(namespaceURI, qualifiedName) {
  return getDocument().createElementNS(namespaceURI, qualifiedName);
}
function getAllTextContent(node, normalizeWhitespace) {
  return getAllTextContent_(node, normalizeWhitespace, []).join("");
}
function getAllTextContent_(node, normalizeWhitespace, accumulator) {
  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
    if (normalizeWhitespace) {
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ""));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    var n = void 0;
    for (n = node.firstChild; n; n = n.nextSibling) {
      getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }
  return accumulator;
}
function isDocument(object) {
  return "documentElement" in object;
}
function getAttributeNS(node, namespaceURI, name) {
  return node.getAttributeNS(namespaceURI, name) || "";
}
function parse(xml) {
  return new DOMParser().parseFromString(xml, "application/xml");
}
function makeArrayExtender(valueReader, opt_this) {
  return function(node, objectStack) {
    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
    if (value !== void 0) {
      var array = objectStack[objectStack.length - 1];
      extend(array, value);
    }
  };
}
function makeArrayPusher(valueReader, opt_this) {
  return function(node, objectStack) {
    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
    if (value !== void 0) {
      var array = objectStack[objectStack.length - 1];
      array.push(value);
    }
  };
}
function makeReplacer(valueReader, opt_this) {
  return function(node, objectStack) {
    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
    if (value !== void 0) {
      objectStack[objectStack.length - 1] = value;
    }
  };
}
function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {
  return function(node, objectStack) {
    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
    if (value !== void 0) {
      var object = objectStack[objectStack.length - 1];
      var property = opt_property !== void 0 ? opt_property : node.localName;
      var array = void 0;
      if (property in object) {
        array = object[property];
      } else {
        array = [];
        object[property] = array;
      }
      array.push(value);
    }
  };
}
function makeObjectPropertySetter(valueReader, opt_property, opt_this) {
  return function(node, objectStack) {
    var value = valueReader.call(opt_this !== void 0 ? opt_this : this, node, objectStack);
    if (value !== void 0) {
      var object = objectStack[objectStack.length - 1];
      var property = opt_property !== void 0 ? opt_property : node.localName;
      object[property] = value;
    }
  };
}
function makeChildAppender(nodeWriter, opt_this) {
  return function(node, value, objectStack) {
    nodeWriter.call(opt_this !== void 0 ? opt_this : this, node, value, objectStack);
    var parent = objectStack[objectStack.length - 1];
    var parentNode = parent.node;
    parentNode.appendChild(node);
  };
}
function makeArraySerializer(nodeWriter, opt_this) {
  var serializersNS, nodeFactory;
  return function(node, value, objectStack) {
    if (serializersNS === void 0) {
      serializersNS = {};
      var serializers = {};
      serializers[node.localName] = nodeWriter;
      serializersNS[node.namespaceURI] = serializers;
      nodeFactory = makeSimpleNodeFactory(node.localName);
    }
    serialize(serializersNS, nodeFactory, value, objectStack);
  };
}
function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {
  var fixedNodeName = opt_nodeName;
  return function(value, objectStack, opt_nodeName2) {
    var context = objectStack[objectStack.length - 1];
    var node = context.node;
    var nodeName = fixedNodeName;
    if (nodeName === void 0) {
      nodeName = opt_nodeName2;
    }
    var namespaceURI = opt_namespaceURI !== void 0 ? opt_namespaceURI : node.namespaceURI;
    return createElementNS(namespaceURI, nodeName);
  };
}
var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();
function makeSequence(object, orderedKeys) {
  var length = orderedKeys.length;
  var sequence = new Array(length);
  for (var i = 0; i < length; ++i) {
    sequence[i] = object[orderedKeys[i]];
  }
  return sequence;
}
function makeStructureNS(namespaceURIs, structure, opt_structureNS) {
  var structureNS = opt_structureNS !== void 0 ? opt_structureNS : {};
  var i, ii;
  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }
  return structureNS;
}
function parseNode(parsersNS, node, objectStack, opt_this) {
  var n;
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var parsers = parsersNS[n.namespaceURI];
    if (parsers !== void 0) {
      var parser = parsers[n.localName];
      if (parser !== void 0) {
        parser.call(opt_this, n, objectStack);
      }
    }
  }
}
function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {
  objectStack.push(object);
  parseNode(parsersNS, node, objectStack, opt_this);
  return objectStack.pop();
}
function serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  var length = (opt_keys !== void 0 ? opt_keys : values).length;
  var value, node;
  for (var i = 0; i < length; ++i) {
    value = values[i];
    if (value !== void 0) {
      node = nodeFactory.call(opt_this !== void 0 ? opt_this : this, value, objectStack, opt_keys !== void 0 ? opt_keys[i] : void 0);
      if (node !== void 0) {
        serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);
      }
    }
  }
}
function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  objectStack.push(object);
  serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);
  return objectStack.pop();
}
var xmlSerializer_ = void 0;
function getXMLSerializer() {
  if (xmlSerializer_ === void 0 && typeof XMLSerializer !== "undefined") {
    xmlSerializer_ = new XMLSerializer();
  }
  return xmlSerializer_;
}
var document_ = void 0;
function getDocument() {
  if (document_ === void 0 && typeof document !== "undefined") {
    document_ = document.implementation.createDocument("", "", null);
  }
  return document_;
}

// node_modules/ol/format/XMLFeature.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var XMLFeature = function(_super) {
  __extends5(XMLFeature2, _super);
  function XMLFeature2() {
    var _this = _super.call(this) || this;
    _this.xmlSerializer_ = getXMLSerializer();
    return _this;
  }
  XMLFeature2.prototype.getType = function() {
    return FormatType_default.XML;
  };
  XMLFeature2.prototype.readFeature = function(source, opt_options) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      var doc = parse(source);
      return this.readFeatureFromDocument(doc, opt_options);
    } else if (isDocument(source)) {
      return this.readFeatureFromDocument(source, opt_options);
    } else {
      return this.readFeatureFromNode(source, opt_options);
    }
  };
  XMLFeature2.prototype.readFeatureFromDocument = function(doc, opt_options) {
    var features = this.readFeaturesFromDocument(doc, opt_options);
    if (features.length > 0) {
      return features[0];
    } else {
      return null;
    }
  };
  XMLFeature2.prototype.readFeatureFromNode = function(node, opt_options) {
    return null;
  };
  XMLFeature2.prototype.readFeatures = function(source, opt_options) {
    if (!source) {
      return [];
    } else if (typeof source === "string") {
      var doc = parse(source);
      return this.readFeaturesFromDocument(doc, opt_options);
    } else if (isDocument(source)) {
      return this.readFeaturesFromDocument(source, opt_options);
    } else {
      return this.readFeaturesFromNode(source, opt_options);
    }
  };
  XMLFeature2.prototype.readFeaturesFromDocument = function(doc, opt_options) {
    var features = [];
    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        extend(features, this.readFeaturesFromNode(n, opt_options));
      }
    }
    return features;
  };
  XMLFeature2.prototype.readFeaturesFromNode = function(node, opt_options) {
    return abstract();
  };
  XMLFeature2.prototype.readGeometry = function(source, opt_options) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      var doc = parse(source);
      return this.readGeometryFromDocument(doc, opt_options);
    } else if (isDocument(source)) {
      return this.readGeometryFromDocument(source, opt_options);
    } else {
      return this.readGeometryFromNode(source, opt_options);
    }
  };
  XMLFeature2.prototype.readGeometryFromDocument = function(doc, opt_options) {
    return null;
  };
  XMLFeature2.prototype.readGeometryFromNode = function(node, opt_options) {
    return null;
  };
  XMLFeature2.prototype.readProjection = function(source) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      var doc = parse(source);
      return this.readProjectionFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readProjectionFromDocument(source);
    } else {
      return this.readProjectionFromNode(source);
    }
  };
  XMLFeature2.prototype.readProjectionFromDocument = function(doc) {
    return this.dataProjection;
  };
  XMLFeature2.prototype.readProjectionFromNode = function(node) {
    return this.dataProjection;
  };
  XMLFeature2.prototype.writeFeature = function(feature, opt_options) {
    var node = this.writeFeatureNode(feature, opt_options);
    return this.xmlSerializer_.serializeToString(node);
  };
  XMLFeature2.prototype.writeFeatureNode = function(feature, opt_options) {
    return null;
  };
  XMLFeature2.prototype.writeFeatures = function(features, opt_options) {
    var node = this.writeFeaturesNode(features, opt_options);
    return this.xmlSerializer_.serializeToString(node);
  };
  XMLFeature2.prototype.writeFeaturesNode = function(features, opt_options) {
    return null;
  };
  XMLFeature2.prototype.writeGeometry = function(geometry, opt_options) {
    var node = this.writeGeometryNode(geometry, opt_options);
    return this.xmlSerializer_.serializeToString(node);
  };
  XMLFeature2.prototype.writeGeometryNode = function(geometry, opt_options) {
    return null;
  };
  return XMLFeature2;
}(Feature_default2);
var XMLFeature_default = XMLFeature;

// node_modules/ol/format/GMLBase.js
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GMLNS = "http://www.opengis.net/gml";
var ONLY_WHITESPACE_RE = /^[\s\xa0]*$/;
var GMLBase = function(_super) {
  __extends6(GMLBase2, _super);
  function GMLBase2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.featureType = options.featureType;
    _this.featureNS = options.featureNS;
    _this.srsName = options.srsName;
    _this.schemaLocation = "";
    _this.FEATURE_COLLECTION_PARSERS = {};
    _this.FEATURE_COLLECTION_PARSERS[_this.namespace] = {
      "featureMember": makeArrayPusher(_this.readFeaturesInternal),
      "featureMembers": makeReplacer(_this.readFeaturesInternal)
    };
    _this.supportedMediaTypes = ["application/gml+xml"];
    return _this;
  }
  GMLBase2.prototype.readFeaturesInternal = function(node, objectStack) {
    var localName = node.localName;
    var features = null;
    if (localName == "FeatureCollection") {
      features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);
    } else if (localName == "featureMembers" || localName == "featureMember" || localName == "member") {
      var context = objectStack[0];
      var featureType = context["featureType"];
      var featureNS = context["featureNS"];
      var prefix = "p";
      var defaultPrefix = "p0";
      if (!featureType && node.childNodes) {
        featureType = [], featureNS = {};
        for (var i = 0, ii = node.childNodes.length; i < ii; ++i) {
          var child = node.childNodes[i];
          if (child.nodeType === 1) {
            var ft = child.nodeName.split(":").pop();
            if (featureType.indexOf(ft) === -1) {
              var key = "";
              var count = 0;
              var uri = child.namespaceURI;
              for (var candidate in featureNS) {
                if (featureNS[candidate] === uri) {
                  key = candidate;
                  break;
                }
                ++count;
              }
              if (!key) {
                key = prefix + count;
                featureNS[key] = uri;
              }
              featureType.push(key + ":" + ft);
            }
          }
        }
        if (localName != "featureMember") {
          context["featureType"] = featureType;
          context["featureNS"] = featureNS;
        }
      }
      if (typeof featureNS === "string") {
        var ns = featureNS;
        featureNS = {};
        featureNS[defaultPrefix] = ns;
      }
      var parsersNS = {};
      var featureTypes = Array.isArray(featureType) ? featureType : [featureType];
      for (var p in featureNS) {
        var parsers = {};
        for (var i = 0, ii = featureTypes.length; i < ii; ++i) {
          var featurePrefix = featureTypes[i].indexOf(":") === -1 ? defaultPrefix : featureTypes[i].split(":")[0];
          if (featurePrefix === p) {
            parsers[featureTypes[i].split(":").pop()] = localName == "featureMembers" ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);
          }
        }
        parsersNS[featureNS[p]] = parsers;
      }
      if (localName == "featureMember" || localName == "member") {
        features = pushParseAndPop(void 0, parsersNS, node, objectStack);
      } else {
        features = pushParseAndPop([], parsersNS, node, objectStack);
      }
    }
    if (features === null) {
      features = [];
    }
    return features;
  };
  GMLBase2.prototype.readGeometryElement = function(node, objectStack) {
    var context = objectStack[0];
    context["srsName"] = node.firstElementChild.getAttribute("srsName");
    context["srsDimension"] = node.firstElementChild.getAttribute("srsDimension");
    var geometry = pushParseAndPop(null, this.GEOMETRY_PARSERS, node, objectStack, this);
    if (geometry) {
      if (Array.isArray(geometry)) {
        return transformExtentWithOptions(geometry, context);
      } else {
        return transformGeometryWithOptions(geometry, false, context);
      }
    } else {
      return void 0;
    }
  };
  GMLBase2.prototype.readFeatureElementInternal = function(node, objectStack, asFeature) {
    var geometryName;
    var values = {};
    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      var value = void 0;
      var localName = n.localName;
      if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {
        value = getAllTextContent(n, false);
        if (ONLY_WHITESPACE_RE.test(value)) {
          value = void 0;
        }
      } else {
        if (asFeature) {
          value = this.readGeometryElement(n, objectStack);
        }
        if (!value) {
          value = this.readFeatureElementInternal(n, objectStack, false);
        } else if (localName !== "boundedBy") {
          geometryName = localName;
        }
      }
      if (values[localName]) {
        if (!(values[localName] instanceof Array)) {
          values[localName] = [values[localName]];
        }
        values[localName].push(value);
      } else {
        values[localName] = value;
      }
      var len = n.attributes.length;
      if (len > 0) {
        values[localName] = { _content_: values[localName] };
        for (var i = 0; i < len; i++) {
          var attName = n.attributes[i].name;
          values[localName][attName] = n.attributes[i].value;
        }
      }
    }
    if (!asFeature) {
      return values;
    } else {
      var feature = new Feature_default(values);
      if (geometryName) {
        feature.setGeometryName(geometryName);
      }
      var fid = node.getAttribute("fid") || getAttributeNS(node, this.namespace, "id");
      if (fid) {
        feature.setId(fid);
      }
      return feature;
    }
  };
  GMLBase2.prototype.readFeatureElement = function(node, objectStack) {
    return this.readFeatureElementInternal(node, objectStack, true);
  };
  GMLBase2.prototype.readPoint = function(node, objectStack) {
    var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
      return new Point_default(flatCoordinates, GeometryLayout_default.XYZ);
    }
  };
  GMLBase2.prototype.readMultiPoint = function(node, objectStack) {
    var coordinates = pushParseAndPop([], this.MULTIPOINT_PARSERS, node, objectStack, this);
    if (coordinates) {
      return new MultiPoint_default(coordinates);
    } else {
      return void 0;
    }
  };
  GMLBase2.prototype.readMultiLineString = function(node, objectStack) {
    var lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS, node, objectStack, this);
    if (lineStrings) {
      return new MultiLineString_default(lineStrings);
    }
  };
  GMLBase2.prototype.readMultiPolygon = function(node, objectStack) {
    var polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS, node, objectStack, this);
    if (polygons) {
      return new MultiPolygon_default(polygons);
    }
  };
  GMLBase2.prototype.pointMemberParser = function(node, objectStack) {
    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);
  };
  GMLBase2.prototype.lineStringMemberParser = function(node, objectStack) {
    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);
  };
  GMLBase2.prototype.polygonMemberParser = function(node, objectStack) {
    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);
  };
  GMLBase2.prototype.readLineString = function(node, objectStack) {
    var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
      var lineString = new LineString_default(flatCoordinates, GeometryLayout_default.XYZ);
      return lineString;
    } else {
      return void 0;
    }
  };
  GMLBase2.prototype.readFlatLinearRing = function(node, objectStack) {
    var ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
    if (ring) {
      return ring;
    } else {
      return void 0;
    }
  };
  GMLBase2.prototype.readLinearRing = function(node, objectStack) {
    var flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
    if (flatCoordinates) {
      return new LinearRing_default(flatCoordinates, GeometryLayout_default.XYZ);
    }
  };
  GMLBase2.prototype.readPolygon = function(node, objectStack) {
    var flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
    if (flatLinearRings && flatLinearRings[0]) {
      var flatCoordinates = flatLinearRings[0];
      var ends = [flatCoordinates.length];
      var i = void 0, ii = void 0;
      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
        extend(flatCoordinates, flatLinearRings[i]);
        ends.push(flatCoordinates.length);
      }
      return new Polygon_default(flatCoordinates, GeometryLayout_default.XYZ, ends);
    } else {
      return void 0;
    }
  };
  GMLBase2.prototype.readFlatCoordinatesFromNode = function(node, objectStack) {
    return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
  };
  GMLBase2.prototype.readGeometryFromNode = function(node, opt_options) {
    var geometry = this.readGeometryElement(node, [
      this.getReadOptions(node, opt_options ? opt_options : {})
    ]);
    return geometry ? geometry : null;
  };
  GMLBase2.prototype.readFeaturesFromNode = function(node, opt_options) {
    var options = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };
    if (opt_options) {
      assign(options, this.getReadOptions(node, opt_options));
    }
    var features = this.readFeaturesInternal(node, [options]);
    return features || [];
  };
  GMLBase2.prototype.readProjectionFromNode = function(node) {
    return get(this.srsName ? this.srsName : node.firstElementChild.getAttribute("srsName"));
  };
  return GMLBase2;
}(XMLFeature_default);
GMLBase.prototype.namespace = GMLNS;
GMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {}
};
GMLBase.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeArrayPusher(GMLBase.prototype.pointMemberParser),
    "pointMembers": makeArrayPusher(GMLBase.prototype.pointMemberParser)
  }
};
GMLBase.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeArrayPusher(GMLBase.prototype.lineStringMemberParser),
    "lineStringMembers": makeArrayPusher(GMLBase.prototype.lineStringMemberParser)
  }
};
GMLBase.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml": {
    "polygonMember": makeArrayPusher(GMLBase.prototype.polygonMemberParser),
    "polygonMembers": makeArrayPusher(GMLBase.prototype.polygonMemberParser)
  }
};
GMLBase.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode)
  }
};
GMLBase.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineString": makeArrayPusher(GMLBase.prototype.readLineString)
  }
};
GMLBase.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Polygon": makeArrayPusher(GMLBase.prototype.readPolygon)
  }
};
GMLBase.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    "LinearRing": makeReplacer(GMLBase.prototype.readFlatLinearRing)
  }
};
var GMLBase_default = GMLBase;

// node_modules/ol/format/xsd.js
function readBoolean(node) {
  var s = getAllTextContent(node, false);
  return readBooleanString(s);
}
function readBooleanString(string) {
  var m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
  if (m) {
    return m[1] !== void 0 || false;
  } else {
    return void 0;
  }
}
function readDateTime(node) {
  var s = getAllTextContent(node, false);
  var dateTime = Date.parse(s);
  return isNaN(dateTime) ? void 0 : dateTime / 1e3;
}
function readDecimal(node) {
  var s = getAllTextContent(node, false);
  return readDecimalString(s);
}
function readDecimalString(string) {
  var m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
  if (m) {
    return parseFloat(m[1]);
  } else {
    return void 0;
  }
}
function readPositiveInteger(node) {
  var s = getAllTextContent(node, false);
  return readNonNegativeIntegerString(s);
}
function readNonNegativeIntegerString(string) {
  var m = /^\s*(\d+)\s*$/.exec(string);
  if (m) {
    return parseInt(m[1], 10);
  } else {
    return void 0;
  }
}
function readString(node) {
  return getAllTextContent(node, false).trim();
}
function writeBooleanTextNode(node, bool) {
  writeStringTextNode(node, bool ? "1" : "0");
}
function writeCDATASection(node, string) {
  node.appendChild(getDocument().createCDATASection(string));
}
function writeDateTimeTextNode(node, dateTime) {
  var date = new Date(dateTime * 1e3);
  var string = date.getUTCFullYear() + "-" + padNumber(date.getUTCMonth() + 1, 2) + "-" + padNumber(date.getUTCDate(), 2) + "T" + padNumber(date.getUTCHours(), 2) + ":" + padNumber(date.getUTCMinutes(), 2) + ":" + padNumber(date.getUTCSeconds(), 2) + "Z";
  node.appendChild(getDocument().createTextNode(string));
}
function writeDecimalTextNode(node, decimal) {
  var string = decimal.toPrecision();
  node.appendChild(getDocument().createTextNode(string));
}
function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {
  var string = nonNegativeInteger.toString();
  node.appendChild(getDocument().createTextNode(string));
}
function writeStringTextNode(node, string) {
  node.appendChild(getDocument().createTextNode(string));
}

// node_modules/ol/format/GML2.js
var __extends7 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var schemaLocation = GMLNS + " http://schemas.opengis.net/gml/2.1.2/feature.xsd";
var MULTIGEOMETRY_TO_MEMBER_NODENAME = {
  "MultiLineString": "lineStringMember",
  "MultiCurve": "curveMember",
  "MultiPolygon": "polygonMember",
  "MultiSurface": "surfaceMember"
};
var GML2 = function(_super) {
  __extends7(GML22, _super);
  function GML22(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.FEATURE_COLLECTION_PARSERS[GMLNS]["featureMember"] = makeArrayPusher(_this.readFeaturesInternal);
    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
    return _this;
  }
  GML22.prototype.readFlatCoordinates = function(node, objectStack) {
    var s = getAllTextContent(node, false).replace(/^\s*|\s*$/g, "");
    var context = objectStack[0];
    var containerSrs = context["srsName"];
    var axisOrientation = "enu";
    if (containerSrs) {
      var proj = get(containerSrs);
      if (proj) {
        axisOrientation = proj.getAxisOrientation();
      }
    }
    var coordsGroups = s.trim().split(/\s+/);
    var flatCoordinates = [];
    for (var i = 0, ii = coordsGroups.length; i < ii; i++) {
      var coords = coordsGroups[i].split(/,+/);
      var x = parseFloat(coords[0]);
      var y = parseFloat(coords[1]);
      var z = coords.length === 3 ? parseFloat(coords[2]) : 0;
      if (axisOrientation.substr(0, 2) === "en") {
        flatCoordinates.push(x, y, z);
      } else {
        flatCoordinates.push(y, x, z);
      }
    }
    return flatCoordinates;
  };
  GML22.prototype.readBox = function(node, objectStack) {
    var flatCoordinates = pushParseAndPop([null], this.BOX_PARSERS_, node, objectStack, this);
    return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);
  };
  GML22.prototype.innerBoundaryIsParser = function(node, objectStack) {
    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
    if (flatLinearRing) {
      var flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings.push(flatLinearRing);
    }
  };
  GML22.prototype.outerBoundaryIsParser = function(node, objectStack) {
    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
    if (flatLinearRing) {
      var flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings[0] = flatLinearRing;
    }
  };
  GML22.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var multiSurface = context["multiSurface"];
    var surface = context["surface"];
    var multiCurve = context["multiCurve"];
    var nodeName;
    if (!Array.isArray(value)) {
      nodeName = value.getType();
      if (nodeName === "MultiPolygon" && multiSurface === true) {
        nodeName = "MultiSurface";
      } else if (nodeName === "Polygon" && surface === true) {
        nodeName = "Surface";
      } else if (nodeName === "MultiLineString" && multiCurve === true) {
        nodeName = "MultiCurve";
      }
    } else {
      nodeName = "Envelope";
    }
    return createElementNS("http://www.opengis.net/gml", nodeName);
  };
  GML22.prototype.writeFeatureElement = function(node, feature, objectStack) {
    var fid = feature.getId();
    if (fid) {
      node.setAttribute("fid", fid);
    }
    var context = objectStack[objectStack.length - 1];
    var featureNS = context["featureNS"];
    var geometryName = feature.getGeometryName();
    if (!context.serializers) {
      context.serializers = {};
      context.serializers[featureNS] = {};
    }
    var keys = [];
    var values = [];
    if (feature.hasProperties()) {
      var properties = feature.getProperties();
      for (var key in properties) {
        var value = properties[key];
        if (value !== null) {
          keys.push(key);
          values.push(value);
          if (key == geometryName || typeof value.getSimplifiedGeometry === "function") {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);
            }
          } else {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
            }
          }
        }
      }
    }
    var item = assign({}, context);
    item.node = node;
    pushSerializeAndPop(item, context.serializers, makeSimpleNodeFactory(void 0, featureNS), values, objectStack, keys);
  };
  GML22.prototype.writeCurveOrLineString = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (node.nodeName !== "LineStringSegment" && srsName) {
      node.setAttribute("srsName", srsName);
    }
    if (node.nodeName === "LineString" || node.nodeName === "LineStringSegment") {
      var coordinates = this.createCoordinatesNode_(node.namespaceURI);
      node.appendChild(coordinates);
      this.writeCoordinates_(coordinates, geometry, objectStack);
    } else if (node.nodeName === "Curve") {
      var segments = createElementNS(node.namespaceURI, "segments");
      node.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  };
  GML22.prototype.writeLineStringOrCurveMember = function(node, line, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  };
  GML22.prototype.writeMultiCurveOrLineString = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    var curve = context["curve"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var lines = geometry.getLineStrings();
    pushSerializeAndPop({ node, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);
  };
  GML22.prototype.writeGeometryElement = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var item = assign({}, context);
    item["node"] = node;
    var value;
    if (Array.isArray(geometry)) {
      value = transformExtentWithOptions(geometry, context);
    } else {
      value = transformGeometryWithOptions(geometry, true, context);
    }
    pushSerializeAndPop(item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, void 0, this);
  };
  GML22.prototype.createCoordinatesNode_ = function(namespaceURI) {
    var coordinates = createElementNS(namespaceURI, "coordinates");
    coordinates.setAttribute("decimal", ".");
    coordinates.setAttribute("cs", ",");
    coordinates.setAttribute("ts", " ");
    return coordinates;
  };
  GML22.prototype.writeCoordinates_ = function(node, value, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    var points = value.getCoordinates();
    var len = points.length;
    var parts = new Array(len);
    for (var i = 0; i < len; ++i) {
      var point = points[i];
      parts[i] = this.getCoords_(point, srsName, hasZ);
    }
    writeStringTextNode(node, parts.join(" "));
  };
  GML22.prototype.writeCurveSegments_ = function(node, line, objectStack) {
    var child = createElementNS(node.namespaceURI, "LineStringSegment");
    node.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  };
  GML22.prototype.writeSurfaceOrPolygon = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    if (node.nodeName !== "PolygonPatch" && srsName) {
      node.setAttribute("srsName", srsName);
    }
    if (node.nodeName === "Polygon" || node.nodeName === "PolygonPatch") {
      var rings = geometry.getLinearRings();
      pushSerializeAndPop({ node, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);
    } else if (node.nodeName === "Surface") {
      var patches = createElementNS(node.namespaceURI, "patches");
      node.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  };
  GML22.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var parentNode = context.node;
    var exteriorWritten = context["exteriorWritten"];
    if (exteriorWritten === void 0) {
      context["exteriorWritten"] = true;
    }
    return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs");
  };
  GML22.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {
    var child = createElementNS(node.namespaceURI, "PolygonPatch");
    node.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  };
  GML22.prototype.writeRing = function(node, ring, objectStack) {
    var linearRing = createElementNS(node.namespaceURI, "LinearRing");
    node.appendChild(linearRing);
    this.writeLinearRing(linearRing, ring, objectStack);
  };
  GML22.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {
    var axisOrientation = "enu";
    if (opt_srsName) {
      axisOrientation = get(opt_srsName).getAxisOrientation();
    }
    var coords = axisOrientation.substr(0, 2) === "en" ? point[0] + "," + point[1] : point[1] + "," + point[0];
    if (opt_hasZ) {
      var z = point[2] || 0;
      coords += "," + z;
    }
    return coords;
  };
  GML22.prototype.writePoint = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var coordinates = this.createCoordinatesNode_(node.namespaceURI);
    node.appendChild(coordinates);
    var point = geometry.getCoordinates();
    var coord = this.getCoords_(point, srsName, hasZ);
    writeStringTextNode(coordinates, coord);
  };
  GML22.prototype.writeMultiPoint = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var points = geometry.getPoints();
    pushSerializeAndPop({ node, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory("pointMember"), points, objectStack, void 0, this);
  };
  GML22.prototype.writePointMember = function(node, point, objectStack) {
    var child = createElementNS(node.namespaceURI, "Point");
    node.appendChild(child);
    this.writePoint(child, point, objectStack);
  };
  GML22.prototype.writeLinearRing = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var coordinates = this.createCoordinatesNode_(node.namespaceURI);
    node.appendChild(coordinates);
    this.writeCoordinates_(coordinates, geometry, objectStack);
  };
  GML22.prototype.writeMultiSurfaceOrPolygon = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    var surface = context["surface"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var polygons = geometry.getPolygons();
    pushSerializeAndPop({ node, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);
  };
  GML22.prototype.writeSurfaceOrPolygonMember = function(node, polygon, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  };
  GML22.prototype.writeEnvelope = function(node, extent, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var keys = ["lowerCorner", "upperCorner"];
    var values = [extent[0] + " " + extent[1], extent[2] + " " + extent[3]];
    pushSerializeAndPop({ node }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);
  };
  GML22.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS("http://www.opengis.net/gml", MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
  };
  return GML22;
}(GMLBase_default);
GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    "coordinates": makeReplacer(GML2.prototype.readFlatCoordinates)
  }
};
GML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    "innerBoundaryIs": GML2.prototype.innerBoundaryIsParser,
    "outerBoundaryIs": GML2.prototype.outerBoundaryIsParser
  }
};
GML2.prototype.BOX_PARSERS_ = {
  "http://www.opengis.net/gml": {
    "coordinates": makeArrayPusher(GML2.prototype.readFlatCoordinates)
  }
};
GML2.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeReplacer(GMLBase_default.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase_default.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase_default.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase_default.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase_default.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase_default.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase_default.prototype.readMultiPolygon),
    "Box": makeReplacer(GML2.prototype.readBox)
  }
};
GML2.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "Curve": makeChildAppender(GML2.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML2.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML2.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML2.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),
    "LinearRing": makeChildAppender(GML2.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon),
    "Surface": makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon),
    "Envelope": makeChildAppender(GML2.prototype.writeEnvelope)
  }
};
GML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeChildAppender(GML2.prototype.writeLineStringOrCurveMember),
    "curveMember": makeChildAppender(GML2.prototype.writeLineStringOrCurveMember)
  }
};
GML2.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "outerBoundaryIs": makeChildAppender(GML2.prototype.writeRing),
    "innerBoundaryIs": makeChildAppender(GML2.prototype.writeRing)
  }
};
GML2.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeChildAppender(GML2.prototype.writePointMember)
  }
};
GML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember),
    "polygonMember": makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember)
  }
};
GML2.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
var GML2_default = GML2;

// node_modules/ol/format/GML3.js
var __extends8 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var schemaLocation2 = GMLNS + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd";
var MULTIGEOMETRY_TO_MEMBER_NODENAME2 = {
  "MultiLineString": "lineStringMember",
  "MultiCurve": "curveMember",
  "MultiPolygon": "polygonMember",
  "MultiSurface": "surfaceMember"
};
var GML3 = function(_super) {
  __extends8(GML33, _super);
  function GML33(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.surface_ = options.surface !== void 0 ? options.surface : false;
    _this.curve_ = options.curve !== void 0 ? options.curve : false;
    _this.multiCurve_ = options.multiCurve !== void 0 ? options.multiCurve : true;
    _this.multiSurface_ = options.multiSurface !== void 0 ? options.multiSurface : true;
    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation2;
    _this.hasZ = options.hasZ !== void 0 ? options.hasZ : false;
    return _this;
  }
  GML33.prototype.readMultiCurve = function(node, objectStack) {
    var lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node, objectStack, this);
    if (lineStrings) {
      var multiLineString = new MultiLineString_default(lineStrings);
      return multiLineString;
    } else {
      return void 0;
    }
  };
  GML33.prototype.readMultiSurface = function(node, objectStack) {
    var polygons = pushParseAndPop([], this.MULTISURFACE_PARSERS, node, objectStack, this);
    if (polygons) {
      return new MultiPolygon_default(polygons);
    }
  };
  GML33.prototype.curveMemberParser = function(node, objectStack) {
    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);
  };
  GML33.prototype.surfaceMemberParser = function(node, objectStack) {
    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);
  };
  GML33.prototype.readPatch = function(node, objectStack) {
    return pushParseAndPop([null], this.PATCHES_PARSERS, node, objectStack, this);
  };
  GML33.prototype.readSegment = function(node, objectStack) {
    return pushParseAndPop([null], this.SEGMENTS_PARSERS, node, objectStack, this);
  };
  GML33.prototype.readPolygonPatch = function(node, objectStack) {
    return pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
  };
  GML33.prototype.readLineStringSegment = function(node, objectStack) {
    return pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
  };
  GML33.prototype.interiorParser = function(node, objectStack) {
    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
    if (flatLinearRing) {
      var flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings.push(flatLinearRing);
    }
  };
  GML33.prototype.exteriorParser = function(node, objectStack) {
    var flatLinearRing = pushParseAndPop(void 0, this.RING_PARSERS, node, objectStack, this);
    if (flatLinearRing) {
      var flatLinearRings = objectStack[objectStack.length - 1];
      flatLinearRings[0] = flatLinearRing;
    }
  };
  GML33.prototype.readSurface = function(node, objectStack) {
    var flatLinearRings = pushParseAndPop([null], this.SURFACE_PARSERS, node, objectStack, this);
    if (flatLinearRings && flatLinearRings[0]) {
      var flatCoordinates = flatLinearRings[0];
      var ends = [flatCoordinates.length];
      var i = void 0, ii = void 0;
      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
        extend(flatCoordinates, flatLinearRings[i]);
        ends.push(flatCoordinates.length);
      }
      return new Polygon_default(flatCoordinates, GeometryLayout_default.XYZ, ends);
    } else {
      return void 0;
    }
  };
  GML33.prototype.readCurve = function(node, objectStack) {
    var flatCoordinates = pushParseAndPop([null], this.CURVE_PARSERS, node, objectStack, this);
    if (flatCoordinates) {
      var lineString = new LineString_default(flatCoordinates, GeometryLayout_default.XYZ);
      return lineString;
    } else {
      return void 0;
    }
  };
  GML33.prototype.readEnvelope = function(node, objectStack) {
    var flatCoordinates = pushParseAndPop([null], this.ENVELOPE_PARSERS, node, objectStack, this);
    return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);
  };
  GML33.prototype.readFlatPos = function(node, objectStack) {
    var s = getAllTextContent(node, false);
    var re = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
    var flatCoordinates = [];
    var m;
    while (m = re.exec(s)) {
      flatCoordinates.push(parseFloat(m[1]));
      s = s.substr(m[0].length);
    }
    if (s !== "") {
      return void 0;
    }
    var context = objectStack[0];
    var containerSrs = context["srsName"];
    var axisOrientation = "enu";
    if (containerSrs) {
      var proj = get(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }
    if (axisOrientation === "neu") {
      var i = void 0, ii = void 0;
      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {
        var y = flatCoordinates[i];
        var x = flatCoordinates[i + 1];
        flatCoordinates[i] = x;
        flatCoordinates[i + 1] = y;
      }
    }
    var len = flatCoordinates.length;
    if (len == 2) {
      flatCoordinates.push(0);
    }
    if (len === 0) {
      return void 0;
    }
    return flatCoordinates;
  };
  GML33.prototype.readFlatPosList = function(node, objectStack) {
    var s = getAllTextContent(node, false).replace(/^\s*|\s*$/g, "");
    var context = objectStack[0];
    var containerSrs = context["srsName"];
    var contextDimension = context["srsDimension"];
    var axisOrientation = "enu";
    if (containerSrs) {
      var proj = get(containerSrs);
      axisOrientation = proj.getAxisOrientation();
    }
    var coords = s.split(/\s+/);
    var dim = 2;
    if (node.getAttribute("srsDimension")) {
      dim = readNonNegativeIntegerString(node.getAttribute("srsDimension"));
    } else if (node.getAttribute("dimension")) {
      dim = readNonNegativeIntegerString(node.getAttribute("dimension"));
    } else if (node.parentNode.getAttribute("srsDimension")) {
      dim = readNonNegativeIntegerString(node.parentNode.getAttribute("srsDimension"));
    } else if (contextDimension) {
      dim = readNonNegativeIntegerString(contextDimension);
    }
    var x, y, z;
    var flatCoordinates = [];
    for (var i = 0, ii = coords.length; i < ii; i += dim) {
      x = parseFloat(coords[i]);
      y = parseFloat(coords[i + 1]);
      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;
      if (axisOrientation.substr(0, 2) === "en") {
        flatCoordinates.push(x, y, z);
      } else {
        flatCoordinates.push(y, x, z);
      }
    }
    return flatCoordinates;
  };
  GML33.prototype.writePos_ = function(node, value, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsDimension = hasZ ? "3" : "2";
    node.setAttribute("srsDimension", srsDimension);
    var srsName = context["srsName"];
    var axisOrientation = "enu";
    if (srsName) {
      axisOrientation = get(srsName).getAxisOrientation();
    }
    var point = value.getCoordinates();
    var coords;
    if (axisOrientation.substr(0, 2) === "en") {
      coords = point[0] + " " + point[1];
    } else {
      coords = point[1] + " " + point[0];
    }
    if (hasZ) {
      var z = point[2] || 0;
      coords += " " + z;
    }
    writeStringTextNode(node, coords);
  };
  GML33.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {
    var axisOrientation = "enu";
    if (opt_srsName) {
      axisOrientation = get(opt_srsName).getAxisOrientation();
    }
    var coords = axisOrientation.substr(0, 2) === "en" ? point[0] + " " + point[1] : point[1] + " " + point[0];
    if (opt_hasZ) {
      var z = point[2] || 0;
      coords += " " + z;
    }
    return coords;
  };
  GML33.prototype.writePosList_ = function(node, value, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsDimension = hasZ ? "3" : "2";
    node.setAttribute("srsDimension", srsDimension);
    var srsName = context["srsName"];
    var points = value.getCoordinates();
    var len = points.length;
    var parts = new Array(len);
    var point;
    for (var i = 0; i < len; ++i) {
      point = points[i];
      parts[i] = this.getCoords_(point, srsName, hasZ);
    }
    writeStringTextNode(node, parts.join(" "));
  };
  GML33.prototype.writePoint = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var pos = createElementNS(node.namespaceURI, "pos");
    node.appendChild(pos);
    this.writePos_(pos, geometry, objectStack);
  };
  GML33.prototype.writeEnvelope = function(node, extent, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var keys = ["lowerCorner", "upperCorner"];
    var values = [extent[0] + " " + extent[1], extent[2] + " " + extent[3]];
    pushSerializeAndPop({ node }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);
  };
  GML33.prototype.writeLinearRing = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var posList = createElementNS(node.namespaceURI, "posList");
    node.appendChild(posList);
    this.writePosList_(posList, geometry, objectStack);
  };
  GML33.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var parentNode = context.node;
    var exteriorWritten = context["exteriorWritten"];
    if (exteriorWritten === void 0) {
      context["exteriorWritten"] = true;
    }
    return createElementNS(parentNode.namespaceURI, exteriorWritten !== void 0 ? "interior" : "exterior");
  };
  GML33.prototype.writeSurfaceOrPolygon = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    if (node.nodeName !== "PolygonPatch" && srsName) {
      node.setAttribute("srsName", srsName);
    }
    if (node.nodeName === "Polygon" || node.nodeName === "PolygonPatch") {
      var rings = geometry.getLinearRings();
      pushSerializeAndPop({ node, hasZ, srsName }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, void 0, this);
    } else if (node.nodeName === "Surface") {
      var patches = createElementNS(node.namespaceURI, "patches");
      node.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  };
  GML33.prototype.writeCurveOrLineString = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    if (node.nodeName !== "LineStringSegment" && srsName) {
      node.setAttribute("srsName", srsName);
    }
    if (node.nodeName === "LineString" || node.nodeName === "LineStringSegment") {
      var posList = createElementNS(node.namespaceURI, "posList");
      node.appendChild(posList);
      this.writePosList_(posList, geometry, objectStack);
    } else if (node.nodeName === "Curve") {
      var segments = createElementNS(node.namespaceURI, "segments");
      node.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  };
  GML33.prototype.writeMultiSurfaceOrPolygon = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    var surface = context["surface"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var polygons = geometry.getPolygons();
    pushSerializeAndPop({ node, hasZ, srsName, surface }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, void 0, this);
  };
  GML33.prototype.writeMultiPoint = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var srsName = context["srsName"];
    var hasZ = context["hasZ"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var points = geometry.getPoints();
    pushSerializeAndPop({ node, hasZ, srsName }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory("pointMember"), points, objectStack, void 0, this);
  };
  GML33.prototype.writeMultiCurveOrLineString = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var hasZ = context["hasZ"];
    var srsName = context["srsName"];
    var curve = context["curve"];
    if (srsName) {
      node.setAttribute("srsName", srsName);
    }
    var lines = geometry.getLineStrings();
    pushSerializeAndPop({ node, hasZ, srsName, curve }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, void 0, this);
  };
  GML33.prototype.writeRing = function(node, ring, objectStack) {
    var linearRing = createElementNS(node.namespaceURI, "LinearRing");
    node.appendChild(linearRing);
    this.writeLinearRing(linearRing, ring, objectStack);
  };
  GML33.prototype.writeSurfaceOrPolygonMember = function(node, polygon, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
  };
  GML33.prototype.writePointMember = function(node, point, objectStack) {
    var child = createElementNS(node.namespaceURI, "Point");
    node.appendChild(child);
    this.writePoint(child, point, objectStack);
  };
  GML33.prototype.writeLineStringOrCurveMember = function(node, line, objectStack) {
    var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
    if (child) {
      node.appendChild(child);
      this.writeCurveOrLineString(child, line, objectStack);
    }
  };
  GML33.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {
    var child = createElementNS(node.namespaceURI, "PolygonPatch");
    node.appendChild(child);
    this.writeSurfaceOrPolygon(child, polygon, objectStack);
  };
  GML33.prototype.writeCurveSegments_ = function(node, line, objectStack) {
    var child = createElementNS(node.namespaceURI, "LineStringSegment");
    node.appendChild(child);
    this.writeCurveOrLineString(child, line, objectStack);
  };
  GML33.prototype.writeGeometryElement = function(node, geometry, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var item = assign({}, context);
    item["node"] = node;
    var value;
    if (Array.isArray(geometry)) {
      value = transformExtentWithOptions(geometry, context);
    } else {
      value = transformGeometryWithOptions(geometry, true, context);
    }
    pushSerializeAndPop(item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, void 0, this);
  };
  GML33.prototype.writeFeatureElement = function(node, feature, objectStack) {
    var fid = feature.getId();
    if (fid) {
      node.setAttribute("fid", fid);
    }
    var context = objectStack[objectStack.length - 1];
    var featureNS = context["featureNS"];
    var geometryName = feature.getGeometryName();
    if (!context.serializers) {
      context.serializers = {};
      context.serializers[featureNS] = {};
    }
    var keys = [];
    var values = [];
    if (feature.hasProperties()) {
      var properties = feature.getProperties();
      for (var key in properties) {
        var value = properties[key];
        if (value !== null) {
          keys.push(key);
          values.push(value);
          if (key == geometryName || typeof value.getSimplifiedGeometry === "function") {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);
            }
          } else {
            if (!(key in context.serializers[featureNS])) {
              context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);
            }
          }
        }
      }
    }
    var item = assign({}, context);
    item.node = node;
    pushSerializeAndPop(item, context.serializers, makeSimpleNodeFactory(void 0, featureNS), values, objectStack, keys);
  };
  GML33.prototype.writeFeatureMembers_ = function(node, features, objectStack) {
    var context = objectStack[objectStack.length - 1];
    var featureType = context["featureType"];
    var featureNS = context["featureNS"];
    var serializers = {};
    serializers[featureNS] = {};
    serializers[featureNS][featureType] = makeChildAppender(this.writeFeatureElement, this);
    var item = assign({}, context);
    item.node = node;
    pushSerializeAndPop(item, serializers, makeSimpleNodeFactory(featureType, featureNS), features, objectStack);
  };
  GML33.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS(this.namespace, MULTIGEOMETRY_TO_MEMBER_NODENAME2[parentNode.nodeName]);
  };
  GML33.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var multiSurface = context["multiSurface"];
    var surface = context["surface"];
    var curve = context["curve"];
    var multiCurve = context["multiCurve"];
    var nodeName;
    if (!Array.isArray(value)) {
      nodeName = value.getType();
      if (nodeName === "MultiPolygon" && multiSurface === true) {
        nodeName = "MultiSurface";
      } else if (nodeName === "Polygon" && surface === true) {
        nodeName = "Surface";
      } else if (nodeName === "LineString" && curve === true) {
        nodeName = "Curve";
      } else if (nodeName === "MultiLineString" && multiCurve === true) {
        nodeName = "MultiCurve";
      }
    } else {
      nodeName = "Envelope";
    }
    return createElementNS(this.namespace, nodeName);
  };
  GML33.prototype.writeGeometryNode = function(geometry, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var geom = createElementNS(this.namespace, "geom");
    var context = {
      node: geom,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };
    if (opt_options) {
      assign(context, opt_options);
    }
    this.writeGeometryElement(geom, geometry, [context]);
    return geom;
  };
  GML33.prototype.writeFeaturesNode = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var node = createElementNS(this.namespace, "featureMembers");
    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", this.schemaLocation);
    var context = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };
    if (opt_options) {
      assign(context, opt_options);
    }
    this.writeFeatureMembers_(node, features, [context]);
    return node;
  };
  return GML33;
}(GMLBase_default);
GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    "pos": makeReplacer(GML3.prototype.readFlatPos),
    "posList": makeReplacer(GML3.prototype.readFlatPosList),
    "coordinates": makeReplacer(GML2_default.prototype.readFlatCoordinates)
  }
};
GML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    "interior": GML3.prototype.interiorParser,
    "exterior": GML3.prototype.exteriorParser
  }
};
GML3.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    "Point": makeReplacer(GMLBase_default.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase_default.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase_default.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase_default.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase_default.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase_default.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase_default.prototype.readMultiPolygon),
    "Surface": makeReplacer(GML3.prototype.readSurface),
    "MultiSurface": makeReplacer(GML3.prototype.readMultiSurface),
    "Curve": makeReplacer(GML3.prototype.readCurve),
    "MultiCurve": makeReplacer(GML3.prototype.readMultiCurve),
    "Envelope": makeReplacer(GML3.prototype.readEnvelope)
  }
};
GML3.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    "curveMember": makeArrayPusher(GML3.prototype.curveMemberParser),
    "curveMembers": makeArrayPusher(GML3.prototype.curveMemberParser)
  }
};
GML3.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeArrayPusher(GML3.prototype.surfaceMemberParser),
    "surfaceMembers": makeArrayPusher(GML3.prototype.surfaceMemberParser)
  }
};
GML3.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineString": makeArrayPusher(GMLBase_default.prototype.readLineString),
    "Curve": makeArrayPusher(GML3.prototype.readCurve)
  }
};
GML3.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    "Polygon": makeArrayPusher(GMLBase_default.prototype.readPolygon),
    "Surface": makeArrayPusher(GML3.prototype.readSurface)
  }
};
GML3.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    "patches": makeReplacer(GML3.prototype.readPatch)
  }
};
GML3.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    "segments": makeReplacer(GML3.prototype.readSegment)
  }
};
GML3.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeArrayPusher(GML3.prototype.readFlatPosList),
    "upperCorner": makeArrayPusher(GML3.prototype.readFlatPosList)
  }
};
GML3.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml": {
    "PolygonPatch": makeReplacer(GML3.prototype.readPolygonPatch)
  }
};
GML3.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml": {
    "LineStringSegment": makeReplacer(GML3.prototype.readLineStringSegment)
  }
};
GML3.prototype.writeFeatures;
GML3.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "exterior": makeChildAppender(GML3.prototype.writeRing),
    "interior": makeChildAppender(GML3.prototype.writeRing)
  }
};
GML3.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
GML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "surfaceMember": makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember),
    "polygonMember": makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember)
  }
};
GML3.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "pointMember": makeChildAppender(GML3.prototype.writePointMember)
  }
};
GML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "lineStringMember": makeChildAppender(GML3.prototype.writeLineStringOrCurveMember),
    "curveMember": makeChildAppender(GML3.prototype.writeLineStringOrCurveMember)
  }
};
GML3.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    "Curve": makeChildAppender(GML3.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML3.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML3.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML3.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),
    "LinearRing": makeChildAppender(GML3.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),
    "Surface": makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),
    "Envelope": makeChildAppender(GML3.prototype.writeEnvelope)
  }
};
var GML3_default = GML3;

// node_modules/ol/format/GML.js
var GML = GML3_default;
GML.prototype.writeFeatures;
GML.prototype.writeFeaturesNode;
var GML_default = GML;

// node_modules/ol/format/GPX.js
var __extends9 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NAMESPACE_URIS = [
  null,
  "http://www.topografix.com/GPX/1/0",
  "http://www.topografix.com/GPX/1/1"
];
var SCHEMA_LOCATION = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd";
var FEATURE_READER = {
  "rte": readRte,
  "trk": readTrk,
  "wpt": readWpt
};
var GPX_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "rte": makeArrayPusher(readRte),
  "trk": makeArrayPusher(readTrk),
  "wpt": makeArrayPusher(readWpt)
});
var LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "text": makeObjectPropertySetter(readString, "linkText"),
  "type": makeObjectPropertySetter(readString, "linkType")
});
var GPX_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "rte": makeChildAppender(writeRte),
  "trk": makeChildAppender(writeTrk),
  "wpt": makeChildAppender(writeWpt)
});
var GPX = function(_super) {
  __extends9(GPX2, _super);
  function GPX2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.dataProjection = get("EPSG:4326");
    _this.readExtensions_ = options.readExtensions;
    return _this;
  }
  GPX2.prototype.handleReadExtensions_ = function(features) {
    if (!features) {
      features = [];
    }
    for (var i = 0, ii = features.length; i < ii; ++i) {
      var feature = features[i];
      if (this.readExtensions_) {
        var extensionsNode = feature.get("extensionsNode_") || null;
        this.readExtensions_(feature, extensionsNode);
      }
      feature.set("extensionsNode_", void 0);
    }
  };
  GPX2.prototype.readFeatureFromNode = function(node, opt_options) {
    if (!includes(NAMESPACE_URIS, node.namespaceURI)) {
      return null;
    }
    var featureReader = FEATURE_READER[node.localName];
    if (!featureReader) {
      return null;
    }
    var feature = featureReader(node, [
      this.getReadOptions(node, opt_options)
    ]);
    if (!feature) {
      return null;
    }
    this.handleReadExtensions_([feature]);
    return feature;
  };
  GPX2.prototype.readFeaturesFromNode = function(node, opt_options) {
    if (!includes(NAMESPACE_URIS, node.namespaceURI)) {
      return [];
    }
    if (node.localName == "gpx") {
      var features = pushParseAndPop([], GPX_PARSERS, node, [
        this.getReadOptions(node, opt_options)
      ]);
      if (features) {
        this.handleReadExtensions_(features);
        return features;
      } else {
        return [];
      }
    }
    return [];
  };
  GPX2.prototype.writeFeaturesNode = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var gpx = createElementNS("http://www.topografix.com/GPX/1/1", "gpx");
    var xmlnsUri = "http://www.w3.org/2000/xmlns/";
    gpx.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
    gpx.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATION);
    gpx.setAttribute("version", "1.1");
    gpx.setAttribute("creator", "OpenLayers");
    pushSerializeAndPop({ node: gpx }, GPX_SERIALIZERS, GPX_NODE_FACTORY, features, [opt_options]);
    return gpx;
  };
  return GPX2;
}(XMLFeature_default);
var RTE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "number": makeObjectPropertySetter(readPositiveInteger),
  "extensions": parseExtensions,
  "type": makeObjectPropertySetter(readString),
  "rtept": parseRtePt
});
var RTEPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime)
});
var TRK_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "number": makeObjectPropertySetter(readPositiveInteger),
  "type": makeObjectPropertySetter(readString),
  "extensions": parseExtensions,
  "trkseg": parseTrkSeg
});
var TRKSEG_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "trkpt": parseTrkPt
});
var TRKPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime)
});
var WPT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeObjectPropertySetter(readDecimal),
  "time": makeObjectPropertySetter(readDateTime),
  "magvar": makeObjectPropertySetter(readDecimal),
  "geoidheight": makeObjectPropertySetter(readDecimal),
  "name": makeObjectPropertySetter(readString),
  "cmt": makeObjectPropertySetter(readString),
  "desc": makeObjectPropertySetter(readString),
  "src": makeObjectPropertySetter(readString),
  "link": parseLink,
  "sym": makeObjectPropertySetter(readString),
  "type": makeObjectPropertySetter(readString),
  "fix": makeObjectPropertySetter(readString),
  "sat": makeObjectPropertySetter(readPositiveInteger),
  "hdop": makeObjectPropertySetter(readDecimal),
  "vdop": makeObjectPropertySetter(readDecimal),
  "pdop": makeObjectPropertySetter(readDecimal),
  "ageofdgpsdata": makeObjectPropertySetter(readDecimal),
  "dgpsid": makeObjectPropertySetter(readPositiveInteger),
  "extensions": parseExtensions
});
var LINK_SEQUENCE = ["text", "type"];
var LINK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "text": makeChildAppender(writeStringTextNode),
  "type": makeChildAppender(writeStringTextNode)
});
var RTE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "rtept"
]);
var RTE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "number": makeChildAppender(writeNonNegativeIntegerTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "rtept": makeArraySerializer(makeChildAppender(writeWptType))
});
var RTEPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ["ele", "time"]);
var TRK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "trkseg"
]);
var TRK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "number": makeChildAppender(writeNonNegativeIntegerTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "trkseg": makeArraySerializer(makeChildAppender(writeTrkSeg))
});
var TRKSEG_NODE_FACTORY = makeSimpleNodeFactory("trkpt");
var TRKSEG_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "trkpt": makeChildAppender(writeWptType)
});
var WPT_TYPE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [
  "ele",
  "time",
  "magvar",
  "geoidheight",
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "sym",
  "type",
  "fix",
  "sat",
  "hdop",
  "vdop",
  "pdop",
  "ageofdgpsdata",
  "dgpsid"
]);
var WPT_TYPE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {
  "ele": makeChildAppender(writeDecimalTextNode),
  "time": makeChildAppender(writeDateTimeTextNode),
  "magvar": makeChildAppender(writeDecimalTextNode),
  "geoidheight": makeChildAppender(writeDecimalTextNode),
  "name": makeChildAppender(writeStringTextNode),
  "cmt": makeChildAppender(writeStringTextNode),
  "desc": makeChildAppender(writeStringTextNode),
  "src": makeChildAppender(writeStringTextNode),
  "link": makeChildAppender(writeLink),
  "sym": makeChildAppender(writeStringTextNode),
  "type": makeChildAppender(writeStringTextNode),
  "fix": makeChildAppender(writeStringTextNode),
  "sat": makeChildAppender(writeNonNegativeIntegerTextNode),
  "hdop": makeChildAppender(writeDecimalTextNode),
  "vdop": makeChildAppender(writeDecimalTextNode),
  "pdop": makeChildAppender(writeDecimalTextNode),
  "ageofdgpsdata": makeChildAppender(writeDecimalTextNode),
  "dgpsid": makeChildAppender(writeNonNegativeIntegerTextNode)
});
var GEOMETRY_TYPE_TO_NODENAME = {
  "Point": "wpt",
  "LineString": "rte",
  "MultiLineString": "trk"
};
function GPX_NODE_FACTORY(value, objectStack, opt_nodeName) {
  var geometry = value.getGeometry();
  if (geometry) {
    var nodeName = GEOMETRY_TYPE_TO_NODENAME[geometry.getType()];
    if (nodeName) {
      var parentNode = objectStack[objectStack.length - 1].node;
      return createElementNS(parentNode.namespaceURI, nodeName);
    }
  }
}
function appendCoordinate(flatCoordinates, layoutOptions, node, values) {
  flatCoordinates.push(parseFloat(node.getAttribute("lon")), parseFloat(node.getAttribute("lat")));
  if ("ele" in values) {
    flatCoordinates.push(values["ele"]);
    delete values["ele"];
    layoutOptions.hasZ = true;
  } else {
    flatCoordinates.push(0);
  }
  if ("time" in values) {
    flatCoordinates.push(values["time"]);
    delete values["time"];
    layoutOptions.hasM = true;
  } else {
    flatCoordinates.push(0);
  }
  return flatCoordinates;
}
function applyLayoutOptions(layoutOptions, flatCoordinates, ends) {
  var layout = GeometryLayout_default.XY;
  var stride = 2;
  if (layoutOptions.hasZ && layoutOptions.hasM) {
    layout = GeometryLayout_default.XYZM;
    stride = 4;
  } else if (layoutOptions.hasZ) {
    layout = GeometryLayout_default.XYZ;
    stride = 3;
  } else if (layoutOptions.hasM) {
    layout = GeometryLayout_default.XYM;
    stride = 3;
  }
  if (stride !== 4) {
    for (var i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {
      flatCoordinates[i * stride] = flatCoordinates[i * 4];
      flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];
      if (layoutOptions.hasZ) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];
      }
      if (layoutOptions.hasM) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];
      }
    }
    flatCoordinates.length = flatCoordinates.length / 4 * stride;
    if (ends) {
      for (var i = 0, ii = ends.length; i < ii; i++) {
        ends[i] = ends[i] / 4 * stride;
      }
    }
  }
  return layout;
}
function parseLink(node, objectStack) {
  var values = objectStack[objectStack.length - 1];
  var href = node.getAttribute("href");
  if (href !== null) {
    values["link"] = href;
  }
  parseNode(LINK_PARSERS, node, objectStack);
}
function parseExtensions(node, objectStack) {
  var values = objectStack[objectStack.length - 1];
  values["extensionsNode_"] = node;
}
function parseRtePt(node, objectStack) {
  var values = pushParseAndPop({}, RTEPT_PARSERS, node, objectStack);
  if (values) {
    var rteValues = objectStack[objectStack.length - 1];
    var flatCoordinates = rteValues["flatCoordinates"];
    var layoutOptions = rteValues["layoutOptions"];
    appendCoordinate(flatCoordinates, layoutOptions, node, values);
  }
}
function parseTrkPt(node, objectStack) {
  var values = pushParseAndPop({}, TRKPT_PARSERS, node, objectStack);
  if (values) {
    var trkValues = objectStack[objectStack.length - 1];
    var flatCoordinates = trkValues["flatCoordinates"];
    var layoutOptions = trkValues["layoutOptions"];
    appendCoordinate(flatCoordinates, layoutOptions, node, values);
  }
}
function parseTrkSeg(node, objectStack) {
  var values = objectStack[objectStack.length - 1];
  parseNode(TRKSEG_PARSERS, node, objectStack);
  var flatCoordinates = values["flatCoordinates"];
  var ends = values["ends"];
  ends.push(flatCoordinates.length);
}
function readRte(node, objectStack) {
  var options = objectStack[0];
  var values = pushParseAndPop({
    "flatCoordinates": [],
    "layoutOptions": {}
  }, RTE_PARSERS, node, objectStack);
  if (!values) {
    return void 0;
  }
  var flatCoordinates = values["flatCoordinates"];
  delete values["flatCoordinates"];
  var layoutOptions = values["layoutOptions"];
  delete values["layoutOptions"];
  var layout = applyLayoutOptions(layoutOptions, flatCoordinates);
  var geometry = new LineString_default(flatCoordinates, layout);
  transformGeometryWithOptions(geometry, false, options);
  var feature = new Feature_default(geometry);
  feature.setProperties(values, true);
  return feature;
}
function readTrk(node, objectStack) {
  var options = objectStack[0];
  var values = pushParseAndPop({
    "flatCoordinates": [],
    "ends": [],
    "layoutOptions": {}
  }, TRK_PARSERS, node, objectStack);
  if (!values) {
    return void 0;
  }
  var flatCoordinates = values["flatCoordinates"];
  delete values["flatCoordinates"];
  var ends = values["ends"];
  delete values["ends"];
  var layoutOptions = values["layoutOptions"];
  delete values["layoutOptions"];
  var layout = applyLayoutOptions(layoutOptions, flatCoordinates, ends);
  var geometry = new MultiLineString_default(flatCoordinates, layout, ends);
  transformGeometryWithOptions(geometry, false, options);
  var feature = new Feature_default(geometry);
  feature.setProperties(values, true);
  return feature;
}
function readWpt(node, objectStack) {
  var options = objectStack[0];
  var values = pushParseAndPop({}, WPT_PARSERS, node, objectStack);
  if (!values) {
    return void 0;
  }
  var layoutOptions = {};
  var coordinates = appendCoordinate([], layoutOptions, node, values);
  var layout = applyLayoutOptions(layoutOptions, coordinates);
  var geometry = new Point_default(coordinates, layout);
  transformGeometryWithOptions(geometry, false, options);
  var feature = new Feature_default(geometry);
  feature.setProperties(values, true);
  return feature;
}
function writeLink(node, value, objectStack) {
  node.setAttribute("href", value);
  var context = objectStack[objectStack.length - 1];
  var properties = context["properties"];
  var link = [properties["linkText"], properties["linkType"]];
  pushSerializeAndPop({ node }, LINK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, link, objectStack, LINK_SEQUENCE);
}
function writeWptType(node, coordinate, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var parentNode = context.node;
  var namespaceURI = parentNode.namespaceURI;
  var properties = context["properties"];
  node.setAttributeNS(null, "lat", String(coordinate[1]));
  node.setAttributeNS(null, "lon", String(coordinate[0]));
  var geometryLayout = context["geometryLayout"];
  switch (geometryLayout) {
    case GeometryLayout_default.XYZM:
      if (coordinate[3] !== 0) {
        properties["time"] = coordinate[3];
      }
    case GeometryLayout_default.XYZ:
      if (coordinate[2] !== 0) {
        properties["ele"] = coordinate[2];
      }
      break;
    case GeometryLayout_default.XYM:
      if (coordinate[2] !== 0) {
        properties["time"] = coordinate[2];
      }
      break;
    default:
  }
  var orderedKeys = node.nodeName == "rtept" ? RTEPT_TYPE_SEQUENCE[namespaceURI] : WPT_TYPE_SEQUENCE[namespaceURI];
  var values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop({ node, "properties": properties }, WPT_TYPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
function writeRte(node, feature, objectStack) {
  var options = objectStack[0];
  var properties = feature.getProperties();
  var context = { node };
  context["properties"] = properties;
  var geometry = feature.getGeometry();
  if (geometry.getType() == GeometryType_default.LINE_STRING) {
    var lineString = transformGeometryWithOptions(geometry, true, options);
    context["geometryLayout"] = lineString.getLayout();
    properties["rtept"] = lineString.getCoordinates();
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = RTE_SEQUENCE[parentNode.namespaceURI];
  var values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, RTE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
function writeTrk(node, feature, objectStack) {
  var options = objectStack[0];
  var properties = feature.getProperties();
  var context = { node };
  context["properties"] = properties;
  var geometry = feature.getGeometry();
  if (geometry.getType() == GeometryType_default.MULTI_LINE_STRING) {
    var multiLineString = transformGeometryWithOptions(geometry, true, options);
    properties["trkseg"] = multiLineString.getLineStrings();
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = TRK_SEQUENCE[parentNode.namespaceURI];
  var values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, TRK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
function writeTrkSeg(node, lineString, objectStack) {
  var context = { node };
  context["geometryLayout"] = lineString.getLayout();
  context["properties"] = {};
  pushSerializeAndPop(context, TRKSEG_SERIALIZERS, TRKSEG_NODE_FACTORY, lineString.getCoordinates(), objectStack);
}
function writeWpt(node, feature, objectStack) {
  var options = objectStack[0];
  var context = objectStack[objectStack.length - 1];
  context["properties"] = feature.getProperties();
  var geometry = feature.getGeometry();
  if (geometry.getType() == GeometryType_default.POINT) {
    var point = transformGeometryWithOptions(geometry, true, options);
    context["geometryLayout"] = point.getLayout();
    writeWptType(node, point.getCoordinates(), objectStack);
  }
}
var GPX_default = GPX;

// node_modules/ol/format/TextFeature.js
var __extends10 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TextFeature = function(_super) {
  __extends10(TextFeature2, _super);
  function TextFeature2() {
    return _super.call(this) || this;
  }
  TextFeature2.prototype.getType = function() {
    return FormatType_default.TEXT;
  };
  TextFeature2.prototype.readFeature = function(source, opt_options) {
    return this.readFeatureFromText(getText(source), this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.readFeatureFromText = function(text, opt_options) {
    return abstract();
  };
  TextFeature2.prototype.readFeatures = function(source, opt_options) {
    return this.readFeaturesFromText(getText(source), this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.readFeaturesFromText = function(text, opt_options) {
    return abstract();
  };
  TextFeature2.prototype.readGeometry = function(source, opt_options) {
    return this.readGeometryFromText(getText(source), this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.readGeometryFromText = function(text, opt_options) {
    return abstract();
  };
  TextFeature2.prototype.readProjection = function(source) {
    return this.readProjectionFromText(getText(source));
  };
  TextFeature2.prototype.readProjectionFromText = function(text) {
    return this.dataProjection;
  };
  TextFeature2.prototype.writeFeature = function(feature, opt_options) {
    return this.writeFeatureText(feature, this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.writeFeatureText = function(feature, opt_options) {
    return abstract();
  };
  TextFeature2.prototype.writeFeatures = function(features, opt_options) {
    return this.writeFeaturesText(features, this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.writeFeaturesText = function(features, opt_options) {
    return abstract();
  };
  TextFeature2.prototype.writeGeometry = function(geometry, opt_options) {
    return this.writeGeometryText(geometry, this.adaptOptions(opt_options));
  };
  TextFeature2.prototype.writeGeometryText = function(geometry, opt_options) {
    return abstract();
  };
  return TextFeature2;
}(Feature_default2);
function getText(source) {
  if (typeof source === "string") {
    return source;
  } else {
    return "";
  }
}
var TextFeature_default = TextFeature;

// node_modules/ol/format/IGC.js
var __extends11 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var IGCZ = {
  BAROMETRIC: "barometric",
  GPS: "gps",
  NONE: "none"
};
var B_RECORD_RE = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/;
var H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;
var HFDTE_RECORD_RE = /^HFDTE(\d{2})(\d{2})(\d{2})/;
var NEWLINE_RE = /\r\n|\r|\n/;
var IGC = function(_super) {
  __extends11(IGC2, _super);
  function IGC2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.dataProjection = get("EPSG:4326");
    _this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : IGCZ.NONE;
    return _this;
  }
  IGC2.prototype.readFeatureFromText = function(text, opt_options) {
    var altitudeMode = this.altitudeMode_;
    var lines = text.split(NEWLINE_RE);
    var properties = {};
    var flatCoordinates = [];
    var year = 2e3;
    var month = 0;
    var day = 1;
    var lastDateTime = -1;
    var i, ii;
    for (i = 0, ii = lines.length; i < ii; ++i) {
      var line = lines[i];
      var m = void 0;
      if (line.charAt(0) == "B") {
        m = B_RECORD_RE.exec(line);
        if (m) {
          var hour = parseInt(m[1], 10);
          var minute = parseInt(m[2], 10);
          var second = parseInt(m[3], 10);
          var y = parseInt(m[4], 10) + parseInt(m[5], 10) / 6e4;
          if (m[6] == "S") {
            y = -y;
          }
          var x = parseInt(m[7], 10) + parseInt(m[8], 10) / 6e4;
          if (m[9] == "W") {
            x = -x;
          }
          flatCoordinates.push(x, y);
          if (altitudeMode != IGCZ.NONE) {
            var z = void 0;
            if (altitudeMode == IGCZ.GPS) {
              z = parseInt(m[11], 10);
            } else if (altitudeMode == IGCZ.BAROMETRIC) {
              z = parseInt(m[12], 10);
            } else {
              z = 0;
            }
            flatCoordinates.push(z);
          }
          var dateTime = Date.UTC(year, month, day, hour, minute, second);
          if (dateTime < lastDateTime) {
            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);
          }
          flatCoordinates.push(dateTime / 1e3);
          lastDateTime = dateTime;
        }
      } else if (line.charAt(0) == "H") {
        m = HFDTE_RECORD_RE.exec(line);
        if (m) {
          day = parseInt(m[1], 10);
          month = parseInt(m[2], 10) - 1;
          year = 2e3 + parseInt(m[3], 10);
        } else {
          m = H_RECORD_RE.exec(line);
          if (m) {
            properties[m[1]] = m[2].trim();
          }
        }
      }
    }
    if (flatCoordinates.length === 0) {
      return null;
    }
    var layout = altitudeMode == IGCZ.NONE ? GeometryLayout_default.XYM : GeometryLayout_default.XYZM;
    var lineString = new LineString_default(flatCoordinates, layout);
    var feature = new Feature_default(transformGeometryWithOptions(lineString, false, opt_options));
    feature.setProperties(properties, true);
    return feature;
  };
  IGC2.prototype.readFeaturesFromText = function(text, opt_options) {
    var feature = this.readFeatureFromText(text, opt_options);
    if (feature) {
      return [feature];
    } else {
      return [];
    }
  };
  return IGC2;
}(TextFeature_default);
var IGC_default = IGC;

// node_modules/ol/format/IIIFInfo.js
var __spreadArray = function(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
    to[j] = from[i];
  return to;
};
var Versions = {
  VERSION1: "version1",
  VERSION2: "version2",
  VERSION3: "version3"
};
var IIIF_PROFILE_VALUES = {};
IIIF_PROFILE_VALUES[Versions.VERSION1] = {
  "level0": {
    supports: [],
    formats: [],
    qualities: ["native"]
  },
  "level1": {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["native"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["native", "color", "grey", "bitonal"]
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION2] = {
  "level0": {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level1": {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByDistortedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default", "bitonal"]
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION3] = {
  "level0": {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level1": {
    supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionSquare",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default"]
  }
};
IIIF_PROFILE_VALUES["none"] = {
  "none": {
    supports: [],
    formats: [],
    qualities: []
  }
};
var COMPLIANCE_VERSION1 = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/;
var COMPLIANCE_VERSION2 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/;
var COMPLIANCE_VERSION3 = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
function generateVersion1Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();
  if (levelProfile === void 0) {
    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]["level0"];
  }
  return {
    url: iiifInfo.imageInfo["@id"] === void 0 ? void 0 : iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    supports: levelProfile.supports,
    formats: __spreadArray(__spreadArray([], levelProfile.formats), [
      iiifInfo.imageInfo.formats === void 0 ? [] : iiifInfo.imageInfo.formats
    ]),
    qualities: __spreadArray(__spreadArray([], levelProfile.qualities), [
      iiifInfo.imageInfo.qualities === void 0 ? [] : iiifInfo.imageInfo.qualities
    ]),
    resolutions: iiifInfo.imageInfo.scale_factors,
    tileSize: iiifInfo.imageInfo.tile_width !== void 0 ? iiifInfo.imageInfo.tile_height !== void 0 ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != void 0 ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : void 0
  };
}
function generateVersion2Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1, profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [], profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [], profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];
  return {
    url: iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.width;
      })[0],
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.height === void 0 ? tile.width : tile.height;
      })[0]
    ],
    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile) {
      return tile.scaleFactors;
    })[0],
    supports: __spreadArray(__spreadArray([], levelProfile.supports), profileSupports),
    formats: __spreadArray(__spreadArray([], levelProfile.formats), profileFormats),
    qualities: __spreadArray(__spreadArray([], levelProfile.qualities), profileQualities)
  };
}
function generateVersion3Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), formats = iiifInfo.imageInfo.extraFormats === void 0 ? levelProfile.formats : __spreadArray(__spreadArray([], levelProfile.formats), iiifInfo.imageInfo.extraFormats), preferredFormat = iiifInfo.imageInfo.preferredFormats !== void 0 && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function(format) {
    return includes(["jpg", "png", "gif"], format);
  }).reduce(function(acc, format) {
    return acc === void 0 && includes(formats, format) ? format : acc;
  }, void 0) : void 0;
  return {
    url: iiifInfo.imageInfo["id"],
    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.width;
      })[0],
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.height;
      })[0]
    ],
    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile) {
      return tile.scaleFactors;
    })[0],
    supports: iiifInfo.imageInfo.extraFeatures === void 0 ? levelProfile.supports : __spreadArray(__spreadArray([], levelProfile.supports), iiifInfo.imageInfo.extraFeatures),
    formats,
    qualities: iiifInfo.imageInfo.extraQualities === void 0 ? levelProfile.qualities : __spreadArray(__spreadArray([], levelProfile.qualities), iiifInfo.imageInfo.extraQualities),
    preferredFormat
  };
}
var versionFunctions = {};
versionFunctions[Versions.VERSION1] = generateVersion1Options;
versionFunctions[Versions.VERSION2] = generateVersion2Options;
versionFunctions[Versions.VERSION3] = generateVersion3Options;
var IIIFInfo = function() {
  function IIIFInfo2(imageInfo) {
    this.setImageInfo(imageInfo);
  }
  IIIFInfo2.prototype.setImageInfo = function(imageInfo) {
    if (typeof imageInfo == "string") {
      this.imageInfo = JSON.parse(imageInfo);
    } else {
      this.imageInfo = imageInfo;
    }
  };
  IIIFInfo2.prototype.getImageApiVersion = function() {
    if (this.imageInfo === void 0) {
      return;
    }
    var context = this.imageInfo["@context"] || "ol-no-context";
    if (typeof context == "string") {
      context = [context];
    }
    for (var i = 0; i < context.length; i++) {
      switch (context[i]) {
        case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
        case "http://iiif.io/api/image/1/context.json":
          return Versions.VERSION1;
        case "http://iiif.io/api/image/2/context.json":
          return Versions.VERSION2;
        case "http://iiif.io/api/image/3/context.json":
          return Versions.VERSION3;
        case "ol-no-context":
          if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {
            return Versions.VERSION1;
          }
          break;
        default:
      }
    }
    assert(false, 61);
  };
  IIIFInfo2.prototype.getComplianceLevelEntryFromProfile = function(version) {
    if (this.imageInfo === void 0 || this.imageInfo.profile === void 0) {
      return;
    }
    if (version === void 0) {
      version = this.getImageApiVersion();
    }
    switch (version) {
      case Versions.VERSION1:
        if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        break;
      case Versions.VERSION3:
        if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        break;
      case Versions.VERSION2:
        if (typeof this.imageInfo.profile === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {
          return this.imageInfo.profile[0];
        }
        break;
      default:
    }
  };
  IIIFInfo2.prototype.getComplianceLevelFromProfile = function(version) {
    var complianceLevel = this.getComplianceLevelEntryFromProfile(version);
    if (complianceLevel === void 0) {
      return void 0;
    }
    var level = complianceLevel.match(/level[0-2](?:\.json)?$/g);
    return Array.isArray(level) ? level[0].replace(".json", "") : void 0;
  };
  IIIFInfo2.prototype.getComplianceLevelSupportedFeatures = function() {
    if (this.imageInfo === void 0) {
      return;
    }
    var version = this.getImageApiVersion();
    var level = this.getComplianceLevelFromProfile(version);
    if (level === void 0) {
      return IIIF_PROFILE_VALUES["none"]["none"];
    }
    return IIIF_PROFILE_VALUES[version][level];
  };
  IIIFInfo2.prototype.getTileSourceOptions = function(opt_preferredOptions) {
    var options = opt_preferredOptions || {}, version = this.getImageApiVersion();
    if (version === void 0) {
      return;
    }
    var imageOptions = version === void 0 ? void 0 : versionFunctions[version](this);
    if (imageOptions === void 0) {
      return;
    }
    return {
      url: imageOptions.url,
      version,
      size: [this.imageInfo.width, this.imageInfo.height],
      sizes: imageOptions.sizes,
      format: options.format !== void 0 && includes(imageOptions.formats, options.format) ? options.format : imageOptions.preferredFormat !== void 0 ? imageOptions.preferredFormat : "jpg",
      supports: imageOptions.supports,
      quality: options.quality && includes(imageOptions.qualities, options.quality) ? options.quality : includes(imageOptions.qualities, "native") ? "native" : "default",
      resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function(a, b) {
        return b - a;
      }) : void 0,
      tileSize: imageOptions.tileSize
    };
  };
  return IIIFInfo2;
}();
var IIIFInfo_default = IIIFInfo;

// node_modules/ol/format/KML.js
var __extends12 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GX_NAMESPACE_URIS = ["http://www.google.com/kml/ext/2.2"];
var NAMESPACE_URIS2 = [
  null,
  "http://earth.google.com/kml/2.0",
  "http://earth.google.com/kml/2.1",
  "http://earth.google.com/kml/2.2",
  "http://www.opengis.net/kml/2.2"
];
var SCHEMA_LOCATION2 = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd";
var ICON_ANCHOR_UNITS_MAP = {
  "fraction": IconAnchorUnits_default.FRACTION,
  "pixels": IconAnchorUnits_default.PIXELS,
  "insetPixels": IconAnchorUnits_default.PIXELS
};
var PLACEMARK_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "ExtendedData": extendedDataParser,
  "Region": regionParser,
  "MultiGeometry": makeObjectPropertySetter(readMultiGeometry, "geometry"),
  "LineString": makeObjectPropertySetter(readLineString, "geometry"),
  "LinearRing": makeObjectPropertySetter(readLinearRing, "geometry"),
  "Point": makeObjectPropertySetter(readPoint, "geometry"),
  "Polygon": makeObjectPropertySetter(readPolygon, "geometry"),
  "Style": makeObjectPropertySetter(readStyle),
  "StyleMap": placemarkStyleMapParser,
  "address": makeObjectPropertySetter(readString),
  "description": makeObjectPropertySetter(readString),
  "name": makeObjectPropertySetter(readString),
  "open": makeObjectPropertySetter(readBoolean),
  "phoneNumber": makeObjectPropertySetter(readString),
  "styleUrl": makeObjectPropertySetter(readStyleURL),
  "visibility": makeObjectPropertySetter(readBoolean)
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "MultiTrack": makeObjectPropertySetter(readGxMultiTrack, "geometry"),
  "Track": makeObjectPropertySetter(readGxTrack, "geometry")
}));
var NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "ExtendedData": extendedDataParser,
  "Region": regionParser,
  "Link": linkParser,
  "address": makeObjectPropertySetter(readString),
  "description": makeObjectPropertySetter(readString),
  "name": makeObjectPropertySetter(readString),
  "open": makeObjectPropertySetter(readBoolean),
  "phoneNumber": makeObjectPropertySetter(readString),
  "visibility": makeObjectPropertySetter(readBoolean)
});
var LINK_PARSERS2 = makeStructureNS(NAMESPACE_URIS2, {
  "href": makeObjectPropertySetter(readURI)
});
var REGION_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "LatLonAltBox": latLonAltBoxParser,
  "Lod": lodParser
});
var KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, ["Document", "Placemark"]);
var KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "Document": makeChildAppender(writeDocument),
  "Placemark": makeChildAppender(writePlacemark)
});
var DEFAULT_COLOR;
var DEFAULT_FILL_STYLE = null;
var DEFAULT_IMAGE_STYLE_ANCHOR;
var DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
var DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
var DEFAULT_IMAGE_STYLE_SIZE;
var DEFAULT_IMAGE_STYLE_SRC;
var DEFAULT_IMAGE_STYLE = null;
var DEFAULT_NO_IMAGE_STYLE;
var DEFAULT_STROKE_STYLE = null;
var DEFAULT_TEXT_STROKE_STYLE;
var DEFAULT_TEXT_STYLE = null;
var DEFAULT_STYLE = null;
var DEFAULT_STYLE_ARRAY = null;
function scaleForSize(size) {
  return 32 / Math.min(size[0], size[1]);
}
function createStyleDefaults() {
  DEFAULT_COLOR = [255, 255, 255, 1];
  DEFAULT_FILL_STYLE = new Fill_default({
    color: DEFAULT_COLOR
  });
  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];
  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = IconAnchorUnits_default.PIXELS;
  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = IconAnchorUnits_default.PIXELS;
  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];
  DEFAULT_IMAGE_STYLE_SRC = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png";
  DEFAULT_IMAGE_STYLE = new Icon_default({
    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,
    anchorOrigin: IconOrigin_default.BOTTOM_LEFT,
    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,
    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,
    crossOrigin: "anonymous",
    rotation: 0,
    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),
    size: DEFAULT_IMAGE_STYLE_SIZE,
    src: DEFAULT_IMAGE_STYLE_SRC
  });
  DEFAULT_NO_IMAGE_STYLE = "NO_IMAGE";
  DEFAULT_STROKE_STYLE = new Stroke_default({
    color: DEFAULT_COLOR,
    width: 1
  });
  DEFAULT_TEXT_STROKE_STYLE = new Stroke_default({
    color: [51, 51, 51, 1],
    width: 2
  });
  DEFAULT_TEXT_STYLE = new Text_default({
    font: "bold 16px Helvetica",
    fill: DEFAULT_FILL_STYLE,
    stroke: DEFAULT_TEXT_STROKE_STYLE,
    scale: 0.8
  });
  DEFAULT_STYLE = new Style_default({
    fill: DEFAULT_FILL_STYLE,
    image: DEFAULT_IMAGE_STYLE,
    text: DEFAULT_TEXT_STYLE,
    stroke: DEFAULT_STROKE_STYLE,
    zIndex: 0
  });
  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];
}
var TEXTAREA;
function defaultIconUrlFunction(href) {
  return href;
}
var KML = function(_super) {
  __extends12(KML2, _super);
  function KML2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    if (!DEFAULT_STYLE_ARRAY) {
      createStyleDefaults();
    }
    _this.dataProjection = get("EPSG:4326");
    _this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : DEFAULT_STYLE_ARRAY;
    _this.extractStyles_ = options.extractStyles !== void 0 ? options.extractStyles : true;
    _this.writeStyles_ = options.writeStyles !== void 0 ? options.writeStyles : true;
    _this.sharedStyles_ = {};
    _this.showPointNames_ = options.showPointNames !== void 0 ? options.showPointNames : true;
    _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    _this.iconUrlFunction_ = options.iconUrlFunction ? options.iconUrlFunction : defaultIconUrlFunction;
    _this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
    return _this;
  }
  KML2.prototype.readDocumentOrFolder_ = function(node, objectStack) {
    var parsersNS = makeStructureNS(NAMESPACE_URIS2, {
      "Document": makeArrayExtender(this.readDocumentOrFolder_, this),
      "Folder": makeArrayExtender(this.readDocumentOrFolder_, this),
      "Placemark": makeArrayPusher(this.readPlacemark_, this),
      "Style": this.readSharedStyle_.bind(this),
      "StyleMap": this.readSharedStyleMap_.bind(this)
    });
    var features = pushParseAndPop([], parsersNS, node, objectStack, this);
    if (features) {
      return features;
    } else {
      return void 0;
    }
  };
  KML2.prototype.readPlacemark_ = function(node, objectStack) {
    var object = pushParseAndPop({ "geometry": null }, PLACEMARK_PARSERS, node, objectStack, this);
    if (!object) {
      return void 0;
    }
    var feature = new Feature_default();
    var id = node.getAttribute("id");
    if (id !== null) {
      feature.setId(id);
    }
    var options = objectStack[0];
    var geometry = object["geometry"];
    if (geometry) {
      transformGeometryWithOptions(geometry, false, options);
    }
    feature.setGeometry(geometry);
    delete object["geometry"];
    if (this.extractStyles_) {
      var style = object["Style"];
      var styleUrl = object["styleUrl"];
      var styleFunction = createFeatureStyleFunction(style, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
      feature.setStyle(styleFunction);
    }
    delete object["Style"];
    feature.setProperties(object, true);
    return feature;
  };
  KML2.prototype.readSharedStyle_ = function(node, objectStack) {
    var id = node.getAttribute("id");
    if (id !== null) {
      var style = readStyle.call(this, node, objectStack);
      if (style) {
        var styleUri = void 0;
        var baseURI = node.baseURI;
        if (!baseURI || baseURI == "about:blank") {
          baseURI = window.location.href;
        }
        if (baseURI) {
          var url = new URL("#" + id, baseURI);
          styleUri = url.href;
        } else {
          styleUri = "#" + id;
        }
        this.sharedStyles_[styleUri] = style;
      }
    }
  };
  KML2.prototype.readSharedStyleMap_ = function(node, objectStack) {
    var id = node.getAttribute("id");
    if (id === null) {
      return;
    }
    var styleMapValue = readStyleMapValue.call(this, node, objectStack);
    if (!styleMapValue) {
      return;
    }
    var styleUri;
    var baseURI = node.baseURI;
    if (!baseURI || baseURI == "about:blank") {
      baseURI = window.location.href;
    }
    if (baseURI) {
      var url = new URL("#" + id, baseURI);
      styleUri = url.href;
    } else {
      styleUri = "#" + id;
    }
    this.sharedStyles_[styleUri] = styleMapValue;
  };
  KML2.prototype.readFeatureFromNode = function(node, opt_options) {
    if (!includes(NAMESPACE_URIS2, node.namespaceURI)) {
      return null;
    }
    var feature = this.readPlacemark_(node, [
      this.getReadOptions(node, opt_options)
    ]);
    if (feature) {
      return feature;
    } else {
      return null;
    }
  };
  KML2.prototype.readFeaturesFromNode = function(node, opt_options) {
    if (!includes(NAMESPACE_URIS2, node.namespaceURI)) {
      return [];
    }
    var features;
    var localName = node.localName;
    if (localName == "Document" || localName == "Folder") {
      features = this.readDocumentOrFolder_(node, [
        this.getReadOptions(node, opt_options)
      ]);
      if (features) {
        return features;
      } else {
        return [];
      }
    } else if (localName == "Placemark") {
      var feature = this.readPlacemark_(node, [
        this.getReadOptions(node, opt_options)
      ]);
      if (feature) {
        return [feature];
      } else {
        return [];
      }
    } else if (localName == "kml") {
      features = [];
      for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
        var fs = this.readFeaturesFromNode(n, opt_options);
        if (fs) {
          extend(features, fs);
        }
      }
      return features;
    } else {
      return [];
    }
  };
  KML2.prototype.readName = function(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      var doc = parse(source);
      return this.readNameFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readNameFromDocument(source);
    } else {
      return this.readNameFromNode(source);
    }
  };
  KML2.prototype.readNameFromDocument = function(doc) {
    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        var name_1 = this.readNameFromNode(n);
        if (name_1) {
          return name_1;
        }
      }
    }
    return void 0;
  };
  KML2.prototype.readNameFromNode = function(node) {
    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (includes(NAMESPACE_URIS2, n.namespaceURI) && n.localName == "name") {
        return readString(n);
      }
    }
    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      var localName = n.localName;
      if (includes(NAMESPACE_URIS2, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "Placemark" || localName == "kml")) {
        var name_2 = this.readNameFromNode(n);
        if (name_2) {
          return name_2;
        }
      }
    }
    return void 0;
  };
  KML2.prototype.readNetworkLinks = function(source) {
    var networkLinks = [];
    if (typeof source === "string") {
      var doc = parse(source);
      extend(networkLinks, this.readNetworkLinksFromDocument(doc));
    } else if (isDocument(source)) {
      extend(networkLinks, this.readNetworkLinksFromDocument(source));
    } else {
      extend(networkLinks, this.readNetworkLinksFromNode(source));
    }
    return networkLinks;
  };
  KML2.prototype.readNetworkLinksFromDocument = function(doc) {
    var networkLinks = [];
    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        extend(networkLinks, this.readNetworkLinksFromNode(n));
      }
    }
    return networkLinks;
  };
  KML2.prototype.readNetworkLinksFromNode = function(node) {
    var networkLinks = [];
    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (includes(NAMESPACE_URIS2, n.namespaceURI) && n.localName == "NetworkLink") {
        var obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);
        networkLinks.push(obj);
      }
    }
    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      var localName = n.localName;
      if (includes(NAMESPACE_URIS2, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
        extend(networkLinks, this.readNetworkLinksFromNode(n));
      }
    }
    return networkLinks;
  };
  KML2.prototype.readRegion = function(source) {
    var regions = [];
    if (typeof source === "string") {
      var doc = parse(source);
      extend(regions, this.readRegionFromDocument(doc));
    } else if (isDocument(source)) {
      extend(regions, this.readRegionFromDocument(source));
    } else {
      extend(regions, this.readRegionFromNode(source));
    }
    return regions;
  };
  KML2.prototype.readRegionFromDocument = function(doc) {
    var regions = [];
    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        extend(regions, this.readRegionFromNode(n));
      }
    }
    return regions;
  };
  KML2.prototype.readRegionFromNode = function(node) {
    var regions = [];
    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (includes(NAMESPACE_URIS2, n.namespaceURI) && n.localName == "Region") {
        var obj = pushParseAndPop({}, REGION_PARSERS, n, []);
        regions.push(obj);
      }
    }
    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      var localName = n.localName;
      if (includes(NAMESPACE_URIS2, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
        extend(regions, this.readRegionFromNode(n));
      }
    }
    return regions;
  };
  KML2.prototype.writeFeaturesNode = function(features, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    var kml = createElementNS(NAMESPACE_URIS2[4], "kml");
    var xmlnsUri = "http://www.w3.org/2000/xmlns/";
    kml.setAttributeNS(xmlnsUri, "xmlns:gx", GX_NAMESPACE_URIS[0]);
    kml.setAttributeNS(xmlnsUri, "xmlns:xsi", XML_SCHEMA_INSTANCE_URI);
    kml.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATION2);
    var context = {
      node: kml
    };
    var properties = {};
    if (features.length > 1) {
      properties["Document"] = features;
    } else if (features.length == 1) {
      properties["Placemark"] = features[0];
    }
    var orderedKeys = KML_SEQUENCE[kml.namespaceURI];
    var values = makeSequence(properties, orderedKeys);
    pushSerializeAndPop(context, KML_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, [opt_options], orderedKeys, this);
    return kml;
  };
  return KML2;
}(XMLFeature_default);
function createNameStyleFunction(foundStyle, name) {
  var textOffset = [0, 0];
  var textAlign = "start";
  var imageStyle = foundStyle.getImage();
  if (imageStyle) {
    var imageSize = imageStyle.getSize();
    if (imageSize && imageSize.length == 2) {
      var imageScale = imageStyle.getScaleArray();
      var anchor = imageStyle.getAnchor();
      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);
      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);
      textAlign = "left";
    }
  }
  var textStyle = foundStyle.getText();
  if (textStyle) {
    textStyle = textStyle.clone();
    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());
    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());
    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());
    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);
  } else {
    textStyle = DEFAULT_TEXT_STYLE.clone();
  }
  textStyle.setText(name);
  textStyle.setOffsetX(textOffset[0]);
  textStyle.setOffsetY(textOffset[1]);
  textStyle.setTextAlign(textAlign);
  var nameStyle = new Style_default({
    image: imageStyle,
    text: textStyle
  });
  return nameStyle;
}
function createFeatureStyleFunction(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {
  return function(feature, resolution) {
    var drawName = showPointNames;
    var name = "";
    var multiGeometryPoints = [];
    if (drawName) {
      var geometry = feature.getGeometry();
      if (geometry) {
        var type = geometry.getType();
        if (type === GeometryType_default.GEOMETRY_COLLECTION) {
          multiGeometryPoints = geometry.getGeometriesArrayRecursive().filter(function(geometry2) {
            var type2 = geometry2.getType();
            return type2 === GeometryType_default.POINT || type2 === GeometryType_default.MULTI_POINT;
          });
          drawName = multiGeometryPoints.length > 0;
        } else {
          drawName = type === GeometryType_default.POINT || type === GeometryType_default.MULTI_POINT;
        }
      }
    }
    if (drawName) {
      name = feature.get("name");
      drawName = drawName && !!name;
      if (drawName && name.search(/&[^&]+;/) > -1) {
        if (!TEXTAREA) {
          TEXTAREA = document.createElement("textarea");
        }
        TEXTAREA.innerHTML = name;
        name = TEXTAREA.value;
      }
    }
    var featureStyle = defaultStyle;
    if (style) {
      featureStyle = style;
    } else if (styleUrl) {
      featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);
    }
    if (drawName) {
      var nameStyle = createNameStyleFunction(featureStyle[0], name);
      if (multiGeometryPoints.length > 0) {
        nameStyle.setGeometry(new GeometryCollection_default(multiGeometryPoints));
        var baseStyle = new Style_default({
          geometry: featureStyle[0].getGeometry(),
          image: null,
          fill: featureStyle[0].getFill(),
          stroke: featureStyle[0].getStroke(),
          text: null
        });
        return [nameStyle, baseStyle].concat(featureStyle.slice(1));
      }
      return nameStyle;
    }
    return featureStyle;
  };
}
function findStyle(styleValue, defaultStyle, sharedStyles) {
  if (Array.isArray(styleValue)) {
    return styleValue;
  } else if (typeof styleValue === "string") {
    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);
  } else {
    return defaultStyle;
  }
}
function readColor(node) {
  var s = getAllTextContent(node, false);
  var m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);
  if (m) {
    var hexColor = m[1];
    return [
      parseInt(hexColor.substr(6, 2), 16),
      parseInt(hexColor.substr(4, 2), 16),
      parseInt(hexColor.substr(2, 2), 16),
      parseInt(hexColor.substr(0, 2), 16) / 255
    ];
  } else {
    return void 0;
  }
}
function readFlatCoordinates(node) {
  var s = getAllTextContent(node, false);
  var flatCoordinates = [];
  s = s.replace(/\s*,\s*/g, ",");
  var re = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  var m;
  while (m = re.exec(s)) {
    var x = parseFloat(m[1]);
    var y = parseFloat(m[2]);
    var z = m[3] ? parseFloat(m[3]) : 0;
    flatCoordinates.push(x, y, z);
    s = s.substr(m[0].length);
  }
  if (s !== "") {
    return void 0;
  }
  return flatCoordinates;
}
function readURI(node) {
  var s = getAllTextContent(node, false).trim();
  var baseURI = node.baseURI;
  if (!baseURI || baseURI == "about:blank") {
    baseURI = window.location.href;
  }
  if (baseURI) {
    var url = new URL(s, baseURI);
    return url.href;
  } else {
    return s;
  }
}
function readStyleURL(node) {
  var s = getAllTextContent(node, false).trim().replace(/^(?!.*#)/, "#");
  var baseURI = node.baseURI;
  if (!baseURI || baseURI == "about:blank") {
    baseURI = window.location.href;
  }
  if (baseURI) {
    var url = new URL(s, baseURI);
    return url.href;
  } else {
    return s;
  }
}
function readVec2(node) {
  var xunits = node.getAttribute("xunits");
  var yunits = node.getAttribute("yunits");
  var origin;
  if (xunits !== "insetPixels") {
    if (yunits !== "insetPixels") {
      origin = IconOrigin_default.BOTTOM_LEFT;
    } else {
      origin = IconOrigin_default.TOP_LEFT;
    }
  } else {
    if (yunits !== "insetPixels") {
      origin = IconOrigin_default.BOTTOM_RIGHT;
    } else {
      origin = IconOrigin_default.TOP_RIGHT;
    }
  }
  return {
    x: parseFloat(node.getAttribute("x")),
    xunits: ICON_ANCHOR_UNITS_MAP[xunits],
    y: parseFloat(node.getAttribute("y")),
    yunits: ICON_ANCHOR_UNITS_MAP[yunits],
    origin
  };
}
function readScale(node) {
  return readDecimal(node);
}
var STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Pair": pairDataParser
});
function readStyleMapValue(node, objectStack) {
  return pushParseAndPop(void 0, STYLE_MAP_PARSERS, node, objectStack, this);
}
var ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Icon": makeObjectPropertySetter(readIcon),
  "color": makeObjectPropertySetter(readColor),
  "heading": makeObjectPropertySetter(readDecimal),
  "hotSpot": makeObjectPropertySetter(readVec2),
  "scale": makeObjectPropertySetter(readScale)
});
function iconStyleParser(node, objectStack) {
  var object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var IconObject = "Icon" in object ? object["Icon"] : {};
  var drawIcon = !("Icon" in object) || Object.keys(IconObject).length > 0;
  var src;
  var href = IconObject["href"];
  if (href) {
    src = href;
  } else if (drawIcon) {
    src = DEFAULT_IMAGE_STYLE_SRC;
  }
  var anchor, anchorXUnits, anchorYUnits;
  var anchorOrigin = IconOrigin_default.BOTTOM_LEFT;
  var hotSpot = object["hotSpot"];
  if (hotSpot) {
    anchor = [hotSpot.x, hotSpot.y];
    anchorXUnits = hotSpot.xunits;
    anchorYUnits = hotSpot.yunits;
    anchorOrigin = hotSpot.origin;
  } else if (/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
    if (/pushpin/.test(src)) {
      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (/arrow-reverse/.test(src)) {
      anchor = [54, 42];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    } else if (/paddle/.test(src)) {
      anchor = [32, 1];
      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;
      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;
    }
  }
  var offset;
  var x = IconObject["x"];
  var y = IconObject["y"];
  if (x !== void 0 && y !== void 0) {
    offset = [x, y];
  }
  var size;
  var w = IconObject["w"];
  var h = IconObject["h"];
  if (w !== void 0 && h !== void 0) {
    size = [w, h];
  }
  var rotation;
  var heading = object["heading"];
  if (heading !== void 0) {
    rotation = toRadians(heading);
  }
  var scale = object["scale"];
  var color = object["color"];
  if (drawIcon) {
    if (src == DEFAULT_IMAGE_STYLE_SRC) {
      size = DEFAULT_IMAGE_STYLE_SIZE;
    }
    var imageStyle_1 = new Icon_default({
      anchor,
      anchorOrigin,
      anchorXUnits,
      anchorYUnits,
      crossOrigin: this.crossOrigin_,
      offset,
      offsetOrigin: IconOrigin_default.BOTTOM_LEFT,
      rotation,
      scale,
      size,
      src: this.iconUrlFunction_(src),
      color
    });
    var imageScale_1 = imageStyle_1.getScaleArray()[0];
    var imageSize = imageStyle_1.getSize();
    if (imageSize === null) {
      var imageState = imageStyle_1.getImageState();
      if (imageState === ImageState_default.IDLE || imageState === ImageState_default.LOADING) {
        var listener_1 = function() {
          var imageState2 = imageStyle_1.getImageState();
          if (!(imageState2 === ImageState_default.IDLE || imageState2 === ImageState_default.LOADING)) {
            var imageSize_1 = imageStyle_1.getSize();
            if (imageSize_1 && imageSize_1.length == 2) {
              var resizeScale2 = scaleForSize(imageSize_1);
              imageStyle_1.setScale(imageScale_1 * resizeScale2);
            }
            imageStyle_1.unlistenImageChange(listener_1);
          }
        };
        imageStyle_1.listenImageChange(listener_1);
        if (imageState === ImageState_default.IDLE) {
          imageStyle_1.load();
        }
      }
    } else if (imageSize.length == 2) {
      var resizeScale = scaleForSize(imageSize);
      imageStyle_1.setScale(imageScale_1 * resizeScale);
    }
    styleObject["imageStyle"] = imageStyle_1;
  } else {
    styleObject["imageStyle"] = DEFAULT_NO_IMAGE_STYLE;
  }
}
var LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeObjectPropertySetter(readColor),
  "scale": makeObjectPropertySetter(readScale)
});
function labelStyleParser(node, objectStack) {
  var object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var textStyle = new Text_default({
    fill: new Fill_default({
      color: "color" in object ? object["color"] : DEFAULT_COLOR
    }),
    scale: object["scale"]
  });
  styleObject["textStyle"] = textStyle;
}
var LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeObjectPropertySetter(readColor),
  "width": makeObjectPropertySetter(readDecimal)
});
function lineStyleParser(node, objectStack) {
  var object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var strokeStyle = new Stroke_default({
    color: "color" in object ? object["color"] : DEFAULT_COLOR,
    width: "width" in object ? object["width"] : 1
  });
  styleObject["strokeStyle"] = strokeStyle;
}
var POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeObjectPropertySetter(readColor),
  "fill": makeObjectPropertySetter(readBoolean),
  "outline": makeObjectPropertySetter(readBoolean)
});
function polyStyleParser(node, objectStack) {
  var object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var fillStyle = new Fill_default({
    color: "color" in object ? object["color"] : DEFAULT_COLOR
  });
  styleObject["fillStyle"] = fillStyle;
  var fill = object["fill"];
  if (fill !== void 0) {
    styleObject["fill"] = fill;
  }
  var outline = object["outline"];
  if (outline !== void 0) {
    styleObject["outline"] = outline;
  }
}
var FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "coordinates": makeReplacer(readFlatCoordinates)
});
function readFlatLinearRing(node, objectStack) {
  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);
}
function gxCoordParser(node, objectStack) {
  var gxTrackObject = objectStack[objectStack.length - 1];
  var coordinates = gxTrackObject.coordinates;
  var s = getAllTextContent(node, false);
  var re = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
  var m = re.exec(s);
  if (m) {
    var x = parseFloat(m[1]);
    var y = parseFloat(m[2]);
    var z = parseFloat(m[3]);
    coordinates.push([x, y, z]);
  } else {
    coordinates.push([]);
  }
}
var GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {
  "Track": makeArrayPusher(readGxTrack)
});
function readGxMultiTrack(node, objectStack) {
  var lineStrings = pushParseAndPop([], GX_MULTITRACK_GEOMETRY_PARSERS, node, objectStack);
  if (!lineStrings) {
    return void 0;
  }
  return new MultiLineString_default(lineStrings);
}
var GX_TRACK_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "when": whenParser
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "coord": gxCoordParser
}));
function readGxTrack(node, objectStack) {
  var gxTrackObject = pushParseAndPop({
    coordinates: [],
    whens: []
  }, GX_TRACK_PARSERS, node, objectStack);
  if (!gxTrackObject) {
    return void 0;
  }
  var flatCoordinates = [];
  var coordinates = gxTrackObject.coordinates;
  var whens = gxTrackObject.whens;
  for (var i = 0, ii = Math.min(coordinates.length, whens.length); i < ii; ++i) {
    if (coordinates[i].length == 3) {
      flatCoordinates.push(coordinates[i][0], coordinates[i][1], coordinates[i][2], whens[i]);
    }
  }
  return new LineString_default(flatCoordinates, GeometryLayout_default.XYZM);
}
var ICON_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "href": makeObjectPropertySetter(readURI)
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "x": makeObjectPropertySetter(readDecimal),
  "y": makeObjectPropertySetter(readDecimal),
  "w": makeObjectPropertySetter(readDecimal),
  "h": makeObjectPropertySetter(readDecimal)
}));
function readIcon(node, objectStack) {
  var iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);
  if (iconObject) {
    return iconObject;
  } else {
    return null;
  }
}
var GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "coordinates": makeReplacer(readFlatCoordinates)
});
function readFlatCoordinatesFromNode(node, objectStack) {
  return pushParseAndPop(null, GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack);
}
var EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "extrude": makeObjectPropertySetter(readBoolean),
  "tessellate": makeObjectPropertySetter(readBoolean),
  "altitudeMode": makeObjectPropertySetter(readString)
});
function readLineString(node, objectStack) {
  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
  var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
  if (flatCoordinates) {
    var lineString = new LineString_default(flatCoordinates, GeometryLayout_default.XYZ);
    lineString.setProperties(properties, true);
    return lineString;
  } else {
    return void 0;
  }
}
function readLinearRing(node, objectStack) {
  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
  var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
  if (flatCoordinates) {
    var polygon = new Polygon_default(flatCoordinates, GeometryLayout_default.XYZ, [
      flatCoordinates.length
    ]);
    polygon.setProperties(properties, true);
    return polygon;
  } else {
    return void 0;
  }
}
var MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "LineString": makeArrayPusher(readLineString),
  "LinearRing": makeArrayPusher(readLinearRing),
  "MultiGeometry": makeArrayPusher(readMultiGeometry),
  "Point": makeArrayPusher(readPoint),
  "Polygon": makeArrayPusher(readPolygon)
});
function readMultiGeometry(node, objectStack) {
  var geometries = pushParseAndPop([], MULTI_GEOMETRY_PARSERS, node, objectStack);
  if (!geometries) {
    return null;
  }
  if (geometries.length === 0) {
    return new GeometryCollection_default(geometries);
  }
  var multiGeometry;
  var homogeneous = true;
  var type = geometries[0].getType();
  var geometry;
  for (var i = 1, ii = geometries.length; i < ii; ++i) {
    geometry = geometries[i];
    if (geometry.getType() != type) {
      homogeneous = false;
      break;
    }
  }
  if (homogeneous) {
    var layout = void 0;
    var flatCoordinates = void 0;
    if (type == GeometryType_default.POINT) {
      var point = geometries[0];
      layout = point.getLayout();
      flatCoordinates = point.getFlatCoordinates();
      for (var i = 1, ii = geometries.length; i < ii; ++i) {
        geometry = geometries[i];
        extend(flatCoordinates, geometry.getFlatCoordinates());
      }
      multiGeometry = new MultiPoint_default(flatCoordinates, layout);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == GeometryType_default.LINE_STRING) {
      multiGeometry = new MultiLineString_default(geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == GeometryType_default.POLYGON) {
      multiGeometry = new MultiPolygon_default(geometries);
      setCommonGeometryProperties(multiGeometry, geometries);
    } else if (type == GeometryType_default.GEOMETRY_COLLECTION) {
      multiGeometry = new GeometryCollection_default(geometries);
    } else {
      assert(false, 37);
    }
  } else {
    multiGeometry = new GeometryCollection_default(geometries);
  }
  return multiGeometry;
}
function readPoint(node, objectStack) {
  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
  var flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);
  if (flatCoordinates) {
    var point = new Point_default(flatCoordinates, GeometryLayout_default.XYZ);
    point.setProperties(properties, true);
    return point;
  } else {
    return void 0;
  }
}
var FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "innerBoundaryIs": innerBoundaryIsParser,
  "outerBoundaryIs": outerBoundaryIsParser
});
function readPolygon(node, objectStack) {
  var properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);
  var flatLinearRings = pushParseAndPop([null], FLAT_LINEAR_RINGS_PARSERS, node, objectStack);
  if (flatLinearRings && flatLinearRings[0]) {
    var flatCoordinates = flatLinearRings[0];
    var ends = [flatCoordinates.length];
    for (var i = 1, ii = flatLinearRings.length; i < ii; ++i) {
      extend(flatCoordinates, flatLinearRings[i]);
      ends.push(flatCoordinates.length);
    }
    var polygon = new Polygon_default(flatCoordinates, GeometryLayout_default.XYZ, ends);
    polygon.setProperties(properties, true);
    return polygon;
  } else {
    return void 0;
  }
}
var STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "IconStyle": iconStyleParser,
  "LabelStyle": labelStyleParser,
  "LineStyle": lineStyleParser,
  "PolyStyle": polyStyleParser
});
function readStyle(node, objectStack) {
  var styleObject = pushParseAndPop({}, STYLE_PARSERS, node, objectStack, this);
  if (!styleObject) {
    return null;
  }
  var fillStyle = "fillStyle" in styleObject ? styleObject["fillStyle"] : DEFAULT_FILL_STYLE;
  var fill = styleObject["fill"];
  if (fill !== void 0 && !fill) {
    fillStyle = null;
  }
  var imageStyle;
  if ("imageStyle" in styleObject) {
    if (styleObject["imageStyle"] != DEFAULT_NO_IMAGE_STYLE) {
      imageStyle = styleObject["imageStyle"];
    }
  } else {
    imageStyle = DEFAULT_IMAGE_STYLE;
  }
  var textStyle = "textStyle" in styleObject ? styleObject["textStyle"] : DEFAULT_TEXT_STYLE;
  var strokeStyle = "strokeStyle" in styleObject ? styleObject["strokeStyle"] : DEFAULT_STROKE_STYLE;
  var outline = styleObject["outline"];
  if (outline !== void 0 && !outline) {
    return [
      new Style_default({
        geometry: function(feature) {
          var geometry = feature.getGeometry();
          var type = geometry.getType();
          if (type === GeometryType_default.GEOMETRY_COLLECTION) {
            var collection = geometry;
            return new GeometryCollection_default(collection.getGeometriesArrayRecursive().filter(function(geometry2) {
              var type2 = geometry2.getType();
              return type2 !== GeometryType_default.POLYGON && type2 !== GeometryType_default.MULTI_POLYGON;
            }));
          } else if (type !== GeometryType_default.POLYGON && type !== GeometryType_default.MULTI_POLYGON) {
            return geometry;
          }
        },
        fill: fillStyle,
        image: imageStyle,
        stroke: strokeStyle,
        text: textStyle,
        zIndex: void 0
      }),
      new Style_default({
        geometry: function(feature) {
          var geometry = feature.getGeometry();
          var type = geometry.getType();
          if (type === GeometryType_default.GEOMETRY_COLLECTION) {
            var collection = geometry;
            return new GeometryCollection_default(collection.getGeometriesArrayRecursive().filter(function(geometry2) {
              var type2 = geometry2.getType();
              return type2 === GeometryType_default.POLYGON || type2 === GeometryType_default.MULTI_POLYGON;
            }));
          } else if (type === GeometryType_default.POLYGON || type === GeometryType_default.MULTI_POLYGON) {
            return geometry;
          }
        },
        fill: fillStyle,
        stroke: null,
        zIndex: void 0
      })
    ];
  }
  return [
    new Style_default({
      fill: fillStyle,
      image: imageStyle,
      stroke: strokeStyle,
      text: textStyle,
      zIndex: void 0
    })
  ];
}
function setCommonGeometryProperties(multiGeometry, geometries) {
  var ii = geometries.length;
  var extrudes = new Array(geometries.length);
  var tessellates = new Array(geometries.length);
  var altitudeModes = new Array(geometries.length);
  var hasExtrude, hasTessellate, hasAltitudeMode;
  hasExtrude = false;
  hasTessellate = false;
  hasAltitudeMode = false;
  for (var i = 0; i < ii; ++i) {
    var geometry = geometries[i];
    extrudes[i] = geometry.get("extrude");
    tessellates[i] = geometry.get("tessellate");
    altitudeModes[i] = geometry.get("altitudeMode");
    hasExtrude = hasExtrude || extrudes[i] !== void 0;
    hasTessellate = hasTessellate || tessellates[i] !== void 0;
    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
  }
  if (hasExtrude) {
    multiGeometry.set("extrude", extrudes);
  }
  if (hasTessellate) {
    multiGeometry.set("tessellate", tessellates);
  }
  if (hasAltitudeMode) {
    multiGeometry.set("altitudeMode", altitudeModes);
  }
}
var DATA_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "displayName": makeObjectPropertySetter(readString),
  "value": makeObjectPropertySetter(readString)
});
function dataParser(node, objectStack) {
  var name = node.getAttribute("name");
  parseNode(DATA_PARSERS, node, objectStack);
  var featureObject = objectStack[objectStack.length - 1];
  if (name && featureObject.displayName) {
    featureObject[name] = {
      value: featureObject.value,
      displayName: featureObject.displayName,
      toString: function() {
        return featureObject.value;
      }
    };
  } else if (name !== null) {
    featureObject[name] = featureObject.value;
  } else if (featureObject.displayName !== null) {
    featureObject[featureObject.displayName] = featureObject.value;
  }
  delete featureObject["value"];
}
var EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Data": dataParser,
  "SchemaData": schemaDataParser
});
function extendedDataParser(node, objectStack) {
  parseNode(EXTENDED_DATA_PARSERS, node, objectStack);
}
function regionParser(node, objectStack) {
  parseNode(REGION_PARSERS, node, objectStack);
}
var PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "Style": makeObjectPropertySetter(readStyle),
  "key": makeObjectPropertySetter(readString),
  "styleUrl": makeObjectPropertySetter(readStyleURL)
});
function pairDataParser(node, objectStack) {
  var pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);
  if (!pairObject) {
    return;
  }
  var key = pairObject["key"];
  if (key && key == "normal") {
    var styleUrl = pairObject["styleUrl"];
    if (styleUrl) {
      objectStack[objectStack.length - 1] = styleUrl;
    }
    var style = pairObject["Style"];
    if (style) {
      objectStack[objectStack.length - 1] = style;
    }
  }
}
function placemarkStyleMapParser(node, objectStack) {
  var styleMapValue = readStyleMapValue.call(this, node, objectStack);
  if (!styleMapValue) {
    return;
  }
  var placemarkObject = objectStack[objectStack.length - 1];
  if (Array.isArray(styleMapValue)) {
    placemarkObject["Style"] = styleMapValue;
  } else if (typeof styleMapValue === "string") {
    placemarkObject["styleUrl"] = styleMapValue;
  } else {
    assert(false, 38);
  }
}
var SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "SimpleData": simpleDataParser
});
function schemaDataParser(node, objectStack) {
  parseNode(SCHEMA_DATA_PARSERS, node, objectStack);
}
function simpleDataParser(node, objectStack) {
  var name = node.getAttribute("name");
  if (name !== null) {
    var data = readString(node);
    var featureObject = objectStack[objectStack.length - 1];
    featureObject[name] = data;
  }
}
var LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "altitudeMode": makeObjectPropertySetter(readString),
  "minAltitude": makeObjectPropertySetter(readDecimal),
  "maxAltitude": makeObjectPropertySetter(readDecimal),
  "north": makeObjectPropertySetter(readDecimal),
  "south": makeObjectPropertySetter(readDecimal),
  "east": makeObjectPropertySetter(readDecimal),
  "west": makeObjectPropertySetter(readDecimal)
});
function latLonAltBoxParser(node, objectStack) {
  var object = pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  var regionObject = objectStack[objectStack.length - 1];
  var extent = [
    parseFloat(object["west"]),
    parseFloat(object["south"]),
    parseFloat(object["east"]),
    parseFloat(object["north"])
  ];
  regionObject["extent"] = extent;
  regionObject["altitudeMode"] = object["altitudeMode"];
  regionObject["minAltitude"] = parseFloat(object["minAltitude"]);
  regionObject["maxAltitude"] = parseFloat(object["maxAltitude"]);
}
var LOD_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "minLodPixels": makeObjectPropertySetter(readDecimal),
  "maxLodPixels": makeObjectPropertySetter(readDecimal),
  "minFadeExtent": makeObjectPropertySetter(readDecimal),
  "maxFadeExtent": makeObjectPropertySetter(readDecimal)
});
function lodParser(node, objectStack) {
  var object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);
  if (!object) {
    return;
  }
  var lodObject = objectStack[objectStack.length - 1];
  lodObject["minLodPixels"] = parseFloat(object["minLodPixels"]);
  lodObject["maxLodPixels"] = parseFloat(object["maxLodPixels"]);
  lodObject["minFadeExtent"] = parseFloat(object["minFadeExtent"]);
  lodObject["maxFadeExtent"] = parseFloat(object["maxFadeExtent"]);
}
var INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "LinearRing": makeArrayPusher(readFlatLinearRing)
});
function innerBoundaryIsParser(node, objectStack) {
  var innerBoundaryFlatLinearRings = pushParseAndPop([], INNER_BOUNDARY_IS_PARSERS, node, objectStack);
  if (innerBoundaryFlatLinearRings.length > 0) {
    var flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings.push.apply(flatLinearRings, innerBoundaryFlatLinearRings);
  }
}
var OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS2, {
  "LinearRing": makeReplacer(readFlatLinearRing)
});
function outerBoundaryIsParser(node, objectStack) {
  var flatLinearRing = pushParseAndPop(void 0, OUTER_BOUNDARY_IS_PARSERS, node, objectStack);
  if (flatLinearRing) {
    var flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings[0] = flatLinearRing;
  }
}
function linkParser(node, objectStack) {
  parseNode(LINK_PARSERS2, node, objectStack);
}
function whenParser(node, objectStack) {
  var gxTrackObject = objectStack[objectStack.length - 1];
  var whens = gxTrackObject.whens;
  var s = getAllTextContent(node, false);
  var when = Date.parse(s);
  whens.push(isNaN(when) ? 0 : when);
}
function writeColorTextNode(node, color) {
  var rgba = asArray(color);
  var opacity = rgba.length == 4 ? rgba[3] : 1;
  var abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];
  for (var i = 0; i < 4; ++i) {
    var hex = Math.floor(abgr[i]).toString(16);
    abgr[i] = hex.length == 1 ? "0" + hex : hex;
  }
  writeStringTextNode(node, abgr.join(""));
}
function writeCoordinatesTextNode(node, coordinates, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var layout = context["layout"];
  var stride = context["stride"];
  var dimension;
  if (layout == GeometryLayout_default.XY || layout == GeometryLayout_default.XYM) {
    dimension = 2;
  } else if (layout == GeometryLayout_default.XYZ || layout == GeometryLayout_default.XYZM) {
    dimension = 3;
  } else {
    assert(false, 34);
  }
  var ii = coordinates.length;
  var text = "";
  if (ii > 0) {
    text += coordinates[0];
    for (var d = 1; d < dimension; ++d) {
      text += "," + coordinates[d];
    }
    for (var i = stride; i < ii; i += stride) {
      text += " " + coordinates[i];
      for (var d = 1; d < dimension; ++d) {
        text += "," + coordinates[i + d];
      }
    }
  }
  writeStringTextNode(node, text);
}
var EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "Data": makeChildAppender(writeDataNode),
  "value": makeChildAppender(writeDataNodeValue),
  "displayName": makeChildAppender(writeDataNodeName)
});
function writeDataNode(node, pair, objectStack) {
  node.setAttribute("name", pair.name);
  var context = { node };
  var value = pair.value;
  if (typeof value == "object") {
    if (value !== null && value.displayName) {
      pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ["displayName"]);
    }
    if (value !== null && value.value) {
      pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ["value"]);
    }
  } else {
    pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ["value"]);
  }
}
function writeDataNodeName(node, name) {
  writeCDATASection(node, name);
}
function writeDataNodeValue(node, value) {
  writeStringTextNode(node, value);
}
var DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "Placemark": makeChildAppender(writePlacemark)
});
var DOCUMENT_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
  var parentNode = objectStack[objectStack.length - 1].node;
  return createElementNS(parentNode.namespaceURI, "Placemark");
};
function writeDocument(node, features, objectStack) {
  var context = { node };
  pushSerializeAndPop(context, DOCUMENT_SERIALIZERS, DOCUMENT_NODE_FACTORY, features, objectStack, void 0, this);
}
var DATA_NODE_FACTORY = makeSimpleNodeFactory("Data");
function writeExtendedData(node, namesAndValues, objectStack) {
  var context = { node };
  var names = namesAndValues.names;
  var values = namesAndValues.values;
  var length = names.length;
  for (var i = 0; i < length; i++) {
    pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, DATA_NODE_FACTORY, [{ name: names[i], value: values[i] }], objectStack);
  }
}
var ICON_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, ["href"], makeStructureNS(GX_NAMESPACE_URIS, ["x", "y", "w", "h"]));
var ICON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "href": makeChildAppender(writeStringTextNode)
}, makeStructureNS(GX_NAMESPACE_URIS, {
  "x": makeChildAppender(writeDecimalTextNode),
  "y": makeChildAppender(writeDecimalTextNode),
  "w": makeChildAppender(writeDecimalTextNode),
  "h": makeChildAppender(writeDecimalTextNode)
}));
var GX_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
  return createElementNS(GX_NAMESPACE_URIS[0], "gx:" + opt_nodeName);
};
function writeIcon(node, icon, objectStack) {
  var context = { node };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];
  var values = makeSequence(icon, orderedKeys);
  pushSerializeAndPop(context, ICON_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];
  values = makeSequence(icon, orderedKeys);
  pushSerializeAndPop(context, ICON_SERIALIZERS, GX_NODE_FACTORY, values, objectStack, orderedKeys);
}
var ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "scale",
  "heading",
  "Icon",
  "color",
  "hotSpot"
]);
var ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "Icon": makeChildAppender(writeIcon),
  "color": makeChildAppender(writeColorTextNode),
  "heading": makeChildAppender(writeDecimalTextNode),
  "hotSpot": makeChildAppender(writeVec2),
  "scale": makeChildAppender(writeScaleTextNode)
});
function writeIconStyle(node, style, objectStack) {
  var context = { node };
  var properties = {};
  var src = style.getSrc();
  var size = style.getSize();
  var iconImageSize = style.getImageSize();
  var iconProperties = {
    "href": src
  };
  if (size) {
    iconProperties["w"] = size[0];
    iconProperties["h"] = size[1];
    var anchor = style.getAnchor();
    var origin_1 = style.getOrigin();
    if (origin_1 && iconImageSize && origin_1[0] !== 0 && origin_1[1] !== size[1]) {
      iconProperties["x"] = origin_1[0];
      iconProperties["y"] = iconImageSize[1] - (origin_1[1] + size[1]);
    }
    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
      var hotSpot = {
        x: anchor[0],
        xunits: IconAnchorUnits_default.PIXELS,
        y: size[1] - anchor[1],
        yunits: IconAnchorUnits_default.PIXELS
      };
      properties["hotSpot"] = hotSpot;
    }
  }
  properties["Icon"] = iconProperties;
  var scale = style.getScaleArray()[0];
  var imageSize = size;
  if (imageSize === null) {
    imageSize = DEFAULT_IMAGE_STYLE_SIZE;
  }
  if (imageSize.length == 2) {
    var resizeScale = scaleForSize(imageSize);
    scale = scale / resizeScale;
  }
  if (scale !== 1) {
    properties["scale"] = scale;
  }
  var rotation = style.getRotation();
  if (rotation !== 0) {
    properties["heading"] = rotation;
  }
  var color = style.getColor();
  if (color) {
    properties["color"] = color;
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, ICON_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
var LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "color",
  "scale"
]);
var LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeChildAppender(writeColorTextNode),
  "scale": makeChildAppender(writeScaleTextNode)
});
function writeLabelStyle(node, style, objectStack) {
  var context = { node };
  var properties = {};
  var fill = style.getFill();
  if (fill) {
    properties["color"] = fill.getColor();
  }
  var scale = style.getScale();
  if (scale && scale !== 1) {
    properties["scale"] = scale;
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, LABEL_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
var LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, ["color", "width"]);
var LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeChildAppender(writeColorTextNode),
  "width": makeChildAppender(writeDecimalTextNode)
});
function writeLineStyle(node, style, objectStack) {
  var context = { node };
  var properties = {
    "color": style.getColor(),
    "width": Number(style.getWidth()) || 1
  };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, LINE_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
var GEOMETRY_TYPE_TO_NODENAME2 = {
  "Point": "Point",
  "LineString": "LineString",
  "LinearRing": "LinearRing",
  "Polygon": "Polygon",
  "MultiPoint": "MultiGeometry",
  "MultiLineString": "MultiGeometry",
  "MultiPolygon": "MultiGeometry",
  "GeometryCollection": "MultiGeometry"
};
var GEOMETRY_NODE_FACTORY = function(value, objectStack, opt_nodeName) {
  if (value) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return createElementNS(parentNode.namespaceURI, GEOMETRY_TYPE_TO_NODENAME2[value.getType()]);
  }
};
var POINT_NODE_FACTORY = makeSimpleNodeFactory("Point");
var LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory("LineString");
var LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory("LinearRing");
var POLYGON_NODE_FACTORY = makeSimpleNodeFactory("Polygon");
var MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "LineString": makeChildAppender(writePrimitiveGeometry),
  "Point": makeChildAppender(writePrimitiveGeometry),
  "Polygon": makeChildAppender(writePolygon),
  "GeometryCollection": makeChildAppender(writeMultiGeometry)
});
function writeMultiGeometry(node, geometry, objectStack) {
  var context = { node };
  var type = geometry.getType();
  var geometries = [];
  var factory;
  if (type === GeometryType_default.GEOMETRY_COLLECTION) {
    geometry.getGeometriesArrayRecursive().forEach(function(geometry2) {
      var type2 = geometry2.getType();
      if (type2 === GeometryType_default.MULTI_POINT) {
        geometries = geometries.concat(geometry2.getPoints());
      } else if (type2 === GeometryType_default.MULTI_LINE_STRING) {
        geometries = geometries.concat(geometry2.getLineStrings());
      } else if (type2 === GeometryType_default.MULTI_POLYGON) {
        geometries = geometries.concat(geometry2.getPolygons());
      } else if (type2 === GeometryType_default.POINT || type2 === GeometryType_default.LINE_STRING || type2 === GeometryType_default.POLYGON) {
        geometries.push(geometry2);
      } else {
        assert(false, 39);
      }
    });
    factory = GEOMETRY_NODE_FACTORY;
  } else if (type === GeometryType_default.MULTI_POINT) {
    geometries = geometry.getPoints();
    factory = POINT_NODE_FACTORY;
  } else if (type === GeometryType_default.MULTI_LINE_STRING) {
    geometries = geometry.getLineStrings();
    factory = LINE_STRING_NODE_FACTORY;
  } else if (type === GeometryType_default.MULTI_POLYGON) {
    geometries = geometry.getPolygons();
    factory = POLYGON_NODE_FACTORY;
  } else {
    assert(false, 39);
  }
  pushSerializeAndPop(context, MULTI_GEOMETRY_SERIALIZERS, factory, geometries, objectStack);
}
var BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "LinearRing": makeChildAppender(writePrimitiveGeometry)
});
function writeBoundaryIs(node, linearRing, objectStack) {
  var context = { node };
  pushSerializeAndPop(context, BOUNDARY_IS_SERIALIZERS, LINEAR_RING_NODE_FACTORY, [linearRing], objectStack);
}
var PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "ExtendedData": makeChildAppender(writeExtendedData),
  "MultiGeometry": makeChildAppender(writeMultiGeometry),
  "LineString": makeChildAppender(writePrimitiveGeometry),
  "LinearRing": makeChildAppender(writePrimitiveGeometry),
  "Point": makeChildAppender(writePrimitiveGeometry),
  "Polygon": makeChildAppender(writePolygon),
  "Style": makeChildAppender(writeStyle),
  "address": makeChildAppender(writeStringTextNode),
  "description": makeChildAppender(writeStringTextNode),
  "name": makeChildAppender(writeStringTextNode),
  "open": makeChildAppender(writeBooleanTextNode),
  "phoneNumber": makeChildAppender(writeStringTextNode),
  "styleUrl": makeChildAppender(writeStringTextNode),
  "visibility": makeChildAppender(writeBooleanTextNode)
});
var PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "name",
  "open",
  "visibility",
  "address",
  "phoneNumber",
  "description",
  "styleUrl",
  "Style"
]);
var EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory("ExtendedData");
function writePlacemark(node, feature, objectStack) {
  var context = { node };
  if (feature.getId()) {
    node.setAttribute("id", feature.getId());
  }
  var properties = feature.getProperties();
  var filter = {
    "address": 1,
    "description": 1,
    "name": 1,
    "open": 1,
    "phoneNumber": 1,
    "styleUrl": 1,
    "visibility": 1
  };
  filter[feature.getGeometryName()] = 1;
  var keys = Object.keys(properties || {}).sort().filter(function(v) {
    return !filter[v];
  });
  var styleFunction = feature.getStyleFunction();
  if (styleFunction) {
    var styles = styleFunction(feature, 0);
    if (styles) {
      var styleArray = Array.isArray(styles) ? styles : [styles];
      var pointStyles = styleArray;
      if (feature.getGeometry()) {
        pointStyles = styleArray.filter(function(style) {
          var geometry2 = style.getGeometryFunction()(feature);
          if (geometry2) {
            var type = geometry2.getType();
            if (type === GeometryType_default.GEOMETRY_COLLECTION) {
              return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                var type2 = geometry3.getType();
                return type2 === GeometryType_default.POINT || type2 === GeometryType_default.MULTI_POINT;
              }).length;
            }
            return type === GeometryType_default.POINT || type === GeometryType_default.MULTI_POINT;
          }
        });
      }
      if (this.writeStyles_) {
        var lineStyles = styleArray;
        var polyStyles = styleArray;
        if (feature.getGeometry()) {
          lineStyles = styleArray.filter(function(style) {
            var geometry2 = style.getGeometryFunction()(feature);
            if (geometry2) {
              var type = geometry2.getType();
              if (type === GeometryType_default.GEOMETRY_COLLECTION) {
                return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                  var type2 = geometry3.getType();
                  return type2 === GeometryType_default.LINE_STRING || type2 === GeometryType_default.MULTI_LINE_STRING;
                }).length;
              }
              return type === GeometryType_default.LINE_STRING || type === GeometryType_default.MULTI_LINE_STRING;
            }
          });
          polyStyles = styleArray.filter(function(style) {
            var geometry2 = style.getGeometryFunction()(feature);
            if (geometry2) {
              var type = geometry2.getType();
              if (type === GeometryType_default.GEOMETRY_COLLECTION) {
                return geometry2.getGeometriesArrayRecursive().filter(function(geometry3) {
                  var type2 = geometry3.getType();
                  return type2 === GeometryType_default.POLYGON || type2 === GeometryType_default.MULTI_POLYGON;
                }).length;
              }
              return type === GeometryType_default.POLYGON || type === GeometryType_default.MULTI_POLYGON;
            }
          });
        }
        properties["Style"] = {
          pointStyles,
          lineStyles,
          polyStyles
        };
      }
      if (pointStyles.length && properties["name"] === void 0) {
        var textStyle = pointStyles[0].getText();
        if (textStyle) {
          properties["name"] = textStyle.getText();
        }
      }
    }
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];
  var values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
  if (keys.length > 0) {
    var sequence = makeSequence(properties, keys);
    var namesAndValues = { names: keys, values: sequence };
    pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);
  }
  var options = objectStack[0];
  var geometry = feature.getGeometry();
  if (geometry) {
    geometry = transformGeometryWithOptions(geometry, true, options);
  }
  pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, GEOMETRY_NODE_FACTORY, [geometry], objectStack);
}
var PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "extrude",
  "tessellate",
  "altitudeMode",
  "coordinates"
]);
var PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "extrude": makeChildAppender(writeBooleanTextNode),
  "tessellate": makeChildAppender(writeBooleanTextNode),
  "altitudeMode": makeChildAppender(writeStringTextNode),
  "coordinates": makeChildAppender(writeCoordinatesTextNode)
});
function writePrimitiveGeometry(node, geometry, objectStack) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var context = { node };
  context["layout"] = geometry.getLayout();
  context["stride"] = geometry.getStride();
  var properties = geometry.getProperties();
  properties.coordinates = flatCoordinates;
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];
  var values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, PRIMITIVE_GEOMETRY_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
var POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "color",
  "fill",
  "outline"
]);
var POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "outerBoundaryIs": makeChildAppender(writeBoundaryIs),
  "innerBoundaryIs": makeChildAppender(writeBoundaryIs)
});
var INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("innerBoundaryIs");
var OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory("outerBoundaryIs");
function writePolygon(node, polygon, objectStack) {
  var linearRings = polygon.getLinearRings();
  var outerRing = linearRings.shift();
  var context = { node };
  pushSerializeAndPop(context, POLYGON_SERIALIZERS, INNER_BOUNDARY_NODE_FACTORY, linearRings, objectStack);
  pushSerializeAndPop(context, POLYGON_SERIALIZERS, OUTER_BOUNDARY_NODE_FACTORY, [outerRing], objectStack);
}
var POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "color": makeChildAppender(writeColorTextNode),
  "fill": makeChildAppender(writeBooleanTextNode),
  "outline": makeChildAppender(writeBooleanTextNode)
});
function writePolyStyle(node, style, objectStack) {
  var context = { node };
  var fill = style.getFill();
  var stroke = style.getStroke();
  var properties = {
    "color": fill ? fill.getColor() : void 0,
    "fill": fill ? void 0 : false,
    "outline": stroke ? void 0 : false
  };
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];
  var values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, POLY_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
function writeScaleTextNode(node, scale) {
  writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);
}
var STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS2, [
  "IconStyle",
  "LabelStyle",
  "LineStyle",
  "PolyStyle"
]);
var STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS2, {
  "IconStyle": makeChildAppender(writeIconStyle),
  "LabelStyle": makeChildAppender(writeLabelStyle),
  "LineStyle": makeChildAppender(writeLineStyle),
  "PolyStyle": makeChildAppender(writePolyStyle)
});
function writeStyle(node, styles, objectStack) {
  var context = { node };
  var properties = {};
  if (styles.pointStyles.length) {
    var textStyle = styles.pointStyles[0].getText();
    if (textStyle) {
      properties["LabelStyle"] = textStyle;
    }
    var imageStyle = styles.pointStyles[0].getImage();
    if (imageStyle && typeof imageStyle.getSrc === "function") {
      properties["IconStyle"] = imageStyle;
    }
  }
  if (styles.lineStyles.length) {
    var strokeStyle = styles.lineStyles[0].getStroke();
    if (strokeStyle) {
      properties["LineStyle"] = strokeStyle;
    }
  }
  if (styles.polyStyles.length) {
    var strokeStyle = styles.polyStyles[0].getStroke();
    if (strokeStyle && !properties["LineStyle"]) {
      properties["LineStyle"] = strokeStyle;
    }
    properties["PolyStyle"] = styles.polyStyles[0];
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];
  var values = makeSequence(properties, orderedKeys);
  pushSerializeAndPop(context, STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
}
function writeVec2(node, vec2) {
  node.setAttribute("x", String(vec2.x));
  node.setAttribute("y", String(vec2.y));
  node.setAttribute("xunits", vec2.xunits);
  node.setAttribute("yunits", vec2.yunits);
}
var KML_default = KML;

// node_modules/ol/format/MVT.js
var import_pbf = __toModule(require_pbf());

// node_modules/ol/render/Feature.js
var tmpTransform = create();
var RenderFeature = function() {
  function RenderFeature2(type, flatCoordinates, ends, properties, id) {
    this.styleFunction;
    this.extent_;
    this.id_ = id;
    this.type_ = type;
    this.flatCoordinates_ = flatCoordinates;
    this.flatInteriorPoints_ = null;
    this.flatMidpoints_ = null;
    this.ends_ = ends;
    this.properties_ = properties;
  }
  RenderFeature2.prototype.get = function(key) {
    return this.properties_[key];
  };
  RenderFeature2.prototype.getExtent = function() {
    if (!this.extent_) {
      this.extent_ = this.type_ === GeometryType_default.POINT ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
    }
    return this.extent_;
  };
  RenderFeature2.prototype.getFlatInteriorPoint = function() {
    if (!this.flatInteriorPoints_) {
      var flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoints_ = getInteriorPointOfArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenter, 0);
    }
    return this.flatInteriorPoints_;
  };
  RenderFeature2.prototype.getFlatInteriorPoints = function() {
    if (!this.flatInteriorPoints_) {
      var flatCenters = linearRingss(this.flatCoordinates_, 0, this.ends_, 2);
      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.flatCoordinates_, 0, this.ends_, 2, flatCenters);
    }
    return this.flatInteriorPoints_;
  };
  RenderFeature2.prototype.getFlatMidpoint = function() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = interpolatePoint(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
    }
    return this.flatMidpoints_;
  };
  RenderFeature2.prototype.getFlatMidpoints = function() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      var flatCoordinates = this.flatCoordinates_;
      var offset = 0;
      var ends = this.ends_;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var midpoint = interpolatePoint(flatCoordinates, offset, end, 2, 0.5);
        extend(this.flatMidpoints_, midpoint);
        offset = end;
      }
    }
    return this.flatMidpoints_;
  };
  RenderFeature2.prototype.getId = function() {
    return this.id_;
  };
  RenderFeature2.prototype.getOrientedFlatCoordinates = function() {
    return this.flatCoordinates_;
  };
  RenderFeature2.prototype.getGeometry = function() {
    return this;
  };
  RenderFeature2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
    return this;
  };
  RenderFeature2.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {
    return this;
  };
  RenderFeature2.prototype.getProperties = function() {
    return this.properties_;
  };
  RenderFeature2.prototype.getStride = function() {
    return 2;
  };
  RenderFeature2.prototype.getStyleFunction = function() {
    return this.styleFunction;
  };
  RenderFeature2.prototype.getType = function() {
    return this.type_;
  };
  RenderFeature2.prototype.transform = function(projection) {
    projection = get(projection);
    var pixelExtent = projection.getExtent();
    var projectedExtent = projection.getWorldExtent();
    if (pixelExtent && projectedExtent) {
      var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
      transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);
    }
  };
  RenderFeature2.prototype.getEnds = function() {
    return this.ends_;
  };
  return RenderFeature2;
}();
RenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;
RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
var Feature_default3 = RenderFeature;

// node_modules/ol/format/MVT.js
var __extends13 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MVT = function(_super) {
  __extends13(MVT2, _super);
  function MVT2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.dataProjection = new Projection_default({
      code: "",
      units: Units_default.TILE_PIXELS
    });
    _this.featureClass_ = options.featureClass ? options.featureClass : Feature_default3;
    _this.geometryName_ = options.geometryName;
    _this.layerName_ = options.layerName ? options.layerName : "layer";
    _this.layers_ = options.layers ? options.layers : null;
    _this.idProperty_ = options.idProperty;
    _this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
    return _this;
  }
  MVT2.prototype.readRawGeometry_ = function(pbf, feature, flatCoordinates, ends) {
    pbf.pos = feature.geometry;
    var end = pbf.readVarint() + pbf.pos;
    var cmd = 1;
    var length = 0;
    var x = 0;
    var y = 0;
    var coordsLen = 0;
    var currentEnd = 0;
    while (pbf.pos < end) {
      if (!length) {
        var cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length = cmdLen >> 3;
      }
      length--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (cmd === 1) {
          if (coordsLen > currentEnd) {
            ends.push(coordsLen);
            currentEnd = coordsLen;
          }
        }
        flatCoordinates.push(x, y);
        coordsLen += 2;
      } else if (cmd === 7) {
        if (coordsLen > currentEnd) {
          flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);
          coordsLen += 2;
        }
      } else {
        assert(false, 59);
      }
    }
    if (coordsLen > currentEnd) {
      ends.push(coordsLen);
      currentEnd = coordsLen;
    }
  };
  MVT2.prototype.createFeature_ = function(pbf, rawFeature, options) {
    var type = rawFeature.type;
    if (type === 0) {
      return null;
    }
    var feature;
    var values = rawFeature.properties;
    var id;
    if (!this.idProperty_) {
      id = rawFeature.id;
    } else {
      id = values[this.idProperty_];
      delete values[this.idProperty_];
    }
    values[this.layerName_] = rawFeature.layer.name;
    var flatCoordinates = [];
    var ends = [];
    this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);
    var geometryType = getGeometryType(type, ends.length);
    if (this.featureClass_ === Feature_default3) {
      feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);
      feature.transform(options.dataProjection);
    } else {
      var geom = void 0;
      if (geometryType == GeometryType_default.POLYGON) {
        var endss = [];
        var offset = 0;
        var prevEndIndex = 0;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {
            endss.push(ends.slice(prevEndIndex, i + 1));
          } else {
            if (endss.length === 0) {
              continue;
            }
            endss[endss.length - 1].push(ends[prevEndIndex]);
          }
          prevEndIndex = i + 1;
          offset = end;
        }
        if (endss.length > 1) {
          geom = new MultiPolygon_default(flatCoordinates, GeometryLayout_default.XY, endss);
        } else {
          geom = new Polygon_default(flatCoordinates, GeometryLayout_default.XY, ends);
        }
      } else {
        geom = geometryType === GeometryType_default.POINT ? new Point_default(flatCoordinates, GeometryLayout_default.XY) : geometryType === GeometryType_default.LINE_STRING ? new LineString_default(flatCoordinates, GeometryLayout_default.XY) : geometryType === GeometryType_default.POLYGON ? new Polygon_default(flatCoordinates, GeometryLayout_default.XY, ends) : geometryType === GeometryType_default.MULTI_POINT ? new MultiPoint_default(flatCoordinates, GeometryLayout_default.XY) : geometryType === GeometryType_default.MULTI_LINE_STRING ? new MultiLineString_default(flatCoordinates, GeometryLayout_default.XY, ends) : null;
      }
      var ctor = this.featureClass_;
      feature = new ctor();
      if (this.geometryName_) {
        feature.setGeometryName(this.geometryName_);
      }
      var geometry = transformGeometryWithOptions(geom, false, options);
      feature.setGeometry(geometry);
      feature.setId(id);
      feature.setProperties(values, true);
    }
    return feature;
  };
  MVT2.prototype.getType = function() {
    return FormatType_default.ARRAY_BUFFER;
  };
  MVT2.prototype.readFeatures = function(source, opt_options) {
    var layers = this.layers_;
    var options = this.adaptOptions(opt_options);
    var dataProjection = get(options.dataProjection);
    dataProjection.setWorldExtent(options.extent);
    options.dataProjection = dataProjection;
    var pbf = new import_pbf.default(source);
    var pbfLayers = pbf.readFields(layersPBFReader, {});
    var features = [];
    for (var name_1 in pbfLayers) {
      if (layers && layers.indexOf(name_1) == -1) {
        continue;
      }
      var pbfLayer = pbfLayers[name_1];
      var extent = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;
      dataProjection.setExtent(extent);
      for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {
        var rawFeature = readRawFeature(pbf, pbfLayer, i);
        var feature = this.createFeature_(pbf, rawFeature, options);
        if (feature !== null) {
          features.push(feature);
        }
      }
    }
    return features;
  };
  MVT2.prototype.readProjection = function(source) {
    return this.dataProjection;
  };
  MVT2.prototype.setLayers = function(layers) {
    this.layers_ = layers;
  };
  return MVT2;
}(Feature_default2);
function layersPBFReader(tag, layers, pbf) {
  if (tag === 3) {
    var layer = {
      keys: [],
      values: [],
      features: []
    };
    var end = pbf.readVarint() + pbf.pos;
    pbf.readFields(layerPBFReader, layer, end);
    layer.length = layer.features.length;
    if (layer.length) {
      layers[layer.name] = layer;
    }
  }
}
function layerPBFReader(tag, layer, pbf) {
  if (tag === 15) {
    layer.version = pbf.readVarint();
  } else if (tag === 1) {
    layer.name = pbf.readString();
  } else if (tag === 5) {
    layer.extent = pbf.readVarint();
  } else if (tag === 2) {
    layer.features.push(pbf.pos);
  } else if (tag === 3) {
    layer.keys.push(pbf.readString());
  } else if (tag === 4) {
    var value = null;
    var end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    layer.values.push(value);
  }
}
function featurePBFReader(tag, feature, pbf) {
  if (tag == 1) {
    feature.id = pbf.readVarint();
  } else if (tag == 2) {
    var end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      var key = feature.layer.keys[pbf.readVarint()];
      var value = feature.layer.values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  } else if (tag == 3) {
    feature.type = pbf.readVarint();
  } else if (tag == 4) {
    feature.geometry = pbf.pos;
  }
}
function readRawFeature(pbf, layer, i) {
  pbf.pos = layer.features[i];
  var end = pbf.readVarint() + pbf.pos;
  var feature = {
    layer,
    type: 0,
    properties: {}
  };
  pbf.readFields(featurePBFReader, feature, end);
  return feature;
}
function getGeometryType(type, numEnds) {
  var geometryType;
  if (type === 1) {
    geometryType = numEnds === 1 ? GeometryType_default.POINT : GeometryType_default.MULTI_POINT;
  } else if (type === 2) {
    geometryType = numEnds === 1 ? GeometryType_default.LINE_STRING : GeometryType_default.MULTI_LINE_STRING;
  } else if (type === 3) {
    geometryType = GeometryType_default.POLYGON;
  }
  return geometryType;
}
var MVT_default = MVT;

// node_modules/ol/format/XML.js
var XML = function() {
  function XML2() {
  }
  XML2.prototype.read = function(source) {
    if (!source) {
      return null;
    } else if (typeof source === "string") {
      var doc = parse(source);
      return this.readFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readFromDocument(source);
    } else {
      return this.readFromNode(source);
    }
  };
  XML2.prototype.readFromDocument = function(doc) {
    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readFromNode(n);
      }
    }
    return null;
  };
  XML2.prototype.readFromNode = function(node) {
  };
  return XML2;
}();
var XML_default = XML;

// node_modules/ol/format/xlink.js
var NAMESPACE_URI = "http://www.w3.org/1999/xlink";
function readHref(node) {
  return node.getAttributeNS(NAMESPACE_URI, "href");
}

// node_modules/ol/format/OWS.js
var __extends14 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NAMESPACE_URIS3 = [null, "http://www.opengis.net/ows/1.1"];
var PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "ServiceIdentification": makeObjectPropertySetter(readServiceIdentification),
  "ServiceProvider": makeObjectPropertySetter(readServiceProvider),
  "OperationsMetadata": makeObjectPropertySetter(readOperationsMetadata)
});
var OWS = function(_super) {
  __extends14(OWS2, _super);
  function OWS2() {
    return _super.call(this) || this;
  }
  OWS2.prototype.readFromNode = function(node) {
    var owsObject = pushParseAndPop({}, PARSERS, node, []);
    return owsObject ? owsObject : null;
  };
  return OWS2;
}(XML_default);
var ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "DeliveryPoint": makeObjectPropertySetter(readString),
  "City": makeObjectPropertySetter(readString),
  "AdministrativeArea": makeObjectPropertySetter(readString),
  "PostalCode": makeObjectPropertySetter(readString),
  "Country": makeObjectPropertySetter(readString),
  "ElectronicMailAddress": makeObjectPropertySetter(readString)
});
var ALLOWED_VALUES_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Value": makeObjectPropertyPusher(readValue)
});
var CONSTRAINT_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "AllowedValues": makeObjectPropertySetter(readAllowedValues)
});
var CONTACT_INFO_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Phone": makeObjectPropertySetter(readPhone),
  "Address": makeObjectPropertySetter(readAddress)
});
var DCP_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "HTTP": makeObjectPropertySetter(readHttp)
});
var HTTP_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Get": makeObjectPropertyPusher(readGet),
  "Post": void 0
});
var OPERATION_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "DCP": makeObjectPropertySetter(readDcp)
});
var OPERATIONS_METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Operation": readOperation
});
var PHONE_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Voice": makeObjectPropertySetter(readString),
  "Facsimile": makeObjectPropertySetter(readString)
});
var REQUEST_METHOD_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Constraint": makeObjectPropertyPusher(readConstraint)
});
var SERVICE_CONTACT_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "IndividualName": makeObjectPropertySetter(readString),
  "PositionName": makeObjectPropertySetter(readString),
  "ContactInfo": makeObjectPropertySetter(readContactInfo)
});
var SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "Abstract": makeObjectPropertySetter(readString),
  "AccessConstraints": makeObjectPropertySetter(readString),
  "Fees": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "ServiceTypeVersion": makeObjectPropertySetter(readString),
  "ServiceType": makeObjectPropertySetter(readString)
});
var SERVICE_PROVIDER_PARSERS = makeStructureNS(NAMESPACE_URIS3, {
  "ProviderName": makeObjectPropertySetter(readString),
  "ProviderSite": makeObjectPropertySetter(readHref),
  "ServiceContact": makeObjectPropertySetter(readServiceContact)
});
function readAddress(node, objectStack) {
  return pushParseAndPop({}, ADDRESS_PARSERS, node, objectStack);
}
function readAllowedValues(node, objectStack) {
  return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node, objectStack);
}
function readConstraint(node, objectStack) {
  var name = node.getAttribute("name");
  if (!name) {
    return void 0;
  }
  return pushParseAndPop({ "name": name }, CONSTRAINT_PARSERS, node, objectStack);
}
function readContactInfo(node, objectStack) {
  return pushParseAndPop({}, CONTACT_INFO_PARSERS, node, objectStack);
}
function readDcp(node, objectStack) {
  return pushParseAndPop({}, DCP_PARSERS, node, objectStack);
}
function readGet(node, objectStack) {
  var href = readHref(node);
  if (!href) {
    return void 0;
  }
  return pushParseAndPop({ "href": href }, REQUEST_METHOD_PARSERS, node, objectStack);
}
function readHttp(node, objectStack) {
  return pushParseAndPop({}, HTTP_PARSERS, node, objectStack);
}
function readOperation(node, objectStack) {
  var name = node.getAttribute("name");
  var value = pushParseAndPop({}, OPERATION_PARSERS, node, objectStack);
  if (!value) {
    return void 0;
  }
  var object = objectStack[objectStack.length - 1];
  object[name] = value;
}
function readOperationsMetadata(node, objectStack) {
  return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node, objectStack);
}
function readPhone(node, objectStack) {
  return pushParseAndPop({}, PHONE_PARSERS, node, objectStack);
}
function readServiceIdentification(node, objectStack) {
  return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);
}
function readServiceContact(node, objectStack) {
  return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node, objectStack);
}
function readServiceProvider(node, objectStack) {
  return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node, objectStack);
}
function readValue(node, objectStack) {
  return readString(node);
}
var OWS_default = OWS;

// node_modules/ol/geom/flat/flip.js
function flipXY(flatCoordinates, offset, end, stride, opt_dest, opt_destOffset) {
  var dest, destOffset;
  if (opt_dest !== void 0) {
    dest = opt_dest;
    destOffset = opt_destOffset !== void 0 ? opt_destOffset : 0;
  } else {
    dest = [];
    destOffset = 0;
  }
  var j = offset;
  while (j < end) {
    var x = flatCoordinates[j++];
    dest[destOffset++] = flatCoordinates[j++];
    dest[destOffset++] = x;
    for (var k = 2; k < stride; ++k) {
      dest[destOffset++] = flatCoordinates[j++];
    }
  }
  dest.length = destOffset;
  return dest;
}

// node_modules/ol/format/Polyline.js
var __extends15 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Polyline = function(_super) {
  __extends15(Polyline2, _super);
  function Polyline2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.dataProjection = get("EPSG:4326");
    _this.factor_ = options.factor ? options.factor : 1e5;
    _this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : GeometryLayout_default.XY;
    return _this;
  }
  Polyline2.prototype.readFeatureFromText = function(text, opt_options) {
    var geometry = this.readGeometryFromText(text, opt_options);
    return new Feature_default(geometry);
  };
  Polyline2.prototype.readFeaturesFromText = function(text, opt_options) {
    var feature = this.readFeatureFromText(text, opt_options);
    return [feature];
  };
  Polyline2.prototype.readGeometryFromText = function(text, opt_options) {
    var stride = getStrideForLayout(this.geometryLayout_);
    var flatCoordinates = decodeDeltas(text, stride, this.factor_);
    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    var coordinates = inflateCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
    var lineString = new LineString_default(coordinates, this.geometryLayout_);
    return transformGeometryWithOptions(lineString, false, this.adaptOptions(opt_options));
  };
  Polyline2.prototype.writeFeatureText = function(feature, opt_options) {
    var geometry = feature.getGeometry();
    if (geometry) {
      return this.writeGeometryText(geometry, opt_options);
    } else {
      assert(false, 40);
      return "";
    }
  };
  Polyline2.prototype.writeFeaturesText = function(features, opt_options) {
    return this.writeFeatureText(features[0], opt_options);
  };
  Polyline2.prototype.writeGeometryText = function(geometry, opt_options) {
    geometry = transformGeometryWithOptions(geometry, true, this.adaptOptions(opt_options));
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
    return encodeDeltas(flatCoordinates, stride, this.factor_);
  };
  return Polyline2;
}(TextFeature_default);
function encodeDeltas(numbers, stride, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var d;
  var lastNumbers = new Array(stride);
  for (d = 0; d < stride; ++d) {
    lastNumbers[d] = 0;
  }
  for (var i = 0, ii = numbers.length; i < ii; ) {
    for (d = 0; d < stride; ++d, ++i) {
      var num = numbers[i];
      var delta = num - lastNumbers[d];
      lastNumbers[d] = num;
      numbers[i] = delta;
    }
  }
  return encodeFloats(numbers, factor);
}
function decodeDeltas(encoded, stride, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var d;
  var lastNumbers = new Array(stride);
  for (d = 0; d < stride; ++d) {
    lastNumbers[d] = 0;
  }
  var numbers = decodeFloats(encoded, factor);
  for (var i = 0, ii = numbers.length; i < ii; ) {
    for (d = 0; d < stride; ++d, ++i) {
      lastNumbers[d] += numbers[i];
      numbers[i] = lastNumbers[d];
    }
  }
  return numbers;
}
function encodeFloats(numbers, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  for (var i = 0, ii = numbers.length; i < ii; ++i) {
    numbers[i] = Math.round(numbers[i] * factor);
  }
  return encodeSignedIntegers(numbers);
}
function decodeFloats(encoded, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var numbers = decodeSignedIntegers(encoded);
  for (var i = 0, ii = numbers.length; i < ii; ++i) {
    numbers[i] /= factor;
  }
  return numbers;
}
function encodeSignedIntegers(numbers) {
  for (var i = 0, ii = numbers.length; i < ii; ++i) {
    var num = numbers[i];
    numbers[i] = num < 0 ? ~(num << 1) : num << 1;
  }
  return encodeUnsignedIntegers(numbers);
}
function decodeSignedIntegers(encoded) {
  var numbers = decodeUnsignedIntegers(encoded);
  for (var i = 0, ii = numbers.length; i < ii; ++i) {
    var num = numbers[i];
    numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;
  }
  return numbers;
}
function encodeUnsignedIntegers(numbers) {
  var encoded = "";
  for (var i = 0, ii = numbers.length; i < ii; ++i) {
    encoded += encodeUnsignedInteger(numbers[i]);
  }
  return encoded;
}
function decodeUnsignedIntegers(encoded) {
  var numbers = [];
  var current = 0;
  var shift = 0;
  for (var i = 0, ii = encoded.length; i < ii; ++i) {
    var b = encoded.charCodeAt(i) - 63;
    current |= (b & 31) << shift;
    if (b < 32) {
      numbers.push(current);
      current = 0;
      shift = 0;
    } else {
      shift += 5;
    }
  }
  return numbers;
}
function encodeUnsignedInteger(num) {
  var value, encoded = "";
  while (num >= 32) {
    value = (32 | num & 31) + 63;
    encoded += String.fromCharCode(value);
    num >>= 5;
  }
  value = num + 63;
  encoded += String.fromCharCode(value);
  return encoded;
}
var Polyline_default = Polyline;

// node_modules/ol/format/TopoJSON.js
var __extends16 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TopoJSON = function(_super) {
  __extends16(TopoJSON2, _super);
  function TopoJSON2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.layerName_ = options.layerName;
    _this.layers_ = options.layers ? options.layers : null;
    _this.dataProjection = get(options.dataProjection ? options.dataProjection : "EPSG:4326");
    return _this;
  }
  TopoJSON2.prototype.readFeaturesFromObject = function(object, opt_options) {
    if (object.type == "Topology") {
      var topoJSONTopology = object;
      var transform = void 0, scale = null, translate = null;
      if (topoJSONTopology["transform"]) {
        transform = topoJSONTopology["transform"];
        scale = transform["scale"];
        translate = transform["translate"];
      }
      var arcs = topoJSONTopology["arcs"];
      if (transform) {
        transformArcs(arcs, scale, translate);
      }
      var features = [];
      var topoJSONFeatures = topoJSONTopology["objects"];
      var property = this.layerName_;
      var feature = void 0;
      for (var objectName in topoJSONFeatures) {
        if (this.layers_ && this.layers_.indexOf(objectName) == -1) {
          continue;
        }
        if (topoJSONFeatures[objectName].type === "GeometryCollection") {
          feature = topoJSONFeatures[objectName];
          features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, opt_options));
        } else {
          feature = topoJSONFeatures[objectName];
          features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, opt_options));
        }
      }
      return features;
    } else {
      return [];
    }
  };
  TopoJSON2.prototype.readProjectionFromObject = function(object) {
    return this.dataProjection;
  };
  return TopoJSON2;
}(JSONFeature_default);
var GEOMETRY_READERS2 = {
  "Point": readPointGeometry3,
  "LineString": readLineStringGeometry3,
  "Polygon": readPolygonGeometry3,
  "MultiPoint": readMultiPointGeometry3,
  "MultiLineString": readMultiLineStringGeometry3,
  "MultiPolygon": readMultiPolygonGeometry3
};
function concatenateArcs(indices, arcs) {
  var coordinates = [];
  var index;
  for (var i = 0, ii = indices.length; i < ii; ++i) {
    index = indices[i];
    if (i > 0) {
      coordinates.pop();
    }
    if (index >= 0) {
      var arc = arcs[index];
      for (var j = 0, jj = arc.length; j < jj; ++j) {
        coordinates.push(arc[j].slice(0));
      }
    } else {
      var arc = arcs[~index];
      for (var j = arc.length - 1; j >= 0; --j) {
        coordinates.push(arc[j].slice(0));
      }
    }
  }
  return coordinates;
}
function readPointGeometry3(object, scale, translate) {
  var coordinates = object["coordinates"];
  if (scale && translate) {
    transformVertex(coordinates, scale, translate);
  }
  return new Point_default(coordinates);
}
function readMultiPointGeometry3(object, scale, translate) {
  var coordinates = object["coordinates"];
  if (scale && translate) {
    for (var i = 0, ii = coordinates.length; i < ii; ++i) {
      transformVertex(coordinates[i], scale, translate);
    }
  }
  return new MultiPoint_default(coordinates);
}
function readLineStringGeometry3(object, arcs) {
  var coordinates = concatenateArcs(object["arcs"], arcs);
  return new LineString_default(coordinates);
}
function readMultiLineStringGeometry3(object, arcs) {
  var coordinates = [];
  for (var i = 0, ii = object["arcs"].length; i < ii; ++i) {
    coordinates[i] = concatenateArcs(object["arcs"][i], arcs);
  }
  return new MultiLineString_default(coordinates);
}
function readPolygonGeometry3(object, arcs) {
  var coordinates = [];
  for (var i = 0, ii = object["arcs"].length; i < ii; ++i) {
    coordinates[i] = concatenateArcs(object["arcs"][i], arcs);
  }
  return new Polygon_default(coordinates);
}
function readMultiPolygonGeometry3(object, arcs) {
  var coordinates = [];
  for (var i = 0, ii = object["arcs"].length; i < ii; ++i) {
    var polyArray = object["arcs"][i];
    var ringCoords = [];
    for (var j = 0, jj = polyArray.length; j < jj; ++j) {
      ringCoords[j] = concatenateArcs(polyArray[j], arcs);
    }
    coordinates[i] = ringCoords;
  }
  return new MultiPolygon_default(coordinates);
}
function readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, opt_options) {
  var geometries = collection["geometries"];
  var features = [];
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, opt_options);
  }
  return features;
}
function readFeatureFromGeometry(object, arcs, scale, translate, property, name, opt_options) {
  var geometry = null;
  var type = object.type;
  if (type) {
    var geometryReader = GEOMETRY_READERS2[type];
    if (type === "Point" || type === "MultiPoint") {
      geometry = geometryReader(object, scale, translate);
    } else {
      geometry = geometryReader(object, arcs);
    }
    geometry = transformGeometryWithOptions(geometry, false, opt_options);
  }
  var feature = new Feature_default({ geometry });
  if (object.id !== void 0) {
    feature.setId(object.id);
  }
  var properties = object.properties;
  if (property) {
    if (!properties) {
      properties = {};
    }
    properties[property] = name;
  }
  if (properties) {
    feature.setProperties(properties, true);
  }
  return feature;
}
function transformArcs(arcs, scale, translate) {
  for (var i = 0, ii = arcs.length; i < ii; ++i) {
    transformArc(arcs[i], scale, translate);
  }
}
function transformArc(arc, scale, translate) {
  var x = 0;
  var y = 0;
  for (var i = 0, ii = arc.length; i < ii; ++i) {
    var vertex = arc[i];
    x += vertex[0];
    y += vertex[1];
    vertex[0] = x;
    vertex[1] = y;
    transformVertex(vertex, scale, translate);
  }
}
function transformVertex(vertex, scale, translate) {
  vertex[0] = vertex[0] * scale[0] + translate[0];
  vertex[1] = vertex[1] * scale[1] + translate[1];
}
var TopoJSON_default = TopoJSON;

// node_modules/ol/format/GML32.js
var __extends17 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GML32 = function(_super) {
  __extends17(GML322, _super);
  function GML322(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    _this.schemaLocation = options.schemaLocation ? options.schemaLocation : _this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
    return _this;
  }
  return GML322;
}(GML3_default);
GML32.prototype.namespace = "http://www.opengis.net/gml/3.2";
GML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "pos": makeReplacer(GML3_default.prototype.readFlatPos),
    "posList": makeReplacer(GML3_default.prototype.readFlatPosList),
    "coordinates": makeReplacer(GML2_default.prototype.readFlatCoordinates)
  }
};
GML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "interior": GML3_default.prototype.interiorParser,
    "exterior": GML3_default.prototype.exteriorParser
  }
};
GML32.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Point": makeReplacer(GMLBase_default.prototype.readPoint),
    "MultiPoint": makeReplacer(GMLBase_default.prototype.readMultiPoint),
    "LineString": makeReplacer(GMLBase_default.prototype.readLineString),
    "MultiLineString": makeReplacer(GMLBase_default.prototype.readMultiLineString),
    "LinearRing": makeReplacer(GMLBase_default.prototype.readLinearRing),
    "Polygon": makeReplacer(GMLBase_default.prototype.readPolygon),
    "MultiPolygon": makeReplacer(GMLBase_default.prototype.readMultiPolygon),
    "Surface": makeReplacer(GML32.prototype.readSurface),
    "MultiSurface": makeReplacer(GML3_default.prototype.readMultiSurface),
    "Curve": makeReplacer(GML32.prototype.readCurve),
    "MultiCurve": makeReplacer(GML3_default.prototype.readMultiCurve),
    "Envelope": makeReplacer(GML32.prototype.readEnvelope)
  }
};
GML32.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "curveMember": makeArrayPusher(GML3_default.prototype.curveMemberParser),
    "curveMembers": makeArrayPusher(GML3_default.prototype.curveMemberParser)
  }
};
GML32.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "surfaceMember": makeArrayPusher(GML3_default.prototype.surfaceMemberParser),
    "surfaceMembers": makeArrayPusher(GML3_default.prototype.surfaceMemberParser)
  }
};
GML32.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineString": makeArrayPusher(GMLBase_default.prototype.readLineString),
    "Curve": makeArrayPusher(GML3_default.prototype.readCurve)
  }
};
GML32.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Polygon": makeArrayPusher(GMLBase_default.prototype.readPolygon),
    "Surface": makeArrayPusher(GML3_default.prototype.readSurface)
  }
};
GML32.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "patches": makeReplacer(GML3_default.prototype.readPatch)
  }
};
GML32.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "segments": makeReplacer(GML3_default.prototype.readSegment)
  }
};
GML32.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "lowerCorner": makeArrayPusher(GML3_default.prototype.readFlatPosList),
    "upperCorner": makeArrayPusher(GML3_default.prototype.readFlatPosList)
  }
};
GML32.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "PolygonPatch": makeReplacer(GML3_default.prototype.readPolygonPatch)
  }
};
GML32.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineStringSegment": makeReplacer(GML3_default.prototype.readLineStringSegment)
  }
};
GML32.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "pointMember": makeArrayPusher(GMLBase_default.prototype.pointMemberParser),
    "pointMembers": makeArrayPusher(GMLBase_default.prototype.pointMemberParser)
  }
};
GML32.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "lineStringMember": makeArrayPusher(GMLBase_default.prototype.lineStringMemberParser),
    "lineStringMembers": makeArrayPusher(GMLBase_default.prototype.lineStringMemberParser)
  }
};
GML32.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "polygonMember": makeArrayPusher(GMLBase_default.prototype.polygonMemberParser),
    "polygonMembers": makeArrayPusher(GMLBase_default.prototype.polygonMemberParser)
  }
};
GML32.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Point": makeArrayPusher(GMLBase_default.prototype.readFlatCoordinatesFromNode)
  }
};
GML32.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LineString": makeArrayPusher(GMLBase_default.prototype.readLineString)
  }
};
GML32.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "Polygon": makeArrayPusher(GMLBase_default.prototype.readPolygon)
  }
};
GML32.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    "LinearRing": makeReplacer(GMLBase_default.prototype.readFlatLinearRing)
  }
};
GML32.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "exterior": makeChildAppender(GML3_default.prototype.writeRing),
    "interior": makeChildAppender(GML3_default.prototype.writeRing)
  }
};
GML32.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "lowerCorner": makeChildAppender(writeStringTextNode),
    "upperCorner": makeChildAppender(writeStringTextNode)
  }
};
GML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "surfaceMember": makeChildAppender(GML3_default.prototype.writeSurfaceOrPolygonMember),
    "polygonMember": makeChildAppender(GML3_default.prototype.writeSurfaceOrPolygonMember)
  }
};
GML32.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "pointMember": makeChildAppender(GML3_default.prototype.writePointMember)
  }
};
GML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "lineStringMember": makeChildAppender(GML3_default.prototype.writeLineStringOrCurveMember),
    "curveMember": makeChildAppender(GML3_default.prototype.writeLineStringOrCurveMember)
  }
};
GML32.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    "Curve": makeChildAppender(GML3_default.prototype.writeCurveOrLineString),
    "MultiCurve": makeChildAppender(GML3_default.prototype.writeMultiCurveOrLineString),
    "Point": makeChildAppender(GML32.prototype.writePoint),
    "MultiPoint": makeChildAppender(GML3_default.prototype.writeMultiPoint),
    "LineString": makeChildAppender(GML3_default.prototype.writeCurveOrLineString),
    "MultiLineString": makeChildAppender(GML3_default.prototype.writeMultiCurveOrLineString),
    "LinearRing": makeChildAppender(GML3_default.prototype.writeLinearRing),
    "Polygon": makeChildAppender(GML3_default.prototype.writeSurfaceOrPolygon),
    "MultiPolygon": makeChildAppender(GML3_default.prototype.writeMultiSurfaceOrPolygon),
    "Surface": makeChildAppender(GML3_default.prototype.writeSurfaceOrPolygon),
    "MultiSurface": makeChildAppender(GML3_default.prototype.writeMultiSurfaceOrPolygon),
    "Envelope": makeChildAppender(GML3_default.prototype.writeEnvelope)
  }
};
var GML32_default = GML32;

// node_modules/ol/format/filter/Filter.js
var Filter = function() {
  function Filter2(tagName) {
    this.tagName_ = tagName;
  }
  Filter2.prototype.getTagName = function() {
    return this.tagName_;
  };
  return Filter2;
}();
var Filter_default = Filter;

// node_modules/ol/format/filter/LogicalNary.js
var __extends18 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LogicalNary = function(_super) {
  __extends18(LogicalNary2, _super);
  function LogicalNary2(tagName, conditions) {
    var _this = _super.call(this, tagName) || this;
    _this.conditions = conditions;
    assert(_this.conditions.length >= 2, 57);
    return _this;
  }
  return LogicalNary2;
}(Filter_default);
var LogicalNary_default = LogicalNary;

// node_modules/ol/format/filter/And.js
var __extends19 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var And = function(_super) {
  __extends19(And2, _super);
  function And2(conditions) {
    return _super.call(this, "And", Array.prototype.slice.call(arguments)) || this;
  }
  return And2;
}(LogicalNary_default);
var And_default = And;

// node_modules/ol/format/filter/Bbox.js
var __extends20 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Bbox = function(_super) {
  __extends20(Bbox2, _super);
  function Bbox2(geometryName, extent, opt_srsName) {
    var _this = _super.call(this, "BBOX") || this;
    _this.geometryName = geometryName;
    _this.extent = extent;
    if (extent.length !== 4) {
      throw new Error("Expected an extent with four values ([minX, minY, maxX, maxY])");
    }
    _this.srsName = opt_srsName;
    return _this;
  }
  return Bbox2;
}(Filter_default);
var Bbox_default = Bbox;

// node_modules/ol/format/filter/Spatial.js
var __extends21 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Spatial = function(_super) {
  __extends21(Spatial2, _super);
  function Spatial2(tagName, geometryName, geometry, opt_srsName) {
    var _this = _super.call(this, tagName) || this;
    _this.geometryName = geometryName || "the_geom";
    _this.geometry = geometry;
    _this.srsName = opt_srsName;
    return _this;
  }
  return Spatial2;
}(Filter_default);
var Spatial_default = Spatial;

// node_modules/ol/format/filter/Contains.js
var __extends22 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Contains = function(_super) {
  __extends22(Contains2, _super);
  function Contains2(geometryName, geometry, opt_srsName) {
    return _super.call(this, "Contains", geometryName, geometry, opt_srsName) || this;
  }
  return Contains2;
}(Spatial_default);

// node_modules/ol/format/filter/DWithin.js
var __extends23 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DWithin = function(_super) {
  __extends23(DWithin2, _super);
  function DWithin2(geometryName, geometry, distance, unit, opt_srsName) {
    var _this = _super.call(this, "DWithin", geometryName, geometry, opt_srsName) || this;
    _this.distance = distance;
    _this.unit = unit;
    return _this;
  }
  return DWithin2;
}(Spatial_default);

// node_modules/ol/format/filter/Disjoint.js
var __extends24 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Disjoint = function(_super) {
  __extends24(Disjoint2, _super);
  function Disjoint2(geometryName, geometry, opt_srsName) {
    return _super.call(this, "Disjoint", geometryName, geometry, opt_srsName) || this;
  }
  return Disjoint2;
}(Spatial_default);

// node_modules/ol/format/filter/Comparison.js
var __extends25 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Comparison = function(_super) {
  __extends25(Comparison2, _super);
  function Comparison2(tagName, propertyName) {
    var _this = _super.call(this, tagName) || this;
    _this.propertyName = propertyName;
    return _this;
  }
  return Comparison2;
}(Filter_default);
var Comparison_default = Comparison;

// node_modules/ol/format/filter/During.js
var __extends26 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var During = function(_super) {
  __extends26(During2, _super);
  function During2(propertyName, begin, end) {
    var _this = _super.call(this, "During", propertyName) || this;
    _this.begin = begin;
    _this.end = end;
    return _this;
  }
  return During2;
}(Comparison_default);

// node_modules/ol/format/filter/ComparisonBinary.js
var __extends27 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ComparisonBinary = function(_super) {
  __extends27(ComparisonBinary2, _super);
  function ComparisonBinary2(tagName, propertyName, expression, opt_matchCase) {
    var _this = _super.call(this, tagName, propertyName) || this;
    _this.expression = expression;
    _this.matchCase = opt_matchCase;
    return _this;
  }
  return ComparisonBinary2;
}(Comparison_default);
var ComparisonBinary_default = ComparisonBinary;

// node_modules/ol/format/filter/EqualTo.js
var __extends28 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var EqualTo = function(_super) {
  __extends28(EqualTo2, _super);
  function EqualTo2(propertyName, expression, opt_matchCase) {
    return _super.call(this, "PropertyIsEqualTo", propertyName, expression, opt_matchCase) || this;
  }
  return EqualTo2;
}(ComparisonBinary_default);

// node_modules/ol/format/filter/GreaterThan.js
var __extends29 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GreaterThan = function(_super) {
  __extends29(GreaterThan2, _super);
  function GreaterThan2(propertyName, expression) {
    return _super.call(this, "PropertyIsGreaterThan", propertyName, expression) || this;
  }
  return GreaterThan2;
}(ComparisonBinary_default);

// node_modules/ol/format/filter/GreaterThanOrEqualTo.js
var __extends30 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GreaterThanOrEqualTo = function(_super) {
  __extends30(GreaterThanOrEqualTo2, _super);
  function GreaterThanOrEqualTo2(propertyName, expression) {
    return _super.call(this, "PropertyIsGreaterThanOrEqualTo", propertyName, expression) || this;
  }
  return GreaterThanOrEqualTo2;
}(ComparisonBinary_default);

// node_modules/ol/format/filter/Intersects.js
var __extends31 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Intersects = function(_super) {
  __extends31(Intersects2, _super);
  function Intersects2(geometryName, geometry, opt_srsName) {
    return _super.call(this, "Intersects", geometryName, geometry, opt_srsName) || this;
  }
  return Intersects2;
}(Spatial_default);

// node_modules/ol/format/filter/IsBetween.js
var __extends32 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var IsBetween = function(_super) {
  __extends32(IsBetween2, _super);
  function IsBetween2(propertyName, lowerBoundary, upperBoundary) {
    var _this = _super.call(this, "PropertyIsBetween", propertyName) || this;
    _this.lowerBoundary = lowerBoundary;
    _this.upperBoundary = upperBoundary;
    return _this;
  }
  return IsBetween2;
}(Comparison_default);

// node_modules/ol/format/filter/IsLike.js
var __extends33 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var IsLike = function(_super) {
  __extends33(IsLike2, _super);
  function IsLike2(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
    var _this = _super.call(this, "PropertyIsLike", propertyName) || this;
    _this.pattern = pattern;
    _this.wildCard = opt_wildCard !== void 0 ? opt_wildCard : "*";
    _this.singleChar = opt_singleChar !== void 0 ? opt_singleChar : ".";
    _this.escapeChar = opt_escapeChar !== void 0 ? opt_escapeChar : "!";
    _this.matchCase = opt_matchCase;
    return _this;
  }
  return IsLike2;
}(Comparison_default);

// node_modules/ol/format/filter/IsNull.js
var __extends34 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var IsNull = function(_super) {
  __extends34(IsNull2, _super);
  function IsNull2(propertyName) {
    return _super.call(this, "PropertyIsNull", propertyName) || this;
  }
  return IsNull2;
}(Comparison_default);

// node_modules/ol/format/filter/LessThan.js
var __extends35 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LessThan = function(_super) {
  __extends35(LessThan2, _super);
  function LessThan2(propertyName, expression) {
    return _super.call(this, "PropertyIsLessThan", propertyName, expression) || this;
  }
  return LessThan2;
}(ComparisonBinary_default);

// node_modules/ol/format/filter/LessThanOrEqualTo.js
var __extends36 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LessThanOrEqualTo = function(_super) {
  __extends36(LessThanOrEqualTo2, _super);
  function LessThanOrEqualTo2(propertyName, expression) {
    return _super.call(this, "PropertyIsLessThanOrEqualTo", propertyName, expression) || this;
  }
  return LessThanOrEqualTo2;
}(ComparisonBinary_default);

// node_modules/ol/format/filter/Not.js
var __extends37 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Not = function(_super) {
  __extends37(Not2, _super);
  function Not2(condition) {
    var _this = _super.call(this, "Not") || this;
    _this.condition = condition;
    return _this;
  }
  return Not2;
}(Filter_default);

// node_modules/ol/format/filter/NotEqualTo.js
var __extends38 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NotEqualTo = function(_super) {
  __extends38(NotEqualTo2, _super);
  function NotEqualTo2(propertyName, expression, opt_matchCase) {
    return _super.call(this, "PropertyIsNotEqualTo", propertyName, expression, opt_matchCase) || this;
  }
  return NotEqualTo2;
}(ComparisonBinary_default);

// node_modules/ol/format/filter/Or.js
var __extends39 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Or = function(_super) {
  __extends39(Or2, _super);
  function Or2(conditions) {
    return _super.call(this, "Or", Array.prototype.slice.call(arguments)) || this;
  }
  return Or2;
}(LogicalNary_default);

// node_modules/ol/format/filter/ResourceId.js
var __extends40 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ResourceId = function(_super) {
  __extends40(ResourceId2, _super);
  function ResourceId2(rid) {
    var _this = _super.call(this, "ResourceId") || this;
    _this.rid = rid;
    return _this;
  }
  return ResourceId2;
}(Filter_default);

// node_modules/ol/format/filter/Within.js
var __extends41 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Within = function(_super) {
  __extends41(Within2, _super);
  function Within2(geometryName, geometry, opt_srsName) {
    return _super.call(this, "Within", geometryName, geometry, opt_srsName) || this;
  }
  return Within2;
}(Spatial_default);

// node_modules/ol/format/filter.js
function and(conditions) {
  var params = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(And_default, params))();
}
function bbox(geometryName, extent, opt_srsName) {
  return new Bbox_default(geometryName, extent, opt_srsName);
}

// node_modules/ol/format/WFS.js
var __extends42 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var FEATURE_COLLECTION_PARSERS = {
  "http://www.opengis.net/gml": {
    "boundedBy": makeObjectPropertySetter(GMLBase_default.prototype.readGeometryElement, "bounds")
  },
  "http://www.opengis.net/wfs/2.0": {
    "member": makeArrayPusher(GMLBase_default.prototype.readFeaturesInternal)
  }
};
var TRANSACTION_SUMMARY_PARSERS = {
  "http://www.opengis.net/wfs": {
    "totalInserted": makeObjectPropertySetter(readPositiveInteger),
    "totalUpdated": makeObjectPropertySetter(readPositiveInteger),
    "totalDeleted": makeObjectPropertySetter(readPositiveInteger)
  },
  "http://www.opengis.net/wfs/2.0": {
    "totalInserted": makeObjectPropertySetter(readPositiveInteger),
    "totalUpdated": makeObjectPropertySetter(readPositiveInteger),
    "totalDeleted": makeObjectPropertySetter(readPositiveInteger)
  }
};
var TRANSACTION_RESPONSE_PARSERS = {
  "http://www.opengis.net/wfs": {
    "TransactionSummary": makeObjectPropertySetter(readTransactionSummary, "transactionSummary"),
    "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
  },
  "http://www.opengis.net/wfs/2.0": {
    "TransactionSummary": makeObjectPropertySetter(readTransactionSummary, "transactionSummary"),
    "InsertResults": makeObjectPropertySetter(readInsertResults, "insertIds")
  }
};
var QUERY_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "PropertyName": makeChildAppender(writeStringTextNode)
  },
  "http://www.opengis.net/wfs/2.0": {
    "PropertyName": makeChildAppender(writeStringTextNode)
  }
};
var TRANSACTION_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "Insert": makeChildAppender(writeFeature),
    "Update": makeChildAppender(writeUpdate),
    "Delete": makeChildAppender(writeDelete),
    "Property": makeChildAppender(writeProperty),
    "Native": makeChildAppender(writeNative)
  },
  "http://www.opengis.net/wfs/2.0": {
    "Insert": makeChildAppender(writeFeature),
    "Update": makeChildAppender(writeUpdate),
    "Delete": makeChildAppender(writeDelete),
    "Property": makeChildAppender(writeProperty),
    "Native": makeChildAppender(writeNative)
  }
};
var FEATURE_PREFIX = "feature";
var XMLNS = "http://www.w3.org/2000/xmlns/";
var OGCNS = {
  "2.0.0": "http://www.opengis.net/ogc/1.1",
  "1.1.0": "http://www.opengis.net/ogc",
  "1.0.0": "http://www.opengis.net/ogc"
};
var WFSNS = {
  "2.0.0": "http://www.opengis.net/wfs/2.0",
  "1.1.0": "http://www.opengis.net/wfs",
  "1.0.0": "http://www.opengis.net/wfs"
};
var FESNS = {
  "2.0.0": "http://www.opengis.net/fes/2.0",
  "1.1.0": "http://www.opengis.net/fes",
  "1.0.0": "http://www.opengis.net/fes"
};
var SCHEMA_LOCATIONS = {
  "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
  "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
  "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
};
var GML_FORMATS = {
  "2.0.0": GML32_default,
  "1.1.0": GML3_default,
  "1.0.0": GML2_default
};
var DEFAULT_VERSION = "1.1.0";
var WFS = function(_super) {
  __extends42(WFS2, _super);
  function WFS2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.version_ = options.version ? options.version : DEFAULT_VERSION;
    _this.featureType_ = options.featureType;
    _this.featureNS_ = options.featureNS;
    _this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[_this.version_]();
    _this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[_this.version_];
    return _this;
  }
  WFS2.prototype.getFeatureType = function() {
    return this.featureType_;
  };
  WFS2.prototype.setFeatureType = function(featureType) {
    this.featureType_ = featureType;
  };
  WFS2.prototype.readFeaturesFromNode = function(node, opt_options) {
    var context = {
      node
    };
    assign(context, {
      "featureType": this.featureType_,
      "featureNS": this.featureNS_
    });
    assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));
    var objectStack = [context];
    var featuresNS;
    if (this.version_ === "2.0.0") {
      featuresNS = FEATURE_COLLECTION_PARSERS;
    } else {
      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    }
    var features = pushParseAndPop([], featuresNS, node, objectStack, this.gmlFormat_);
    if (!features) {
      features = [];
    }
    return features;
  };
  WFS2.prototype.readTransactionResponse = function(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      var doc = parse(source);
      return this.readTransactionResponseFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readTransactionResponseFromDocument(source);
    } else {
      return this.readTransactionResponseFromNode(source);
    }
  };
  WFS2.prototype.readFeatureCollectionMetadata = function(source) {
    if (!source) {
      return void 0;
    } else if (typeof source === "string") {
      var doc = parse(source);
      return this.readFeatureCollectionMetadataFromDocument(doc);
    } else if (isDocument(source)) {
      return this.readFeatureCollectionMetadataFromDocument(source);
    } else {
      return this.readFeatureCollectionMetadataFromNode(source);
    }
  };
  WFS2.prototype.readFeatureCollectionMetadataFromDocument = function(doc) {
    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readFeatureCollectionMetadataFromNode(n);
      }
    }
    return void 0;
  };
  WFS2.prototype.readFeatureCollectionMetadataFromNode = function(node) {
    var result = {};
    var value = readNonNegativeIntegerString(node.getAttribute("numberOfFeatures"));
    result["numberOfFeatures"] = value;
    return pushParseAndPop(result, FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);
  };
  WFS2.prototype.readTransactionResponseFromDocument = function(doc) {
    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readTransactionResponseFromNode(n);
      }
    }
    return void 0;
  };
  WFS2.prototype.readTransactionResponseFromNode = function(node) {
    return pushParseAndPop({}, TRANSACTION_RESPONSE_PARSERS, node, []);
  };
  WFS2.prototype.writeGetFeature = function(options) {
    var _this = this;
    var node = createElementNS(WFSNS[this.version_], "GetFeature");
    node.setAttribute("service", "WFS");
    node.setAttribute("version", this.version_);
    if (options.handle) {
      node.setAttribute("handle", options.handle);
    }
    if (options.outputFormat) {
      node.setAttribute("outputFormat", options.outputFormat);
    }
    if (options.maxFeatures !== void 0) {
      node.setAttribute("maxFeatures", String(options.maxFeatures));
    }
    if (options.resultType) {
      node.setAttribute("resultType", options.resultType);
    }
    if (options.startIndex !== void 0) {
      node.setAttribute("startIndex", String(options.startIndex));
    }
    if (options.count !== void 0) {
      node.setAttribute("count", String(options.count));
    }
    if (options.viewParams !== void 0) {
      node.setAttribute("viewParams", options.viewParams);
    }
    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", this.schemaLocation_);
    var context = {
      node
    };
    assign(context, {
      "version": this.version_,
      "srsName": options.srsName,
      "featureNS": options.featureNS ? options.featureNS : this.featureNS_,
      "featurePrefix": options.featurePrefix,
      "propertyNames": options.propertyNames ? options.propertyNames : []
    });
    assert(Array.isArray(options.featureTypes), 11);
    if (typeof options.featureTypes[0] === "string") {
      var filter = options.filter;
      if (options.bbox) {
        assert(options.geometryName, 12);
        filter = this.combineBboxAndFilter(options.geometryName, options.bbox, options.srsName, filter);
      }
      assign(context, {
        "geometryName": options.geometryName,
        "filter": filter
      });
      writeGetFeature(node, options.featureTypes, [context]);
    } else {
      options.featureTypes.forEach(function(featureType) {
        var completeFilter = _this.combineBboxAndFilter(featureType.geometryName, featureType.bbox, options.srsName, options.filter);
        assign(context, {
          "geometryName": featureType.geometryName,
          "filter": completeFilter
        });
        writeGetFeature(node, [featureType.name], [context]);
      });
    }
    return node;
  };
  WFS2.prototype.combineBboxAndFilter = function(geometryName, extent, opt_srsName, opt_filter) {
    var bboxFilter = bbox(geometryName, extent, opt_srsName);
    if (opt_filter) {
      return and(opt_filter, bboxFilter);
    }
    return bboxFilter;
  };
  WFS2.prototype.writeTransaction = function(inserts, updates, deletes, options) {
    var objectStack = [];
    var version = options.version ? options.version : this.version_;
    var node = createElementNS(WFSNS[version], "Transaction");
    node.setAttribute("service", "WFS");
    node.setAttribute("version", version);
    var baseObj;
    if (options) {
      baseObj = options.gmlOptions ? options.gmlOptions : {};
      if (options.handle) {
        node.setAttribute("handle", options.handle);
      }
    }
    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, "xsi:schemaLocation", SCHEMA_LOCATIONS[version]);
    var request = createTransactionRequest(node, baseObj, version, options);
    if (inserts) {
      serializeTransactionRequest("Insert", inserts, objectStack, request);
    }
    if (updates) {
      serializeTransactionRequest("Update", updates, objectStack, request);
    }
    if (deletes) {
      serializeTransactionRequest("Delete", deletes, objectStack, request);
    }
    if (options.nativeElements) {
      serializeTransactionRequest("Native", options.nativeElements, objectStack, request);
    }
    return node;
  };
  WFS2.prototype.readProjectionFromDocument = function(doc) {
    for (var n = doc.firstChild; n; n = n.nextSibling) {
      if (n.nodeType == Node.ELEMENT_NODE) {
        return this.readProjectionFromNode(n);
      }
    }
    return null;
  };
  WFS2.prototype.readProjectionFromNode = function(node) {
    if (node.firstElementChild && node.firstElementChild.firstElementChild) {
      node = node.firstElementChild.firstElementChild;
      for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
        if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {
          var objectStack = [{}];
          this.gmlFormat_.readGeometryElement(n, objectStack);
          return get(objectStack.pop().srsName);
        }
      }
    }
    return null;
  };
  return WFS2;
}(XMLFeature_default);
function createTransactionRequest(node, baseObj, version, options) {
  var featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;
  var gmlVersion;
  if (version === "1.0.0") {
    gmlVersion = 2;
  } else if (version === "1.1.0") {
    gmlVersion = 3;
  } else if (version === "2.0.0") {
    gmlVersion = 3.2;
  }
  var obj = assign({ node }, {
    version,
    "featureNS": options.featureNS,
    "featureType": options.featureType,
    "featurePrefix": featurePrefix,
    "gmlVersion": gmlVersion,
    "hasZ": options.hasZ,
    "srsName": options.srsName
  }, baseObj);
  return obj;
}
function serializeTransactionRequest(type, features, objectStack, request) {
  pushSerializeAndPop(request, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory(type), features, objectStack);
}
function readTransactionSummary(node, objectStack) {
  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);
}
var OGC_FID_PARSERS = {
  "http://www.opengis.net/ogc": {
    "FeatureId": makeArrayPusher(function(node, objectStack) {
      return node.getAttribute("fid");
    })
  },
  "http://www.opengis.net/ogc/1.1": {
    "FeatureId": makeArrayPusher(function(node, objectStack) {
      return node.getAttribute("fid");
    })
  }
};
function fidParser(node, objectStack) {
  parseNode(OGC_FID_PARSERS, node, objectStack);
}
var INSERT_RESULTS_PARSERS = {
  "http://www.opengis.net/wfs": {
    "Feature": fidParser
  },
  "http://www.opengis.net/wfs/2.0": {
    "Feature": fidParser
  }
};
function readInsertResults(node, objectStack) {
  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);
}
function writeFeature(node, feature, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var featureType = context["featureType"];
  var featureNS = context["featureNS"];
  var gmlVersion = context["gmlVersion"];
  var child = createElementNS(featureNS, featureType);
  node.appendChild(child);
  if (gmlVersion === 2) {
    GML2_default.prototype.writeFeatureElement(child, feature, objectStack);
  } else if (gmlVersion === 3) {
    GML3_default.prototype.writeFeatureElement(child, feature, objectStack);
  } else {
    GML32_default.prototype.writeFeatureElement(child, feature, objectStack);
  }
}
function writeOgcFidFilter(node, fid, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var version = context["version"];
  var ns = OGCNS[version];
  var filter = createElementNS(ns, "Filter");
  var child = createElementNS(ns, "FeatureId");
  filter.appendChild(child);
  child.setAttribute("fid", fid);
  node.appendChild(filter);
}
function getTypeName(featurePrefix, featureType) {
  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;
  var prefix = featurePrefix + ":";
  if (featureType.indexOf(prefix) === 0) {
    return featureType;
  } else {
    return prefix + featureType;
  }
}
function writeDelete(node, feature, objectStack) {
  var context = objectStack[objectStack.length - 1];
  assert(feature.getId() !== void 0, 26);
  var featureType = context["featureType"];
  var featurePrefix = context["featurePrefix"];
  var featureNS = context["featureNS"];
  var typeName = getTypeName(featurePrefix, featureType);
  node.setAttribute("typeName", typeName);
  node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  var fid = feature.getId();
  if (fid !== void 0) {
    writeOgcFidFilter(node, fid, objectStack);
  }
}
function writeUpdate(node, feature, objectStack) {
  var context = objectStack[objectStack.length - 1];
  assert(feature.getId() !== void 0, 27);
  var version = context["version"];
  var featureType = context["featureType"];
  var featurePrefix = context["featurePrefix"];
  var featureNS = context["featureNS"];
  var typeName = getTypeName(featurePrefix, featureType);
  var geometryName = feature.getGeometryName();
  node.setAttribute("typeName", typeName);
  node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  var fid = feature.getId();
  if (fid !== void 0) {
    var keys = feature.getKeys();
    var values = [];
    for (var i = 0, ii = keys.length; i < ii; i++) {
      var value = feature.get(keys[i]);
      if (value !== void 0) {
        var name_1 = keys[i];
        if (value && typeof value.getSimplifiedGeometry === "function") {
          name_1 = geometryName;
        }
        values.push({ name: name_1, value });
      }
    }
    pushSerializeAndPop({
      version,
      "gmlVersion": context["gmlVersion"],
      node,
      "hasZ": context["hasZ"],
      "srsName": context["srsName"]
    }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory("Property"), values, objectStack);
    writeOgcFidFilter(node, fid, objectStack);
  }
}
function writeProperty(node, pair, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var version = context["version"];
  var ns = WFSNS[version];
  var name = createElementNS(ns, "Name");
  var gmlVersion = context["gmlVersion"];
  node.appendChild(name);
  writeStringTextNode(name, pair.name);
  if (pair.value !== void 0 && pair.value !== null) {
    var value = createElementNS(ns, "Value");
    node.appendChild(value);
    if (pair.value && typeof pair.value.getSimplifiedGeometry === "function") {
      if (gmlVersion === 2) {
        GML2_default.prototype.writeGeometryElement(value, pair.value, objectStack);
      } else if (gmlVersion === 3) {
        GML3_default.prototype.writeGeometryElement(value, pair.value, objectStack);
      } else {
        GML32_default.prototype.writeGeometryElement(value, pair.value, objectStack);
      }
    } else {
      writeStringTextNode(value, pair.value);
    }
  }
}
function writeNative(node, nativeElement, objectStack) {
  if (nativeElement.vendorId) {
    node.setAttribute("vendorId", nativeElement.vendorId);
  }
  if (nativeElement.safeToIgnore !== void 0) {
    node.setAttribute("safeToIgnore", String(nativeElement.safeToIgnore));
  }
  if (nativeElement.value !== void 0) {
    writeStringTextNode(node, nativeElement.value);
  }
}
var GETFEATURE_SERIALIZERS = {
  "http://www.opengis.net/wfs": {
    "Query": makeChildAppender(writeQuery)
  },
  "http://www.opengis.net/wfs/2.0": {
    "Query": makeChildAppender(writeQuery)
  },
  "http://www.opengis.net/ogc": {
    "During": makeChildAppender(writeDuringFilter),
    "And": makeChildAppender(writeLogicalFilter),
    "Or": makeChildAppender(writeLogicalFilter),
    "Not": makeChildAppender(writeNotFilter),
    "BBOX": makeChildAppender(writeBboxFilter),
    "Contains": makeChildAppender(writeSpatialFilter),
    "Intersects": makeChildAppender(writeSpatialFilter),
    "Within": makeChildAppender(writeSpatialFilter),
    "DWithin": makeChildAppender(writeDWithinFilter),
    "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNull": makeChildAppender(writeIsNullFilter),
    "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
    "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
  },
  "http://www.opengis.net/fes/2.0": {
    "During": makeChildAppender(writeDuringFilter),
    "And": makeChildAppender(writeLogicalFilter),
    "Or": makeChildAppender(writeLogicalFilter),
    "Not": makeChildAppender(writeNotFilter),
    "BBOX": makeChildAppender(writeBboxFilter),
    "Contains": makeChildAppender(writeSpatialFilter),
    "Disjoint": makeChildAppender(writeSpatialFilter),
    "Intersects": makeChildAppender(writeSpatialFilter),
    "ResourceId": makeChildAppender(writeResourceIdFilter),
    "Within": makeChildAppender(writeSpatialFilter),
    "DWithin": makeChildAppender(writeDWithinFilter),
    "PropertyIsEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNotEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsLessThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThan": makeChildAppender(writeComparisonFilter),
    "PropertyIsGreaterThanOrEqualTo": makeChildAppender(writeComparisonFilter),
    "PropertyIsNull": makeChildAppender(writeIsNullFilter),
    "PropertyIsBetween": makeChildAppender(writeIsBetweenFilter),
    "PropertyIsLike": makeChildAppender(writeIsLikeFilter)
  }
};
function writeQuery(node, featureType, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var version = context["version"];
  var featurePrefix = context["featurePrefix"];
  var featureNS = context["featureNS"];
  var propertyNames = context["propertyNames"];
  var srsName = context["srsName"];
  var typeName;
  if (featurePrefix) {
    typeName = getTypeName(featurePrefix, featureType);
  } else {
    typeName = featureType;
  }
  var typeNameAttr;
  if (version === "2.0.0") {
    typeNameAttr = "typeNames";
  } else {
    typeNameAttr = "typeName";
  }
  node.setAttribute(typeNameAttr, typeName);
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  if (featureNS) {
    node.setAttributeNS(XMLNS, "xmlns:" + featurePrefix, featureNS);
  }
  var item = assign({}, context);
  item.node = node;
  pushSerializeAndPop(item, QUERY_SERIALIZERS, makeSimpleNodeFactory("PropertyName"), propertyNames, objectStack);
  var filter = context["filter"];
  if (filter) {
    var child = createElementNS(getFilterNS(version), "Filter");
    node.appendChild(child);
    writeFilterCondition(child, filter, objectStack);
  }
}
function writeFilterCondition(node, filter, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var item = { node };
  assign(item, { context });
  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);
}
function writeBboxFilter(node, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version = context["version"];
  parent["srsName"] = filter.srsName;
  var format = GML_FORMATS[version];
  writePropertyName(version, node, filter.geometryName);
  format.prototype.writeGeometryElement(node, filter.extent, objectStack);
}
function writeResourceIdFilter(node, filter, objectStack) {
  node.setAttribute("rid", filter.rid);
}
function writeSpatialFilter(node, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version = context["version"];
  parent["srsName"] = filter.srsName;
  var format = GML_FORMATS[version];
  writePropertyName(version, node, filter.geometryName);
  format.prototype.writeGeometryElement(node, filter.geometry, objectStack);
}
function writeDWithinFilter(node, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version = context["version"];
  writeSpatialFilter(node, filter, objectStack);
  var distance = createElementNS(getFilterNS(version), "Distance");
  writeStringTextNode(distance, filter.distance.toString());
  if (version === "2.0.0") {
    distance.setAttribute("uom", filter.unit);
  } else {
    distance.setAttribute("units", filter.unit);
  }
  node.appendChild(distance);
}
function writeDuringFilter(node, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version = context["version"];
  writeExpression(FESNS[version], "ValueReference", node, filter.propertyName);
  var timePeriod = createElementNS(GMLNS, "TimePeriod");
  node.appendChild(timePeriod);
  var begin = createElementNS(GMLNS, "begin");
  timePeriod.appendChild(begin);
  writeTimeInstant(begin, filter.begin);
  var end = createElementNS(GMLNS, "end");
  timePeriod.appendChild(end);
  writeTimeInstant(end, filter.end);
}
function writeLogicalFilter(node, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var item = { node };
  assign(item, { context });
  var conditions = filter.conditions;
  for (var i = 0, ii = conditions.length; i < ii; ++i) {
    var condition = conditions[i];
    pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
  }
}
function writeNotFilter(node, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var item = { node };
  assign(item, { context });
  var condition = filter.condition;
  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
}
function writeComparisonFilter(node, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version = context["version"];
  if (filter.matchCase !== void 0) {
    node.setAttribute("matchCase", filter.matchCase.toString());
  }
  writePropertyName(version, node, filter.propertyName);
  writeLiteral(version, node, "" + filter.expression);
}
function writeIsNullFilter(node, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version = context["version"];
  writePropertyName(version, node, filter.propertyName);
}
function writeIsBetweenFilter(node, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version = context["version"];
  var ns = getFilterNS(version);
  writePropertyName(version, node, filter.propertyName);
  var lowerBoundary = createElementNS(ns, "LowerBoundary");
  node.appendChild(lowerBoundary);
  writeLiteral(version, lowerBoundary, "" + filter.lowerBoundary);
  var upperBoundary = createElementNS(ns, "UpperBoundary");
  node.appendChild(upperBoundary);
  writeLiteral(version, upperBoundary, "" + filter.upperBoundary);
}
function writeIsLikeFilter(node, filter, objectStack) {
  var parent = objectStack[objectStack.length - 1];
  var context = parent["context"];
  var version = context["version"];
  node.setAttribute("wildCard", filter.wildCard);
  node.setAttribute("singleChar", filter.singleChar);
  node.setAttribute("escapeChar", filter.escapeChar);
  if (filter.matchCase !== void 0) {
    node.setAttribute("matchCase", filter.matchCase.toString());
  }
  writePropertyName(version, node, filter.propertyName);
  writeLiteral(version, node, "" + filter.pattern);
}
function writeExpression(ns, tagName, node, value) {
  var property = createElementNS(ns, tagName);
  writeStringTextNode(property, value);
  node.appendChild(property);
}
function writeLiteral(version, node, value) {
  writeExpression(getFilterNS(version), "Literal", node, value);
}
function writePropertyName(version, node, value) {
  if (version === "2.0.0") {
    writeExpression(FESNS[version], "ValueReference", node, value);
  } else {
    writeExpression(OGCNS[version], "PropertyName", node, value);
  }
}
function writeTimeInstant(node, time) {
  var timeInstant = createElementNS(GMLNS, "TimeInstant");
  node.appendChild(timeInstant);
  var timePosition = createElementNS(GMLNS, "timePosition");
  timeInstant.appendChild(timePosition);
  writeStringTextNode(timePosition, time);
}
function writeGetFeature(node, featureTypes, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var item = assign({}, context);
  item.node = node;
  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory("Query"), featureTypes, objectStack);
}
function getFilterNS(version) {
  var ns;
  if (version === "2.0.0") {
    ns = FESNS[version];
  } else {
    ns = OGCNS[version];
  }
  return ns;
}
var WFS_default = WFS;

// node_modules/ol/format/WKB.js
var __extends43 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WKBGeometryType = {
  POINT: 1,
  LINE_STRING: 2,
  POLYGON: 3,
  MULTI_POINT: 4,
  MULTI_LINE_STRING: 5,
  MULTI_POLYGON: 6,
  GEOMETRY_COLLECTION: 7,
  POLYHEDRAL_SURFACE: 15,
  TIN: 16,
  TRIANGLE: 17
};
var WkbReader = function() {
  function WkbReader2(view) {
    this.view_ = view;
    this.pos_ = 0;
    this.initialized_ = false;
    this.isLittleEndian_ = false;
    this.hasZ_ = false;
    this.hasM_ = false;
    this.srid_ = null;
    this.layout_ = GeometryLayout_default.XY;
  }
  WkbReader2.prototype.readUint8 = function() {
    return this.view_.getUint8(this.pos_++);
  };
  WkbReader2.prototype.readUint32 = function(isLittleEndian) {
    return this.view_.getUint32((this.pos_ += 4) - 4, isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_);
  };
  WkbReader2.prototype.readDouble = function(isLittleEndian) {
    return this.view_.getFloat64((this.pos_ += 8) - 8, isLittleEndian !== void 0 ? isLittleEndian : this.isLittleEndian_);
  };
  WkbReader2.prototype.readPoint = function() {
    var coords = [];
    coords.push(this.readDouble());
    coords.push(this.readDouble());
    if (this.hasZ_) {
      coords.push(this.readDouble());
    }
    if (this.hasM_) {
      coords.push(this.readDouble());
    }
    return coords;
  };
  WkbReader2.prototype.readLineString = function() {
    var numPoints = this.readUint32();
    var coords = [];
    for (var i = 0; i < numPoints; i++) {
      coords.push(this.readPoint());
    }
    return coords;
  };
  WkbReader2.prototype.readPolygon = function() {
    var numRings = this.readUint32();
    var rings = [];
    for (var i = 0; i < numRings; i++) {
      rings.push(this.readLineString());
    }
    return rings;
  };
  WkbReader2.prototype.readWkbHeader = function(expectedTypeId) {
    var byteOrder = this.readUint8();
    var isLittleEndian = byteOrder > 0;
    var wkbType = this.readUint32(isLittleEndian);
    var wkbTypeThousandth = Math.floor((wkbType & 268435455) / 1e3);
    var hasZ = Boolean(wkbType & 2147483648) || wkbTypeThousandth === 1 || wkbTypeThousandth === 3;
    var hasM = Boolean(wkbType & 1073741824) || wkbTypeThousandth === 2 || wkbTypeThousandth === 3;
    var hasSRID = Boolean(wkbType & 536870912);
    var typeId = (wkbType & 268435455) % 1e3;
    var layout = ["XY", hasZ ? "Z" : "", hasM ? "M" : ""].join("");
    var srid = hasSRID ? this.readUint32(isLittleEndian) : null;
    if (expectedTypeId !== void 0 && expectedTypeId !== typeId) {
      throw new Error("Unexpected WKB geometry type " + typeId);
    }
    if (this.initialized_) {
      if (this.isLittleEndian_ !== isLittleEndian) {
        throw new Error("Inconsistent endian");
      }
      if (this.layout_ !== layout) {
        throw new Error("Inconsistent geometry layout");
      }
      if (srid && this.srid_ !== srid) {
        throw new Error("Inconsistent coordinate system (SRID)");
      }
    } else {
      this.isLittleEndian_ = isLittleEndian;
      this.hasZ_ = hasZ;
      this.hasM_ = hasM;
      this.layout_ = layout;
      this.srid_ = srid;
      this.initialized_ = true;
    }
    return typeId;
  };
  WkbReader2.prototype.readWkbPayload = function(typeId) {
    switch (typeId) {
      case WKBGeometryType.POINT:
        return this.readPoint();
      case WKBGeometryType.LINE_STRING:
        return this.readLineString();
      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return this.readPolygon();
      case WKBGeometryType.MULTI_POINT:
        return this.readMultiPoint();
      case WKBGeometryType.MULTI_LINE_STRING:
        return this.readMultiLineString();
      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return this.readMultiPolygon();
      case WKBGeometryType.GEOMETRY_COLLECTION:
        return this.readGeometryCollection();
      default:
        throw new Error("Unsupported WKB geometry type " + typeId + " is found");
    }
  };
  WkbReader2.prototype.readWkbBlock = function(expectedTypeId) {
    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));
  };
  WkbReader2.prototype.readWkbCollection = function(reader, expectedTypeId) {
    var num = this.readUint32();
    var items = [];
    for (var i = 0; i < num; i++) {
      var result = reader.call(this, expectedTypeId);
      if (result) {
        items.push(result);
      }
    }
    return items;
  };
  WkbReader2.prototype.readMultiPoint = function() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);
  };
  WkbReader2.prototype.readMultiLineString = function() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.LINE_STRING);
  };
  WkbReader2.prototype.readMultiPolygon = function() {
    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);
  };
  WkbReader2.prototype.readGeometryCollection = function() {
    return this.readWkbCollection(this.readGeometry);
  };
  WkbReader2.prototype.readGeometry = function() {
    var typeId = this.readWkbHeader();
    var result = this.readWkbPayload(typeId);
    switch (typeId) {
      case WKBGeometryType.POINT:
        return new Point_default(result, this.layout_);
      case WKBGeometryType.LINE_STRING:
        return new LineString_default(result, this.layout_);
      case WKBGeometryType.POLYGON:
      case WKBGeometryType.TRIANGLE:
        return new Polygon_default(result, this.layout_);
      case WKBGeometryType.MULTI_POINT:
        return new MultiPoint_default(result, this.layout_);
      case WKBGeometryType.MULTI_LINE_STRING:
        return new MultiLineString_default(result, this.layout_);
      case WKBGeometryType.MULTI_POLYGON:
      case WKBGeometryType.POLYHEDRAL_SURFACE:
      case WKBGeometryType.TIN:
        return new MultiPolygon_default(result, this.layout_);
      case WKBGeometryType.GEOMETRY_COLLECTION:
        return new GeometryCollection_default(result);
      default:
        return null;
    }
  };
  WkbReader2.prototype.getSrid = function() {
    return this.srid_;
  };
  return WkbReader2;
}();
var WkbWriter = function() {
  function WkbWriter2(opts) {
    opts = opts || {};
    this.layout_ = opts.layout;
    this.isLittleEndian_ = opts.littleEndian !== false;
    this.isEWKB_ = opts.ewkb !== false;
    this.writeQueue_ = [];
    this.nodata_ = assign({ X: 0, Y: 0, Z: 0, M: 0 }, opts.nodata);
  }
  WkbWriter2.prototype.writeUint8 = function(value) {
    this.writeQueue_.push([1, value]);
  };
  WkbWriter2.prototype.writeUint32 = function(value) {
    this.writeQueue_.push([4, value]);
  };
  WkbWriter2.prototype.writeDouble = function(value) {
    this.writeQueue_.push([8, value]);
  };
  WkbWriter2.prototype.writePoint = function(coords, layout) {
    var coordsObj = assign.apply(null, layout.split("").map(function(axis2, idx) {
      var _a2;
      return _a2 = {}, _a2[axis2] = coords[idx], _a2;
    }));
    for (var _i = 0, _a = this.layout_; _i < _a.length; _i++) {
      var axis = _a[_i];
      this.writeDouble(axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]);
    }
  };
  WkbWriter2.prototype.writeLineString = function(coords, layout) {
    this.writeUint32(coords.length);
    for (var i = 0; i < coords.length; i++) {
      this.writePoint(coords[i], layout);
    }
  };
  WkbWriter2.prototype.writePolygon = function(rings, layout) {
    this.writeUint32(rings.length);
    for (var i = 0; i < rings.length; i++) {
      this.writeLineString(rings[i], layout);
    }
  };
  WkbWriter2.prototype.writeWkbHeader = function(wkbType, srid) {
    wkbType %= 1e3;
    if (this.layout_.indexOf("Z") >= 0) {
      wkbType += this.isEWKB_ ? 2147483648 : 1e3;
    }
    if (this.layout_.indexOf("M") >= 0) {
      wkbType += this.isEWKB_ ? 1073741824 : 2e3;
    }
    if (this.isEWKB_ && Number.isInteger(srid)) {
      wkbType |= 536870912;
    }
    this.writeUint8(this.isLittleEndian_ ? 1 : 0);
    this.writeUint32(wkbType);
    if (this.isEWKB_ && Number.isInteger(srid)) {
      this.writeUint32(srid);
    }
  };
  WkbWriter2.prototype.writeMultiPoint = function(coords, layout) {
    this.writeUint32(coords.length);
    for (var i = 0; i < coords.length; i++) {
      this.writeWkbHeader(1);
      this.writePoint(coords[i], layout);
    }
  };
  WkbWriter2.prototype.writeMultiLineString = function(coords, layout) {
    this.writeUint32(coords.length);
    for (var i = 0; i < coords.length; i++) {
      this.writeWkbHeader(2);
      this.writeLineString(coords[i], layout);
    }
  };
  WkbWriter2.prototype.writeMultiPolygon = function(coords, layout) {
    this.writeUint32(coords.length);
    for (var i = 0; i < coords.length; i++) {
      this.writeWkbHeader(3);
      this.writePolygon(coords[i], layout);
    }
  };
  WkbWriter2.prototype.writeGeometryCollection = function(geometries) {
    this.writeUint32(geometries.length);
    for (var i = 0; i < geometries.length; i++) {
      this.writeGeometry(geometries[i]);
    }
  };
  WkbWriter2.prototype.findMinimumLayout = function(geom, layout) {
    if (layout === void 0) {
      layout = GeometryLayout_default.XYZM;
    }
    var GeometryLayout_min = function(a, b) {
      if (a === b) {
        return a;
      }
      if (a === GeometryLayout_default.XYZM) {
        return b;
      }
      if (b === GeometryLayout_default.XYZM) {
        return a;
      }
      return GeometryLayout_default.XY;
    };
    if (geom instanceof SimpleGeometry_default) {
      return GeometryLayout_min(geom.getLayout(), layout);
    }
    if (geom instanceof GeometryCollection_default) {
      var geoms = geom.getGeometriesArray();
      for (var i = 0; i < geoms.length && layout !== GeometryLayout_default.XY; i++) {
        layout = this.findMinimumLayout(geoms[i], layout);
      }
    }
    return layout;
  };
  WkbWriter2.prototype.writeGeometry = function(geom, srid) {
    var _a, _b;
    var wkblut = (_a = {}, _a[GeometryType_default.POINT] = WKBGeometryType.POINT, _a[GeometryType_default.LINE_STRING] = WKBGeometryType.LINE_STRING, _a[GeometryType_default.POLYGON] = WKBGeometryType.POLYGON, _a[GeometryType_default.MULTI_POINT] = WKBGeometryType.MULTI_POINT, _a[GeometryType_default.MULTI_LINE_STRING] = WKBGeometryType.MULTI_LINE_STRING, _a[GeometryType_default.MULTI_POLYGON] = WKBGeometryType.MULTI_POLYGON, _a[GeometryType_default.GEOMETRY_COLLECTION] = WKBGeometryType.GEOMETRY_COLLECTION, _a);
    var geomType = geom.getType();
    var typeId = wkblut[geomType];
    if (!typeId) {
      throw new Error("GeometryType " + geomType + " is not supported");
    }
    if (!this.layout_) {
      this.layout_ = this.findMinimumLayout(geom);
    }
    this.writeWkbHeader(typeId, srid);
    if (geom instanceof SimpleGeometry_default) {
      var writerLUT = (_b = {}, _b[GeometryType_default.POINT] = this.writePoint, _b[GeometryType_default.LINE_STRING] = this.writeLineString, _b[GeometryType_default.POLYGON] = this.writePolygon, _b[GeometryType_default.MULTI_POINT] = this.writeMultiPoint, _b[GeometryType_default.MULTI_LINE_STRING] = this.writeMultiLineString, _b[GeometryType_default.MULTI_POLYGON] = this.writeMultiPolygon, _b);
      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());
    } else if (geom instanceof GeometryCollection_default) {
      this.writeGeometryCollection(geom.getGeometriesArray());
    }
  };
  WkbWriter2.prototype.getBuffer = function() {
    var _this = this;
    var byteLength = this.writeQueue_.reduce(function(acc, item) {
      return acc + item[0];
    }, 0);
    var buffer = new ArrayBuffer(byteLength);
    var view = new DataView(buffer);
    var pos = 0;
    this.writeQueue_.forEach(function(item) {
      switch (item[0]) {
        case 1:
          view.setUint8(pos, item[1]);
          break;
        case 4:
          view.setUint32(pos, item[1], _this.isLittleEndian_);
          break;
        case 8:
          view.setFloat64(pos, item[1], _this.isLittleEndian_);
          break;
        default:
          break;
      }
      pos += item[0];
    });
    return buffer;
  };
  return WkbWriter2;
}();
var WKB = function(_super) {
  __extends43(WKB2, _super);
  function WKB2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.splitCollection = Boolean(options.splitCollection);
    _this.viewCache_ = null;
    _this.hex_ = options.hex !== false;
    _this.littleEndian_ = options.littleEndian !== false;
    _this.ewkb_ = options.ewkb !== false;
    _this.layout_ = options.geometryLayout;
    _this.nodataZ_ = options.nodataZ || 0;
    _this.nodataM_ = options.nodataM || 0;
    _this.srid_ = options.srid;
    return _this;
  }
  WKB2.prototype.getType = function() {
    return this.hex_ ? FormatType_default.TEXT : FormatType_default.ARRAY_BUFFER;
  };
  WKB2.prototype.readFeature = function(source, opt_options) {
    return new Feature_default({
      geometry: this.readGeometry(source, opt_options)
    });
  };
  WKB2.prototype.readFeatures = function(source, opt_options) {
    var geometries = [];
    var geometry = this.readGeometry(source, opt_options);
    if (this.splitCollection && geometry instanceof GeometryCollection_default) {
      geometries = geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }
    return geometries.map(function(geometry2) {
      return new Feature_default({ geometry: geometry2 });
    });
  };
  WKB2.prototype.readGeometry = function(source, opt_options) {
    var view = getDataView(source);
    if (!view) {
      return null;
    }
    var reader = new WkbReader(view);
    var geometry = reader.readGeometry();
    this.viewCache_ = view;
    var options = this.getReadOptions(source, opt_options);
    this.viewCache_ = null;
    return transformGeometryWithOptions(geometry, false, options);
  };
  WKB2.prototype.readProjection = function(source) {
    var view = this.viewCache_ || getDataView(source);
    if (!view) {
      return void 0;
    }
    var reader = new WkbReader(view);
    reader.readWkbHeader();
    return reader.getSrid() && get("EPSG:" + reader.getSrid()) || void 0;
  };
  WKB2.prototype.writeFeature = function(feature, opt_options) {
    return this.writeGeometry(feature.getGeometry(), opt_options);
  };
  WKB2.prototype.writeFeatures = function(features, opt_options) {
    return this.writeGeometry(new GeometryCollection_default(features.map(function(f) {
      return f.getGeometry();
    })), opt_options);
  };
  WKB2.prototype.writeGeometry = function(geometry, opt_options) {
    var options = this.adaptOptions(opt_options);
    var writer = new WkbWriter({
      layout: this.layout_,
      littleEndian: this.littleEndian_,
      ewkb: this.ewkb_,
      nodata: {
        Z: this.nodataZ_,
        M: this.nodataM_
      }
    });
    var srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {
      var dataProjection = options.dataProjection && get(options.dataProjection);
      if (dataProjection) {
        var code = dataProjection.getCode();
        if (code.indexOf("EPSG:") === 0) {
          srid = Number(code.substring(5));
        }
      }
    }
    writer.writeGeometry(transformGeometryWithOptions(geometry, true, options), srid);
    var buffer = writer.getBuffer();
    return this.hex_ ? encodeHexString(buffer) : buffer;
  };
  return WKB2;
}(Feature_default2);
function encodeHexString(buffer) {
  var view = new Uint8Array(buffer);
  return Array.from(view.values()).map(function(x) {
    return (x < 16 ? "0" : "") + Number(x).toString(16).toUpperCase();
  }).join("");
}
function decodeHexString(text) {
  var buffer = new Uint8Array(text.length / 2);
  for (var i = 0; i < text.length / 2; i++) {
    buffer[i] = parseInt(text.substr(i * 2, 2), 16);
  }
  return new DataView(buffer.buffer);
}
function getDataView(source) {
  if (typeof source === "string") {
    return decodeHexString(source);
  } else if (ArrayBuffer.isView(source)) {
    if (source instanceof DataView) {
      return source;
    }
    return new DataView(source.buffer, source.byteOffset, source.byteLength);
  } else if (source instanceof ArrayBuffer) {
    return new DataView(source);
  } else {
    return null;
  }
}
var WKB_default = WKB;

// node_modules/ol/format/WKT.js
var __extends44 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GeometryConstructor = {
  "POINT": Point_default,
  "LINESTRING": LineString_default,
  "POLYGON": Polygon_default,
  "MULTIPOINT": MultiPoint_default,
  "MULTILINESTRING": MultiLineString_default,
  "MULTIPOLYGON": MultiPolygon_default
};
var EMPTY = "EMPTY";
var Z = "Z";
var M = "M";
var ZM = "ZM";
var TokenType = {
  START: 0,
  TEXT: 1,
  LEFT_PAREN: 2,
  RIGHT_PAREN: 3,
  NUMBER: 4,
  COMMA: 5,
  EOF: 6
};
var WKTGeometryType = {};
for (type in GeometryType_default) {
  WKTGeometryType[type] = GeometryType_default[type].toUpperCase();
}
var type;
var Lexer = function() {
  function Lexer2(wkt) {
    this.wkt = wkt;
    this.index_ = -1;
  }
  Lexer2.prototype.isAlpha_ = function(c) {
    return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
  };
  Lexer2.prototype.isNumeric_ = function(c, opt_decimal) {
    var decimal = opt_decimal !== void 0 ? opt_decimal : false;
    return c >= "0" && c <= "9" || c == "." && !decimal;
  };
  Lexer2.prototype.isWhiteSpace_ = function(c) {
    return c == " " || c == "	" || c == "\r" || c == "\n";
  };
  Lexer2.prototype.nextChar_ = function() {
    return this.wkt.charAt(++this.index_);
  };
  Lexer2.prototype.nextToken = function() {
    var c = this.nextChar_();
    var position = this.index_;
    var value = c;
    var type;
    if (c == "(") {
      type = TokenType.LEFT_PAREN;
    } else if (c == ",") {
      type = TokenType.COMMA;
    } else if (c == ")") {
      type = TokenType.RIGHT_PAREN;
    } else if (this.isNumeric_(c) || c == "-") {
      type = TokenType.NUMBER;
      value = this.readNumber_();
    } else if (this.isAlpha_(c)) {
      type = TokenType.TEXT;
      value = this.readText_();
    } else if (this.isWhiteSpace_(c)) {
      return this.nextToken();
    } else if (c === "") {
      type = TokenType.EOF;
    } else {
      throw new Error("Unexpected character: " + c);
    }
    return { position, value, type };
  };
  Lexer2.prototype.readNumber_ = function() {
    var c;
    var index = this.index_;
    var decimal = false;
    var scientificNotation = false;
    do {
      if (c == ".") {
        decimal = true;
      } else if (c == "e" || c == "E") {
        scientificNotation = true;
      }
      c = this.nextChar_();
    } while (this.isNumeric_(c, decimal) || !scientificNotation && (c == "e" || c == "E") || scientificNotation && (c == "-" || c == "+"));
    return parseFloat(this.wkt.substring(index, this.index_--));
  };
  Lexer2.prototype.readText_ = function() {
    var c;
    var index = this.index_;
    do {
      c = this.nextChar_();
    } while (this.isAlpha_(c));
    return this.wkt.substring(index, this.index_--).toUpperCase();
  };
  return Lexer2;
}();
var Parser = function() {
  function Parser2(lexer) {
    this.lexer_ = lexer;
    this.token_ = {
      position: 0,
      type: TokenType.START
    };
    this.layout_ = GeometryLayout_default.XY;
  }
  Parser2.prototype.consume_ = function() {
    this.token_ = this.lexer_.nextToken();
  };
  Parser2.prototype.isTokenType = function(type) {
    return this.token_.type == type;
  };
  Parser2.prototype.match = function(type) {
    var isMatch = this.isTokenType(type);
    if (isMatch) {
      this.consume_();
    }
    return isMatch;
  };
  Parser2.prototype.parse = function() {
    this.consume_();
    return this.parseGeometry_();
  };
  Parser2.prototype.parseGeometryLayout_ = function() {
    var layout = GeometryLayout_default.XY;
    var dimToken = this.token_;
    if (this.isTokenType(TokenType.TEXT)) {
      var dimInfo = dimToken.value;
      if (dimInfo === Z) {
        layout = GeometryLayout_default.XYZ;
      } else if (dimInfo === M) {
        layout = GeometryLayout_default.XYM;
      } else if (dimInfo === ZM) {
        layout = GeometryLayout_default.XYZM;
      }
      if (layout !== GeometryLayout_default.XY) {
        this.consume_();
      }
    }
    return layout;
  };
  Parser2.prototype.parseGeometryCollectionText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var geometries = [];
      do {
        geometries.push(this.parseGeometry_());
      } while (this.match(TokenType.COMMA));
      if (this.match(TokenType.RIGHT_PAREN)) {
        return geometries;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parsePointText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = this.parsePoint_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parseLineStringText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = this.parsePointList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parsePolygonText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = this.parseLineStringTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parseMultiPointText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = void 0;
      if (this.token_.type == TokenType.LEFT_PAREN) {
        coordinates = this.parsePointTextList_();
      } else {
        coordinates = this.parsePointList_();
      }
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parseMultiLineStringText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = this.parseLineStringTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parseMultiPolygonText_ = function() {
    if (this.match(TokenType.LEFT_PAREN)) {
      var coordinates = this.parsePolygonTextList_();
      if (this.match(TokenType.RIGHT_PAREN)) {
        return coordinates;
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parsePoint_ = function() {
    var coordinates = [];
    var dimensions = this.layout_.length;
    for (var i = 0; i < dimensions; ++i) {
      var token = this.token_;
      if (this.match(TokenType.NUMBER)) {
        coordinates.push(token.value);
      } else {
        break;
      }
    }
    if (coordinates.length == dimensions) {
      return coordinates;
    }
    throw new Error(this.formatErrorMessage_());
  };
  Parser2.prototype.parsePointList_ = function() {
    var coordinates = [this.parsePoint_()];
    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parsePoint_());
    }
    return coordinates;
  };
  Parser2.prototype.parsePointTextList_ = function() {
    var coordinates = [this.parsePointText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parsePointText_());
    }
    return coordinates;
  };
  Parser2.prototype.parseLineStringTextList_ = function() {
    var coordinates = [this.parseLineStringText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parseLineStringText_());
    }
    return coordinates;
  };
  Parser2.prototype.parsePolygonTextList_ = function() {
    var coordinates = [this.parsePolygonText_()];
    while (this.match(TokenType.COMMA)) {
      coordinates.push(this.parsePolygonText_());
    }
    return coordinates;
  };
  Parser2.prototype.isEmptyGeometry_ = function() {
    var isEmpty2 = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;
    if (isEmpty2) {
      this.consume_();
    }
    return isEmpty2;
  };
  Parser2.prototype.formatErrorMessage_ = function() {
    return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
  };
  Parser2.prototype.parseGeometry_ = function() {
    var token = this.token_;
    if (this.match(TokenType.TEXT)) {
      var geomType = token.value;
      this.layout_ = this.parseGeometryLayout_();
      var isEmpty2 = this.isEmptyGeometry_();
      if (geomType == "GEOMETRYCOLLECTION") {
        if (isEmpty2) {
          return new GeometryCollection_default([]);
        }
        var geometries = this.parseGeometryCollectionText_();
        return new GeometryCollection_default(geometries);
      } else {
        var ctor = GeometryConstructor[geomType];
        if (!ctor) {
          throw new Error("Invalid geometry type: " + geomType);
        }
        var coordinates = void 0;
        if (isEmpty2) {
          if (geomType == "POINT") {
            coordinates = [NaN, NaN];
          } else {
            coordinates = [];
          }
        } else {
          switch (geomType) {
            case "POINT": {
              coordinates = this.parsePointText_();
              break;
            }
            case "LINESTRING": {
              coordinates = this.parseLineStringText_();
              break;
            }
            case "POLYGON": {
              coordinates = this.parsePolygonText_();
              break;
            }
            case "MULTIPOINT": {
              coordinates = this.parseMultiPointText_();
              break;
            }
            case "MULTILINESTRING": {
              coordinates = this.parseMultiLineStringText_();
              break;
            }
            case "MULTIPOLYGON": {
              coordinates = this.parseMultiPolygonText_();
              break;
            }
            default:
              break;
          }
        }
        return new ctor(coordinates, this.layout_);
      }
    }
    throw new Error(this.formatErrorMessage_());
  };
  return Parser2;
}();
var WKT = function(_super) {
  __extends44(WKT2, _super);
  function WKT2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.splitCollection_ = options.splitCollection !== void 0 ? options.splitCollection : false;
    return _this;
  }
  WKT2.prototype.parse_ = function(wkt) {
    var lexer = new Lexer(wkt);
    var parser = new Parser(lexer);
    return parser.parse();
  };
  WKT2.prototype.readFeatureFromText = function(text, opt_options) {
    var geom = this.readGeometryFromText(text, opt_options);
    var feature = new Feature_default();
    feature.setGeometry(geom);
    return feature;
  };
  WKT2.prototype.readFeaturesFromText = function(text, opt_options) {
    var geometries = [];
    var geometry = this.readGeometryFromText(text, opt_options);
    if (this.splitCollection_ && geometry.getType() == GeometryType_default.GEOMETRY_COLLECTION) {
      geometries = geometry.getGeometriesArray();
    } else {
      geometries = [geometry];
    }
    var features = [];
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      var feature = new Feature_default();
      feature.setGeometry(geometries[i]);
      features.push(feature);
    }
    return features;
  };
  WKT2.prototype.readGeometryFromText = function(text, opt_options) {
    var geometry = this.parse_(text);
    return transformGeometryWithOptions(geometry, false, opt_options);
  };
  WKT2.prototype.writeFeatureText = function(feature, opt_options) {
    var geometry = feature.getGeometry();
    if (geometry) {
      return this.writeGeometryText(geometry, opt_options);
    }
    return "";
  };
  WKT2.prototype.writeFeaturesText = function(features, opt_options) {
    if (features.length == 1) {
      return this.writeFeatureText(features[0], opt_options);
    }
    var geometries = [];
    for (var i = 0, ii = features.length; i < ii; ++i) {
      geometries.push(features[i].getGeometry());
    }
    var collection = new GeometryCollection_default(geometries);
    return this.writeGeometryText(collection, opt_options);
  };
  WKT2.prototype.writeGeometryText = function(geometry, opt_options) {
    return encode(transformGeometryWithOptions(geometry, true, opt_options));
  };
  return WKT2;
}(TextFeature_default);
function encodePointGeometry(geom) {
  var coordinates = geom.getCoordinates();
  if (coordinates.length === 0) {
    return "";
  }
  return coordinates.join(" ");
}
function encodeMultiPointGeometry(geom) {
  var array = [];
  var components = geom.getPoints();
  for (var i = 0, ii = components.length; i < ii; ++i) {
    array.push("(" + encodePointGeometry(components[i]) + ")");
  }
  return array.join(",");
}
function encodeGeometryCollectionGeometry(geom) {
  var array = [];
  var geoms = geom.getGeometries();
  for (var i = 0, ii = geoms.length; i < ii; ++i) {
    array.push(encode(geoms[i]));
  }
  return array.join(",");
}
function encodeLineStringGeometry(geom) {
  var coordinates = geom.getCoordinates();
  var array = [];
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    array.push(coordinates[i].join(" "));
  }
  return array.join(",");
}
function encodeMultiLineStringGeometry(geom) {
  var array = [];
  var components = geom.getLineStrings();
  for (var i = 0, ii = components.length; i < ii; ++i) {
    array.push("(" + encodeLineStringGeometry(components[i]) + ")");
  }
  return array.join(",");
}
function encodePolygonGeometry(geom) {
  var array = [];
  var rings = geom.getLinearRings();
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    array.push("(" + encodeLineStringGeometry(rings[i]) + ")");
  }
  return array.join(",");
}
function encodeMultiPolygonGeometry(geom) {
  var array = [];
  var components = geom.getPolygons();
  for (var i = 0, ii = components.length; i < ii; ++i) {
    array.push("(" + encodePolygonGeometry(components[i]) + ")");
  }
  return array.join(",");
}
function encodeGeometryLayout(geom) {
  var layout = geom.getLayout();
  var dimInfo = "";
  if (layout === GeometryLayout_default.XYZ || layout === GeometryLayout_default.XYZM) {
    dimInfo += Z;
  }
  if (layout === GeometryLayout_default.XYM || layout === GeometryLayout_default.XYZM) {
    dimInfo += M;
  }
  return dimInfo;
}
var GeometryEncoder = {
  "Point": encodePointGeometry,
  "LineString": encodeLineStringGeometry,
  "Polygon": encodePolygonGeometry,
  "MultiPoint": encodeMultiPointGeometry,
  "MultiLineString": encodeMultiLineStringGeometry,
  "MultiPolygon": encodeMultiPolygonGeometry,
  "GeometryCollection": encodeGeometryCollectionGeometry
};
function encode(geom) {
  var type = geom.getType();
  var geometryEncoder = GeometryEncoder[type];
  var enc = geometryEncoder(geom);
  type = type.toUpperCase();
  if (typeof geom.getFlatCoordinates === "function") {
    var dimInfo = encodeGeometryLayout(geom);
    if (dimInfo.length > 0) {
      type += " " + dimInfo;
    }
  }
  if (enc.length === 0) {
    return type + " " + EMPTY;
  }
  return type + "(" + enc + ")";
}
var WKT_default = WKT;

// node_modules/ol/format/WMSCapabilities.js
var __extends45 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NAMESPACE_URIS4 = [null, "http://www.opengis.net/wms"];
var PARSERS2 = makeStructureNS(NAMESPACE_URIS4, {
  "Service": makeObjectPropertySetter(readService),
  "Capability": makeObjectPropertySetter(readCapability)
});
var CAPABILITY_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Request": makeObjectPropertySetter(readRequest),
  "Exception": makeObjectPropertySetter(readException),
  "Layer": makeObjectPropertySetter(readCapabilityLayer)
});
var WMSCapabilities = function(_super) {
  __extends45(WMSCapabilities2, _super);
  function WMSCapabilities2() {
    var _this = _super.call(this) || this;
    _this.version = void 0;
    return _this;
  }
  WMSCapabilities2.prototype.readFromNode = function(node) {
    this.version = node.getAttribute("version").trim();
    var wmsCapabilityObject = pushParseAndPop({
      "version": this.version
    }, PARSERS2, node, []);
    return wmsCapabilityObject ? wmsCapabilityObject : null;
  };
  return WMSCapabilities2;
}(XML_default);
var SERVICE_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "KeywordList": makeObjectPropertySetter(readKeywordList),
  "OnlineResource": makeObjectPropertySetter(readHref),
  "ContactInformation": makeObjectPropertySetter(readContactInformation),
  "Fees": makeObjectPropertySetter(readString),
  "AccessConstraints": makeObjectPropertySetter(readString),
  "LayerLimit": makeObjectPropertySetter(readPositiveInteger),
  "MaxWidth": makeObjectPropertySetter(readPositiveInteger),
  "MaxHeight": makeObjectPropertySetter(readPositiveInteger)
});
var CONTACT_INFORMATION_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "ContactPersonPrimary": makeObjectPropertySetter(readContactPersonPrimary),
  "ContactPosition": makeObjectPropertySetter(readString),
  "ContactAddress": makeObjectPropertySetter(readContactAddress),
  "ContactVoiceTelephone": makeObjectPropertySetter(readString),
  "ContactFacsimileTelephone": makeObjectPropertySetter(readString),
  "ContactElectronicMailAddress": makeObjectPropertySetter(readString)
});
var CONTACT_PERSON_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "ContactPerson": makeObjectPropertySetter(readString),
  "ContactOrganization": makeObjectPropertySetter(readString)
});
var CONTACT_ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "AddressType": makeObjectPropertySetter(readString),
  "Address": makeObjectPropertySetter(readString),
  "City": makeObjectPropertySetter(readString),
  "StateOrProvince": makeObjectPropertySetter(readString),
  "PostCode": makeObjectPropertySetter(readString),
  "Country": makeObjectPropertySetter(readString)
});
var EXCEPTION_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Format": makeArrayPusher(readString)
});
var LAYER_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "KeywordList": makeObjectPropertySetter(readKeywordList),
  "CRS": makeObjectPropertyPusher(readString),
  "EX_GeographicBoundingBox": makeObjectPropertySetter(readEXGeographicBoundingBox),
  "BoundingBox": makeObjectPropertyPusher(readBoundingBox),
  "Dimension": makeObjectPropertyPusher(readDimension),
  "Attribution": makeObjectPropertySetter(readAttribution),
  "AuthorityURL": makeObjectPropertyPusher(readAuthorityURL),
  "Identifier": makeObjectPropertyPusher(readString),
  "MetadataURL": makeObjectPropertyPusher(readMetadataURL),
  "DataURL": makeObjectPropertyPusher(readFormatOnlineresource),
  "FeatureListURL": makeObjectPropertyPusher(readFormatOnlineresource),
  "Style": makeObjectPropertyPusher(readStyle2),
  "MinScaleDenominator": makeObjectPropertySetter(readDecimal),
  "MaxScaleDenominator": makeObjectPropertySetter(readDecimal),
  "Layer": makeObjectPropertyPusher(readLayer)
});
var ATTRIBUTION_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Title": makeObjectPropertySetter(readString),
  "OnlineResource": makeObjectPropertySetter(readHref),
  "LogoURL": makeObjectPropertySetter(readSizedFormatOnlineresource)
});
var EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "westBoundLongitude": makeObjectPropertySetter(readDecimal),
  "eastBoundLongitude": makeObjectPropertySetter(readDecimal),
  "southBoundLatitude": makeObjectPropertySetter(readDecimal),
  "northBoundLatitude": makeObjectPropertySetter(readDecimal)
});
var REQUEST_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "GetCapabilities": makeObjectPropertySetter(readOperationType),
  "GetMap": makeObjectPropertySetter(readOperationType),
  "GetFeatureInfo": makeObjectPropertySetter(readOperationType)
});
var OPERATIONTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Format": makeObjectPropertyPusher(readString),
  "DCPType": makeObjectPropertyPusher(readDCPType)
});
var DCPTYPE_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "HTTP": makeObjectPropertySetter(readHTTP)
});
var HTTP_PARSERS2 = makeStructureNS(NAMESPACE_URIS4, {
  "Get": makeObjectPropertySetter(readFormatOnlineresource),
  "Post": makeObjectPropertySetter(readFormatOnlineresource)
});
var STYLE_PARSERS2 = makeStructureNS(NAMESPACE_URIS4, {
  "Name": makeObjectPropertySetter(readString),
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "LegendURL": makeObjectPropertyPusher(readSizedFormatOnlineresource),
  "StyleSheetURL": makeObjectPropertySetter(readFormatOnlineresource),
  "StyleURL": makeObjectPropertySetter(readFormatOnlineresource)
});
var FORMAT_ONLINERESOURCE_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Format": makeObjectPropertySetter(readString),
  "OnlineResource": makeObjectPropertySetter(readHref)
});
var KEYWORDLIST_PARSERS = makeStructureNS(NAMESPACE_URIS4, {
  "Keyword": makeArrayPusher(readString)
});
function readAttribution(node, objectStack) {
  return pushParseAndPop({}, ATTRIBUTION_PARSERS, node, objectStack);
}
function readBoundingBox(node, objectStack) {
  var extent = [
    readDecimalString(node.getAttribute("minx")),
    readDecimalString(node.getAttribute("miny")),
    readDecimalString(node.getAttribute("maxx")),
    readDecimalString(node.getAttribute("maxy"))
  ];
  var resolutions = [
    readDecimalString(node.getAttribute("resx")),
    readDecimalString(node.getAttribute("resy"))
  ];
  return {
    "crs": node.getAttribute("CRS"),
    "extent": extent,
    "res": resolutions
  };
}
function readEXGeographicBoundingBox(node, objectStack) {
  var geographicBoundingBox = pushParseAndPop({}, EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS, node, objectStack);
  if (!geographicBoundingBox) {
    return void 0;
  }
  var westBoundLongitude = geographicBoundingBox["westBoundLongitude"];
  var southBoundLatitude = geographicBoundingBox["southBoundLatitude"];
  var eastBoundLongitude = geographicBoundingBox["eastBoundLongitude"];
  var northBoundLatitude = geographicBoundingBox["northBoundLatitude"];
  if (westBoundLongitude === void 0 || southBoundLatitude === void 0 || eastBoundLongitude === void 0 || northBoundLatitude === void 0) {
    return void 0;
  }
  return [
    westBoundLongitude,
    southBoundLatitude,
    eastBoundLongitude,
    northBoundLatitude
  ];
}
function readCapability(node, objectStack) {
  return pushParseAndPop({}, CAPABILITY_PARSERS, node, objectStack);
}
function readService(node, objectStack) {
  return pushParseAndPop({}, SERVICE_PARSERS, node, objectStack);
}
function readContactInformation(node, objectStack) {
  return pushParseAndPop({}, CONTACT_INFORMATION_PARSERS, node, objectStack);
}
function readContactPersonPrimary(node, objectStack) {
  return pushParseAndPop({}, CONTACT_PERSON_PARSERS, node, objectStack);
}
function readContactAddress(node, objectStack) {
  return pushParseAndPop({}, CONTACT_ADDRESS_PARSERS, node, objectStack);
}
function readException(node, objectStack) {
  return pushParseAndPop([], EXCEPTION_PARSERS, node, objectStack);
}
function readCapabilityLayer(node, objectStack) {
  var layerObject = pushParseAndPop({}, LAYER_PARSERS, node, objectStack);
  if (layerObject["Layer"] === void 0) {
    return Object.assign(layerObject, readLayer(node, objectStack));
  }
  return layerObject;
}
function readLayer(node, objectStack) {
  var parentLayerObject = objectStack[objectStack.length - 1];
  var layerObject = pushParseAndPop({}, LAYER_PARSERS, node, objectStack);
  if (!layerObject) {
    return void 0;
  }
  var queryable = readBooleanString(node.getAttribute("queryable"));
  if (queryable === void 0) {
    queryable = parentLayerObject["queryable"];
  }
  layerObject["queryable"] = queryable !== void 0 ? queryable : false;
  var cascaded = readNonNegativeIntegerString(node.getAttribute("cascaded"));
  if (cascaded === void 0) {
    cascaded = parentLayerObject["cascaded"];
  }
  layerObject["cascaded"] = cascaded;
  var opaque = readBooleanString(node.getAttribute("opaque"));
  if (opaque === void 0) {
    opaque = parentLayerObject["opaque"];
  }
  layerObject["opaque"] = opaque !== void 0 ? opaque : false;
  var noSubsets = readBooleanString(node.getAttribute("noSubsets"));
  if (noSubsets === void 0) {
    noSubsets = parentLayerObject["noSubsets"];
  }
  layerObject["noSubsets"] = noSubsets !== void 0 ? noSubsets : false;
  var fixedWidth = readDecimalString(node.getAttribute("fixedWidth"));
  if (!fixedWidth) {
    fixedWidth = parentLayerObject["fixedWidth"];
  }
  layerObject["fixedWidth"] = fixedWidth;
  var fixedHeight = readDecimalString(node.getAttribute("fixedHeight"));
  if (!fixedHeight) {
    fixedHeight = parentLayerObject["fixedHeight"];
  }
  layerObject["fixedHeight"] = fixedHeight;
  var addKeys = ["Style", "CRS", "AuthorityURL"];
  addKeys.forEach(function(key) {
    if (key in parentLayerObject) {
      var childValue = layerObject[key] || [];
      layerObject[key] = childValue.concat(parentLayerObject[key]);
    }
  });
  var replaceKeys = [
    "EX_GeographicBoundingBox",
    "BoundingBox",
    "Dimension",
    "Attribution",
    "MinScaleDenominator",
    "MaxScaleDenominator"
  ];
  replaceKeys.forEach(function(key) {
    if (!(key in layerObject)) {
      var parentValue = parentLayerObject[key];
      layerObject[key] = parentValue;
    }
  });
  return layerObject;
}
function readDimension(node, objectStack) {
  var dimensionObject = {
    "name": node.getAttribute("name"),
    "units": node.getAttribute("units"),
    "unitSymbol": node.getAttribute("unitSymbol"),
    "default": node.getAttribute("default"),
    "multipleValues": readBooleanString(node.getAttribute("multipleValues")),
    "nearestValue": readBooleanString(node.getAttribute("nearestValue")),
    "current": readBooleanString(node.getAttribute("current")),
    "values": readString(node)
  };
  return dimensionObject;
}
function readFormatOnlineresource(node, objectStack) {
  return pushParseAndPop({}, FORMAT_ONLINERESOURCE_PARSERS, node, objectStack);
}
function readRequest(node, objectStack) {
  return pushParseAndPop({}, REQUEST_PARSERS, node, objectStack);
}
function readDCPType(node, objectStack) {
  return pushParseAndPop({}, DCPTYPE_PARSERS, node, objectStack);
}
function readHTTP(node, objectStack) {
  return pushParseAndPop({}, HTTP_PARSERS2, node, objectStack);
}
function readOperationType(node, objectStack) {
  return pushParseAndPop({}, OPERATIONTYPE_PARSERS, node, objectStack);
}
function readSizedFormatOnlineresource(node, objectStack) {
  var formatOnlineresource = readFormatOnlineresource(node, objectStack);
  if (formatOnlineresource) {
    var size = [
      readNonNegativeIntegerString(node.getAttribute("width")),
      readNonNegativeIntegerString(node.getAttribute("height"))
    ];
    formatOnlineresource["size"] = size;
    return formatOnlineresource;
  }
  return void 0;
}
function readAuthorityURL(node, objectStack) {
  var authorityObject = readFormatOnlineresource(node, objectStack);
  if (authorityObject) {
    authorityObject["name"] = node.getAttribute("name");
    return authorityObject;
  }
  return void 0;
}
function readMetadataURL(node, objectStack) {
  var metadataObject = readFormatOnlineresource(node, objectStack);
  if (metadataObject) {
    metadataObject["type"] = node.getAttribute("type");
    return metadataObject;
  }
  return void 0;
}
function readStyle2(node, objectStack) {
  return pushParseAndPop({}, STYLE_PARSERS2, node, objectStack);
}
function readKeywordList(node, objectStack) {
  return pushParseAndPop([], KEYWORDLIST_PARSERS, node, objectStack);
}
var WMSCapabilities_default = WMSCapabilities;

// node_modules/ol/format/WMSGetFeatureInfo.js
var __extends46 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var featureIdentifier = "_feature";
var layerIdentifier = "_layer";
var WMSGetFeatureInfo = function(_super) {
  __extends46(WMSGetFeatureInfo2, _super);
  function WMSGetFeatureInfo2(opt_options) {
    var _this = _super.call(this) || this;
    var options = opt_options ? opt_options : {};
    _this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver";
    _this.gmlFormat_ = new GML2_default();
    _this.layers_ = options.layers ? options.layers : null;
    return _this;
  }
  WMSGetFeatureInfo2.prototype.getLayers = function() {
    return this.layers_;
  };
  WMSGetFeatureInfo2.prototype.setLayers = function(layers) {
    this.layers_ = layers;
  };
  WMSGetFeatureInfo2.prototype.readFeatures_ = function(node, objectStack) {
    node.setAttribute("namespaceURI", this.featureNS_);
    var localName = node.localName;
    var features = [];
    if (node.childNodes.length === 0) {
      return features;
    }
    if (localName == "msGMLOutput") {
      for (var i = 0, ii = node.childNodes.length; i < ii; i++) {
        var layer = node.childNodes[i];
        if (layer.nodeType !== Node.ELEMENT_NODE) {
          continue;
        }
        var layerElement = layer;
        var context = objectStack[0];
        var toRemove = layerIdentifier;
        var layerName = layerElement.localName.replace(toRemove, "");
        if (this.layers_ && !includes(this.layers_, layerName)) {
          continue;
        }
        var featureType = layerName + featureIdentifier;
        context["featureType"] = featureType;
        context["featureNS"] = this.featureNS_;
        var parsers = {};
        parsers[featureType] = makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
        var parsersNS = makeStructureNS([context["featureNS"], null], parsers);
        layerElement.setAttribute("namespaceURI", this.featureNS_);
        var layerFeatures = pushParseAndPop([], parsersNS, layerElement, objectStack, this.gmlFormat_);
        if (layerFeatures) {
          extend(features, layerFeatures);
        }
      }
    }
    if (localName == "FeatureCollection") {
      var gmlFeatures = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, [{}], this.gmlFormat_);
      if (gmlFeatures) {
        features = gmlFeatures;
      }
    }
    return features;
  };
  WMSGetFeatureInfo2.prototype.readFeaturesFromNode = function(node, opt_options) {
    var options = {};
    if (opt_options) {
      assign(options, this.getReadOptions(node, opt_options));
    }
    return this.readFeatures_(node, [options]);
  };
  return WMSGetFeatureInfo2;
}(XMLFeature_default);
var WMSGetFeatureInfo_default = WMSGetFeatureInfo;

// node_modules/ol/format/WMTSCapabilities.js
var __extends47 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NAMESPACE_URIS5 = [null, "http://www.opengis.net/wmts/1.0"];
var OWS_NAMESPACE_URIS = [null, "http://www.opengis.net/ows/1.1"];
var PARSERS3 = makeStructureNS(NAMESPACE_URIS5, {
  "Contents": makeObjectPropertySetter(readContents)
});
var WMTSCapabilities = function(_super) {
  __extends47(WMTSCapabilities2, _super);
  function WMTSCapabilities2() {
    var _this = _super.call(this) || this;
    _this.owsParser_ = new OWS_default();
    return _this;
  }
  WMTSCapabilities2.prototype.readFromNode = function(node) {
    var version = node.getAttribute("version");
    if (version) {
      version = version.trim();
    }
    var WMTSCapabilityObject = this.owsParser_.readFromNode(node);
    if (!WMTSCapabilityObject) {
      return null;
    }
    WMTSCapabilityObject["version"] = version;
    WMTSCapabilityObject = pushParseAndPop(WMTSCapabilityObject, PARSERS3, node, []);
    return WMTSCapabilityObject ? WMTSCapabilityObject : null;
  };
  return WMTSCapabilities2;
}(XML_default);
var CONTENTS_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "Layer": makeObjectPropertyPusher(readLayer2),
  "TileMatrixSet": makeObjectPropertyPusher(readTileMatrixSet)
});
var LAYER_PARSERS2 = makeStructureNS(NAMESPACE_URIS5, {
  "Style": makeObjectPropertyPusher(readStyle3),
  "Format": makeObjectPropertyPusher(readString),
  "TileMatrixSetLink": makeObjectPropertyPusher(readTileMatrixSetLink),
  "Dimension": makeObjectPropertyPusher(readDimensions),
  "ResourceURL": makeObjectPropertyPusher(readResourceUrl)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Title": makeObjectPropertySetter(readString),
  "Abstract": makeObjectPropertySetter(readString),
  "WGS84BoundingBox": makeObjectPropertySetter(readBoundingBox2),
  "Identifier": makeObjectPropertySetter(readString)
}));
var STYLE_PARSERS3 = makeStructureNS(NAMESPACE_URIS5, {
  "LegendURL": makeObjectPropertyPusher(readLegendUrl)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Title": makeObjectPropertySetter(readString),
  "Identifier": makeObjectPropertySetter(readString)
}));
var TMS_LINKS_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "TileMatrixSet": makeObjectPropertySetter(readString),
  "TileMatrixSetLimits": makeObjectPropertySetter(readTileMatrixLimitsList)
});
var TMS_LIMITS_LIST_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "TileMatrixLimits": makeArrayPusher(readTileMatrixLimits)
});
var TMS_LIMITS_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "TileMatrix": makeObjectPropertySetter(readString),
  "MinTileRow": makeObjectPropertySetter(readPositiveInteger),
  "MaxTileRow": makeObjectPropertySetter(readPositiveInteger),
  "MinTileCol": makeObjectPropertySetter(readPositiveInteger),
  "MaxTileCol": makeObjectPropertySetter(readPositiveInteger)
});
var DIMENSION_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "Default": makeObjectPropertySetter(readString),
  "Value": makeObjectPropertyPusher(readString)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Identifier": makeObjectPropertySetter(readString)
}));
var WGS84_BBOX_READERS = makeStructureNS(OWS_NAMESPACE_URIS, {
  "LowerCorner": makeArrayPusher(readCoordinates),
  "UpperCorner": makeArrayPusher(readCoordinates)
});
var TMS_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "WellKnownScaleSet": makeObjectPropertySetter(readString),
  "TileMatrix": makeObjectPropertyPusher(readTileMatrix)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "SupportedCRS": makeObjectPropertySetter(readString),
  "Identifier": makeObjectPropertySetter(readString),
  "BoundingBox": makeObjectPropertySetter(readBoundingBox2)
}));
var TM_PARSERS = makeStructureNS(NAMESPACE_URIS5, {
  "TopLeftCorner": makeObjectPropertySetter(readCoordinates),
  "ScaleDenominator": makeObjectPropertySetter(readDecimal),
  "TileWidth": makeObjectPropertySetter(readPositiveInteger),
  "TileHeight": makeObjectPropertySetter(readPositiveInteger),
  "MatrixWidth": makeObjectPropertySetter(readPositiveInteger),
  "MatrixHeight": makeObjectPropertySetter(readPositiveInteger)
}, makeStructureNS(OWS_NAMESPACE_URIS, {
  "Identifier": makeObjectPropertySetter(readString)
}));
function readContents(node, objectStack) {
  return pushParseAndPop({}, CONTENTS_PARSERS, node, objectStack);
}
function readLayer2(node, objectStack) {
  return pushParseAndPop({}, LAYER_PARSERS2, node, objectStack);
}
function readTileMatrixSet(node, objectStack) {
  return pushParseAndPop({}, TMS_PARSERS, node, objectStack);
}
function readStyle3(node, objectStack) {
  var style = pushParseAndPop({}, STYLE_PARSERS3, node, objectStack);
  if (!style) {
    return void 0;
  }
  var isDefault = node.getAttribute("isDefault") === "true";
  style["isDefault"] = isDefault;
  return style;
}
function readTileMatrixSetLink(node, objectStack) {
  return pushParseAndPop({}, TMS_LINKS_PARSERS, node, objectStack);
}
function readDimensions(node, objectStack) {
  return pushParseAndPop({}, DIMENSION_PARSERS, node, objectStack);
}
function readResourceUrl(node, objectStack) {
  var format = node.getAttribute("format");
  var template = node.getAttribute("template");
  var resourceType = node.getAttribute("resourceType");
  var resource = {};
  if (format) {
    resource["format"] = format;
  }
  if (template) {
    resource["template"] = template;
  }
  if (resourceType) {
    resource["resourceType"] = resourceType;
  }
  return resource;
}
function readBoundingBox2(node, objectStack) {
  var coordinates = pushParseAndPop([], WGS84_BBOX_READERS, node, objectStack);
  if (coordinates.length != 2) {
    return void 0;
  }
  return boundingExtent(coordinates);
}
function readLegendUrl(node, objectStack) {
  var legend = {};
  legend["format"] = node.getAttribute("format");
  legend["href"] = readHref(node);
  return legend;
}
function readCoordinates(node, objectStack) {
  var coordinates = readString(node).split(/\s+/);
  if (!coordinates || coordinates.length != 2) {
    return void 0;
  }
  var x = +coordinates[0];
  var y = +coordinates[1];
  if (isNaN(x) || isNaN(y)) {
    return void 0;
  }
  return [x, y];
}
function readTileMatrix(node, objectStack) {
  return pushParseAndPop({}, TM_PARSERS, node, objectStack);
}
function readTileMatrixLimitsList(node, objectStack) {
  return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node, objectStack);
}
function readTileMatrixLimits(node, objectStack) {
  return pushParseAndPop({}, TMS_LIMITS_PARSERS, node, objectStack);
}
var WMTSCapabilities_default = WMTSCapabilities;
export {
  EsriJSON_default as EsriJSON,
  GML_default as GML,
  GPX_default as GPX,
  GeoJSON_default as GeoJSON,
  IGC_default as IGC,
  IIIFInfo_default as IIIFInfo,
  KML_default as KML,
  MVT_default as MVT,
  OWS_default as OWS,
  Polyline_default as Polyline,
  TopoJSON_default as TopoJSON,
  WFS_default as WFS,
  WKB_default as WKB,
  WKT_default as WKT,
  WMSCapabilities_default as WMSCapabilities,
  WMSGetFeatureInfo_default as WMSGetFeatureInfo,
  WMTSCapabilities_default as WMTSCapabilities
};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=ol_format.js.map
